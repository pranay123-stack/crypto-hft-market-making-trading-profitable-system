================================================================================
MARKET ABUSE DETECTION SYSTEM
Advanced Pattern Recognition and Regulatory Surveillance
High-Frequency Trading Compliance
================================================================================

OVERVIEW
--------
Comprehensive market abuse detection implementing MAR (Market Abuse Regulation),
Dodd-Frank anti-manipulation rules, and SEC regulations. Includes real-time
detection, machine learning models, and behavioral analysis.

================================================================================
SECTION 1: MARKET MANIPULATION DETECTION
================================================================================

1.1 PRICE MANIPULATION DETECTION
---------------------------------

class PriceManipulationDetector {
public:
    enum class ManipulationType {
        MARKING_THE_CLOSE,      // Manipulating closing price
        PAINTING_THE_TAPE,      // Creating false trading activity
        PUMP_AND_DUMP,          // Inflating price then selling
        BEAR_RAID,              // Aggressive short selling
        MOMENTUM_IGNITION,      // Triggering algo trading cascades
        QUOTE_STUFFING          // Overwhelming with quotes
    };

    struct ManipulationPattern {
        ManipulationType type;
        std::string symbol;
        std::vector<std::string> implicated_accounts;
        uint64_t detection_time_ns;

        // Pattern metrics
        double price_impact;
        double volume_spike_ratio;
        uint32_t order_message_rate;
        double market_share_percentage;

        // Evidence
        std::vector<std::string> order_ids;
        std::vector<std::string> trade_ids;
        std::string behavioral_analysis;

        double confidence_score;
    };

    void MonitorPriceManipulation() {
        while (running_) {
            auto now_ns = GetNanosecondTimestamp();

            // Check different manipulation types
            DetectMarkingTheClose(now_ns);
            DetectPaintingTheTape(now_ns);
            DetectPumpAndDump(now_ns);
            DetectBearRaid(now_ns);
            DetectMomentumIgnition(now_ns);
            DetectQuoteStuffing(now_ns);

            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }

private:
    // Marking the Close: Manipulating closing price
    void DetectMarkingTheClose(uint64_t now_ns) {
        // Check if near market close
        if (!IsNearMarketClose(now_ns, std::chrono::minutes(5))) {
            return;
        }

        auto active_symbols = GetActivelyTradedSymbols();

        for (const auto& symbol : active_symbols) {
            // Get orders in final minutes
            auto close_window_start = now_ns - (5ULL * 60 * 1000000000ULL);
            auto orders = GetOrdersInWindow(symbol, close_window_start, now_ns);

            // Analyze order pattern
            MarkingCloseMetrics metrics = AnalyzeClosingActivity(orders);

            // Check for manipulation indicators:
            // 1. Unusual volume spike near close
            // 2. Orders moving price in specific direction
            // 3. No economic rationale
            // 4. Account has position that benefits

            if (IsMarkingTheClosePattern(metrics)) {
                ManipulationPattern pattern;
                pattern.type = ManipulationType::MARKING_THE_CLOSE;
                pattern.symbol = symbol;
                pattern.detection_time_ns = now_ns;
                pattern.confidence_score = CalculateConfidence(metrics);

                if (pattern.confidence_score > 0.75) {
                    GenerateManipulationAlert(pattern);
                }
            }
        }
    }

    struct MarkingCloseMetrics {
        double close_volume_ratio;        // Close volume vs daily avg
        double price_impact_close;        // Price movement in close
        double directional_bias;          // Buy vs sell imbalance
        std::map<std::string, int64_t> account_positions;
        bool single_account_dominance;    // One account dominant
        double closing_print_deviation;   // Deviation from VWAP
    };

    bool IsMarkingTheClosePattern(const MarkingCloseMetrics& metrics) {
        // Indicators of marking the close:
        // 1. Volume spike > 300% of average
        if (metrics.close_volume_ratio < 3.0) return false;

        // 2. Significant price impact (> 0.5%)
        if (std::abs(metrics.price_impact_close) < 0.005) return false;

        // 3. Strong directional bias (> 70%)
        if (std::abs(metrics.directional_bias) < 0.70) return false;

        // 4. Single account dominance
        if (!metrics.single_account_dominance) return false;

        // 5. Closing price deviates from VWAP
        if (std::abs(metrics.closing_print_deviation) < 0.003) return false;

        return true;
    }

    // Momentum Ignition: Triggering algorithmic trading cascades
    void DetectMomentumIgnition(uint64_t now_ns) {
        auto active_symbols = GetActivelyTradedSymbols();

        for (const auto& symbol : active_symbols) {
            MomentumMetrics metrics = AnalyzeMomentumPattern(symbol, now_ns);

            if (IsMomentumIgnitionPattern(metrics)) {
                ManipulationPattern pattern;
                pattern.type = ManipulationType::MOMENTUM_IGNITION;
                pattern.symbol = symbol;
                pattern.detection_time_ns = now_ns;

                pattern.price_impact = metrics.rapid_price_movement;
                pattern.volume_spike_ratio = metrics.volume_spike;
                pattern.order_message_rate = metrics.message_rate_spike;

                pattern.confidence_score = CalculateMomentumIgnitionConfidence(metrics);

                if (pattern.confidence_score > 0.70) {
                    GenerateManipulationAlert(pattern);
                }
            }
        }
    }

    struct MomentumMetrics {
        double rapid_price_movement;      // Price move in < 1 second
        double volume_spike;              // Volume surge ratio
        uint32_t message_rate_spike;      // Order message rate spike
        bool followed_by_reversal;        // Price reverses after spike
        std::string initiating_account;   // Account that triggered
        bool account_profited;            // Did initiator profit?
        uint64_t time_to_reversal_ns;    // Time until price reversal
    };

    bool IsMomentumIgnitionPattern(const MomentumMetrics& metrics) {
        // Momentum ignition characteristics:
        // 1. Rapid price movement (> 1% in < 1 second)
        if (metrics.rapid_price_movement < 0.01) return false;

        // 2. Followed by price reversal
        if (!metrics.followed_by_reversal) return false;

        // 3. Initiating account profited from reversal
        if (!metrics.account_profited) return false;

        // 4. Message rate spike preceding movement
        if (metrics.message_rate_spike < 1000) return false;

        // 5. Quick reversal (< 5 seconds)
        if (metrics.time_to_reversal_ns > 5ULL * 1000000000ULL) return false;

        return true;
    }

    // Quote Stuffing: Overwhelming market with quotes
    void DetectQuoteStuffing(uint64_t now_ns) {
        auto active_accounts = GetActiveAccounts();

        for (const auto& account : active_accounts) {
            QuoteStuffingMetrics metrics = AnalyzeQuoteActivity(account, now_ns);

            if (IsQuoteStuffingPattern(metrics)) {
                ManipulationPattern pattern;
                pattern.type = ManipulationType::QUOTE_STUFFING;
                pattern.implicated_accounts.push_back(account);
                pattern.detection_time_ns = now_ns;

                pattern.order_message_rate = metrics.peak_message_rate;
                pattern.confidence_score = CalculateQuoteStuffingConfidence(metrics);

                if (pattern.confidence_score > 0.80) {
                    GenerateManipulationAlert(pattern);
                }
            }
        }
    }

    struct QuoteStuffingMetrics {
        uint32_t peak_message_rate;       // Messages per second
        double cancel_rate;               // % of orders cancelled
        std::chrono::milliseconds avg_quote_lifetime;
        double execution_rate;            // % of orders executed
        bool market_disruption;           // Caused latency/disruption
        std::vector<std::string> affected_symbols;
    };

    bool IsQuoteStuffingPattern(const QuoteStuffingMetrics& metrics) {
        // Quote stuffing characteristics:
        // 1. Extremely high message rate (> 10,000/second)
        if (metrics.peak_message_rate < 10000) return false;

        // 2. Very high cancellation rate (> 95%)
        if (metrics.cancel_rate < 0.95) return false;

        // 3. Very short quote lifetime (< 100ms)
        if (metrics.avg_quote_lifetime > std::chrono::milliseconds(100)) return false;

        // 4. Very low execution rate (< 1%)
        if (metrics.execution_rate > 0.01) return false;

        // 5. Caused market disruption
        if (!metrics.market_disruption) return false;

        return true;
    }

    std::atomic<bool> running_{true};
};


================================================================================
SECTION 2: INSIDER TRADING DETECTION
================================================================================

2.1 UNUSUAL TRADING PATTERN ANALYSIS
-------------------------------------

class InsiderTradingDetector {
public:
    struct InsiderTradingPattern {
        std::string symbol;
        std::string account_id;
        std::string trader_id;
        uint64_t detection_time_ns;

        // Unusual activity indicators
        double historical_deviation_score;  // σ from normal behavior
        bool traded_before_announcement;
        bool unusual_profit;
        double profit_amount;
        std::chrono::hours time_before_news;

        // Information analysis
        bool had_potential_access;        // Access to material info
        std::string related_corporate_event;
        bool timing_suspicious;

        double confidence_score;
    };

    void MonitorInsiderTrading() {
        while (running_) {
            auto now_ns = GetNanosecondTimestamp();

            // Check for upcoming corporate events
            auto upcoming_events = GetUpcomingCorporateEvents(
                std::chrono::hours(72));  // 3 days ahead

            for (const auto& event : upcoming_events) {
                // Analyze trading activity before event
                auto suspicious_activity = AnalyzePreEventTrading(event);

                for (const auto& activity : suspicious_activity) {
                    if (activity.confidence_score > 0.70) {
                        GenerateInsiderTradingAlert(activity);
                    }
                }
            }

            // Monitor post-event profit analysis
            auto past_events = GetRecentCorporateEvents(std::chrono::hours(24));
            for (const auto& event : past_events) {
                AnalyzePostEventProfits(event);
            }

            std::this_thread::sleep_for(std::chrono::minutes(5));
        }
    }

private:
    struct CorporateEvent {
        std::string symbol;
        std::string event_type;           // EARNINGS, MERGER, etc.
        uint64_t event_timestamp_ns;
        double price_impact;              // Actual price movement
        bool material_information;        // Was it material?
    };

    std::vector<InsiderTradingPattern> AnalyzePreEventTrading(
        const CorporateEvent& event) {

        std::vector<InsiderTradingPattern> suspicious_patterns;

        // Look at trading 7 days before event
        auto analysis_start = event.event_timestamp_ns -
                             (7ULL * 24 * 3600 * 1000000000ULL);

        auto trades = GetTradesInWindow(event.symbol,
                                       analysis_start,
                                       event.event_timestamp_ns);

        // Analyze each account's trading pattern
        std::map<std::string, std::vector<Trade>> trades_by_account;
        for (const auto& trade : trades) {
            trades_by_account[trade.account_id].push_back(trade);
        }

        for (const auto& [account, account_trades] : trades_by_account) {
            InsiderTradingPattern pattern =
                EvaluateInsiderTradingRisk(account, account_trades, event);

            if (pattern.confidence_score > 0.0) {
                suspicious_patterns.push_back(pattern);
            }
        }

        return suspicious_patterns;
    }

    InsiderTradingPattern EvaluateInsiderTradingRisk(
        const std::string& account,
        const std::vector<Trade>& trades,
        const CorporateEvent& event) {

        InsiderTradingPattern pattern{};
        pattern.symbol = event.symbol;
        pattern.account_id = account;
        pattern.detection_time_ns = GetNanosecondTimestamp();

        // Calculate historical trading pattern
        auto historical_trades = GetHistoricalTrades(account, event.symbol, 90);
        TradingBehavior historical = AnalyzeTradingBehavior(historical_trades);
        TradingBehavior recent = AnalyzeTradingBehavior(trades);

        // Statistical deviation from normal behavior
        pattern.historical_deviation_score =
            CalculateDeviationScore(historical, recent);

        // Check timing
        if (!trades.empty()) {
            uint64_t earliest_trade = trades[0].execution_time_ns;
            uint64_t time_before_event_ns = event.event_timestamp_ns - earliest_trade;
            pattern.time_before_news =
                std::chrono::hours(time_before_event_ns / (3600ULL * 1000000000ULL));
            pattern.traded_before_announcement = true;

            // Suspicious if traded within 72 hours before event
            pattern.timing_suspicious = (pattern.time_before_news <= std::chrono::hours(72));
        }

        // Calculate profit from trades
        double total_profit = 0.0;
        for (const auto& trade : trades) {
            // Estimate profit based on price movement after event
            double entry_price = trade.price;
            double exit_price = GetPriceAfterEvent(event);
            double profit = (trade.side == 'B') ?
                           (exit_price - entry_price) * trade.quantity :
                           (entry_price - exit_price) * trade.quantity;
            total_profit += profit;
        }
        pattern.profit_amount = total_profit;
        pattern.unusual_profit = (total_profit > 10000.0);  // Significant profit

        // Check for potential access to information
        pattern.had_potential_access = CheckInformationAccess(account, event);

        pattern.related_corporate_event = event.event_type;

        // Calculate overall confidence score
        pattern.confidence_score = CalculateInsiderTradingConfidence(pattern);

        return pattern;
    }

    struct TradingBehavior {
        double avg_trade_size;
        double std_dev_trade_size;
        double avg_daily_volume;
        uint32_t avg_trades_per_day;
        double position_size_ratio;       // Position vs typical
    };

    double CalculateDeviationScore(const TradingBehavior& historical,
                                   const TradingBehavior& recent) {
        // Calculate z-score for recent activity
        double z_size = (recent.avg_trade_size - historical.avg_trade_size) /
                       historical.std_dev_trade_size;

        double z_volume = (recent.avg_daily_volume - historical.avg_daily_volume) /
                         (historical.avg_daily_volume * 0.3);  // Assume 30% std dev

        // Combined z-score
        return std::max(std::abs(z_size), std::abs(z_volume));
    }

    bool CheckInformationAccess(const std::string& account,
                               const CorporateEvent& event) {
        // Check if account holder could have had access to material information

        // 1. Check if account is corporate insider
        if (IsCorporateInsider(account, event.symbol)) {
            return true;
        }

        // 2. Check for business relationships
        if (HasBusinessRelationship(account, event.symbol)) {
            return true;
        }

        // 3. Check for family connections
        if (HasFamilyConnections(account, event.symbol)) {
            return true;
        }

        // 4. Check for professional connections (lawyers, accountants, etc.)
        if (HasProfessionalConnections(account, event.symbol)) {
            return true;
        }

        return false;
    }

    double CalculateInsiderTradingConfidence(const InsiderTradingPattern& pattern) {
        double confidence = 0.0;

        // High statistical deviation (> 3σ)
        if (pattern.historical_deviation_score > 3.0) {
            confidence += 0.3;
        } else if (pattern.historical_deviation_score > 2.0) {
            confidence += 0.2;
        }

        // Suspicious timing
        if (pattern.timing_suspicious) {
            confidence += 0.2;
        }

        // Unusual profit
        if (pattern.unusual_profit) {
            confidence += 0.2;
            // Very large profit
            if (pattern.profit_amount > 100000.0) {
                confidence += 0.1;
            }
        }

        // Potential access to information
        if (pattern.had_potential_access) {
            confidence += 0.3;
        }

        return std::min(confidence, 1.0);
    }

    void GenerateInsiderTradingAlert(const InsiderTradingPattern& pattern) {
        SurveillanceAlert alert{};

        GenerateAlertID(alert.alert_id);
        alert.alert_timestamp_ns = GetNanosecondTimestamp();
        alert.severity = AlertSeverity::CRITICAL;
        strcpy(alert.alert_type, "INSIDER_TRADING");

        snprintf(alert.description, sizeof(alert.description),
                "Potential insider trading: Account traded %ld hours before %s, "
                "deviation score %.2f σ, profit $%.2f",
                pattern.time_before_news.count(),
                pattern.related_corporate_event.c_str(),
                pattern.historical_deviation_score,
                pattern.profit_amount);

        alert.symbols.push_back(pattern.symbol);
        alert.accounts.push_back(pattern.account_id);
        alert.confidence_score = pattern.confidence_score;

        strcpy(alert.status, "NEW");

        StoreAlert(alert);
        NotifyCompliance(alert);
        NotifyRegulators(alert);  // May require SAR filing

        LOG_CRITICAL("Insider trading alert generated: " << alert.alert_id);
    }

    std::atomic<bool> running_{true};
};


================================================================================
SECTION 3: CROSS-MARKET MANIPULATION
================================================================================

3.1 CROSS-VENUE MANIPULATION DETECTION
---------------------------------------

class CrossMarketManipulationDetector {
public:
    struct CrossMarketPattern {
        std::string symbol;
        std::vector<std::string> venues;
        std::vector<std::string> accounts;
        uint64_t detection_time_ns;

        // Pattern characteristics
        double price_divergence;          // Price diff across venues
        bool coordinated_trading;         // Coordinated across venues
        double arbitrage_profit;          // Profit from manipulation

        // Spoofing across markets
        bool spoofing_one_market;
        bool executing_another_market;

        double confidence_score;
    };

    void MonitorCrossMarketManipulation() {
        while (running_) {
            auto now_ns = GetNanosecondTimestamp();

            auto multi_listed_symbols = GetMultiListedSymbols();

            for (const auto& symbol : multi_listed_symbols) {
                // Get trading activity across all venues
                auto venues = GetTradingVenues(symbol);

                if (venues.size() < 2) continue;

                // Analyze cross-venue patterns
                CrossMarketPattern pattern =
                    AnalyzeCrossVenueActivity(symbol, venues, now_ns);

                if (pattern.confidence_score > 0.70) {
                    GenerateCrossMarketAlert(pattern);
                }
            }

            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
    }

private:
    CrossMarketPattern AnalyzeCrossVenueActivity(
        const std::string& symbol,
        const std::vector<std::string>& venues,
        uint64_t now_ns) {

        CrossMarketPattern pattern{};
        pattern.symbol = symbol;
        pattern.venues = venues;
        pattern.detection_time_ns = now_ns;

        auto window_start = now_ns - (60ULL * 1000000000ULL);  // 1 minute

        // Get prices across venues
        std::map<std::string, double> venue_prices;
        for (const auto& venue : venues) {
            venue_prices[venue] = GetMarketPrice(symbol, venue, now_ns);
        }

        // Calculate price divergence
        auto [min_price, max_price] = std::minmax_element(
            venue_prices.begin(), venue_prices.end(),
            [](const auto& a, const auto& b) { return a.second < b.second; });

        pattern.price_divergence = (max_price->second - min_price->second) /
                                  min_price->second;

        // Check for spoofing on one venue, execution on another
        for (size_t i = 0; i < venues.size(); i++) {
            for (size_t j = i + 1; j < venues.size(); j++) {
                const auto& venue1 = venues[i];
                const auto& venue2 = venues[j];

                // Check if same account is spoofing on venue1 and executing on venue2
                auto venue1_orders = GetOrdersInWindow(symbol, venue1,
                                                      window_start, now_ns);
                auto venue2_orders = GetOrdersInWindow(symbol, venue2,
                                                      window_start, now_ns);

                if (IsCrossVenueSpoofing(venue1_orders, venue2_orders)) {
                    pattern.spoofing_one_market = true;
                    pattern.executing_another_market = true;
                }
            }
        }

        pattern.confidence_score = CalculateCrossMarketConfidence(pattern);

        return pattern;
    }

    bool IsCrossVenueSpoofing(const std::vector<Order>& venue1_orders,
                             const std::vector<Order>& venue2_orders) {
        // Check if same account is placing large cancelled orders on venue1
        // while executing on venue2

        // Group by account
        std::map<std::string, std::vector<Order>> venue1_by_account;
        std::map<std::string, std::vector<Order>> venue2_by_account;

        for (const auto& order : venue1_orders) {
            venue1_by_account[order.account_id].push_back(order);
        }
        for (const auto& order : venue2_orders) {
            venue2_by_account[order.account_id].push_back(order);
        }

        // Check for pattern
        for (const auto& [account, v1_orders] : venue1_by_account) {
            // Check if account has cancelled orders on venue1
            uint32_t cancelled_count = 0;
            for (const auto& order : v1_orders) {
                if (order.status == "CANCELLED") cancelled_count++;
            }

            if (cancelled_count < 5) continue;

            // Check if same account executed on venue2
            auto it = venue2_by_account.find(account);
            if (it != venue2_by_account.end()) {
                uint32_t executed_count = 0;
                for (const auto& order : it->second) {
                    if (order.status == "FILLED") executed_count++;
                }

                if (executed_count > 0) {
                    return true;  // Found cross-venue spoofing
                }
            }
        }

        return false;
    }

    double CalculateCrossMarketConfidence(const CrossMarketPattern& pattern) {
        double confidence = 0.0;

        // Significant price divergence (> 0.5%)
        if (pattern.price_divergence > 0.005) {
            confidence += 0.3;
        }

        // Spoofing detected
        if (pattern.spoofing_one_market && pattern.executing_another_market) {
            confidence += 0.5;
        }

        // Profit from arbitrage
        if (pattern.arbitrage_profit > 1000.0) {
            confidence += 0.2;
        }

        return std::min(confidence, 1.0);
    }

    void GenerateCrossMarketAlert(const CrossMarketPattern& pattern) {
        SurveillanceAlert alert{};

        GenerateAlertID(alert.alert_id);
        alert.alert_timestamp_ns = GetNanosecondTimestamp();
        alert.severity = AlertSeverity::HIGH;
        strcpy(alert.alert_type, "CROSS_MARKET_MANIPULATION");

        snprintf(alert.description, sizeof(alert.description),
                "Potential cross-market manipulation: Price divergence %.2f%%, "
                "spoofing detected across venues",
                pattern.price_divergence * 100.0);

        alert.symbols.push_back(pattern.symbol);
        alert.accounts = pattern.accounts;
        alert.confidence_score = pattern.confidence_score;

        strcpy(alert.status, "NEW");

        StoreAlert(alert);
        NotifyCompliance(alert);

        LOG_WARN("Cross-market manipulation alert: " << alert.alert_id);
    }

    std::atomic<bool> running_{true};
};


================================================================================
SECTION 4: MACHINE LEARNING MODELS
================================================================================

4.1 ANOMALY DETECTION MODELS
-----------------------------

class MLAnomalyDetector {
public:
    struct TrainingFeatures {
        // Time-based features
        uint8_t hour_of_day;
        uint8_t day_of_week;
        bool near_market_open;
        bool near_market_close;

        // Trading features
        double order_size_zscore;
        double order_rate_zscore;
        double price_deviation_from_vwap;
        double order_imbalance;

        // Historical features
        double avg_trade_size_30d;
        double std_trade_size_30d;
        uint32_t avg_trades_per_day_30d;

        // Behavioral features
        double cancel_rate;
        double modify_rate;
        double order_lifetime_avg_ms;

        // Market context
        double market_volatility;
        double market_volume_ratio;
        uint32_t market_participant_count;
    };

    struct AnomalyScore {
        double score;                     // 0.0 - 1.0
        std::vector<std::string> contributing_features;
        std::string explanation;
    };

    MLAnomalyDetector() {
        LoadTrainedModels();
        inference_thread_ = std::thread(&MLAnomalyDetector::InferenceLoop, this);
    }

    AnomalyScore DetectAnomaly(const Order& order) {
        // Extract features
        TrainingFeatures features = ExtractFeatures(order);

        // Run through ensemble of models
        std::vector<double> model_scores;

        // Isolation Forest
        model_scores.push_back(isolation_forest_->Predict(features));

        // Autoencoder (reconstruction error)
        model_scores.push_back(autoencoder_->Predict(features));

        // LSTM (sequence anomaly)
        model_scores.push_back(lstm_model_->Predict(features, GetOrderSequence(order)));

        // Combine scores (weighted average)
        double combined_score = 0.0;
        combined_score += 0.4 * model_scores[0];  // Isolation forest
        combined_score += 0.3 * model_scores[1];  // Autoencoder
        combined_score += 0.3 * model_scores[2];  // LSTM

        AnomalyScore result;
        result.score = combined_score;

        // Identify contributing features
        if (combined_score > 0.7) {
            result.contributing_features = IdentifyContributingFeatures(features);
            result.explanation = GenerateExplanation(features,
                                                    result.contributing_features);
        }

        return result;
    }

private:
    TrainingFeatures ExtractFeatures(const Order& order) {
        TrainingFeatures features{};

        // Time features
        auto time_info = GetTimeInfo(order.creation_time_ns);
        features.hour_of_day = time_info.hour;
        features.day_of_week = time_info.day_of_week;
        features.near_market_open = time_info.minutes_from_open < 30;
        features.near_market_close = time_info.minutes_to_close < 30;

        // Trading features
        auto historical_stats = GetHistoricalStats(order.account_id, order.symbol);
        features.order_size_zscore =
            (order.quantity - historical_stats.mean_size) / historical_stats.std_size;

        auto current_rate = GetCurrentOrderRate(order.account_id);
        features.order_rate_zscore =
            (current_rate - historical_stats.mean_rate) / historical_stats.std_rate;

        double vwap = GetVWAP(order.symbol);
        features.price_deviation_from_vwap = (order.limit_price - vwap) / vwap;

        auto book_imbalance = GetOrderBookImbalance(order.symbol);
        features.order_imbalance = book_imbalance;

        // Historical features
        features.avg_trade_size_30d = historical_stats.avg_size_30d;
        features.std_trade_size_30d = historical_stats.std_size_30d;
        features.avg_trades_per_day_30d = historical_stats.avg_trades_per_day_30d;

        // Behavioral features
        auto behavior = GetTradingBehavior(order.account_id, 7);
        features.cancel_rate = behavior.cancel_rate;
        features.modify_rate = behavior.modify_rate;
        features.order_lifetime_avg_ms = behavior.avg_lifetime_ms;

        // Market context
        features.market_volatility = GetMarketVolatility(order.symbol);
        features.market_volume_ratio = GetVolumeRatio(order.symbol);
        features.market_participant_count = GetParticipantCount(order.symbol);

        return features;
    }

    void InferenceLoop() {
        while (running_) {
            // Process queued orders through ML models
            Order order;
            if (inference_queue_.try_dequeue(order)) {
                auto anomaly_score = DetectAnomaly(order);

                if (anomaly_score.score > 0.75) {
                    GenerateMLAlert(order, anomaly_score);
                }
            } else {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
            }
        }
    }

    void GenerateMLAlert(const Order& order, const AnomalyScore& score) {
        SurveillanceAlert alert{};

        GenerateAlertID(alert.alert_id);
        alert.alert_timestamp_ns = GetNanosecondTimestamp();
        alert.severity = (score.score > 0.90) ? AlertSeverity::HIGH :
                                               AlertSeverity::MEDIUM;
        strcpy(alert.alert_type, "ML_ANOMALY");

        snprintf(alert.description, sizeof(alert.description),
                "ML anomaly detected: score %.2f - %s",
                score.score,
                score.explanation.c_str());

        alert.order_ids.push_back(order.id);
        alert.symbols.push_back(order.symbol);
        alert.accounts.push_back(order.account_id);
        alert.confidence_score = score.score;

        strcpy(alert.status, "NEW");

        StoreAlert(alert);
        NotifyCompliance(alert);

        LOG_INFO("ML anomaly alert generated: " << alert.alert_id);
    }

    std::unique_ptr<IsolationForestModel> isolation_forest_;
    std::unique_ptr<AutoencoderModel> autoencoder_;
    std::unique_ptr<LSTMModel> lstm_model_;

    moodycamel::ConcurrentQueue<Order> inference_queue_;
    std::thread inference_thread_;
    std::atomic<bool> running_{true};
};


================================================================================
SECTION 5: SUSPICIOUS ACTIVITY REPORTING (SAR)
================================================================================

5.1 SAR GENERATION AND FILING
------------------------------

class SuspiciousActivityReporter {
public:
    struct SARReport {
        char sar_id[64];
        uint64_t generation_time_ns;
        uint64_t filing_deadline_ns;

        // Subject information
        std::vector<std::string> subject_accounts;
        std::vector<std::string> subject_individuals;

        // Suspicious activity description
        char activity_type[128];
        char detailed_description[4096];
        uint64_t activity_start_ns;
        uint64_t activity_end_ns;

        // Financial information
        double total_dollar_amount;
        uint32_t number_of_transactions;

        // Supporting documentation
        std::vector<std::string> supporting_documents;
        std::vector<std::string> related_alerts;

        // Filing information
        char filing_institution[128];
        char filing_contact_name[64];
        char filing_contact_phone[20];
        bool filed;
        uint64_t filed_timestamp_ns;
    };

    void ConsiderSARFiling(const SurveillanceAlert& alert) {
        // Determine if alert warrants SAR filing
        if (RequiresSARFiling(alert)) {
            SARReport sar = GenerateSARReport(alert);

            // Review and approval process
            SubmitForSARReview(sar);
        }
    }

private:
    bool RequiresSARFiling(const SurveillanceAlert& alert) {
        // SAR filing requirements:
        // 1. Suspected insider trading
        // 2. Market manipulation
        // 3. Transactions > $5,000 involving potential violations
        // 4. Aggregated suspicious activity

        if (alert.alert_type == "INSIDER_TRADING" &&
            alert.confidence_score > 0.80) {
            return true;
        }

        if ((alert.alert_type == "SPOOFING" ||
             alert.alert_type == "LAYERING" ||
             alert.alert_type == "WASH_TRADING") &&
            alert.confidence_score > 0.85) {
            return true;
        }

        // Check dollar amount threshold
        double total_amount = CalculateTransactionAmount(alert);
        if (total_amount > 5000.0 && alert.confidence_score > 0.75) {
            return true;
        }

        return false;
    }

    SARReport GenerateSARReport(const SurveillanceAlert& alert) {
        SARReport sar{};

        GenerateSARID(sar.sar_id);
        sar.generation_time_ns = GetNanosecondTimestamp();

        // SAR must be filed within 30 days
        sar.filing_deadline_ns = sar.generation_time_ns +
                                (30ULL * 24 * 3600 * 1000000000ULL);

        // Populate subject information
        sar.subject_accounts = alert.accounts;

        // Activity description
        strcpy(sar.activity_type, alert.alert_type);
        strcpy(sar.detailed_description, alert.description);

        // Financial information
        sar.total_dollar_amount = CalculateTransactionAmount(alert);
        sar.number_of_transactions = CountTransactions(alert);

        // Filing institution information
        strcpy(sar.filing_institution, firm_name_.c_str());
        strcpy(sar.filing_contact_name, compliance_officer_.c_str());

        sar.filed = false;

        return sar;
    }

    void SubmitForSARReview(const SARReport& sar) {
        // Store SAR for compliance review
        StoreSARReport(sar);

        // Notify compliance officer
        NotifyComplianceOfficer("SAR review required", sar.sar_id);

        LOG_INFO("SAR generated for review: " << sar.sar_id);
    }

    void FileSAR(const std::string& sar_id) {
        auto sar = GetSARReport(sar_id);

        // Generate BSA E-Filing XML
        std::string sar_xml = FormatSAR_XML(sar);

        // Submit to FinCEN via BSA E-Filing System
        if (SubmitToFinCEN(sar_xml)) {
            sar.filed = true;
            sar.filed_timestamp_ns = GetNanosecondTimestamp();
            UpdateSARReport(sar);

            LOG_INFO("SAR filed successfully: " << sar_id);
        } else {
            LOG_ERROR("SAR filing failed: " << sar_id);
        }
    }

    std::string firm_name_;
    std::string compliance_officer_;
};

================================================================================
END OF DOCUMENT
================================================================================
