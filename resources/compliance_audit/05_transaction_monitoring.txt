================================================================================
TRANSACTION MONITORING SYSTEM
Real-Time Surveillance and Pattern Detection
High-Frequency Trading Compliance
================================================================================

OVERVIEW
--------
Comprehensive transaction monitoring framework for detecting suspicious trading
patterns, market manipulation, insider trading, and other regulatory violations
in real-time. Implements automated surveillance with machine learning models.

================================================================================
SECTION 1: SURVEILLANCE ARCHITECTURE
================================================================================

1.1 REAL-TIME MONITORING FRAMEWORK
-----------------------------------

class TransactionMonitoringEngine {
public:
    enum class AlertSeverity {
        INFO,           // Informational
        LOW,            // Minor deviation
        MEDIUM,         // Suspicious pattern
        HIGH,           // Likely violation
        CRITICAL        // Immediate action required
    };

    struct SurveillanceAlert {
        char alert_id[64];
        uint64_t alert_timestamp_ns;
        AlertSeverity severity;
        char alert_type[64];
        char description[512];

        // Associated entities
        std::vector<std::string> order_ids;
        std::vector<std::string> symbols;
        std::vector<std::string> accounts;
        std::vector<std::string> traders;

        // Metrics
        std::map<std::string, double> metric_values;
        double confidence_score;          // 0.0 - 1.0

        // Status
        char status[32];                  // NEW, INVESTIGATING, CLOSED
        char assigned_to[64];
        char resolution[256];
        uint64_t closed_timestamp_ns;
    };

    TransactionMonitoringEngine() {
        InitializeMonitoringRules();
        StartMonitoringThreads();
    }

private:
    void StartMonitoringThreads() {
        // Multiple monitoring threads for different checks
        monitoring_threads_.emplace_back(
            &TransactionMonitoringEngine::MonitorLayering, this);
        monitoring_threads_.emplace_back(
            &TransactionMonitoringEngine::MonitorSpoofing, this);
        monitoring_threads_.emplace_back(
            &TransactionMonitoringEngine::MonitorWashTrading, this);
        monitoring_threads_.emplace_back(
            &TransactionMonitoringEngine::MonitorFrontRunning, this);
        monitoring_threads_.emplace_back(
            &TransactionMonitoringEngine::MonitorPriceManipulation, this);
        monitoring_threads_.emplace_back(
            &TransactionMonitoringEngine::MonitorInsiderTrading, this);
        monitoring_threads_.emplace_back(
            &TransactionMonitoringEngine::MonitorCrossTrade, this);
    }

    std::vector<std::thread> monitoring_threads_;
    std::atomic<bool> running_{true};
};


1.2 EVENT STREAM PROCESSING
----------------------------

class EventStreamProcessor {
public:
    struct TradeEvent {
        uint64_t timestamp_ns;
        char order_id[64];
        char symbol[16];
        char account_id[32];
        char trader_id[16];
        char side;
        int64_t quantity;
        double price;
        char event_type[32];
        char venue[8];
    };

    EventStreamProcessor() {
        // Initialize lock-free queue for event processing
        event_queue_ = new moodycamel::ConcurrentQueue<TradeEvent>(1000000);

        // Start processing threads (one per CPU core)
        uint32_t num_threads = std::thread::hardware_concurrency();
        for (uint32_t i = 0; i < num_threads; i++) {
            processing_threads_.emplace_back(
                &EventStreamProcessor::ProcessEvents, this, i);
        }
    }

    void IngestEvent(const TradeEvent& event) {
        event_queue_->enqueue(event);

        // Update real-time statistics
        UpdateStatistics(event);

        // Check immediate thresholds
        CheckImmediateThresholds(event);
    }

private:
    void ProcessEvents(uint32_t thread_id) {
        TradeEvent event;

        while (running_) {
            if (event_queue_->try_dequeue(event)) {
                // Process through all monitoring rules
                ProcessEventThroughRules(event);

                // Update time-series data
                UpdateTimeSeries(event);

                // Feed to ML models
                FeedToMLModels(event);
            } else {
                // Small sleep to reduce CPU usage when idle
                std::this_thread::sleep_for(std::chrono::microseconds(100));
            }
        }
    }

    void ProcessEventThroughRules(const TradeEvent& event) {
        // Check against all active rules
        for (const auto& rule : monitoring_rules_) {
            if (rule.enabled && rule.applies_to(event)) {
                auto result = rule.evaluate(event, GetContext(event));

                if (result.violation_detected) {
                    GenerateAlert(event, rule, result);
                }
            }
        }
    }

    moodycamel::ConcurrentQueue<TradeEvent>* event_queue_;
    std::vector<std::thread> processing_threads_;
    std::atomic<bool> running_{true};
};


================================================================================
SECTION 2: MARKET MANIPULATION DETECTION
================================================================================

2.1 LAYERING DETECTION
-----------------------

Layering: Placing multiple orders on one side of the book with no intention
to execute, creating false impression of supply/demand.

class LayeringDetector {
public:
    struct LayeringPattern {
        std::string symbol;
        std::string account_id;
        uint64_t detection_time_ns;

        // Pattern characteristics
        uint32_t num_orders_placed;       // Orders placed on one side
        uint32_t num_orders_cancelled;    // Rapid cancellations
        double total_quantity_placed;
        double total_quantity_cancelled;
        std::chrono::milliseconds avg_order_lifetime;

        // Execution on opposite side
        bool executed_opposite_side;
        double opposite_side_quantity;
        double opposite_side_price;

        // Scoring
        double pattern_confidence;        // 0.0 - 1.0
    };

    void MonitorLayering() {
        while (running_) {
            auto now_ns = GetNanosecondTimestamp();

            // Check recent order activity (last 5 minutes)
            auto recent_window = now_ns - (5ULL * 60 * 1000000000ULL);

            // Group orders by symbol and account
            auto grouped_orders = GroupOrdersBySymbolAccount(recent_window, now_ns);

            for (const auto& [key, orders] : grouped_orders) {
                auto [symbol, account] = key;

                // Analyze order pattern
                if (IsLayeringPattern(orders)) {
                    LayeringPattern pattern = AnalyzeLayeringPattern(orders);

                    if (pattern.pattern_confidence > 0.75) {
                        GenerateLayeringAlert(pattern);
                    }
                }
            }

            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }

private:
    bool IsLayeringPattern(const std::vector<Order>& orders) {
        // Layering indicators:
        // 1. Multiple orders on one side of book
        // 2. Rapid cancellation of those orders
        // 3. Execution on opposite side shortly after
        // 4. Price movement in favorable direction

        // Count orders by side
        uint32_t buy_orders = 0, sell_orders = 0;
        uint32_t buy_cancels = 0, sell_cancels = 0;
        uint32_t buy_executions = 0, sell_executions = 0;

        for (const auto& order : orders) {
            if (order.side == 'B') {
                buy_orders++;
                if (order.status == "CANCELLED") buy_cancels++;
                if (order.status == "FILLED") buy_executions++;
            } else {
                sell_orders++;
                if (order.status == "CANCELLED") sell_cancels++;
                if (order.status == "FILLED") sell_executions++;
            }
        }

        // Check for pattern:
        // Many orders on one side with high cancel rate
        // Few executions on that side
        // Execution on opposite side

        bool heavy_buy_side = (buy_orders > 10 &&
                              static_cast<double>(buy_cancels) / buy_orders > 0.8 &&
                              buy_executions < 3 &&
                              sell_executions > 0);

        bool heavy_sell_side = (sell_orders > 10 &&
                               static_cast<double>(sell_cancels) / sell_orders > 0.8 &&
                               sell_executions < 3 &&
                               buy_executions > 0);

        return heavy_buy_side || heavy_sell_side;
    }

    LayeringPattern AnalyzeLayeringPattern(const std::vector<Order>& orders) {
        LayeringPattern pattern{};

        pattern.symbol = orders[0].symbol;
        pattern.account_id = orders[0].account_id;
        pattern.detection_time_ns = GetNanosecondTimestamp();

        // Calculate metrics
        uint64_t total_lifetime_ns = 0;
        char dominant_side = '\0';
        uint32_t dominant_side_orders = 0;

        for (const auto& order : orders) {
            if (order.status == "CANCELLED") {
                pattern.num_orders_cancelled++;
                pattern.total_quantity_cancelled += order.quantity;

                // Order lifetime
                uint64_t lifetime_ns = order.cancel_time_ns - order.creation_time_ns;
                total_lifetime_ns += lifetime_ns;
            }

            pattern.num_orders_placed++;
            pattern.total_quantity_placed += order.quantity;

            // Determine dominant side
            if (order.side == 'B' || order.side == 'S') {
                if (dominant_side == '\0') {
                    dominant_side = order.side;
                    dominant_side_orders = 1;
                } else if (dominant_side == order.side) {
                    dominant_side_orders++;
                }
            }
        }

        // Average order lifetime
        if (pattern.num_orders_cancelled > 0) {
            uint64_t avg_lifetime_ns = total_lifetime_ns / pattern.num_orders_cancelled;
            pattern.avg_order_lifetime =
                std::chrono::milliseconds(avg_lifetime_ns / 1000000);
        }

        // Check for execution on opposite side
        char opposite_side = (dominant_side == 'B') ? 'S' : 'B';
        for (const auto& order : orders) {
            if (order.side == opposite_side && order.status == "FILLED") {
                pattern.executed_opposite_side = true;
                pattern.opposite_side_quantity += order.filled_quantity;
                pattern.opposite_side_price = order.average_fill_price;
            }
        }

        // Calculate confidence score
        pattern.pattern_confidence = CalculateLayeringConfidence(pattern);

        return pattern;
    }

    double CalculateLayeringConfidence(const LayeringPattern& pattern) {
        double confidence = 0.0;

        // High cancellation rate
        double cancel_rate = pattern.total_quantity_cancelled /
                            pattern.total_quantity_placed;
        if (cancel_rate > 0.9) confidence += 0.3;
        else if (cancel_rate > 0.8) confidence += 0.2;

        // Short order lifetime
        if (pattern.avg_order_lifetime < std::chrono::seconds(5)) {
            confidence += 0.3;
        } else if (pattern.avg_order_lifetime < std::chrono::seconds(30)) {
            confidence += 0.2;
        }

        // Execution on opposite side
        if (pattern.executed_opposite_side) {
            confidence += 0.3;
        }

        // Many orders
        if (pattern.num_orders_placed > 20) {
            confidence += 0.1;
        }

        return std::min(confidence, 1.0);
    }

    void GenerateLayeringAlert(const LayeringPattern& pattern) {
        SurveillanceAlert alert{};

        GenerateAlertID(alert.alert_id);
        alert.alert_timestamp_ns = GetNanosecondTimestamp();
        alert.severity = AlertSeverity::HIGH;
        strcpy(alert.alert_type, "LAYERING");

        snprintf(alert.description, sizeof(alert.description),
                "Potential layering detected: %s placed %u orders (%.0f shares), "
                "cancelled %u orders (%.0f shares), executed %.0f shares on opposite side",
                pattern.symbol.c_str(),
                pattern.num_orders_placed,
                pattern.total_quantity_placed,
                pattern.num_orders_cancelled,
                pattern.total_quantity_cancelled,
                pattern.opposite_side_quantity);

        alert.symbols.push_back(pattern.symbol);
        alert.accounts.push_back(pattern.account_id);
        alert.confidence_score = pattern.pattern_confidence;

        strcpy(alert.status, "NEW");

        // Store alert
        StoreAlert(alert);

        // Notify compliance team
        NotifyCompliance(alert);

        LOG_WARN("Layering alert generated: " << alert.alert_id);
    }

    std::atomic<bool> running_{true};
};


2.2 SPOOFING DETECTION
-----------------------

Spoofing: Placing orders with intent to cancel before execution to manipulate
price movement.

class SpoofingDetector {
public:
    struct SpoofingPattern {
        std::string symbol;
        std::string account_id;
        uint64_t detection_time_ns;

        // Pattern characteristics
        double large_order_size;          // Large order placed
        double large_order_price;
        char large_order_side;
        std::chrono::milliseconds large_order_lifetime;
        bool large_order_cancelled;

        // Market reaction
        double price_movement;            // Price moved towards large order
        bool executed_during_movement;    // Executed opposite side
        double execution_quantity;

        double pattern_confidence;
    };

    void MonitorSpoofing() {
        while (running_) {
            // Monitor order book for large orders
            auto large_orders = IdentifyLargeOrders();

            for (const auto& large_order : large_orders) {
                // Track order lifecycle
                TrackOrderLifecycle(large_order);

                // Check for spoofing pattern
                if (IsSpoofingPattern(large_order)) {
                    SpoofingPattern pattern = AnalyzeSpoofingPattern(large_order);

                    if (pattern.pattern_confidence > 0.70) {
                        GenerateSpoofingAlert(pattern);
                    }
                }
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }

private:
    bool IsSpoofingPattern(const Order& order) {
        // Spoofing indicators:
        // 1. Large order placed (relative to typical order size)
        // 2. Price moves toward the large order
        // 3. Trader executes on opposite side during price movement
        // 4. Large order cancelled before execution

        // Check if order is large (> 5x average)
        double avg_order_size = GetAverageOrderSize(order.symbol, order.account_id);
        if (order.quantity < avg_order_size * 5) {
            return false;
        }

        // Check if order was cancelled quickly
        if (order.status != "CANCELLED") {
            return false;
        }

        uint64_t lifetime_ns = order.cancel_time_ns - order.creation_time_ns;
        if (lifetime_ns > 30ULL * 1000000000ULL) {  // > 30 seconds
            return false;
        }

        // Check for opposite-side execution during lifetime
        auto opposite_executions = GetOppositeExecutions(
            order.symbol,
            order.account_id,
            order.side == 'B' ? 'S' : 'B',
            order.creation_time_ns,
            order.cancel_time_ns);

        if (opposite_executions.empty()) {
            return false;
        }

        // Check price movement
        double price_before = GetMarketPrice(order.symbol, order.creation_time_ns);
        double price_after = GetMarketPrice(order.symbol, order.cancel_time_ns);

        // Price should move toward the large order
        if (order.side == 'B' && price_after <= price_before) {
            return false;  // Buy order should push price up
        }
        if (order.side == 'S' && price_after >= price_before) {
            return false;  // Sell order should push price down
        }

        return true;
    }

    SpoofingPattern AnalyzeSpoofingPattern(const Order& order) {
        SpoofingPattern pattern{};

        pattern.symbol = order.symbol;
        pattern.account_id = order.account_id;
        pattern.detection_time_ns = GetNanosecondTimestamp();

        pattern.large_order_size = order.quantity;
        pattern.large_order_price = order.limit_price;
        pattern.large_order_side = order.side;

        uint64_t lifetime_ns = order.cancel_time_ns - order.creation_time_ns;
        pattern.large_order_lifetime =
            std::chrono::milliseconds(lifetime_ns / 1000000);
        pattern.large_order_cancelled = true;

        // Calculate price movement
        double price_before = GetMarketPrice(order.symbol, order.creation_time_ns);
        double price_after = GetMarketPrice(order.symbol, order.cancel_time_ns);
        pattern.price_movement = price_after - price_before;

        // Get opposite-side executions
        auto opposite_executions = GetOppositeExecutions(
            order.symbol,
            order.account_id,
            order.side == 'B' ? 'S' : 'B',
            order.creation_time_ns,
            order.cancel_time_ns);

        if (!opposite_executions.empty()) {
            pattern.executed_during_movement = true;
            for (const auto& exec : opposite_executions) {
                pattern.execution_quantity += exec.quantity;
            }
        }

        // Calculate confidence
        pattern.pattern_confidence = CalculateSpoofingConfidence(pattern);

        return pattern;
    }

    double CalculateSpoofingConfidence(const SpoofingPattern& pattern) {
        double confidence = 0.0;

        // Large order size relative to market
        double avg_size = GetAverageOrderSize(pattern.symbol, pattern.account_id);
        double size_ratio = pattern.large_order_size / avg_size;
        if (size_ratio > 10) confidence += 0.3;
        else if (size_ratio > 5) confidence += 0.2;

        // Quick cancellation
        if (pattern.large_order_lifetime < std::chrono::seconds(10)) {
            confidence += 0.3;
        } else if (pattern.large_order_lifetime < std::chrono::seconds(30)) {
            confidence += 0.2;
        }

        // Execution on opposite side
        if (pattern.executed_during_movement) {
            confidence += 0.3;
        }

        // Significant price movement
        double price_change_pct = std::abs(pattern.price_movement) /
                                 pattern.large_order_price * 100.0;
        if (price_change_pct > 0.5) {
            confidence += 0.1;
        }

        return std::min(confidence, 1.0);
    }

    void GenerateSpoofingAlert(const SpoofingPattern& pattern) {
        SurveillanceAlert alert{};

        GenerateAlertID(alert.alert_id);
        alert.alert_timestamp_ns = GetNanosecondTimestamp();
        alert.severity = AlertSeverity::CRITICAL;
        strcpy(alert.alert_type, "SPOOFING");

        snprintf(alert.description, sizeof(alert.description),
                "Potential spoofing detected: Large %s order (%.0f shares) "
                "cancelled after %lld ms, price moved %.4f, executed %.0f shares opposite",
                pattern.large_order_side == 'B' ? "BUY" : "SELL",
                pattern.large_order_size,
                pattern.large_order_lifetime.count(),
                pattern.price_movement,
                pattern.execution_quantity);

        alert.symbols.push_back(pattern.symbol);
        alert.accounts.push_back(pattern.account_id);
        alert.confidence_score = pattern.pattern_confidence;

        strcpy(alert.status, "NEW");

        StoreAlert(alert);
        NotifyCompliance(alert);

        LOG_CRITICAL("Spoofing alert generated: " << alert.alert_id);
    }

    std::atomic<bool> running_{true};
};


2.3 WASH TRADING DETECTION
---------------------------

Wash Trading: Buying and selling the same security to create artificial volume.

class WashTradingDetector {
public:
    struct WashTradingPattern {
        std::string symbol;
        std::vector<std::string> related_accounts;
        uint64_t detection_time_ns;

        // Pattern characteristics
        uint32_t matched_trades_count;
        double matched_volume;
        double price_variance;            // Low variance indicates wash
        std::chrono::milliseconds avg_time_between_trades;

        // Account relationships
        bool same_beneficial_owner;
        bool coordinated_trading;
        double pattern_confidence;
    };

    void MonitorWashTrading() {
        while (running_) {
            auto now_ns = GetNanosecondTimestamp();
            auto window_start = now_ns - (60ULL * 60 * 1000000000ULL);  // 1 hour

            // Get all executions in window
            auto executions = GetExecutionsInWindow(window_start, now_ns);

            // Group by symbol
            std::map<std::string, std::vector<Execution>> by_symbol;
            for (const auto& exec : executions) {
                by_symbol[exec.symbol].push_back(exec);
            }

            // Check each symbol for wash trading
            for (const auto& [symbol, symbol_execs] : by_symbol) {
                if (IsWashTradingPattern(symbol_execs)) {
                    WashTradingPattern pattern = AnalyzeWashTrading(symbol_execs);

                    if (pattern.pattern_confidence > 0.70) {
                        GenerateWashTradingAlert(pattern);
                    }
                }
            }

            std::this_thread::sleep_for(std::chrono::minutes(5));
        }
    }

private:
    bool IsWashTradingPattern(const std::vector<Execution>& executions) {
        // Wash trading indicators:
        // 1. Buy and sell executions at similar prices
        // 2. Similar quantities
        // 3. Related accounts (same owner or coordinated)
        // 4. No economic benefit (net position unchanged)

        // Find matching buy/sell pairs
        std::vector<std::pair<Execution, Execution>> matched_pairs;

        for (size_t i = 0; i < executions.size(); i++) {
            for (size_t j = i + 1; j < executions.size(); j++) {
                const auto& exec1 = executions[i];
                const auto& exec2 = executions[j];

                // Opposite sides
                if (exec1.side == exec2.side) continue;

                // Similar prices (within 0.1%)
                double price_diff_pct = std::abs(exec1.price - exec2.price) /
                                       exec1.price * 100.0;
                if (price_diff_pct > 0.1) continue;

                // Similar quantities (within 5%)
                double qty_diff_pct = std::abs(static_cast<double>(exec1.quantity) -
                                              static_cast<double>(exec2.quantity)) /
                                     exec1.quantity * 100.0;
                if (qty_diff_pct > 5.0) continue;

                // Within short time window (< 10 minutes)
                uint64_t time_diff_ns = (exec2.execution_time_ns >
                                        exec1.execution_time_ns) ?
                                       (exec2.execution_time_ns -
                                        exec1.execution_time_ns) :
                                       (exec1.execution_time_ns -
                                        exec2.execution_time_ns);
                if (time_diff_ns > 10ULL * 60 * 1000000000ULL) continue;

                // Check account relationship
                if (AreAccountsRelated(exec1.account_id, exec2.account_id)) {
                    matched_pairs.push_back({exec1, exec2});
                }
            }
        }

        // Significant number of matched pairs
        return matched_pairs.size() >= 3;
    }

    bool AreAccountsRelated(const std::string& account1,
                           const std::string& account2) {
        // Check if accounts have same beneficial owner
        auto owner1 = GetBeneficialOwner(account1);
        auto owner2 = GetBeneficialOwner(account2);

        if (owner1 == owner2) {
            return true;
        }

        // Check for coordinated trading patterns
        return DetectCoordinatedTrading(account1, account2);
    }

    WashTradingPattern AnalyzeWashTrading(
        const std::vector<Execution>& executions) {

        WashTradingPattern pattern{};
        pattern.symbol = executions[0].symbol;
        pattern.detection_time_ns = GetNanosecondTimestamp();

        // Find all matched pairs
        std::vector<double> prices;
        std::vector<uint64_t> time_diffs;
        std::set<std::string> involved_accounts;

        for (size_t i = 0; i < executions.size(); i++) {
            for (size_t j = i + 1; j < executions.size(); j++) {
                const auto& exec1 = executions[i];
                const auto& exec2 = executions[j];

                if (IsMatchedPair(exec1, exec2)) {
                    pattern.matched_trades_count++;
                    pattern.matched_volume += exec1.quantity;

                    prices.push_back(exec1.price);
                    prices.push_back(exec2.price);

                    uint64_t time_diff = std::abs(static_cast<int64_t>(
                        exec2.execution_time_ns - exec1.execution_time_ns));
                    time_diffs.push_back(time_diff);

                    involved_accounts.insert(exec1.account_id);
                    involved_accounts.insert(exec2.account_id);
                }
            }
        }

        pattern.related_accounts = std::vector<std::string>(
            involved_accounts.begin(), involved_accounts.end());

        // Calculate price variance (should be low for wash trading)
        if (!prices.empty()) {
            double mean = std::accumulate(prices.begin(), prices.end(), 0.0) /
                         prices.size();
            double sq_sum = 0.0;
            for (double price : prices) {
                sq_sum += (price - mean) * (price - mean);
            }
            pattern.price_variance = sq_sum / prices.size();
        }

        // Average time between trades
        if (!time_diffs.empty()) {
            uint64_t avg_ns = std::accumulate(time_diffs.begin(),
                                             time_diffs.end(), 0ULL) /
                             time_diffs.size();
            pattern.avg_time_between_trades =
                std::chrono::milliseconds(avg_ns / 1000000);
        }

        // Check for same beneficial owner
        if (pattern.related_accounts.size() >= 2) {
            pattern.same_beneficial_owner =
                AreAccountsRelated(pattern.related_accounts[0],
                                 pattern.related_accounts[1]);
        }

        // Calculate confidence
        pattern.pattern_confidence = CalculateWashTradingConfidence(pattern);

        return pattern;
    }

    double CalculateWashTradingConfidence(const WashTradingPattern& pattern) {
        double confidence = 0.0;

        // Multiple matched trades
        if (pattern.matched_trades_count > 5) confidence += 0.3;
        else if (pattern.matched_trades_count > 3) confidence += 0.2;

        // Low price variance
        if (pattern.price_variance < 0.01) confidence += 0.3;
        else if (pattern.price_variance < 0.1) confidence += 0.2;

        // Same beneficial owner
        if (pattern.same_beneficial_owner) {
            confidence += 0.4;
        }

        return std::min(confidence, 1.0);
    }

    void GenerateWashTradingAlert(const WashTradingPattern& pattern) {
        SurveillanceAlert alert{};

        GenerateAlertID(alert.alert_id);
        alert.alert_timestamp_ns = GetNanosecondTimestamp();
        alert.severity = AlertSeverity::CRITICAL;
        strcpy(alert.alert_type, "WASH_TRADING");

        snprintf(alert.description, sizeof(alert.description),
                "Potential wash trading detected: %u matched trades, "
                "%.0f shares, price variance %.4f",
                pattern.matched_trades_count,
                pattern.matched_volume,
                pattern.price_variance);

        alert.symbols.push_back(pattern.symbol);
        alert.accounts = pattern.related_accounts;
        alert.confidence_score = pattern.pattern_confidence;

        strcpy(alert.status, "NEW");

        StoreAlert(alert);
        NotifyCompliance(alert);

        LOG_CRITICAL("Wash trading alert generated: " << alert.alert_id);
    }

    std::atomic<bool> running_{true};
};


================================================================================
SECTION 3: FRONT-RUNNING DETECTION
================================================================================

3.1 CLIENT ORDER FRONT-RUNNING
-------------------------------

class FrontRunningDetector {
public:
    struct FrontRunningPattern {
        std::string symbol;
        std::string firm_account;
        std::string client_account;
        uint64_t detection_time_ns;

        // Pattern characteristics
        double firm_order_quantity;
        double firm_order_price;
        uint64_t firm_order_time_ns;

        double client_order_quantity;
        double client_order_price;
        uint64_t client_order_time_ns;

        std::chrono::milliseconds time_difference;
        bool firm_order_first;
        double firm_profit;               // Estimated profit from front-run

        double pattern_confidence;
    };

    void MonitorFrontRunning() {
        while (running_) {
            auto now_ns = GetNanosecondTimestamp();
            auto window_start = now_ns - (60ULL * 1000000000ULL);  // 1 minute

            // Get firm proprietary orders
            auto firm_orders = GetFirmProprietaryOrders(window_start, now_ns);

            // Get client orders
            auto client_orders = GetClientOrders(window_start, now_ns);

            // Check for front-running patterns
            for (const auto& firm_order : firm_orders) {
                for (const auto& client_order : client_orders) {
                    if (IsFrontRunningPattern(firm_order, client_order)) {
                        FrontRunningPattern pattern =
                            AnalyzeFrontRunning(firm_order, client_order);

                        if (pattern.pattern_confidence > 0.80) {
                            GenerateFrontRunningAlert(pattern);
                        }
                    }
                }
            }

            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
    }

private:
    bool IsFrontRunningPattern(const Order& firm_order,
                              const Order& client_order) {
        // Front-running indicators:
        // 1. Firm order placed before large client order
        // 2. Same symbol, same side
        // 3. Firm profits when client order moves market
        // 4. Short time difference

        // Same symbol
        if (firm_order.symbol != client_order.symbol) {
            return false;
        }

        // Same side
        if (firm_order.side != client_order.side) {
            return false;
        }

        // Firm order should be before client order
        if (firm_order.creation_time_ns >= client_order.creation_time_ns) {
            return false;
        }

        // Time difference should be short (< 60 seconds)
        uint64_t time_diff_ns = client_order.creation_time_ns -
                               firm_order.creation_time_ns;
        if (time_diff_ns > 60ULL * 1000000000ULL) {
            return false;
        }

        // Client order should be large (potential market impact)
        double avg_volume = GetAverageDailyVolume(client_order.symbol, 30);
        if (client_order.quantity < avg_volume * 0.01) {  // < 1% of ADV
            return false;
        }

        return true;
    }

    FrontRunningPattern AnalyzeFrontRunning(const Order& firm_order,
                                           const Order& client_order) {
        FrontRunningPattern pattern{};

        pattern.symbol = firm_order.symbol;
        pattern.firm_account = firm_order.account_id;
        pattern.client_account = client_order.account_id;
        pattern.detection_time_ns = GetNanosecondTimestamp();

        pattern.firm_order_quantity = firm_order.quantity;
        pattern.firm_order_price = firm_order.average_fill_price;
        pattern.firm_order_time_ns = firm_order.creation_time_ns;

        pattern.client_order_quantity = client_order.quantity;
        pattern.client_order_price = client_order.average_fill_price;
        pattern.client_order_time_ns = client_order.creation_time_ns;

        uint64_t time_diff_ns = client_order.creation_time_ns -
                               firm_order.creation_time_ns;
        pattern.time_difference = std::chrono::milliseconds(time_diff_ns / 1000000);
        pattern.firm_order_first = true;

        // Calculate estimated profit
        // Price likely moved in favorable direction after client order
        double price_after_client = GetMarketPrice(
            client_order.symbol,
            client_order.creation_time_ns + 1000000000ULL);  // 1 second after

        if (firm_order.side == 'B') {
            pattern.firm_profit = (price_after_client - pattern.firm_order_price) *
                                 pattern.firm_order_quantity;
        } else {
            pattern.firm_profit = (pattern.firm_order_price - price_after_client) *
                                 pattern.firm_order_quantity;
        }

        pattern.pattern_confidence = CalculateFrontRunningConfidence(pattern);

        return pattern;
    }

    double CalculateFrontRunningConfidence(const FrontRunningPattern& pattern) {
        double confidence = 0.0;

        // Short time difference
        if (pattern.time_difference < std::chrono::seconds(10)) {
            confidence += 0.4;
        } else if (pattern.time_difference < std::chrono::seconds(30)) {
            confidence += 0.3;
        }

        // Firm made profit
        if (pattern.firm_profit > 0) {
            confidence += 0.4;

            // Significant profit
            if (pattern.firm_profit > 1000.0) {
                confidence += 0.1;
            }
        }

        // Large client order
        double adv = GetAverageDailyVolume(pattern.symbol, 30);
        if (pattern.client_order_quantity > adv * 0.05) {
            confidence += 0.1;
        }

        return std::min(confidence, 1.0);
    }

    void GenerateFrontRunningAlert(const FrontRunningPattern& pattern) {
        SurveillanceAlert alert{};

        GenerateAlertID(alert.alert_id);
        alert.alert_timestamp_ns = GetNanosecondTimestamp();
        alert.severity = AlertSeverity::CRITICAL;
        strcpy(alert.alert_type, "FRONT_RUNNING");

        snprintf(alert.description, sizeof(alert.description),
                "Potential front-running detected: Firm order %.0f shares %lld ms "
                "before client order %.0f shares, estimated profit $%.2f",
                pattern.firm_order_quantity,
                pattern.time_difference.count(),
                pattern.client_order_quantity,
                pattern.firm_profit);

        alert.symbols.push_back(pattern.symbol);
        alert.accounts.push_back(pattern.firm_account);
        alert.accounts.push_back(pattern.client_account);
        alert.confidence_score = pattern.pattern_confidence;

        strcpy(alert.status, "NEW");

        StoreAlert(alert);
        NotifyCompliance(alert);

        LOG_CRITICAL("Front-running alert generated: " << alert.alert_id);
    }

    std::atomic<bool> running_{true};
};


================================================================================
SECTION 4: ALERT MANAGEMENT SYSTEM
================================================================================

4.1 ALERT WORKFLOW
------------------

class AlertManagementSystem {
public:
    void ProcessAlert(const SurveillanceAlert& alert) {
        // Store alert
        StoreAlertInDatabase(alert);

        // Route based on severity
        if (alert.severity == AlertSeverity::CRITICAL) {
            // Immediate notification
            NotifyComplianceOfficer(alert);
            NotifyManagement(alert);

            // Consider trading halt
            if (alert.confidence_score > 0.90) {
                ConsiderTradingHalt(alert);
            }
        } else if (alert.severity == AlertSeverity::HIGH) {
            NotifyComplianceTeam(alert);
            AssignToAnalyst(alert);
        } else {
            QueueForReview(alert);
        }

        // Log alert generation
        LogAlertGeneration(alert);
    }

    void InvestigateAlert(const std::string& alert_id,
                         const std::string& analyst) {
        // Mark as under investigation
        UpdateAlertStatus(alert_id, "INVESTIGATING", analyst);

        // Retrieve alert details
        auto alert = GetAlert(alert_id);

        // Gather supporting evidence
        auto evidence = GatherEvidence(alert);

        // Generate investigation report
        auto report = GenerateInvestigationReport(alert, evidence);

        // Store report
        StoreInvestigationReport(report);
    }

    void CloseAlert(const std::string& alert_id,
                   const std::string& resolution,
                   const std::string& action_taken) {
        UpdateAlertStatus(alert_id, "CLOSED", "");

        SurveillanceAlert alert = GetAlert(alert_id);
        strcpy(alert.resolution, resolution.c_str());
        alert.closed_timestamp_ns = GetNanosecondTimestamp();

        UpdateAlert(alert);

        LOG_INFO("Alert closed: " << alert_id << " - " << resolution);
    }
};

================================================================================
END OF DOCUMENT
================================================================================
