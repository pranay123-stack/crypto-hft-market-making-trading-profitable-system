================================================================================
TRADE LOGGING AND AUDIT TRAILS SYSTEM
High-Frequency Trading Compliance Framework
================================================================================

OVERVIEW
--------
Comprehensive trade logging system ensuring complete audit trail coverage for
all trading activities, order lifecycle events, and system interactions in
compliance with regulatory requirements (MiFID II, Dodd-Frank, SEC Rule 613).

================================================================================
1. AUDIT LOG SCHEMA DEFINITIONS
================================================================================

1.1 ORDER EVENT LOG SCHEMA
---------------------------
struct OrderEventLog {
    // Unique Identifiers
    uint64_t event_id;                    // Monotonically increasing event ID
    char order_id[36];                    // UUID format order identifier
    char parent_order_id[36];             // Link to parent order (if child)
    char execution_id[36];                // Unique execution identifier

    // Timestamp Fields (Nanosecond precision)
    uint64_t gateway_receive_time_ns;     // Gateway receipt timestamp
    uint64_t strategy_decision_time_ns;   // Strategy decision timestamp
    uint64_t order_creation_time_ns;      // Order object creation time
    uint64_t oms_accept_time_ns;          // OMS acceptance timestamp
    uint64_t exchange_send_time_ns;       // Message sent to exchange
    uint64_t exchange_ack_time_ns;        // Exchange acknowledgment time
    uint64_t event_timestamp_ns;          // Current event timestamp
    uint64_t system_clock_ns;             // System clock at event

    // Order Attributes
    char symbol[16];                      // Trading instrument
    char exchange[8];                     // Exchange/venue code
    char side;                            // 'B'uy or 'S'ell
    char order_type[4];                   // LMT, MKT, STP, etc.
    char time_in_force[4];                // DAY, GTC, IOC, FOK

    // Quantity and Price Fields
    int64_t order_quantity;               // Original order quantity
    int64_t filled_quantity;              // Cumulative filled quantity
    int64_t remaining_quantity;           // Remaining quantity
    double limit_price;                   // Limit price (if applicable)
    double stop_price;                    // Stop price (if applicable)
    double average_fill_price;            // Average execution price

    // Event Information
    char event_type[32];                  // NEW, MODIFY, CANCEL, FILL, etc.
    char event_status[32];                // PENDING, ACCEPTED, REJECTED, etc.
    char rejection_reason[128];           // Rejection/error description
    uint32_t error_code;                  // Standardized error code

    // Regulatory Fields
    char trader_id[16];                   // Trader/algorithm identifier
    char account_id[32];                  // Trading account
    char client_id[32];                   // End client identifier
    char investment_decision_maker[32];   // Investment decision entity
    char execution_decision_maker[32];    // Execution decision entity
    char regulatory_algo_id[32];          // Algorithm identifier (MiFID II)

    // Risk and Compliance Flags
    bool pre_trade_risk_passed;           // Pre-trade risk check result
    bool post_trade_risk_passed;          // Post-trade risk check result
    bool compliance_approved;             // Compliance approval flag
    char risk_flags[64];                  // Comma-separated risk flags

    // Market Context
    double market_price_at_event;         // Best bid/ask at event time
    int32_t market_depth_levels;          // Order book depth
    uint64_t market_volume;               // Market volume at time

    // Routing Information
    char routing_strategy[32];            // Smart routing strategy used
    uint32_t routing_priority;            // Routing priority score
    char venue_selection_reason[128];     // Venue selection justification

    // System Metadata
    char hostname[64];                    // Server hostname
    uint32_t process_id;                  // Process ID
    uint32_t thread_id;                   // Thread ID
    char component_name[32];              // Component generating log
    uint32_t sequence_number;             // Per-session sequence number

    // Data Integrity
    char checksum[64];                    // SHA-256 checksum of record
    char previous_event_hash[64];         // Blockchain-style linking
};

Size: 1024 bytes per record
Estimated daily volume: 10M events = 10GB/day compressed


1.2 EXECUTION REPORT LOG SCHEMA
--------------------------------
struct ExecutionReportLog {
    // Core Identifiers
    uint64_t report_id;
    char execution_id[36];
    char order_id[36];
    char trade_id[36];                    // Exchange trade ID

    // Execution Timing
    uint64_t execution_time_ns;           // Exchange execution timestamp
    uint64_t report_receive_time_ns;      // System receipt time
    uint64_t processing_time_ns;          // Processing completion time

    // Execution Details
    int64_t executed_quantity;            // Quantity executed
    double execution_price;               // Execution price
    double commission;                    // Commission charged
    double exchange_fee;                  // Exchange fees
    double clearing_fee;                  // Clearing fees
    double total_transaction_cost;        // Total cost

    // Counterparty Information
    char counterparty_id[32];             // Counterparty identifier
    char executing_broker[32];            // Executing broker
    char clearing_broker[32];             // Clearing broker

    // Execution Quality
    double price_improvement;             // Price improvement amount
    double effective_spread;              // Effective spread
    char liquidity_flag;                  // 'A'dded or 'R'emoved
    char execution_venue[16];             // Actual execution venue

    // Regulatory Fields
    char execution_report_type[32];       // NEW, PARTIAL, FULL, CANCEL
    bool away_market_flag;                // Execution away from primary
    char capacity;                        // 'P'rincipal or 'A'gent

    // Settlement Information
    char settlement_date[11];             // YYYY-MM-DD
    char settlement_currency[4];          // Currency code
    double settlement_amount;             // Settlement amount

    char checksum[64];
};

Size: 512 bytes per record


1.3 MARKET DATA EVENT LOG SCHEMA
---------------------------------
struct MarketDataEventLog {
    uint64_t event_id;
    uint64_t timestamp_ns;
    uint64_t exchange_timestamp_ns;

    char symbol[16];
    char exchange[8];
    char event_type[16];                  // QUOTE, TRADE, DEPTH, IMBALANCE

    // Quote Data
    double bid_price;
    double ask_price;
    int64_t bid_size;
    int64_t ask_size;

    // Trade Data
    double trade_price;
    int64_t trade_size;
    char trade_condition[8];

    // Book Data
    uint32_t book_level;
    double level_price;
    int64_t level_size;

    // Sequence Control
    uint64_t sequence_number;
    uint32_t message_count;

    char checksum[64];
};

Size: 256 bytes per record
Estimated volume: 100M events/day = 25GB/day compressed


1.4 RISK EVENT LOG SCHEMA
--------------------------
struct RiskEventLog {
    uint64_t event_id;
    uint64_t timestamp_ns;

    char risk_check_type[32];             // PRE_TRADE, POST_TRADE, LIMIT
    char risk_level[16];                  // INFO, WARNING, BREACH, CRITICAL
    bool check_passed;

    // Associated Trade
    char order_id[36];
    char account_id[32];
    char trader_id[16];

    // Risk Metrics
    char metric_name[64];
    double metric_value;
    double threshold_value;
    double breach_percentage;

    // Position Information
    int64_t current_position;
    int64_t position_after_trade;
    double current_pnl;
    double var_impact;

    // Actions Taken
    char action_taken[128];               // BLOCKED, ALLOWED_WITH_WARNING, etc.
    char override_user[32];               // User who overrode (if any)
    char override_reason[256];

    char checksum[64];
};


================================================================================
2. AUDIT TRAIL IMPLEMENTATION
================================================================================

2.1 LOGGING ENGINE ARCHITECTURE
--------------------------------

class AuditLogger {
private:
    // Lock-free ring buffer for high-performance logging
    static constexpr size_t RING_BUFFER_SIZE = 1024 * 1024;

    struct alignas(64) LogEntry {
        uint64_t timestamp_ns;
        uint32_t log_type;
        uint32_t data_size;
        char data[4096];
        char checksum[32];
    };

    // Lock-free ring buffer
    std::atomic<uint64_t> write_index_{0};
    std::atomic<uint64_t> read_index_{0};
    LogEntry* ring_buffer_;

    // Background persistence thread
    std::thread persistence_thread_;
    std::atomic<bool> running_{true};

    // Multiple log file handlers
    struct LogFileHandler {
        int fd;
        std::string filepath;
        size_t current_size;
        size_t max_size;
        time_t rotation_time;
    };

    std::unordered_map<uint32_t, LogFileHandler> log_handlers_;

    // Write-ahead log for durability
    int wal_fd_;
    std::atomic<uint64_t> wal_sequence_{0};

public:
    AuditLogger(const std::string& base_path) {
        // Initialize lock-free ring buffer
        ring_buffer_ = static_cast<LogEntry*>(
            aligned_alloc(64, RING_BUFFER_SIZE * sizeof(LogEntry))
        );

        // Initialize log file handlers
        InitializeLogHandlers(base_path);

        // Start persistence thread
        persistence_thread_ = std::thread(&AuditLogger::PersistenceLoop, this);

        // Pin thread to dedicated CPU core
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        CPU_SET(15, &cpuset);  // Use core 15 for logging
        pthread_setaffinity_np(persistence_thread_.native_handle(),
                              sizeof(cpu_set_t), &cpuset);
    }

    // Ultra-low latency logging (< 100ns)
    template<typename T>
    void LogEvent(uint32_t log_type, const T& event_data) {
        uint64_t write_idx = write_index_.fetch_add(1, std::memory_order_acquire);
        uint64_t slot = write_idx % RING_BUFFER_SIZE;

        LogEntry& entry = ring_buffer_[slot];

        // Wait if buffer is full (should rarely happen)
        while (write_idx - read_index_.load(std::memory_order_acquire) >= RING_BUFFER_SIZE) {
            _mm_pause();
        }

        // Populate log entry
        entry.timestamp_ns = GetNanosecondTimestamp();
        entry.log_type = log_type;
        entry.data_size = sizeof(T);
        memcpy(entry.data, &event_data, sizeof(T));

        // Calculate checksum
        CalculateChecksum(entry);

        // Memory fence to ensure visibility
        std::atomic_thread_fence(std::memory_order_release);
    }

private:
    void PersistenceLoop() {
        while (running_.load(std::memory_order_acquire)) {
            uint64_t read_idx = read_index_.load(std::memory_order_acquire);
            uint64_t write_idx = write_index_.load(std::memory_order_acquire);

            // Process all pending log entries
            while (read_idx < write_idx) {
                uint64_t slot = read_idx % RING_BUFFER_SIZE;
                const LogEntry& entry = ring_buffer_[slot];

                // Write to appropriate log file
                PersistLogEntry(entry);

                // Write to WAL for durability
                WriteToWAL(entry);

                read_idx++;
            }

            read_index_.store(read_idx, std::memory_order_release);

            // Sync to disk periodically
            if (read_idx % 10000 == 0) {
                SyncAllLogFiles();
            }

            // Small sleep to reduce CPU usage when idle
            if (read_idx == write_idx) {
                std::this_thread::sleep_for(std::chrono::microseconds(100));
            }
        }
    }

    void PersistLogEntry(const LogEntry& entry) {
        auto& handler = log_handlers_[entry.log_type];

        // Check if log rotation needed
        if (handler.current_size >= handler.max_size) {
            RotateLogFile(handler);
        }

        // Write to log file using direct I/O
        ssize_t written = write(handler.fd, &entry,
                               sizeof(uint64_t) + sizeof(uint32_t) * 2 +
                               entry.data_size + 32);

        if (written > 0) {
            handler.current_size += written;
        }
    }

    void WriteToWAL(const LogEntry& entry) {
        // Write-ahead log ensures durability
        uint64_t seq = wal_sequence_.fetch_add(1, std::memory_order_acq_rel);

        struct WALRecord {
            uint64_t sequence;
            uint64_t timestamp;
            LogEntry entry;
        } wal_record;

        wal_record.sequence = seq;
        wal_record.timestamp = entry.timestamp_ns;
        wal_record.entry = entry;

        write(wal_fd_, &wal_record, sizeof(WALRecord));

        // Force sync every 100 records
        if (seq % 100 == 0) {
            fsync(wal_fd_);
        }
    }

    void RotateLogFile(LogFileHandler& handler) {
        // Close current file
        fsync(handler.fd);
        close(handler.fd);

        // Generate new filename with timestamp
        time_t now = time(nullptr);
        struct tm tm_info;
        localtime_r(&now, &tm_info);

        char new_filename[256];
        snprintf(new_filename, sizeof(new_filename),
                "%s.%04d%02d%02d_%02d%02d%02d.log",
                handler.filepath.c_str(),
                tm_info.tm_year + 1900, tm_info.tm_mon + 1, tm_info.tm_mday,
                tm_info.tm_hour, tm_info.tm_min, tm_info.tm_sec);

        // Open new file with direct I/O
        handler.fd = open(new_filename,
                         O_WRONLY | O_CREAT | O_APPEND | O_DIRECT,
                         0644);
        handler.current_size = 0;
        handler.rotation_time = now;
    }

    void CalculateChecksum(LogEntry& entry) {
        // Simple but fast checksum (use SHA-256 for production)
        uint64_t hash = 0xcbf29ce484222325ULL;  // FNV offset basis
        const uint8_t* data = reinterpret_cast<const uint8_t*>(&entry);
        size_t len = sizeof(uint64_t) + sizeof(uint32_t) * 2 + entry.data_size;

        for (size_t i = 0; i < len; i++) {
            hash ^= data[i];
            hash *= 0x100000001b3ULL;  // FNV prime
        }

        snprintf(entry.checksum, sizeof(entry.checksum), "%016lx", hash);
    }
};


2.2 COMPREHENSIVE EVENT CAPTURE
--------------------------------

class OrderEventAuditor {
public:
    void AuditOrderCreation(const Order& order) {
        OrderEventLog log_entry{};

        log_entry.event_id = GenerateEventID();
        strcpy(log_entry.order_id, order.id.c_str());

        // Capture all timestamps
        log_entry.gateway_receive_time_ns = order.gateway_timestamp;
        log_entry.strategy_decision_time_ns = order.strategy_timestamp;
        log_entry.order_creation_time_ns = GetNanosecondTimestamp();
        log_entry.event_timestamp_ns = log_entry.order_creation_time_ns;
        log_entry.system_clock_ns = GetSystemClock();

        // Populate order attributes
        strcpy(log_entry.symbol, order.symbol.c_str());
        strcpy(log_entry.exchange, order.exchange.c_str());
        log_entry.side = order.side;
        strcpy(log_entry.order_type, order.type.c_str());

        log_entry.order_quantity = order.quantity;
        log_entry.limit_price = order.limit_price;

        // Regulatory fields
        strcpy(log_entry.trader_id, order.trader_id.c_str());
        strcpy(log_entry.account_id, order.account_id.c_str());
        strcpy(log_entry.regulatory_algo_id, order.algo_id.c_str());

        // Risk checks
        log_entry.pre_trade_risk_passed = order.risk_approved;

        // Market context
        log_entry.market_price_at_event = GetCurrentMarketPrice(order.symbol);

        strcpy(log_entry.event_type, "ORDER_NEW");
        strcpy(log_entry.event_status, "CREATED");

        // System metadata
        gethostname(log_entry.hostname, sizeof(log_entry.hostname));
        log_entry.process_id = getpid();
        log_entry.thread_id = gettid();

        // Calculate checksum
        CalculateRecordChecksum(log_entry);

        // Log to audit system
        audit_logger_.LogEvent(LOG_TYPE_ORDER_EVENT, log_entry);
    }

    void AuditOrderModification(const Order& order,
                               const OrderModification& mod) {
        OrderEventLog log_entry{};

        log_entry.event_id = GenerateEventID();
        strcpy(log_entry.order_id, order.id.c_str());
        log_entry.event_timestamp_ns = GetNanosecondTimestamp();

        log_entry.order_quantity = mod.new_quantity;
        log_entry.limit_price = mod.new_price;
        log_entry.filled_quantity = order.filled_quantity;
        log_entry.remaining_quantity = order.remaining_quantity;

        strcpy(log_entry.event_type, "ORDER_MODIFY");
        strcpy(log_entry.event_status, "PENDING");

        // Link to previous event
        strcpy(log_entry.previous_event_hash,
               order.last_event_checksum.c_str());

        CalculateRecordChecksum(log_entry);
        audit_logger_.LogEvent(LOG_TYPE_ORDER_EVENT, log_entry);
    }

    void AuditExecution(const Execution& exec) {
        ExecutionReportLog log_entry{};

        log_entry.report_id = GenerateReportID();
        strcpy(log_entry.execution_id, exec.id.c_str());
        strcpy(log_entry.order_id, exec.order_id.c_str());
        strcpy(log_entry.trade_id, exec.exchange_trade_id.c_str());

        log_entry.execution_time_ns = exec.exchange_timestamp;
        log_entry.report_receive_time_ns = GetNanosecondTimestamp();

        log_entry.executed_quantity = exec.quantity;
        log_entry.execution_price = exec.price;
        log_entry.commission = exec.commission;
        log_entry.exchange_fee = exec.exchange_fee;
        log_entry.total_transaction_cost = CalculateTotalCost(exec);

        // Execution quality metrics
        log_entry.price_improvement = CalculatePriceImprovement(exec);
        log_entry.effective_spread = CalculateEffectiveSpread(exec);
        log_entry.liquidity_flag = exec.liquidity_flag;

        strcpy(log_entry.execution_report_type, "FILL");

        CalculateRecordChecksum(log_entry);
        audit_logger_.LogEvent(LOG_TYPE_EXECUTION, log_entry);
    }

private:
    AuditLogger audit_logger_;
    std::atomic<uint64_t> event_id_counter_{0};
    std::atomic<uint64_t> report_id_counter_{0};

    uint64_t GenerateEventID() {
        return event_id_counter_.fetch_add(1, std::memory_order_acq_rel);
    }
};


================================================================================
3. AUDIT TRAIL STORAGE AND RETRIEVAL
================================================================================

3.1 HIERARCHICAL STORAGE STRATEGY
----------------------------------

Hot Storage (0-7 days):
- Location: NVMe SSD RAID 10
- Format: Binary logs with indexes
- Compression: None (raw speed)
- Retention: 7 days
- Query performance: < 1ms

Warm Storage (8-90 days):
- Location: SSD RAID 5
- Format: Compressed binary with columnar indexes
- Compression: LZ4 (3:1 ratio)
- Retention: 90 days
- Query performance: < 100ms

Cold Storage (91 days - 7 years):
- Location: High-capacity HDD array or tape
- Format: Compressed archive with metadata
- Compression: ZSTD (5:1 ratio)
- Retention: 7 years (regulatory requirement)
- Query performance: < 10 seconds


3.2 INDEX STRUCTURES
--------------------

Primary Indexes:
- event_id (monotonic sequence)
- timestamp_ns (time-based queries)
- order_id (order lifecycle tracking)

Secondary Indexes:
- symbol (instrument-based queries)
- account_id (account activity)
- trader_id (trader activity)
- exchange (venue-based queries)

Composite Indexes:
- (symbol, timestamp_ns) - symbol time series
- (account_id, timestamp_ns) - account activity
- (trader_id, event_type, timestamp_ns) - trader event analysis


3.3 QUERY INTERFACE
--------------------

class AuditTrailQuery {
public:
    // Query by order ID - get complete order lifecycle
    std::vector<OrderEventLog> GetOrderLifecycle(const std::string& order_id) {
        std::vector<OrderEventLog> events;

        // Query hot storage first
        auto hot_events = hot_storage_.QueryByOrderID(order_id);
        events.insert(events.end(), hot_events.begin(), hot_events.end());

        // Query warm storage if needed
        if (events.empty() || NeedWarmStorage(events)) {
            auto warm_events = warm_storage_.QueryByOrderID(order_id);
            events.insert(events.end(), warm_events.begin(), warm_events.end());
        }

        // Sort by timestamp
        std::sort(events.begin(), events.end(),
                 [](const auto& a, const auto& b) {
                     return a.event_timestamp_ns < b.event_timestamp_ns;
                 });

        return events;
    }

    // Query by time range
    std::vector<OrderEventLog> QueryByTimeRange(
        uint64_t start_time_ns,
        uint64_t end_time_ns,
        const QueryFilter& filter = {}) {

        std::vector<OrderEventLog> results;

        // Determine which storage tiers to query
        if (IsHotStorage(start_time_ns, end_time_ns)) {
            results = hot_storage_.QueryTimeRange(start_time_ns, end_time_ns, filter);
        } else if (IsWarmStorage(start_time_ns, end_time_ns)) {
            results = warm_storage_.QueryTimeRange(start_time_ns, end_time_ns, filter);
        } else {
            // Need cold storage retrieval
            results = cold_storage_.QueryTimeRange(start_time_ns, end_time_ns, filter);
        }

        return results;
    }

    // Reconstruct complete trading day
    TradingDaySnapshot ReconstructTradingDay(const std::string& date) {
        TradingDaySnapshot snapshot;

        auto [start_ns, end_ns] = GetDayBoundaries(date);

        // Query all event types
        snapshot.order_events = QueryByTimeRange(start_ns, end_ns);
        snapshot.execution_events = QueryExecutions(start_ns, end_ns);
        snapshot.market_data_events = QueryMarketData(start_ns, end_ns);
        snapshot.risk_events = QueryRiskEvents(start_ns, end_ns);

        return snapshot;
    }
};


================================================================================
4. AUDIT TRAIL INTEGRITY VERIFICATION
================================================================================

4.1 BLOCKCHAIN-STYLE INTEGRITY
-------------------------------

class AuditIntegrityVerifier {
public:
    // Verify integrity of audit log chain
    bool VerifyLogChainIntegrity(const std::vector<OrderEventLog>& logs) {
        if (logs.empty()) return true;

        for (size_t i = 1; i < logs.size(); i++) {
            const auto& prev = logs[i-1];
            const auto& curr = logs[i];

            // Verify checksum chain
            if (strcmp(curr.previous_event_hash, prev.checksum) != 0) {
                LOG_ERROR("Integrity violation: broken hash chain at event "
                         << curr.event_id);
                return false;
            }

            // Verify timestamp monotonicity
            if (curr.event_timestamp_ns < prev.event_timestamp_ns) {
                LOG_ERROR("Integrity violation: timestamp regression at event "
                         << curr.event_id);
                return false;
            }

            // Verify checksum calculation
            if (!VerifyChecksum(curr)) {
                LOG_ERROR("Integrity violation: invalid checksum at event "
                         << curr.event_id);
                return false;
            }
        }

        return true;
    }

    // Verify no gaps in sequence
    bool VerifySequenceCompleteness(const std::vector<OrderEventLog>& logs) {
        for (size_t i = 1; i < logs.size(); i++) {
            if (logs[i].event_id != logs[i-1].event_id + 1) {
                LOG_ERROR("Sequence gap detected: "
                         << logs[i-1].event_id << " -> " << logs[i].event_id);
                return false;
            }
        }
        return true;
    }

private:
    bool VerifyChecksum(const OrderEventLog& log) {
        char calculated_checksum[64];
        // Recalculate and compare
        CalculateRecordChecksum(log, calculated_checksum);
        return strcmp(calculated_checksum, log.checksum) == 0;
    }
};


================================================================================
5. REGULATORY COMPLIANCE MAPPINGS
================================================================================

5.1 MiFID II CLOCK SYNCHRONIZATION
-----------------------------------
- All timestamps synchronized to UTC within 100 microseconds
- NTP servers: Multiple stratum 1 sources
- Hardware timestamping using PTP (Precision Time Protocol)
- Timestamp accuracy verification logs
- Clock drift monitoring and alerts


5.2 SEC RULE 613 (CAT) COMPLIANCE
----------------------------------
- Order lifecycle tracking from inception to completion
- Customer account information
- Routing decisions and execution venues
- Timestamps at each stage (gateway, OMS, exchange)
- Error handling and exception reporting


5.3 DODD-FRANK SWAP REPORTING
------------------------------
- Real-time reporting to Swap Data Repositories
- Unique Transaction Identifiers (UTI)
- Counterparty identification
- Valuation and risk metrics
- Lifecycle events (creation, modification, termination)

================================================================================
END OF DOCUMENT
================================================================================
