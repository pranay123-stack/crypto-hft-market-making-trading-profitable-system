================================================================================
BEST EXECUTION MONITORING SYSTEM
Regulatory Compliance and Execution Quality Analysis
High-Frequency Trading System
================================================================================

OVERVIEW
--------
Comprehensive best execution monitoring implementing MiFID II best execution
requirements, SEC Rule 605/606, and FCA COBS 11.2A. Real-time monitoring of
execution quality, venue selection, and order routing decisions.

================================================================================
SECTION 1: BEST EXECUTION FRAMEWORK
================================================================================

1.1 BEST EXECUTION OBLIGATION
------------------------------

Regulatory Requirements:

MiFID II (Article 27):
- Take all sufficient steps to obtain best possible result for clients
- Consider price, costs, speed, likelihood of execution and settlement
- Execution policy must be documented and disclosed
- Annual review and client reporting

SEC (Regulation NMS):
- Duty of best execution for customer orders
- Consider all available markets
- Regular and rigorous review of execution quality

FCA (COBS 11.2A):
- Best execution must consider total consideration
- Select venues that enable consistent best execution
- Monitor effectiveness of execution arrangements


1.2 EXECUTION FACTORS SCHEMA
-----------------------------

struct ExecutionQualityMetrics {
    // Order Information
    char order_id[64];
    char symbol[16];
    char side;
    int64_t order_quantity;
    double limit_price;
    uint64_t order_timestamp_ns;

    // Execution Information
    char execution_id[64];
    char venue[16];
    int64_t executed_quantity;
    double execution_price;
    uint64_t execution_timestamp_ns;

    // Execution Quality Factors
    struct QualityFactors {
        // 1. Price
        double effective_spread;          // Spread paid
        double price_improvement;         // Improvement vs NBBO
        double realized_spread;           // Spread after execution
        double implementation_shortfall;  // Cost vs decision price

        // 2. Costs
        double explicit_costs;            // Commissions + fees
        double implicit_costs;            // Market impact
        double total_costs_bps;           // Total cost in basis points

        // 3. Speed
        uint64_t latency_ns;              // Order to execution time
        uint64_t routing_latency_ns;      // Routing decision time
        uint64_t venue_latency_ns;        // Venue processing time

        // 4. Likelihood of Execution
        double fill_rate;                 // % of order filled
        uint32_t num_partial_fills;       // Number of fills
        bool fully_filled;

        // 5. Size
        double market_size_available;     // Available liquidity
        double order_size_ratio;          // Order vs available size

        // 6. Nature
        char order_type[16];              // LMT, MKT, etc.
        char urgency_classification[16];  // IMMEDIATE, PASSIVE, etc.

        // 7. Other Relevant Factors
        double market_volatility;         // Market conditions
        char liquidity_classification[16]; // Liquid, illiquid
        bool information_leakage_risk;    // Risk of information leakage
    } factors;

    // Venue Comparison (What would have happened elsewhere)
    struct VenueComparison {
        char venue_name[16];
        double hypothetical_price;
        double hypothetical_costs;
        double quality_delta;             // Better/worse than actual
    };
    std::vector<VenueComparison> venue_alternatives;

    // Best Execution Assessment
    bool best_execution_achieved;
    double execution_quality_score;       // 0-100 score
    char execution_rating;                // A, B, C, D, F
    std::string deviation_explanation;    // If not best
};


================================================================================
SECTION 2: REAL-TIME EXECUTION MONITORING
================================================================================

2.1 EXECUTION QUALITY ANALYZER
-------------------------------

class BestExecutionMonitor {
public:
    BestExecutionMonitor() {
        monitoring_thread_ = std::thread(
            &BestExecutionMonitor::MonitoringLoop, this);
    }

    void AnalyzeExecution(const Execution& exec, const Order& order) {
        ExecutionQualityMetrics metrics{};

        // Populate basic information
        strcpy(metrics.order_id, order.id.c_str());
        strcpy(metrics.symbol, order.symbol.c_str());
        metrics.side = order.side;
        metrics.order_quantity = order.quantity;
        metrics.limit_price = order.limit_price;
        metrics.order_timestamp_ns = order.creation_time_ns;

        strcpy(metrics.execution_id, exec.id.c_str());
        strcpy(metrics.venue, exec.venue.c_str());
        metrics.executed_quantity = exec.quantity;
        metrics.execution_price = exec.price;
        metrics.execution_timestamp_ns = exec.execution_time_ns;

        // Calculate execution quality factors
        CalculateQualityFactors(metrics, exec, order);

        // Compare with alternative venues
        CompareVenuePerformance(metrics, exec, order);

        // Assess overall execution quality
        AssessExecutionQuality(metrics);

        // Store metrics
        StoreExecutionMetrics(metrics);

        // Check for best execution violations
        if (!metrics.best_execution_achieved) {
            GenerateBestExecutionAlert(metrics);
        }
    }

private:
    void CalculateQualityFactors(ExecutionQualityMetrics& metrics,
                                 const Execution& exec,
                                 const Order& order) {
        auto& factors = metrics.factors;

        // Get market data at execution time
        auto nbbo = GetNBBO(order.symbol, exec.execution_time_ns);
        double mid_price = (nbbo.bid + nbbo.ask) / 2.0;
        double quoted_spread = nbbo.ask - nbbo.bid;

        // 1. PRICE FACTORS
        // Effective spread: How much worse than mid-price
        if (order.side == 'B') {
            factors.effective_spread = exec.price - mid_price;
        } else {
            factors.effective_spread = mid_price - exec.price;
        }

        // Price improvement: Better than NBBO
        if (order.side == 'B') {
            factors.price_improvement = nbbo.ask - exec.price;
        } else {
            factors.price_improvement = exec.price - nbbo.bid;
        }

        // Realized spread: Price movement after execution
        auto price_after = GetPriceAfter(order.symbol, exec.execution_time_ns,
                                        std::chrono::seconds(30));
        if (order.side == 'B') {
            factors.realized_spread = exec.price - price_after;
        } else {
            factors.realized_spread = price_after - exec.price;
        }

        // Implementation shortfall: Cost vs decision price
        double decision_price = GetMarketPrice(order.symbol, order.creation_time_ns);
        if (order.side == 'B') {
            factors.implementation_shortfall =
                (exec.price - decision_price) / decision_price;
        } else {
            factors.implementation_shortfall =
                (decision_price - exec.price) / decision_price;
        }

        // 2. COST FACTORS
        // Explicit costs
        factors.explicit_costs = exec.commission + exec.exchange_fee +
                                exec.clearing_fee + exec.sec_fee;

        // Implicit costs (market impact)
        factors.implicit_costs = CalculateMarketImpact(exec, order);

        // Total costs in basis points
        double total_cost_dollars = factors.explicit_costs +
                                   (factors.implicit_costs * exec.quantity);
        double trade_value = exec.price * exec.quantity;
        factors.total_costs_bps = (total_cost_dollars / trade_value) * 10000.0;

        // 3. SPEED FACTORS
        // Total latency
        factors.latency_ns = exec.execution_time_ns - order.creation_time_ns;

        // Routing latency
        factors.routing_latency_ns = order.routing_timestamp_ns -
                                     order.creation_time_ns;

        // Venue latency
        factors.venue_latency_ns = exec.execution_time_ns -
                                  order.venue_send_timestamp_ns;

        // 4. LIKELIHOOD OF EXECUTION
        factors.fill_rate = static_cast<double>(exec.quantity) / order.quantity;
        factors.num_partial_fills = CountPartialFills(order.id);
        factors.fully_filled = (exec.quantity == order.quantity);

        // 5. SIZE FACTORS
        factors.market_size_available = GetAvailableLiquidity(order.symbol,
                                                             exec.venue,
                                                             exec.execution_time_ns);
        factors.order_size_ratio = static_cast<double>(order.quantity) /
                                  factors.market_size_available;

        // 6. NATURE FACTORS
        strcpy(factors.order_type, order.type.c_str());
        strcpy(factors.urgency_classification,
               ClassifyUrgency(order).c_str());

        // 7. OTHER FACTORS
        factors.market_volatility = GetMarketVolatility(order.symbol,
                                                       exec.execution_time_ns);
        strcpy(factors.liquidity_classification,
               ClassifyLiquidity(order.symbol).c_str());
        factors.information_leakage_risk = AssessInformationLeakageRisk(order);
    }

    double CalculateMarketImpact(const Execution& exec, const Order& order) {
        // Measure price movement caused by order
        auto price_before = GetMarketPrice(order.symbol,
                                          order.creation_time_ns);
        auto price_after = GetMarketPrice(order.symbol,
                                         exec.execution_time_ns +
                                         5000000000ULL);  // 5 seconds after

        double impact;
        if (order.side == 'B') {
            impact = price_after - price_before;
        } else {
            impact = price_before - price_after;
        }

        // Positive impact = price moved against us (cost)
        return std::max(0.0, impact);
    }

    void CompareVenuePerformance(ExecutionQualityMetrics& metrics,
                                const Execution& exec,
                                const Order& order) {
        // Get all available venues for this symbol
        auto available_venues = GetAvailableVenues(order.symbol);

        for (const auto& venue : available_venues) {
            if (venue == exec.venue) continue;  // Skip actual venue

            ExecutionQualityMetrics::VenueComparison comparison;
            strcpy(comparison.venue_name, venue.c_str());

            // Get market data from alternative venue at execution time
            auto venue_quote = GetVenueQuote(order.symbol, venue,
                                           exec.execution_time_ns);

            // Hypothetical execution price
            if (order.side == 'B') {
                comparison.hypothetical_price = venue_quote.ask;
            } else {
                comparison.hypothetical_price = venue_quote.bid;
            }

            // Hypothetical costs
            comparison.hypothetical_costs = GetVenueFees(venue, order.quantity);

            // Calculate quality delta
            double actual_total_cost = exec.price * exec.quantity +
                                      metrics.factors.explicit_costs;
            double hypothetical_total_cost = comparison.hypothetical_price *
                                            exec.quantity +
                                            comparison.hypothetical_costs;

            if (order.side == 'B') {
                comparison.quality_delta = actual_total_cost -
                                          hypothetical_total_cost;
            } else {
                comparison.quality_delta = hypothetical_total_cost -
                                          actual_total_cost;
            }

            metrics.venue_alternatives.push_back(comparison);
        }
    }

    void AssessExecutionQuality(ExecutionQualityMetrics& metrics) {
        // Calculate overall execution quality score (0-100)
        double score = 0.0;

        // Price component (40% weight)
        double price_score = CalculatePriceScore(metrics.factors);
        score += 0.40 * price_score;

        // Cost component (30% weight)
        double cost_score = CalculateCostScore(metrics.factors);
        score += 0.30 * cost_score;

        // Speed component (15% weight)
        double speed_score = CalculateSpeedScore(metrics.factors);
        score += 0.15 * speed_score;

        // Fill rate component (15% weight)
        double fill_score = metrics.factors.fill_rate * 100.0;
        score += 0.15 * fill_score;

        metrics.execution_quality_score = score;

        // Assign letter grade
        if (score >= 90) {
            metrics.execution_rating = 'A';
            metrics.best_execution_achieved = true;
        } else if (score >= 80) {
            metrics.execution_rating = 'B';
            metrics.best_execution_achieved = true;
        } else if (score >= 70) {
            metrics.execution_rating = 'C';
            metrics.best_execution_achieved = false;
            metrics.deviation_explanation = "Execution quality below acceptable threshold";
        } else if (score >= 60) {
            metrics.execution_rating = 'D';
            metrics.best_execution_achieved = false;
            metrics.deviation_explanation = "Poor execution quality";
        } else {
            metrics.execution_rating = 'F';
            metrics.best_execution_achieved = false;
            metrics.deviation_explanation = "Unacceptable execution quality";
        }

        // Check if alternative venue would have been significantly better
        for (const auto& alt : metrics.venue_alternatives) {
            if (alt.quality_delta < -100.0) {  // $100 better elsewhere
                metrics.best_execution_achieved = false;
                metrics.deviation_explanation +=
                    " - Alternative venue " + std::string(alt.venue_name) +
                    " would have been $" + std::to_string(-alt.quality_delta) +
                    " better";
            }
        }
    }

    double CalculatePriceScore(const ExecutionQualityMetrics::QualityFactors& factors) {
        double score = 100.0;

        // Penalize for effective spread
        double spread_penalty = (factors.effective_spread / 0.01) * 10.0;  // 1Â¢ spread = 10 points
        score -= spread_penalty;

        // Reward price improvement
        double improvement_bonus = (factors.price_improvement / 0.01) * 15.0;
        score += improvement_bonus;

        // Penalize implementation shortfall
        double shortfall_penalty = std::abs(factors.implementation_shortfall) * 1000.0;
        score -= shortfall_penalty;

        return std::max(0.0, std::min(100.0, score));
    }

    double CalculateCostScore(const ExecutionQualityMetrics::QualityFactors& factors) {
        // Cost score based on total costs in basis points
        // 0 bps = 100 score
        // 10 bps = 50 score
        // 20 bps = 0 score

        double score = 100.0 - (factors.total_costs_bps * 5.0);
        return std::max(0.0, std::min(100.0, score));
    }

    double CalculateSpeedScore(const ExecutionQualityMetrics::QualityFactors& factors) {
        // Speed score based on latency
        // < 100ms = 100 score
        // 1 second = 50 score
        // > 5 seconds = 0 score

        double latency_ms = factors.latency_ns / 1000000.0;

        if (latency_ms < 100.0) {
            return 100.0;
        } else if (latency_ms < 1000.0) {
            return 100.0 - ((latency_ms - 100.0) / 900.0) * 50.0;
        } else if (latency_ms < 5000.0) {
            return 50.0 - ((latency_ms - 1000.0) / 4000.0) * 50.0;
        } else {
            return 0.0;
        }
    }

    void GenerateBestExecutionAlert(const ExecutionQualityMetrics& metrics) {
        ComplianceAlert alert{};

        GenerateAlertID(alert.alert_id);
        alert.alert_timestamp_ns = GetNanosecondTimestamp();
        alert.severity = AlertSeverity::MEDIUM;
        strcpy(alert.alert_type, "BEST_EXECUTION_VIOLATION");

        snprintf(alert.description, sizeof(alert.description),
                "Best execution not achieved: Order %s, Quality score %.1f (%c), %s",
                metrics.order_id,
                metrics.execution_quality_score,
                metrics.execution_rating,
                metrics.deviation_explanation.c_str());

        alert.order_ids.push_back(metrics.order_id);
        alert.symbols.push_back(metrics.symbol);

        strcpy(alert.status, "NEW");

        StoreAlert(alert);
        NotifyCompliance(alert);

        LOG_WARN("Best execution alert generated: " << alert.alert_id);
    }

    void MonitoringLoop() {
        while (running_) {
            // Periodic analysis of execution quality trends
            AnalyzeExecutionQualityTrends();

            std::this_thread::sleep_for(std::chrono::minutes(5));
        }
    }

    void AnalyzeExecutionQualityTrends() {
        auto now_ns = GetNanosecondTimestamp();
        auto window_start = now_ns - (24ULL * 3600 * 1000000000ULL);  // 24 hours

        // Get all executions in window
        auto executions = GetExecutionsInWindow(window_start, now_ns);

        // Group by venue
        std::map<std::string, std::vector<ExecutionQualityMetrics>> by_venue;
        for (const auto& exec_id : executions) {
            auto metrics = GetExecutionMetrics(exec_id);
            by_venue[metrics.venue].push_back(metrics);
        }

        // Analyze each venue
        for (const auto& [venue, venue_executions] : by_venue) {
            VenuePerformanceReport report =
                GenerateVenuePerformanceReport(venue, venue_executions);

            // Check if venue performance is degrading
            if (report.avg_quality_score < 70.0) {
                LOG_WARN("Venue performance below threshold: " << venue
                        << " avg score " << report.avg_quality_score);

                // Consider removing venue from routing
                ConsiderVenueRemoval(venue, report);
            }
        }
    }

    std::thread monitoring_thread_;
    std::atomic<bool> running_{true};
};


================================================================================
SECTION 3: VENUE SELECTION AND SMART ORDER ROUTING
================================================================================

3.1 VENUE SELECTION FRAMEWORK
------------------------------

class SmartOrderRouter {
public:
    struct VenueScore {
        std::string venue_name;
        double total_score;               // 0-100

        // Component scores
        double price_score;
        double liquidity_score;
        double speed_score;
        double cost_score;
        double fill_probability_score;
        double historical_performance_score;

        // Venue characteristics
        double current_bid;
        double current_ask;
        int64_t available_size;
        double fee_rate;
        std::chrono::microseconds avg_latency;
        double recent_fill_rate;
    };

    std::string SelectVenue(const Order& order) {
        // Get all eligible venues
        auto eligible_venues = GetEligibleVenues(order.symbol);

        if (eligible_venues.empty()) {
            LOG_ERROR("No eligible venues for symbol: " << order.symbol);
            return "";
        }

        // Score each venue
        std::vector<VenueScore> venue_scores;
        for (const auto& venue : eligible_venues) {
            VenueScore score = ScoreVenue(venue, order);
            venue_scores.push_back(score);
        }

        // Sort by total score (descending)
        std::sort(venue_scores.begin(), venue_scores.end(),
                 [](const VenueScore& a, const VenueScore& b) {
                     return a.total_score > b.total_score;
                 });

        // Select best venue
        const auto& best_venue = venue_scores[0];

        // Log venue selection decision
        LogVenueSelection(order, venue_scores);

        return best_venue.venue_name;
    }

private:
    VenueScore ScoreVenue(const std::string& venue, const Order& order) {
        VenueScore score;
        score.venue_name = venue;

        // Get venue market data
        auto quote = GetVenueQuote(order.symbol, venue, GetNanosecondTimestamp());
        score.current_bid = quote.bid;
        score.current_ask = quote.ask;
        score.available_size = (order.side == 'B') ? quote.ask_size : quote.bid_size;

        // Get venue characteristics
        auto venue_info = GetVenueInfo(venue);
        score.fee_rate = venue_info.fee_rate;
        score.avg_latency = venue_info.avg_latency;

        // Get historical performance
        auto historical = GetVenueHistoricalPerformance(venue, order.symbol, 30);
        score.recent_fill_rate = historical.fill_rate;

        // Calculate component scores

        // 1. Price score (35% weight)
        score.price_score = CalculateVenuePriceScore(score, order);

        // 2. Liquidity score (25% weight)
        score.liquidity_score = CalculateVenueLiquidityScore(score, order);

        // 3. Speed score (15% weight)
        score.speed_score = CalculateVenueSpeedScore(score);

        // 4. Cost score (15% weight)
        score.cost_score = CalculateVenueCostScore(score, order);

        // 5. Fill probability score (10% weight)
        score.fill_probability_score = score.recent_fill_rate * 100.0;

        // Calculate total weighted score
        score.total_score = 0.35 * score.price_score +
                           0.25 * score.liquidity_score +
                           0.15 * score.speed_score +
                           0.15 * score.cost_score +
                           0.10 * score.fill_probability_score;

        return score;
    }

    double CalculateVenuePriceScore(const VenueScore& venue, const Order& order) {
        // Get NBBO (National Best Bid Offer)
        auto nbbo = GetNBBO(order.symbol, GetNanosecondTimestamp());

        double venue_price = (order.side == 'B') ? venue.current_ask : venue.current_bid;
        double best_price = (order.side == 'B') ? nbbo.ask : nbbo.bid;

        // Calculate price advantage/disadvantage
        double price_diff;
        if (order.side == 'B') {
            price_diff = best_price - venue_price;  // Positive if venue cheaper
        } else {
            price_diff = venue_price - best_price;  // Positive if venue better
        }

        // Convert to score (0-100)
        // At NBBO = 90 score
        // 0.1% better = 100 score
        // 0.1% worse = 70 score

        double price_diff_pct = (price_diff / best_price) * 100.0;

        if (price_diff_pct >= 0.1) {
            return 100.0;
        } else if (price_diff_pct >= 0.0) {
            return 90.0 + (price_diff_pct / 0.1) * 10.0;
        } else if (price_diff_pct >= -0.1) {
            return 90.0 + (price_diff_pct / 0.1) * 20.0;
        } else {
            return std::max(0.0, 70.0 + (price_diff_pct + 0.1) / 0.1 * 70.0);
        }
    }

    double CalculateVenueLiquidityScore(const VenueScore& venue, const Order& order) {
        // Score based on available size vs order size
        double size_ratio = static_cast<double>(venue.available_size) / order.quantity;

        if (size_ratio >= 5.0) {
            return 100.0;  // Ample liquidity
        } else if (size_ratio >= 1.0) {
            return 70.0 + (size_ratio - 1.0) / 4.0 * 30.0;
        } else {
            return size_ratio * 70.0;  // Partial fill likely
        }
    }

    double CalculateVenueSpeedScore(const VenueScore& venue) {
        // Score based on latency
        double latency_ms = venue.avg_latency.count() / 1000.0;

        if (latency_ms < 1.0) {
            return 100.0;  // Sub-millisecond
        } else if (latency_ms < 10.0) {
            return 100.0 - (latency_ms - 1.0) / 9.0 * 20.0;
        } else if (latency_ms < 100.0) {
            return 80.0 - (latency_ms - 10.0) / 90.0 * 40.0;
        } else {
            return std::max(0.0, 40.0 - (latency_ms - 100.0) / 100.0 * 40.0);
        }
    }

    double CalculateVenueCostScore(const VenueScore& venue, const Order& order) {
        // Calculate total cost in basis points
        double trade_value = venue.current_ask * order.quantity;
        double fee_amount = trade_value * venue.fee_rate;
        double fee_bps = (fee_amount / trade_value) * 10000.0;

        // Score: 0 bps = 100, 5 bps = 50, 10 bps = 0
        return std::max(0.0, 100.0 - fee_bps * 10.0);
    }

    void LogVenueSelection(const Order& order,
                          const std::vector<VenueScore>& venue_scores) {
        VenueSelectionLog log{};

        strcpy(log.order_id, order.id.c_str());
        strcpy(log.symbol, order.symbol.c_str());
        log.timestamp_ns = GetNanosecondTimestamp();

        // Store all venue scores for audit
        for (const auto& venue : venue_scores) {
            VenueScoreEntry entry;
            strcpy(entry.venue_name, venue.venue_name.c_str());
            entry.total_score = venue.total_score;
            entry.price_score = venue.price_score;
            entry.liquidity_score = venue.liquidity_score;
            entry.speed_score = venue.speed_score;
            entry.cost_score = venue.cost_score;

            log.venue_scores.push_back(entry);
        }

        // Selected venue
        strcpy(log.selected_venue, venue_scores[0].venue_name.c_str());
        log.selection_rationale = "Highest weighted score based on price, "
                                  "liquidity, speed, cost, and fill probability";

        // Store for audit trail
        StoreVenueSelectionLog(log);
    }
};


================================================================================
SECTION 4: EXECUTION POLICY AND DISCLOSURE
================================================================================

4.1 EXECUTION POLICY DOCUMENTATION
-----------------------------------

class ExecutionPolicyManager {
public:
    struct ExecutionPolicy {
        // Policy identification
        char policy_id[64];
        char version[16];
        uint64_t effective_date_ns;
        uint64_t review_date_ns;

        // Execution factors and priorities
        struct FactorWeight {
            char factor_name[64];         // Price, Cost, Speed, etc.
            double weight_percentage;     // 0-100
            std::string description;
        };
        std::vector<FactorWeight> factor_weights;

        // Venue selection criteria
        std::vector<std::string> approved_venues;
        std::string venue_selection_methodology;

        // Order handling procedures
        std::string market_order_handling;
        std::string limit_order_handling;
        std::string large_order_handling;

        // Monitoring and review
        std::string monitoring_procedures;
        std::string periodic_review_frequency;

        // Client consent and disclosure
        bool client_consent_required;
        std::string disclosure_method;
    };

    ExecutionPolicy GetCurrentPolicy() {
        ExecutionPolicy policy{};

        strcpy(policy.policy_id, "EXEC_POLICY_2024_V1");
        strcpy(policy.version, "1.0");
        policy.effective_date_ns = GetNanosecondTimestamp();

        // Define execution factors and weights (MiFID II Article 27)
        policy.factor_weights = {
            {"Price", 35.0, "Best available price considering all venues"},
            {"Costs", 15.0, "Explicit costs (fees) and implicit costs (impact)"},
            {"Speed", 15.0, "Time to execute and market access latency"},
            {"Likelihood of Execution", 20.0, "Probability of fill and size available"},
            {"Likelihood of Settlement", 5.0, "Settlement risk and operational risk"},
            {"Size", 5.0, "Order size relative to market liquidity"},
            {"Nature", 3.0, "Order type and characteristics"},
            {"Other Relevant Factors", 2.0, "Market conditions and client instructions"}
        };

        // Approved execution venues
        policy.approved_venues = {
            "NYSE", "NASDAQ", "BATS", "IEX", "EDGX", "EDGA",
            "LSE", "XETRA", "Euronext", "TSE"
        };

        policy.venue_selection_methodology =
            "Smart order routing algorithm evaluates all approved venues based on "
            "real-time market data and historical performance. Venue selection "
            "considers price, liquidity, speed, and costs with weights as defined "
            "in execution factors.";

        // Review requirements
        policy.periodic_review_frequency = "Annual review with quarterly monitoring";
        policy.monitoring_procedures =
            "Real-time execution quality monitoring with daily reports and alerts "
            "for execution quality below threshold. Monthly venue performance review.";

        return policy;
    }

    std::string GenerateClientDisclosure() {
        std::stringstream disclosure;

        disclosure << "EXECUTION POLICY DISCLOSURE\n\n";

        disclosure << "Best Execution Obligation:\n";
        disclosure << "We are required to take all sufficient steps to obtain the "
                  << "best possible result for our clients when executing orders. "
                  << "This is known as 'best execution'.\n\n";

        disclosure << "Execution Factors:\n";
        disclosure << "We consider the following factors when executing orders:\n";

        auto policy = GetCurrentPolicy();
        for (const auto& factor : policy.factor_weights) {
            disclosure << "  - " << factor.factor_name << " (" << factor.weight_percentage
                      << "%): " << factor.description << "\n";
        }

        disclosure << "\nExecution Venues:\n";
        disclosure << "We may execute your orders on the following venues:\n";
        for (const auto& venue : policy.approved_venues) {
            disclosure << "  - " << venue << "\n";
        }

        disclosure << "\nMonitoring and Review:\n";
        disclosure << policy.monitoring_procedures << "\n\n";

        disclosure << "Annual Reporting:\n";
        disclosure << "We will provide you with an annual report on the quality of "
                  << "execution obtained on your orders.\n\n";

        return disclosure.str();
    }
};


================================================================================
SECTION 5: ANNUAL BEST EXECUTION REPORTING
================================================================================

5.1 CLIENT EXECUTION QUALITY REPORT
------------------------------------

class BestExecutionReporting {
public:
    struct AnnualExecutionReport {
        // Reporting period
        uint32_t year;
        std::string client_id;

        // Overall statistics
        uint64_t total_orders;
        uint64_t total_executions;
        double total_value_traded;
        double avg_execution_quality_score;

        // Venue breakdown
        struct VenueStats {
            std::string venue_name;
            uint64_t order_count;
            double percentage_of_total;
            double avg_quality_score;
            double avg_price_improvement;
            double avg_fill_rate;
        };
        std::vector<VenueStats> venue_statistics;

        // Asset class breakdown
        struct AssetClassStats {
            std::string asset_class;
            uint64_t order_count;
            double avg_quality_score;
            double avg_costs_bps;
        };
        std::vector<AssetClassStats> asset_class_statistics;

        // Best execution achievement
        double best_execution_rate;       // % of orders achieving best execution
        uint32_t violations_count;        // Number of violations
        std::string improvement_actions;  // Actions taken to improve
    };

    AnnualExecutionReport GenerateAnnualReport(const std::string& client_id,
                                               uint32_t year) {
        AnnualExecutionReport report{};
        report.year = year;
        report.client_id = client_id;

        // Get all executions for client in year
        auto [year_start, year_end] = GetYearBoundaries(year);
        auto executions = GetClientExecutions(client_id, year_start, year_end);

        // Calculate overall statistics
        report.total_orders = executions.size();
        report.total_executions = CountExecutions(executions);
        report.total_value_traded = CalculateTotalValue(executions);

        // Calculate avg execution quality
        double total_quality = 0.0;
        uint32_t quality_count = 0;
        uint32_t best_ex_achieved = 0;

        for (const auto& exec : executions) {
            auto metrics = GetExecutionMetrics(exec.execution_id);
            total_quality += metrics.execution_quality_score;
            quality_count++;

            if (metrics.best_execution_achieved) {
                best_ex_achieved++;
            } else {
                report.violations_count++;
            }
        }

        report.avg_execution_quality_score = total_quality / quality_count;
        report.best_execution_rate =
            (static_cast<double>(best_ex_achieved) / report.total_orders) * 100.0;

        // Venue breakdown
        report.venue_statistics = GenerateVenueStatistics(executions);

        // Asset class breakdown
        report.asset_class_statistics = GenerateAssetClassStatistics(executions);

        // Improvement actions
        report.improvement_actions = GenerateImprovementActions(report);

        return report;
    }

    std::string FormatReportForClient(const AnnualExecutionReport& report) {
        std::stringstream formatted;

        formatted << "ANNUAL BEST EXECUTION REPORT\n";
        formatted << "Year: " << report.year << "\n";
        formatted << "Client: " << report.client_id << "\n\n";

        formatted << "EXECUTIVE SUMMARY\n";
        formatted << "-----------------\n";
        formatted << "Total Orders: " << report.total_orders << "\n";
        formatted << "Total Value Traded: $" << std::fixed << std::setprecision(2)
                 << report.total_value_traded << "\n";
        formatted << "Average Execution Quality Score: "
                 << std::setprecision(1) << report.avg_execution_quality_score << "/100\n";
        formatted << "Best Execution Achievement Rate: "
                 << std::setprecision(1) << report.best_execution_rate << "%\n\n";

        formatted << "VENUE PERFORMANCE\n";
        formatted << "-----------------\n";
        for (const auto& venue : report.venue_statistics) {
            formatted << venue.venue_name << ":\n";
            formatted << "  Orders: " << venue.order_count
                     << " (" << std::setprecision(1) << venue.percentage_of_total << "%)\n";
            formatted << "  Avg Quality Score: " << venue.avg_quality_score << "/100\n";
            formatted << "  Avg Price Improvement: $" << std::setprecision(4)
                     << venue.avg_price_improvement << "\n";
            formatted << "  Avg Fill Rate: " << std::setprecision(1)
                     << venue.avg_fill_rate * 100.0 << "%\n\n";
        }

        formatted << "CONTINUOUS IMPROVEMENT\n";
        formatted << "----------------------\n";
        formatted << report.improvement_actions << "\n";

        return formatted.str();
    }

private:
    std::vector<AnnualExecutionReport::VenueStats> GenerateVenueStatistics(
        const std::vector<Execution>& executions) {

        std::map<std::string, std::vector<Execution>> by_venue;
        for (const auto& exec : executions) {
            by_venue[exec.venue].push_back(exec);
        }

        std::vector<AnnualExecutionReport::VenueStats> stats;

        for (const auto& [venue, venue_execs] : by_venue) {
            AnnualExecutionReport::VenueStats venue_stat;
            venue_stat.venue_name = venue;
            venue_stat.order_count = venue_execs.size();
            venue_stat.percentage_of_total =
                (static_cast<double>(venue_execs.size()) / executions.size()) * 100.0;

            // Calculate metrics
            double total_quality = 0.0;
            double total_price_improvement = 0.0;
            double total_fill_rate = 0.0;

            for (const auto& exec : venue_execs) {
                auto metrics = GetExecutionMetrics(exec.execution_id);
                total_quality += metrics.execution_quality_score;
                total_price_improvement += metrics.factors.price_improvement;
                total_fill_rate += metrics.factors.fill_rate;
            }

            venue_stat.avg_quality_score = total_quality / venue_execs.size();
            venue_stat.avg_price_improvement = total_price_improvement / venue_execs.size();
            venue_stat.avg_fill_rate = total_fill_rate / venue_execs.size();

            stats.push_back(venue_stat);
        }

        return stats;
    }

    std::string GenerateImprovementActions(const AnnualExecutionReport& report) {
        std::stringstream actions;

        if (report.best_execution_rate < 95.0) {
            actions << "- Implemented enhanced venue selection algorithm\n";
            actions << "- Added additional execution venues for better liquidity\n";
        }

        if (report.avg_execution_quality_score < 80.0) {
            actions << "- Optimized order routing logic\n";
            actions << "- Enhanced pre-trade analytics\n";
        }

        actions << "- Conducted quarterly execution policy reviews\n";
        actions << "- Provided trader training on best execution requirements\n";

        return actions.str();
    }
};

================================================================================
END OF DOCUMENT
================================================================================
