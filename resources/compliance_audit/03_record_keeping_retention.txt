================================================================================
RECORD KEEPING AND RETENTION POLICIES
Regulatory Compliance Data Management
High-Frequency Trading System
================================================================================

OVERVIEW
--------
Comprehensive record keeping and data retention framework ensuring compliance
with global regulatory requirements including SEC Rule 17a-4, MiFID II RTS 24,
CFTC Regulation 1.31, and other jurisdictional mandates.

================================================================================
SECTION 1: REGULATORY RETENTION REQUIREMENTS
================================================================================

1.1 RETENTION PERIODS BY JURISDICTION
--------------------------------------

United States (SEC):
------------------
Record Type                          | Retention Period | Rule Reference
-------------------------------------|------------------|----------------
Order tickets                        | 3 years          | Rule 17a-3(a)(6)
Trade confirmations                  | 3 years          | Rule 17a-4(b)(1)
Ledgers & journals                   | 6 years          | Rule 17a-4(b)(2)
Customer account records             | 6 years          | Rule 17a-4(b)(4)
Written communications               | 3 years          | Rule 17a-4(b)(4)
Algorithmic trading records          | 5 years          | Rule 17a-4(b)(8)
Compliance manuals                   | 6 years          | Rule 17a-4(e)(1)
Customer complaints                  | 4 years          | Rule 17a-4(b)(4)


European Union (MiFID II):
-------------------------
Record Type                          | Retention Period | Regulation
-------------------------------------|------------------|----------------
Transaction records                  | 5 years          | MiFID II Art. 25(1)
Order records                        | 5 years          | RTS 24
Client communications                | 5 years          | MiFID II Art. 16(7)
Recorded telephone lines             | 5 years          | MiFID II Art. 16(7)
Investment research                  | 5 years          | MiFID II Art. 16(6)
Organizational requirements          | 5 years          | MiFID II Art. 16(6)


CFTC (Commodities/Futures):
---------------------------
Record Type                          | Retention Period | Regulation
-------------------------------------|------------------|----------------
Trading records                      | 5 years          | Reg 1.31
Oral communications                  | 1 year           | Reg 1.31(b)(1)
Algorithmic trading source code      | 5 years          | Reg AT (proposed)
Risk management records              | 5 years          | Reg 1.11


United Kingdom (FCA):
--------------------
Record Type                          | Retention Period | Regulation
-------------------------------------|------------------|----------------
Order records                        | 5 years          | MAR Article 16
Client money records                 | 5 years          | CASS 7
Financial promotions                 | 5 years          | COBS 4.11.5


Asia-Pacific:
------------
Hong Kong (SFC):
- Trading records: 7 years
- Client information: 7 years from account closure

Singapore (MAS):
- Trading records: 5 years
- Audit trails: 5 years

Japan (JSDA):
- Trading records: 5 years
- Customer records: 10 years


1.2 COMPREHENSIVE RETENTION MATRIX
-----------------------------------

struct RetentionPolicy {
    char record_type[64];
    uint32_t retention_years;
    char regulation[32];
    char jurisdiction[16];
    bool worm_required;               // Write-Once-Read-Many
    bool encryption_required;
    char storage_tier[16];            // Hot, Warm, Cold, Archive
};

static const RetentionPolicy RETENTION_POLICIES[] = {
    // Order lifecycle records
    {"order_events", 6, "SEC 17a-4", "US", true, true, "Hot->Warm->Cold"},
    {"order_events", 5, "MiFID II", "EU", true, true, "Hot->Warm->Cold"},
    {"order_modifications", 6, "SEC 17a-4", "US", true, true, "Hot->Warm->Cold"},
    {"order_cancellations", 6, "SEC 17a-4", "US", true, true, "Hot->Warm->Cold"},

    // Execution records
    {"executions", 6, "SEC 17a-4", "US", true, true, "Hot->Warm->Cold"},
    {"trade_confirmations", 3, "SEC 17a-4", "US", true, true, "Warm->Cold"},
    {"allocation_records", 6, "SEC 17a-4", "US", true, true, "Warm->Cold"},

    // Market data
    {"market_data_snapshots", 5, "CFTC 1.31", "US", false, false, "Warm->Cold"},
    {"order_book_depth", 5, "MiFID II", "EU", false, true, "Warm->Cold"},
    {"quotes", 5, "CFTC 1.31", "US", false, false, "Cold"},

    // Risk management
    {"risk_checks", 5, "SEC 15c3-5", "US", true, true, "Hot->Warm->Cold"},
    {"position_reports", 5, "CFTC 1.73", "US", true, true, "Warm->Cold"},
    {"margin_calculations", 5, "CFTC 1.17", "US", true, true, "Warm->Cold"},

    // Compliance records
    {"surveillance_alerts", 7, "FINRA 4511", "US", true, true, "Hot->Warm->Cold"},
    {"compliance_reviews", 6, "SEC 17a-4", "US", true, true, "Warm->Cold"},
    {"exception_reports", 6, "SEC 17a-4", "US", true, true, "Warm->Cold"},

    // Client records
    {"client_accounts", 6, "SEC 17a-3", "US", true, true, "Warm->Cold"},
    {"client_agreements", 6, "SEC 17a-4", "US", true, true, "Cold->Archive"},
    {"kyc_documents", 7, "FinCEN", "US", true, true, "Cold->Archive"},

    // Communications
    {"emails", 3, "SEC 17a-4", "US", true, true, "Warm->Cold"},
    {"instant_messages", 3, "FINRA 4511", "US", true, true, "Warm->Cold"},
    {"recorded_calls", 5, "MiFID II", "EU", true, true, "Cold->Archive"},

    // System logs
    {"application_logs", 5, "Various", "Global", false, true, "Hot->Warm->Cold"},
    {"access_logs", 3, "SOX", "US", true, true, "Warm->Cold"},
    {"change_logs", 7, "SOX", "US", true, true, "Warm->Cold"},

    // Algorithm records
    {"algo_parameters", 5, "Reg AT", "US", true, true, "Cold->Archive"},
    {"algo_source_code", 5, "Reg AT", "US", true, true, "Cold->Archive"},
    {"algo_testing_results", 5, "Reg AT", "US", true, true, "Cold->Archive"},
};


================================================================================
SECTION 2: RECORD KEEPING ARCHITECTURE
================================================================================

2.1 HIERARCHICAL STORAGE MANAGEMENT
------------------------------------

class RecordKeepingSystem {
public:
    enum class StorageTier {
        HOT,        // 0-30 days: NVMe SSD, immediate access
        WARM,       // 31-365 days: SSD, fast access
        COLD,       // 1-7 years: HDD/Tape, slower access
        ARCHIVE     // 7+ years: Tape/Cloud, archival
    };

    struct StorageTierConfig {
        StorageTier tier;
        std::string mount_point;
        size_t capacity_bytes;
        std::chrono::seconds access_latency;
        double cost_per_tb_month;
        bool compression_enabled;
        std::string compression_algorithm;
        int compression_level;
    };

    RecordKeepingSystem() {
        InitializeStorageTiers();
        StartTieringThread();
        StartIntegrityCheckThread();
    }

private:
    void InitializeStorageTiers() {
        // Hot storage configuration
        storage_tiers_[StorageTier::HOT] = StorageTierConfig{
            .tier = StorageTier::HOT,
            .mount_point = "/mnt/hot_storage",
            .capacity_bytes = 10ULL * 1024 * 1024 * 1024 * 1024,  // 10TB
            .access_latency = std::chrono::milliseconds(1),
            .cost_per_tb_month = 500.0,
            .compression_enabled = false,
            .compression_algorithm = "none",
            .compression_level = 0
        };

        // Warm storage configuration
        storage_tiers_[StorageTier::WARM] = StorageTierConfig{
            .tier = StorageTier::WARM,
            .mount_point = "/mnt/warm_storage",
            .capacity_bytes = 100ULL * 1024 * 1024 * 1024 * 1024,  // 100TB
            .access_latency = std::chrono::milliseconds(100),
            .cost_per_tb_month = 100.0,
            .compression_enabled = true,
            .compression_algorithm = "lz4",
            .compression_level = 3
        };

        // Cold storage configuration
        storage_tiers_[StorageTier::COLD] = StorageTierConfig{
            .tier = StorageTier::COLD,
            .mount_point = "/mnt/cold_storage",
            .capacity_bytes = 1000ULL * 1024 * 1024 * 1024 * 1024,  // 1PB
            .access_latency = std::chrono::seconds(10),
            .cost_per_tb_month = 10.0,
            .compression_enabled = true,
            .compression_algorithm = "zstd",
            .compression_level = 9
        };

        // Archive storage configuration
        storage_tiers_[StorageTier::ARCHIVE] = StorageTierConfig{
            .tier = StorageTier::ARCHIVE,
            .mount_point = "/mnt/archive_storage",
            .capacity_bytes = 10000ULL * 1024 * 1024 * 1024 * 1024,  // 10PB
            .access_latency = std::chrono::minutes(5),
            .cost_per_tb_month = 1.0,
            .compression_enabled = true,
            .compression_algorithm = "zstd",
            .compression_level = 19
        };
    }

    std::unordered_map<StorageTier, StorageTierConfig> storage_tiers_;
};


2.2 WORM STORAGE IMPLEMENTATION
--------------------------------

Write-Once-Read-Many (WORM) storage required for regulatory compliance:

class WORMStorage {
public:
    struct WORMRecord {
        char record_id[64];
        char content_hash[64];              // SHA-256
        uint64_t creation_timestamp_ns;
        uint64_t retention_until_timestamp;
        char record_type[64];
        size_t record_size_bytes;
        char storage_location[256];
        bool immutable;
        bool encrypted;
        char encryption_key_id[64];
    };

    // Write record to WORM storage
    bool WriteRecord(const std::string& record_type,
                    const void* data,
                    size_t size,
                    uint32_t retention_years) {

        WORMRecord worm_record{};

        // Generate unique record ID
        GenerateRecordID(record_type, worm_record.record_id);

        // Calculate content hash
        CalculateSHA256(data, size, worm_record.content_hash);

        // Set retention period
        worm_record.creation_timestamp_ns = GetNanosecondTimestamp();
        worm_record.retention_until_timestamp =
            worm_record.creation_timestamp_ns +
            (retention_years * 365ULL * 24 * 3600 * 1000000000ULL);

        strcpy(worm_record.record_type, record_type.c_str());
        worm_record.record_size_bytes = size;
        worm_record.immutable = true;

        // Encrypt if required
        std::vector<uint8_t> storage_data;
        if (RequiresEncryption(record_type)) {
            storage_data = EncryptData(data, size, worm_record.encryption_key_id);
            worm_record.encrypted = true;
        } else {
            storage_data.assign(static_cast<const uint8_t*>(data),
                              static_cast<const uint8_t*>(data) + size);
            worm_record.encrypted = false;
        }

        // Determine storage location
        StorageTier tier = DetermineStorageTier(record_type, 0);
        std::string storage_path = GenerateStoragePath(tier, worm_record.record_id);
        strcpy(worm_record.storage_location, storage_path.c_str());

        // Write to filesystem with immutable flag
        if (!WriteToWORMFilesystem(storage_path, storage_data)) {
            LOG_ERROR("Failed to write WORM record: " << worm_record.record_id);
            return false;
        }

        // Set immutable attribute (Linux chattr +i)
        SetImmutableAttribute(storage_path);

        // Store metadata in index
        StoreWORMMetadata(worm_record);

        // Verify write
        if (!VerifyWORMWrite(worm_record, data, size)) {
            LOG_ERROR("WORM write verification failed: " << worm_record.record_id);
            return false;
        }

        LOG_INFO("WORM record written: " << worm_record.record_id
                << " size=" << size << " retention=" << retention_years << "y");

        return true;
    }

    // Read record from WORM storage
    std::vector<uint8_t> ReadRecord(const std::string& record_id) {
        // Lookup metadata
        WORMRecord worm_record;
        if (!LookupWORMMetadata(record_id, worm_record)) {
            LOG_ERROR("WORM record not found: " << record_id);
            return {};
        }

        // Check if retention period still active
        if (GetNanosecondTimestamp() > worm_record.retention_until_timestamp) {
            LOG_WARN("Accessing expired WORM record: " << record_id);
        }

        // Read from storage
        std::vector<uint8_t> storage_data =
            ReadFromWORMFilesystem(worm_record.storage_location);

        if (storage_data.empty()) {
            LOG_ERROR("Failed to read WORM record: " << record_id);
            return {};
        }

        // Decrypt if necessary
        std::vector<uint8_t> plaintext_data;
        if (worm_record.encrypted) {
            plaintext_data = DecryptData(storage_data,
                                        worm_record.encryption_key_id);
        } else {
            plaintext_data = storage_data;
        }

        // Verify integrity
        char computed_hash[64];
        CalculateSHA256(plaintext_data.data(), plaintext_data.size(),
                       computed_hash);

        if (strcmp(computed_hash, worm_record.content_hash) != 0) {
            LOG_CRITICAL("WORM record integrity violation: " << record_id);
            // Alert compliance team
            AlertComplianceTeam("WORM integrity violation", record_id);
            return {};
        }

        // Log access
        LogWORMAccess(record_id);

        return plaintext_data;
    }

private:
    bool WriteToWORMFilesystem(const std::string& path,
                              const std::vector<uint8_t>& data) {
        // Open file with O_CREAT | O_EXCL to prevent overwrite
        int fd = open(path.c_str(), O_WRONLY | O_CREAT | O_EXCL, 0444);
        if (fd < 0) {
            LOG_ERROR("Failed to create WORM file: " << path
                     << " errno=" << errno);
            return false;
        }

        // Write data
        ssize_t written = write(fd, data.data(), data.size());
        if (written != static_cast<ssize_t>(data.size())) {
            LOG_ERROR("Failed to write complete WORM data: " << path);
            close(fd);
            return false;
        }

        // Sync to disk
        fsync(fd);
        close(fd);

        return true;
    }

    void SetImmutableAttribute(const std::string& path) {
        // Set Linux immutable flag (requires root or CAP_LINUX_IMMUTABLE)
        #ifdef __linux__
        int fd = open(path.c_str(), O_RDONLY);
        if (fd >= 0) {
            int flags = FS_IMMUTABLE_FL;
            ioctl(fd, FS_IOC_SETFLAGS, &flags);
            close(fd);
        }
        #endif
    }

    std::unordered_map<std::string, WORMRecord> worm_index_;
    std::shared_mutex index_mutex_;
};


2.3 DATA TIERING ENGINE
------------------------

class DataTieringEngine {
public:
    DataTieringEngine() {
        tiering_thread_ = std::thread(&DataTieringEngine::TieringLoop, this);
    }

    void TieringLoop() {
        while (running_) {
            // Scan records for tiering candidates
            auto tiering_candidates = IdentifyTieringCandidates();

            for (const auto& candidate : tiering_candidates) {
                // Determine target tier
                auto current_tier = GetCurrentTier(candidate.record_id);
                auto target_tier = DetermineTargetTier(candidate);

                if (target_tier != current_tier) {
                    // Execute tiering
                    TierRecord(candidate.record_id, current_tier, target_tier);
                }
            }

            // Run every hour
            std::this_thread::sleep_for(std::chrono::hours(1));
        }
    }

private:
    struct TieringCandidate {
        std::string record_id;
        std::string record_type;
        uint64_t creation_timestamp_ns;
        size_t size_bytes;
        uint32_t access_count_30d;
        uint64_t last_access_timestamp_ns;
    };

    std::vector<TieringCandidate> IdentifyTieringCandidates() {
        std::vector<TieringCandidate> candidates;

        // Query hot storage for records older than 30 days
        uint64_t threshold_ns = GetNanosecondTimestamp() -
                               (30ULL * 24 * 3600 * 1000000000ULL);

        auto hot_records = QueryRecordsByAge(StorageTier::HOT, threshold_ns);

        for (const auto& record : hot_records) {
            TieringCandidate candidate;
            candidate.record_id = record.record_id;
            candidate.record_type = record.record_type;
            candidate.creation_timestamp_ns = record.creation_timestamp_ns;
            candidate.size_bytes = record.record_size_bytes;
            candidate.access_count_30d = GetAccessCount(record.record_id, 30);
            candidate.last_access_timestamp_ns =
                GetLastAccessTime(record.record_id);

            candidates.push_back(candidate);
        }

        return candidates;
    }

    StorageTier DetermineTargetTier(const TieringCandidate& candidate) {
        uint64_t age_ns = GetNanosecondTimestamp() -
                         candidate.creation_timestamp_ns;
        uint32_t age_days = age_ns / (24ULL * 3600 * 1000000000ULL);

        // Tier based on age and access pattern
        if (age_days < 30 || candidate.access_count_30d > 100) {
            return StorageTier::HOT;
        } else if (age_days < 365) {
            return StorageTier::WARM;
        } else if (age_days < 2555) {  // 7 years
            return StorageTier::COLD;
        } else {
            return StorageTier::ARCHIVE;
        }
    }

    bool TierRecord(const std::string& record_id,
                   StorageTier source_tier,
                   StorageTier target_tier) {

        LOG_INFO("Tiering record: " << record_id
                << " from " << TierName(source_tier)
                << " to " << TierName(target_tier));

        // Read from source
        auto data = ReadFromTier(record_id, source_tier);
        if (data.empty()) {
            LOG_ERROR("Failed to read record for tiering: " << record_id);
            return false;
        }

        // Apply compression if moving to colder tier
        if (target_tier > source_tier) {
            data = CompressData(data, target_tier);
        }

        // Write to target
        if (!WriteToTier(record_id, target_tier, data)) {
            LOG_ERROR("Failed to write record to target tier: " << record_id);
            return false;
        }

        // Verify write
        if (!VerifyTieredRecord(record_id, target_tier, data)) {
            LOG_ERROR("Tiered record verification failed: " << record_id);
            return false;
        }

        // Update metadata
        UpdateRecordTier(record_id, target_tier);

        // Delete from source (after verification)
        DeleteFromTier(record_id, source_tier);

        LOG_INFO("Record tiered successfully: " << record_id);
        return true;
    }

    std::thread tiering_thread_;
    std::atomic<bool> running_{true};
};


================================================================================
SECTION 3: RETENTION POLICY ENFORCEMENT
================================================================================

3.1 AUTOMATED RETENTION MANAGEMENT
-----------------------------------

class RetentionPolicyEnforcement {
public:
    struct RetentionRule {
        std::string record_type;
        uint32_t retention_years;
        std::string regulation;
        bool legal_hold_exempt;           // Can be held beyond retention
        bool auto_delete_enabled;         // Automatic deletion allowed
    };

    RetentionPolicyEnforcement() {
        LoadRetentionPolicies();
        enforcement_thread_ = std::thread(
            &RetentionPolicyEnforcement::EnforcementLoop, this);
    }

    void EnforcementLoop() {
        while (running_) {
            // Identify records eligible for deletion
            auto deletion_candidates = IdentifyDeletionCandidates();

            for (const auto& candidate : deletion_candidates) {
                // Check for legal holds
                if (IsUnderLegalHold(candidate.record_id)) {
                    LOG_INFO("Record under legal hold, skipping deletion: "
                            << candidate.record_id);
                    continue;
                }

                // Check for active investigations
                if (IsUnderInvestigation(candidate.record_id)) {
                    LOG_INFO("Record under investigation, skipping deletion: "
                            << candidate.record_id);
                    continue;
                }

                // Execute deletion
                ExecuteRecordDeletion(candidate);
            }

            // Run daily
            std::this_thread::sleep_for(std::chrono::hours(24));
        }
    }

private:
    struct DeletionCandidate {
        std::string record_id;
        std::string record_type;
        uint64_t creation_timestamp_ns;
        uint64_t retention_until_timestamp;
        StorageTier current_tier;
    };

    std::vector<DeletionCandidate> IdentifyDeletionCandidates() {
        std::vector<DeletionCandidate> candidates;

        uint64_t now_ns = GetNanosecondTimestamp();

        // Query all storage tiers for expired records
        for (auto tier : {StorageTier::HOT, StorageTier::WARM,
                         StorageTier::COLD, StorageTier::ARCHIVE}) {

            auto expired_records = QueryExpiredRecords(tier, now_ns);

            for (const auto& record : expired_records) {
                // Check if auto-deletion is allowed
                auto policy = GetRetentionPolicy(record.record_type);
                if (policy.auto_delete_enabled) {
                    DeletionCandidate candidate;
                    candidate.record_id = record.record_id;
                    candidate.record_type = record.record_type;
                    candidate.creation_timestamp_ns = record.creation_timestamp_ns;
                    candidate.retention_until_timestamp =
                        record.retention_until_timestamp;
                    candidate.current_tier = tier;

                    candidates.push_back(candidate);
                }
            }
        }

        return candidates;
    }

    void ExecuteRecordDeletion(const DeletionCandidate& candidate) {
        LOG_INFO("Deleting expired record: " << candidate.record_id
                << " type=" << candidate.record_type);

        // Create deletion audit record
        RecordDeletion(candidate);

        // Delete record
        if (DeleteRecord(candidate.record_id, candidate.current_tier)) {
            LOG_INFO("Record deleted successfully: " << candidate.record_id);

            // Update metadata
            MarkRecordDeleted(candidate.record_id);
        } else {
            LOG_ERROR("Failed to delete record: " << candidate.record_id);
        }
    }

    void RecordDeletion(const DeletionCandidate& candidate) {
        struct DeletionAuditRecord {
            char record_id[64];
            char record_type[64];
            uint64_t deletion_timestamp_ns;
            uint64_t original_creation_timestamp_ns;
            uint64_t retention_period_years;
            char regulation[64];
            char deleted_by[64];
            char deletion_reason[256];
        };

        DeletionAuditRecord audit{};
        strcpy(audit.record_id, candidate.record_id.c_str());
        strcpy(audit.record_type, candidate.record_type.c_str());
        audit.deletion_timestamp_ns = GetNanosecondTimestamp();
        audit.original_creation_timestamp_ns = candidate.creation_timestamp_ns;

        auto policy = GetRetentionPolicy(candidate.record_type);
        audit.retention_period_years = policy.retention_years;
        strcpy(audit.regulation, policy.regulation.c_str());
        strcpy(audit.deleted_by, "AUTOMATED_RETENTION_POLICY");
        strcpy(audit.deletion_reason, "Retention period expired");

        // Store in permanent deletion log (never deleted)
        StoreDeletionAudit(audit);
    }

    std::unordered_map<std::string, RetentionRule> retention_policies_;
    std::thread enforcement_thread_;
    std::atomic<bool> running_{true};
};


3.2 LEGAL HOLD MANAGEMENT
--------------------------

class LegalHoldManagement {
public:
    struct LegalHold {
        char hold_id[64];
        char case_number[64];
        char description[256];
        uint64_t hold_start_timestamp_ns;
        uint64_t hold_end_timestamp_ns;   // 0 if indefinite
        char custodian[64];
        std::vector<std::string> affected_record_types;
        std::vector<std::string> affected_accounts;
        std::vector<std::string> affected_traders;
        bool active;
    };

    std::string PlaceLegalHold(const LegalHold& hold) {
        // Generate hold ID
        std::string hold_id = GenerateHoldID();

        // Store legal hold
        legal_holds_[hold_id] = hold;

        // Identify affected records
        auto affected_records = IdentifyAffectedRecords(hold);

        // Mark records with legal hold flag
        for (const auto& record_id : affected_records) {
            MarkRecordWithLegalHold(record_id, hold_id);
        }

        LOG_INFO("Legal hold placed: " << hold_id
                << " affecting " << affected_records.size() << " records");

        // Notify compliance team
        NotifyComplianceTeam("Legal hold placed", hold_id);

        return hold_id;
    }

    void ReleaseLegalHold(const std::string& hold_id) {
        auto it = legal_holds_.find(hold_id);
        if (it == legal_holds_.end()) {
            LOG_ERROR("Legal hold not found: " << hold_id);
            return;
        }

        // Mark hold as inactive
        it->second.active = false;
        it->second.hold_end_timestamp_ns = GetNanosecondTimestamp();

        // Remove hold flags from records
        auto affected_records = GetRecordsUnderHold(hold_id);
        for (const auto& record_id : affected_records) {
            RemoveLegalHoldFlag(record_id, hold_id);
        }

        LOG_INFO("Legal hold released: " << hold_id
                << " affecting " << affected_records.size() << " records");

        // Notify compliance team
        NotifyComplianceTeam("Legal hold released", hold_id);
    }

private:
    std::unordered_map<std::string, LegalHold> legal_holds_;
    std::shared_mutex holds_mutex_;
};


================================================================================
SECTION 4: DATA INTEGRITY AND VERIFICATION
================================================================================

4.1 CONTINUOUS INTEGRITY MONITORING
------------------------------------

class DataIntegrityMonitor {
public:
    DataIntegrityMonitor() {
        integrity_thread_ = std::thread(
            &DataIntegrityMonitor::IntegrityCheckLoop, this);
    }

    void IntegrityCheckLoop() {
        while (running_) {
            // Check random sample of records
            auto sample_records = SelectRandomSample(1000);

            uint32_t verified = 0;
            uint32_t failed = 0;

            for (const auto& record_id : sample_records) {
                if (VerifyRecordIntegrity(record_id)) {
                    verified++;
                } else {
                    failed++;
                    LOG_CRITICAL("Integrity check failed: " << record_id);
                    HandleIntegrityViolation(record_id);
                }
            }

            LOG_INFO("Integrity check completed: verified=" << verified
                    << " failed=" << failed);

            // Run every 6 hours
            std::this_thread::sleep_for(std::chrono::hours(6));
        }
    }

private:
    bool VerifyRecordIntegrity(const std::string& record_id) {
        // Read record
        auto data = worm_storage_.ReadRecord(record_id);
        if (data.empty()) {
            LOG_ERROR("Failed to read record for integrity check: "
                     << record_id);
            return false;
        }

        // Retrieve stored hash
        WORMStorage::WORMRecord metadata;
        if (!worm_storage_.LookupWORMMetadata(record_id, metadata)) {
            LOG_ERROR("Failed to retrieve metadata: " << record_id);
            return false;
        }

        // Calculate current hash
        char computed_hash[64];
        CalculateSHA256(data.data(), data.size(), computed_hash);

        // Compare hashes
        if (strcmp(computed_hash, metadata.content_hash) != 0) {
            LOG_CRITICAL("Hash mismatch for record: " << record_id
                        << " stored=" << metadata.content_hash
                        << " computed=" << computed_hash);
            return false;
        }

        return true;
    }

    void HandleIntegrityViolation(const std::string& record_id) {
        // Alert critical systems
        AlertCriticalSystems("DATA_INTEGRITY_VIOLATION", record_id);

        // Attempt recovery from backup
        if (RestoreFromBackup(record_id)) {
            LOG_INFO("Record restored from backup: " << record_id);
        } else {
            LOG_CRITICAL("Failed to restore record from backup: "
                        << record_id);
        }

        // Log incident
        LogSecurityIncident("Data integrity violation", record_id);
    }

    WORMStorage worm_storage_;
    std::thread integrity_thread_;
    std::atomic<bool> running_{true};
};


================================================================================
SECTION 5: BACKUP AND DISASTER RECOVERY
================================================================================

5.1 BACKUP STRATEGY
-------------------

class BackupManagement {
public:
    enum class BackupType {
        FULL,           // Complete backup
        INCREMENTAL,    // Changes since last backup
        DIFFERENTIAL    // Changes since last full backup
    };

    struct BackupPolicy {
        BackupType type;
        std::chrono::hours frequency;
        uint32_t retention_count;
        std::vector<std::string> target_locations;
        bool offsite_replication;
        bool encryption_required;
    };

    BackupManagement() {
        // Full backup weekly
        backup_policies_[BackupType::FULL] = BackupPolicy{
            .type = BackupType::FULL,
            .frequency = std::chrono::hours(168),  // 7 days
            .retention_count = 52,  // 1 year
            .target_locations = {"/backup/full", "s3://backup-bucket/full"},
            .offsite_replication = true,
            .encryption_required = true
        };

        // Incremental backup daily
        backup_policies_[BackupType::INCREMENTAL] = BackupPolicy{
            .type = BackupType::INCREMENTAL,
            .frequency = std::chrono::hours(24),
            .retention_count = 30,
            .target_locations = {"/backup/incremental"},
            .offsite_replication = true,
            .encryption_required = true
        };

        backup_thread_ = std::thread(&BackupManagement::BackupLoop, this);
    }

private:
    void BackupLoop() {
        while (running_) {
            // Check which backups are due
            for (auto& [type, policy] : backup_policies_) {
                if (IsBackupDue(type)) {
                    ExecuteBackup(type, policy);
                }
            }

            std::this_thread::sleep_for(std::chrono::hours(1));
        }
    }

    void ExecuteBackup(BackupType type, const BackupPolicy& policy) {
        LOG_INFO("Starting backup: type=" << BackupTypeName(type));

        auto start_time = std::chrono::steady_clock::now();

        // Identify data to backup
        auto backup_manifest = GenerateBackupManifest(type);

        // Execute backup to all targets
        for (const auto& target : policy.target_locations) {
            bool success = BackupToTarget(backup_manifest, target, policy);
            if (!success) {
                LOG_ERROR("Backup failed to target: " << target);
            }
        }

        auto end_time = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::seconds>(
            end_time - start_time).count();

        LOG_INFO("Backup completed: type=" << BackupTypeName(type)
                << " duration=" << duration << "s");
    }

    std::unordered_map<BackupType, BackupPolicy> backup_policies_;
    std::thread backup_thread_;
    std::atomic<bool> running_{true};
};

================================================================================
END OF DOCUMENT
================================================================================
