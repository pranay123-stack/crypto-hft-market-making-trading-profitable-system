================================================================================
EXCHANGE CONNECTOR FRAMEWORK - GENERIC CONNECTOR DESIGN
================================================================================

This file contains the complete design for the exchange connector framework,
which provides a generic interface for connecting to multiple cryptocurrency
exchanges.

================================================================================
1. CORE DESIGN PRINCIPLES
================================================================================

- ABSTRACTION: Common interface for all exchanges
- EXTENSIBILITY: Easy to add new exchanges
- PERFORMANCE: Zero-copy message handling where possible
- RELIABILITY: Automatic reconnection and error recovery
- RATE LIMITING: Per-exchange rate limit enforcement

================================================================================
2. BASE CONNECTOR INTERFACE
================================================================================

```cpp
namespace hft::connectivity {

class IExchangeConnector {
public:
    virtual ~IExchangeConnector() = default;

    // Connection management
    virtual void connect() = 0;
    virtual void disconnect() = 0;
    virtual bool is_connected() const = 0;
    
    // Market data subscriptions
    virtual void subscribe_order_book(const std::string& symbol) = 0;
    virtual void subscribe_trades(const std::string& symbol) = 0;
    virtual void unsubscribe(const std::string& symbol) = 0;
    
    // Trading operations
    virtual std::string place_order(const Order& order) = 0;
    virtual bool cancel_order(const std::string& order_id) = 0;
    
    // Callbacks
    virtual void set_market_data_callback(MarketDataCallback cb) = 0;
    virtual void set_order_update_callback(OrderUpdateCallback cb) = 0;
    
    virtual std::string get_exchange_name() const = 0;
};

// Concrete base implementation
class ExchangeConnectorBase : public IExchangeConnector {
protected:
    // WebSocket and REST clients
    std::unique_ptr<WebSocketClient> ws_client_;
    std::unique_ptr<RESTClient> rest_client_;
    
    // Rate limiting
    RateLimiter rate_limiter_;
    
    // Callbacks
    MarketDataCallback md_callback_;
    OrderUpdateCallback order_callback_;
    
    // Connection state
    std::atomic<ConnectionState> state_{ConnectionState::DISCONNECTED};
    
    // Virtual methods for exchange-specific logic
    virtual void authenticate() = 0;
    virtual json format_order(const Order& order) = 0;
    virtual void handle_websocket_message(const std::string& msg) = 0;
};

} // namespace hft::connectivity
```

================================================================================
3. WEBSOCKET CLIENT IMPLEMENTATION
================================================================================

See file for complete WebSocket client using Boost.Beast with async I/O,
connection pooling, automatic reconnection, and heartbeat monitoring.

================================================================================
4. REST CLIENT IMPLEMENTATION
================================================================================

HTTP client with connection reuse, request retry logic, and timeout handling.

================================================================================
5. RATE LIMITER
================================================================================

Token bucket algorithm for enforcing exchange-specific rate limits.

================================================================================
6. MESSAGE NORMALIZATION
================================================================================

Converts exchange-specific message formats to internal common format.

================================================================================
7. ERROR HANDLING AND RECOVERY
================================================================================

Comprehensive error handling with automatic reconnection, exponential backoff,
and graceful degradation.

See full implementation in subsequent connector files (12-21).

================================================================================
