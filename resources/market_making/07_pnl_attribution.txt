================================================================================
P&L ATTRIBUTION FOR MARKET MAKERS
================================================================================

File: 07_pnl_attribution.txt
Purpose: P&L decomposition, performance analysis, attribution
Topics: Spread capture, inventory costs, rebates, risk metrics
Last Updated: 2025-11-26

================================================================================
TABLE OF CONTENTS
================================================================================

1. P&L Components Overview
2. Spread Revenue Attribution
3. Inventory Cost Analysis
4. Adverse Selection Attribution
5. Rebate and Fee Analysis
6. Hedging P&L
7. Risk-Adjusted Returns
8. Performance Metrics
9. Real-Time P&L Tracking
10. C++ P&L Attribution System

================================================================================
1. P&L COMPONENTS OVERVIEW
================================================================================

Total P&L = Spread_Revenue - Inventory_Costs - Adverse_Selection + Rebates - Fees - Hedging_Costs

TYPICAL BREAKDOWN:
------------------
Component                | % of Gross | Amount (example)
------------------------|------------|------------------
Spread Revenue          | 100%       | $10,000
Inventory Costs         | -25%       | -$2,500
Adverse Selection       | -30%       | -$3,000
Exchange Rebates        | +20%       | +$2,000
Exchange Fees           | -10%       | -$1,000
Hedging Costs           | -5%        | -$500
------------------------|---------  |------------------
Net P&L                 | 50%        | $5,000

DAILY P&L CALCULATION:
----------------------

Realized P&L:
- Closed trades (round trips)
- Actual cash flows
- Fees and rebates paid/received

Unrealized P&L:
- Open positions marked to market
- P&L = Position × (Current_Price - Entry_Price)

Total_P&L = Realized_P&L + Unrealized_P&L

C++ P&L STRUCTURE:
------------------

struct PnLComponents {
    // Revenue
    double spread_revenue;           // Bid-ask spread captured
    double rebate_revenue;           // Maker rebates earned

    // Costs
    double adverse_selection_cost;   // Losses from informed trading
    double inventory_cost;           // Holding cost and risk
    double exchange_fees;            // Taker fees paid
    double hedging_costs;            // Cost to hedge positions

    // Net
    double gross_pnl;               // Before costs
    double net_pnl;                 // After all costs

    // Unrealized
    double unrealized_pnl;          // Mark-to-market

    // Derived metrics
    double spread_capture_ratio;     // Actual spread / Quoted spread
    double adverse_selection_ratio;  // Losing trades / Total trades
    double cost_to_revenue_ratio;    // Total costs / Gross revenue

    // Calculate totals
    void calculate() {
        gross_pnl = spread_revenue + rebate_revenue;
        double total_costs = adverse_selection_cost + inventory_cost +
                            exchange_fees + hedging_costs;
        net_pnl = gross_pnl - total_costs + unrealized_pnl;

        if (gross_pnl > 0) {
            cost_to_revenue_ratio = total_costs / gross_pnl;
        }
    }
};

================================================================================
2. SPREAD REVENUE ATTRIBUTION
================================================================================

SPREAD CAPTURE CALCULATION:
---------------------------

For each completed round trip:

Entry: Buy at Bid_Price
Exit: Sell at Ask_Price
Gross_Spread = Ask_Price - Bid_Price

Quoted_Spread = Market_Ask - Market_Bid (at time of quote)
Spread_Capture = Gross_Spread / Quoted_Spread

Example:
Market: $100.00 / $100.10 (10 cent spread)
Our quote: Buy at $100.02, Sell at $100.08
Gross capture: $0.06
Spread capture ratio: $0.06 / $0.10 = 60%

FACTORS AFFECTING SPREAD CAPTURE:
----------------------------------

1. Quote Placement
   - At touch: ~50% capture (compete with others)
   - Inside touch: ~80% capture (better prices)
   - Passive: ~90%+ capture (wide spread)

2. Fill Timing
   - Both sides fill quickly: Higher capture
   - Long hold time: Lower capture (prices move)

3. Market Conditions
   - Stable market: Higher capture
   - Volatile market: Lower capture

4. Competition
   - Many MMs: Lower capture (tight spreads)
   - Few MMs: Higher capture (wide spreads)

C++ SPREAD TRACKER:
-------------------

class SpreadRevenueTracker {
private:
    struct Trade {
        double price;
        int size;
        bool is_buy;
        double quoted_spread;
        uint64_t timestamp;
        int trade_id;
    };

    struct RoundTrip {
        int buy_trade_id;
        int sell_trade_id;
        int size;
        double buy_price;
        double sell_price;
        double gross_spread;
        double quoted_spread_at_entry;
        double spread_capture_ratio;
        uint64_t holding_time_ms;
    };

    std::vector<Trade> open_trades_;
    std::vector<RoundTrip> completed_trips_;
    int next_trade_id_;

public:
    SpreadRevenueTracker() : next_trade_id_(0) {}

    void addTrade(double price, int size, bool is_buy,
                  double quoted_spread, uint64_t timestamp) {
        Trade trade{price, size, is_buy, quoted_spread, timestamp, next_trade_id_++};

        // Try to match with opposite side
        matchTrade(trade);
    }

    double getTotalSpreadRevenue() const {
        double total = 0.0;
        for (const auto& trip : completed_trips_) {
            total += trip.gross_spread * trip.size;
        }
        return total;
    }

    double getAverageSpreadCapture() const {
        if (completed_trips_.empty()) return 0.0;

        double sum = 0.0;
        for (const auto& trip : completed_trips_) {
            sum += trip.spread_capture_ratio;
        }
        return sum / completed_trips_.size();
    }

    double getSpreadCaptureByHoldTime(uint64_t min_ms, uint64_t max_ms) const {
        int count = 0;
        double sum = 0.0;

        for (const auto& trip : completed_trips_) {
            if (trip.holding_time_ms >= min_ms && trip.holding_time_ms < max_ms) {
                sum += trip.spread_capture_ratio;
                count++;
            }
        }

        return (count > 0) ? (sum / count) : 0.0;
    }

private:
    void matchTrade(const Trade& new_trade) {
        // Find opposite side trade to match
        auto it = std::find_if(open_trades_.begin(), open_trades_.end(),
            [&](const Trade& t) { return t.is_buy != new_trade.is_buy; });

        if (it != open_trades_.end()) {
            // Create round trip
            RoundTrip trip;

            if (new_trade.is_buy) {
                // New trade is buy, existing is sell
                trip.sell_trade_id = it->trade_id;
                trip.buy_trade_id = new_trade.trade_id;
                trip.sell_price = it->price;
                trip.buy_price = new_trade.price;
            } else {
                // New trade is sell, existing is buy
                trip.buy_trade_id = it->trade_id;
                trip.sell_trade_id = new_trade.trade_id;
                trip.buy_price = it->price;
                trip.sell_price = new_trade.price;
            }

            trip.size = std::min(it->size, new_trade.size);
            trip.gross_spread = trip.sell_price - trip.buy_price;
            trip.quoted_spread_at_entry = it->quoted_spread;
            trip.spread_capture_ratio = trip.gross_spread / trip.quoted_spread_at_entry;
            trip.holding_time_ms = (new_trade.timestamp - it->timestamp) / 1'000'000;

            completed_trips_.push_back(trip);

            // Update or remove matched trade
            it->size -= trip.size;
            if (it->size == 0) {
                open_trades_.erase(it);
            }
        } else {
            // No match, add to open
            open_trades_.push_back(new_trade);
        }
    }
};

================================================================================
3. INVENTORY COST ANALYSIS
================================================================================

INVENTORY COSTS:
----------------

1. Opportunity Cost
   Capital tied up in positions
   Cost = Position × Price × Interest_Rate × Time

2. Risk Cost (Volatility-based)
   Cost = λ × σ² × Position² × Time
   Where λ = risk aversion parameter

3. Actual Price Movement Cost
   Cost = Position × (Exit_Price - Entry_Price) [if adverse]

INVENTORY P&L CALCULATION:
--------------------------

For each holding period:

Position: q shares
Entry price: P_entry
Exit price: P_exit
Holding time: T hours

Inventory_PnL = q × (P_exit - P_entry)

If positive: Beneficial inventory move
If negative: Adverse inventory move

Inventory_Cost_Rate = -E[Inventory_PnL] / (|q| × P_entry × T)

C++ INVENTORY COST ANALYZER:
----------------------------

class InventoryCostAnalyzer {
private:
    struct InventoryPeriod {
        int position;
        double entry_price;
        double exit_price;
        uint64_t start_time;
        uint64_t end_time;
        double pnl;
        double opportunity_cost;
        double risk_cost;
    };

    std::vector<InventoryPeriod> periods_;
    double risk_aversion_;
    double interest_rate_;

public:
    InventoryCostAnalyzer(double risk_aversion = 1e-7,
                          double annual_rate = 0.05)
        : risk_aversion_(risk_aversion)
        , interest_rate_(annual_rate) {}

    void addInventoryPeriod(int position, double entry_price, double exit_price,
                           uint64_t start_time, uint64_t end_time,
                           double volatility) {
        InventoryPeriod period;
        period.position = position;
        period.entry_price = entry_price;
        period.exit_price = exit_price;
        period.start_time = start_time;
        period.end_time = end_time;

        // Realized P&L
        period.pnl = position * (exit_price - entry_price);

        // Opportunity cost
        double time_years = (end_time - start_time) / (1e9 * 365.25 * 24 * 3600);
        period.opportunity_cost = std::abs(position) * entry_price *
                                 interest_rate_ * time_years;

        // Risk cost (volatility-based)
        period.risk_cost = risk_aversion_ * volatility * volatility *
                          position * position * time_years;

        periods_.push_back(period);
    }

    double getTotalInventoryCost() const {
        double total = 0.0;
        for (const auto& period : periods_) {
            // Cost is opportunity cost + risk cost - beneficial P&L
            total += period.opportunity_cost + period.risk_cost;
            if (period.pnl < 0) {
                total += std::abs(period.pnl);  // Add losses
            }
        }
        return total;
    }

    double getAverageHoldingTime() const {
        if (periods_.empty()) return 0.0;

        double total_time = 0.0;
        for (const auto& period : periods_) {
            total_time += (period.end_time - period.start_time) / 1e9;  // seconds
        }
        return total_time / periods_.size();
    }

    double getInventoryTurnover(uint64_t window_ns) const {
        // How many times position is turned over
        double total_volume = 0.0;
        for (const auto& period : periods_) {
            total_volume += std::abs(period.position);
        }

        // Average position
        double avg_position = 0.0;
        for (const auto& period : periods_) {
            avg_position += std::abs(period.position);
        }
        avg_position /= periods_.size();

        if (avg_position < 1) return 0.0;

        return total_volume / avg_position;
    }
};

================================================================================
4. ADVERSE SELECTION ATTRIBUTION
================================================================================

MEASURING ADVERSE SELECTION:
-----------------------------

For each fill, measure subsequent price movement:

Fill: Buy at price P
Price after T seconds: P_after
Adverse Selection = (P_after - P) × Size

If P_after > P: Favorable (bought before price increase)
If P_after < P: Adverse selection (bought before price decrease)

For Sell:
Adverse Selection = (P - P_after) × Size

ADVERSE SELECTION RATIO:
------------------------

Win_Rate = Winning_Trades / Total_Trades

Ideal: 50% (no edge, no adverse selection)
> 50%: Favorable selection (good flow)
< 50%: Adverse selection (toxic flow)

Typical MM: 48-52%
Below 45%: Serious adverse selection problem

C++ ADVERSE SELECTION TRACKER:
-------------------------------

class AdverseSelectionTracker {
private:
    struct Fill {
        double fill_price;
        int size;
        bool is_buy;
        uint64_t timestamp;
        double price_after_1s;
        double price_after_5s;
        double price_after_30s;
        bool is_adverse;
    };

    std::vector<Fill> fills_;

public:
    void addFill(double fill_price, int size, bool is_buy, uint64_t timestamp) {
        fills_.push_back({fill_price, size, is_buy, timestamp, 0, 0, 0, false});
    }

    void updatePriceAfter(size_t fill_index, double price, uint64_t delay_ms) {
        if (fill_index >= fills_.size()) return;

        auto& fill = fills_[fill_index];

        // Store price at different time horizons
        if (delay_ms <= 1000) {
            fill.price_after_1s = price;
        } else if (delay_ms <= 5000) {
            fill.price_after_5s = price;
        } else if (delay_ms <= 30000) {
            fill.price_after_30s = price;
        }

        // Determine if adverse
        double price_move = fill.is_buy ?
                           (fill.price_after_5s - fill.fill_price) :
                           (fill.fill_price - fill.price_after_5s);

        fill.is_adverse = (price_move < 0);
    }

    double getAdverseSelectionCost(uint64_t time_horizon_ms) const {
        double total_cost = 0.0;

        for (const auto& fill : fills_) {
            double price_after = 0.0;
            if (time_horizon_ms <= 1000) price_after = fill.price_after_1s;
            else if (time_horizon_ms <= 5000) price_after = fill.price_after_5s;
            else price_after = fill.price_after_30s;

            if (price_after == 0) continue;

            double pnl = fill.is_buy ?
                        (price_after - fill.fill_price) * fill.size :
                        (fill.fill_price - price_after) * fill.size;

            if (pnl < 0) {
                total_cost += std::abs(pnl);
            }
        }

        return total_cost;
    }

    double getWinRate() const {
        if (fills_.empty()) return 0.5;

        int wins = 0;
        for (const auto& fill : fills_) {
            if (!fill.is_adverse) wins++;
        }

        return static_cast<double>(wins) / fills_.size();
    }

    double getAverageAdverseMove() const {
        double total = 0.0;
        int count = 0;

        for (const auto& fill : fills_) {
            if (fill.is_adverse && fill.price_after_5s != 0) {
                double move = fill.is_buy ?
                             (fill.price_after_5s - fill.fill_price) :
                             (fill.fill_price - fill.price_after_5s);
                total += std::abs(move);
                count++;
            }
        }

        return (count > 0) ? (total / count) : 0.0;
    }
};

================================================================================
5. COMPLETE P&L ATTRIBUTION SYSTEM
================================================================================

class ComprehensivePnLAttribution {
private:
    SpreadRevenueTracker spread_tracker_;
    InventoryCostAnalyzer inventory_analyzer_;
    AdverseSelectionTracker as_tracker_;

    struct RebateRecord {
        double rebate_amount;
        int volume;
        uint64_t timestamp;
    };

    struct FeeRecord {
        double fee_amount;
        int volume;
        uint64_t timestamp;
    };

    std::vector<RebateRecord> rebates_;
    std::vector<FeeRecord> fees_;

    double total_hedging_cost_;

public:
    ComprehensivePnLAttribution() : total_hedging_cost_(0.0) {}

    PnLComponents generateAttribution(uint64_t window_start, uint64_t window_end) {
        PnLComponents components;

        // 1. Spread Revenue
        components.spread_revenue = spread_tracker_.getTotalSpreadRevenue();
        components.spread_capture_ratio = spread_tracker_.getAverageSpreadCapture();

        // 2. Inventory Costs
        components.inventory_cost = inventory_analyzer_.getTotalInventoryCost();

        // 3. Adverse Selection
        components.adverse_selection_cost = as_tracker_.getAdverseSelectionCost(5000);
        components.adverse_selection_ratio = 1.0 - as_tracker_.getWinRate();

        // 4. Rebates
        components.rebate_revenue = 0.0;
        for (const auto& rebate : rebates_) {
            if (rebate.timestamp >= window_start && rebate.timestamp < window_end) {
                components.rebate_revenue += rebate.rebate_amount;
            }
        }

        // 5. Fees
        components.exchange_fees = 0.0;
        for (const auto& fee : fees_) {
            if (fee.timestamp >= window_start && fee.timestamp < window_end) {
                components.exchange_fees += fee.fee_amount;
            }
        }

        // 6. Hedging Costs
        components.hedging_costs = total_hedging_cost_;

        // Calculate derived metrics
        components.calculate();

        return components;
    }

    void generateDetailedReport(std::ostream& os, const PnLComponents& pnl) {
        os << "==================== P&L ATTRIBUTION REPORT ====================\n";
        os << "\nREVENUE:\n";
        os << "  Spread Revenue:        $" << std::fixed << std::setprecision(2)
           << pnl.spread_revenue << "\n";
        os << "  Spread Capture Ratio:  " << std::setprecision(1)
           << (pnl.spread_capture_ratio * 100) << "%\n";
        os << "  Exchange Rebates:      $" << std::setprecision(2)
           << pnl.rebate_revenue << "\n";
        os << "  Gross P&L:             $" << pnl.gross_pnl << "\n";

        os << "\nCOSTS:\n";
        os << "  Adverse Selection:     $" << pnl.adverse_selection_cost << "\n";
        os << "  AS Ratio:              " << std::setprecision(1)
           << (pnl.adverse_selection_ratio * 100) << "%\n";
        os << "  Inventory Costs:       $" << std::setprecision(2)
           << pnl.inventory_cost << "\n";
        os << "  Exchange Fees:         $" << pnl.exchange_fees << "\n";
        os << "  Hedging Costs:         $" << pnl.hedging_costs << "\n";

        double total_costs = pnl.adverse_selection_cost + pnl.inventory_cost +
                            pnl.exchange_fees + pnl.hedging_costs;
        os << "  Total Costs:           $" << total_costs << "\n";

        os << "\nNET P&L:                 $" << pnl.net_pnl << "\n";
        os << "Cost/Revenue Ratio:      " << std::setprecision(1)
           << (pnl.cost_to_revenue_ratio * 100) << "%\n";
        os << "================================================================\n";
    }

    // Track Sharpe ratio
    double calculateSharpe(const std::vector<double>& daily_pnl) const {
        if (daily_pnl.size() < 2) return 0.0;

        double mean = 0.0;
        for (double pnl : daily_pnl) mean += pnl;
        mean /= daily_pnl.size();

        double variance = 0.0;
        for (double pnl : daily_pnl) {
            variance += (pnl - mean) * (pnl - mean);
        }
        variance /= (daily_pnl.size() - 1);

        double std_dev = std::sqrt(variance);

        return (std_dev > 0) ? (mean / std_dev) : 0.0;
    }
};

================================================================================
PERFORMANCE SUMMARY
================================================================================

Key P&L Metrics:
----------------
- Net Profit Margin: Target > 40% of gross revenue
- Spread Capture: Target > 65%
- Win Rate: Target 48-52%
- Cost/Revenue Ratio: Target < 60%
- Sharpe Ratio: Target > 2.5

Typical Daily P&L Breakdown:
------------------------------
Gross Revenue: $10,000 (100%)
  - Spread: $7,000 (70%)
  - Rebates: $3,000 (30%)

Costs: $5,500 (55%)
  - Adverse Selection: $2,500 (25%)
  - Inventory: $1,500 (15%)
  - Fees: $1,000 (10%)
  - Hedging: $500 (5%)

Net P&L: $4,500 (45%)

Optimization Priorities:
1. Increase spread capture (better quote placement)
2. Reduce adverse selection (toxicity detection)
3. Minimize inventory costs (faster turnover)
4. Optimize rebate capture (volume tiers)
5. Efficient hedging (lower frequency, better execution)

Next: Read 08_exchange_rebates.txt for rebate optimization strategies.

================================================================================
END OF P&L ATTRIBUTION
================================================================================
