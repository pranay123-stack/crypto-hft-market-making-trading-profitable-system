================================================================================
HEDGING STRATEGIES FOR MARKET MAKERS
================================================================================

File: 06_hedging_strategies.txt
Purpose: Delta hedging, portfolio hedging, and risk neutralization
Topics: Hedging frequency, execution, cross-asset hedging
Last Updated: 2025-11-26

================================================================================
TABLE OF CONTENTS
================================================================================

1. Why Market Makers Hedge
2. Delta Hedging Fundamentals
3. Optimal Hedging Frequency
4. Hedging Execution Strategies
5. Cross-Asset Hedging
6. Futures and Options Hedging
7. Statistical Hedging
8. Dynamic Hedging Algorithms
9. Hedging Cost Analysis
10. C++ Hedging Implementation

================================================================================
1. WHY MARKET MAKERS HEDGE
================================================================================

Market makers accumulate inventory risk through their liquidity provision.
Hedging reduces this directional risk while maintaining profitability.

UNHEDGED RISK:
--------------

Position: +10,000 shares @ $100
Price drops to $99
Loss: 10,000 × $1 = $10,000

Spread revenue needs to exceed potential losses:
Daily spread revenue: $0.02 × 10,000 = $200
Days to recover loss: $10,000 / $200 = 50 days

HEDGED POSITION:
----------------

Position: +10,000 shares @ $100
Hedge: Short 10,000 shares (via futures or another venue)
Price drops to $99
Loss on position: -$10,000
Gain on hedge: +$10,000
Net: $0

Now can focus on earning spread without directional risk.

HEDGING OBJECTIVES:
-------------------

1. Neutralize directional risk (delta)
2. Reduce capital requirements
3. Maintain spread capture profitability
4. Minimize hedging costs
5. Optimize risk-adjusted returns

HEDGING COSTS:
--------------

1. Transaction costs (fees)
2. Bid-ask spread on hedge instrument
3. Slippage
4. Market impact
5. Basis risk (hedge doesn't perfectly track)

Total Hedging Cost = Fixed_Costs + Variable_Costs + Basis_Risk

Example:
Position: 10,000 shares
Hedge via futures (1 contract = 100 shares = 100 contracts)
Fee: $0.50 per contract × 100 = $50
Spread: $0.05 × 10,000 = $500
Total: $550 for full hedge

If daily P&L volatility reduction is $2,000:
Hedging value: $2,000
Hedging cost: $550
Net benefit: $1,450

================================================================================
2. DELTA HEDGING FUNDAMENTALS
================================================================================

DELTA DEFINITION:
-----------------

Delta (Δ) = ∂P&L / ∂S

Where:
- P&L = portfolio profit/loss
- S = underlying price

For single stock position:
Delta = Position (in shares)

Example:
Long 5,000 shares → Delta = +5,000
Short 3,000 shares → Delta = -3,000

DELTA-NEUTRAL TARGET:
---------------------

Target: Δ_portfolio = 0

Achieved by:
1. Trading opposite direction in same stock
2. Trading correlated instruments
3. Using derivatives (futures, options)

REBALANCING TRIGGER:
--------------------

Hedge when |Delta| exceeds threshold:

if |Current_Delta| > Delta_Threshold:
    Hedge_Size = Current_Delta
    Execute hedge trade

Typical thresholds:
- Conservative: 1,000-2,000 shares
- Moderate: 3,000-5,000 shares
- Aggressive: 5,000-10,000 shares

C++ DELTA TRACKER:
------------------

class DeltaHedger {
private:
    int target_delta_;           // Target delta (usually 0)
    int delta_threshold_;        // Trigger for hedging
    int current_position_;
    double last_hedge_price_;

public:
    DeltaHedger(int target, int threshold)
        : target_delta_(target)
        , delta_threshold_(threshold)
        , current_position_(0)
        , last_hedge_price_(0.0) {}

    struct HedgeDecision {
        bool should_hedge;
        int hedge_size;        // Signed: +buy, -sell
        double urgency;        // [0,1]
        std::string reason;
    };

    void updatePosition(int position) {
        current_position_ = position;
    }

    int getCurrentDelta() const {
        return current_position_ - target_delta_;
    }

    HedgeDecision checkHedging(double current_price,
                              double volatility) const {
        HedgeDecision decision;
        decision.should_hedge = false;
        decision.hedge_size = 0;
        decision.urgency = 0.0;

        int delta = getCurrentDelta();
        int abs_delta = std::abs(delta);

        // Check if hedge is needed
        if (abs_delta < delta_threshold_) {
            decision.reason = "Delta within threshold";
            return decision;
        }

        // Calculate hedge size
        decision.should_hedge = true;
        decision.hedge_size = -delta;  // Opposite sign to neutralize

        // Calculate urgency (0 to 1)
        decision.urgency = static_cast<double>(abs_delta - delta_threshold_) /
                          (2.0 * delta_threshold_);
        decision.urgency = std::clamp(decision.urgency, 0.0, 1.0);

        // Adjust for volatility (more urgent in high vol)
        decision.urgency *= (1.0 + volatility / 0.30);  // Normalize to 30% annual vol
        decision.urgency = std::min(decision.urgency, 1.0);

        decision.reason = "Delta exceeds threshold: " + std::to_string(delta);

        return decision;
    }

    // Calculate hedging P&L
    double calculateHedgePnL(double hedge_price) const {
        if (last_hedge_price_ == 0.0) return 0.0;

        double price_change = hedge_price - last_hedge_price_;
        // P&L = -delta × price_change (negative because hedge is opposite)
        return -target_delta_ * price_change;
    }

    void recordHedge(double hedge_price) {
        last_hedge_price_ = hedge_price;
    }
};

================================================================================
3. OPTIMAL HEDGING FREQUENCY
================================================================================

HEDGING FREQUENCY TRADE-OFF:
-----------------------------

Too Frequent:
- High transaction costs
- Excessive fees
- Market impact
- Reduced net profitability

Too Infrequent:
- Large position risk
- High P&L volatility
- Potential for large losses
- Higher capital requirements

Optimal frequency balances costs and risk.

MEAN-VARIANCE OPTIMIZATION:
----------------------------

Minimize:
Cost = Transaction_Cost × Frequency + Risk_Cost × (1/Frequency)

Optimal Frequency:
f* = √(Risk_Cost / Transaction_Cost)

Example:
Transaction_Cost per hedge = $500
Risk_Cost (daily P&L volatility) = $4,000/day without hedging

Daily hedges (f=1):
Cost = $500 × 1 + $4,000 × 1 = $4,500

Half-day hedges (f=2):
Cost = $500 × 2 + $4,000 × 0.5 = $3,000

Optimal frequency:
f* = √($4,000 / $500) = √8 ≈ 2.8 times per day

THRESHOLD-BASED HEDGING:
-------------------------

Hedge when position × volatility × price exceeds value:

Hedge_Trigger = |Position| × Price × σ_daily

Example:
Position: 8,000 shares
Price: $100
σ_daily: 1.5%
Threshold: $10,000

Hedge_Value = 8,000 × $100 × 0.015 = $12,000
$12,000 > $10,000 → Hedge now

TIME-AND-THRESHOLD:
-------------------

Combine time and position triggers:

Hedge if:
1. Position exceeds threshold, OR
2. Time since last hedge exceeds max interval

Provides both risk control and regular rebalancing.

C++ OPTIMAL HEDGING CALCULATOR:
--------------------------------

class OptimalHedgingCalculator {
private:
    double transaction_cost_;
    double risk_cost_per_day_;
    uint64_t max_time_between_hedges_ms_;
    uint64_t last_hedge_time_;

public:
    OptimalHedgingCalculator(double trans_cost, double risk_cost,
                            uint64_t max_interval_ms)
        : transaction_cost_(trans_cost)
        , risk_cost_per_day_(risk_cost)
        , max_time_between_hedges_ms_(max_interval_ms)
        , last_hedge_time_(0) {}

    // Calculate optimal hedging frequency (times per day)
    double calculateOptimalFrequency() const {
        if (transaction_cost_ < 0.0001) return 10.0;  // Default

        double optimal_freq = std::sqrt(risk_cost_per_day_ / transaction_cost_);
        return std::clamp(optimal_freq, 0.5, 20.0);  // 0.5 to 20 times/day
    }

    // Calculate expected cost at different frequencies
    double calculateExpectedCost(double frequency) const {
        return transaction_cost_ * frequency +
               risk_cost_per_day_ / frequency;
    }

    // Determine if should hedge based on time and threshold
    bool shouldHedge(int position,
                    int threshold,
                    double price,
                    double volatility,
                    uint64_t current_time) const {
        // Check position threshold
        if (std::abs(position) >= threshold) {
            return true;
        }

        // Check time threshold
        if (last_hedge_time_ > 0) {
            uint64_t time_since_hedge = current_time - last_hedge_time_;
            if (time_since_hedge >= max_time_between_hedges_ms_) {
                return true;
            }
        }

        // Check value-at-risk threshold
        double position_risk = std::abs(position) * price * volatility;
        double risk_threshold = 10000.0;  // $10K daily VaR

        if (position_risk >= risk_threshold) {
            return true;
        }

        return false;
    }

    void recordHedge(uint64_t timestamp) {
        last_hedge_time_ = timestamp;
    }

    // Calculate break-even hedging frequency
    double calculateBreakEvenFrequency(double spread_revenue_per_day) const {
        // Frequency where hedging cost = spread revenue
        // trans_cost × f + risk_cost / f = spread_revenue
        // Solve quadratic: trans_cost × f² - spread_revenue × f + risk_cost = 0

        double a = transaction_cost_;
        double b = -spread_revenue_per_day;
        double c = risk_cost_per_day_;

        double discriminant = b * b - 4 * a * c;
        if (discriminant < 0) return 0.0;

        double f1 = (-b + std::sqrt(discriminant)) / (2 * a);
        double f2 = (-b - std::sqrt(discriminant)) / (2 * a);

        // Return positive solution
        return std::max(f1, f2);
    }
};

================================================================================
4. HEDGING EXECUTION STRATEGIES
================================================================================

IMMEDIATE MARKET ORDER:
-----------------------

Fastest execution, highest cost

Pros:
+ Immediate risk reduction
+ Guaranteed execution
+ Simple

Cons:
- Pay bid-ask spread
- Market impact
- Adverse selection

Use when: Urgent risk reduction needed

LIMIT ORDER HEDGING:
--------------------

Post limit order to hedge position

Pros:
+ Better prices
+ May earn spread
+ Lower cost

Cons:
- Uncertain execution
- Delayed risk reduction
- Requires monitoring

Use when: Not urgent, stable market

ICEBERG EXECUTION:
------------------

Large hedge broken into smaller pieces

Order = 10,000 shares
Display: 500 shares at a time
Hidden: 9,500 shares

Pros:
+ Reduced market impact
+ Better average price
+ Hidden size

Cons:
- Slower execution
- Partial fill risk

TWAP (Time-Weighted Average Price):
------------------------------------

Execute hedge evenly over time period

Total: 10,000 shares
Period: 30 minutes
Slices: 30 (one per minute)
Per slice: 333 shares

Pros:
+ Smooth execution
+ Reduced market impact
+ Predictable

Cons:
- Longer exposure
- May miss opportunities

VWAP (Volume-Weighted Average Price):
--------------------------------------

Execute proportional to market volume

Trade faster during high volume periods
Trade slower during low volume periods

Pros:
+ Minimal market impact
+ Good benchmark

Cons:
- Complex algorithm
- Requires volume prediction

C++ HEDGING EXECUTION ENGINE:
------------------------------

class HedgingExecutionEngine {
public:
    enum class ExecutionStrategy {
        IMMEDIATE,
        LIMIT_PASSIVE,
        ICEBERG,
        TWAP,
        VWAP,
        ADAPTIVE
    };

private:
    ExecutionStrategy strategy_;

public:
    HedgingExecutionEngine(ExecutionStrategy strategy)
        : strategy_(strategy) {}

    struct ExecutionPlan {
        std::vector<int> slice_sizes;
        std::vector<uint64_t> slice_times;
        double estimated_cost;
        double estimated_duration_ms;
    };

    ExecutionPlan createExecutionPlan(int total_size,
                                     double current_price,
                                     double avg_volume_per_minute,
                                     uint64_t urgency_level) const {
        ExecutionPlan plan;

        switch (strategy_) {
            case ExecutionStrategy::IMMEDIATE:
                plan = createImmediatePlan(total_size);
                break;

            case ExecutionStrategy::TWAP:
                plan = createTWAPPlan(total_size, 30 * 60 * 1000);  // 30 min
                break;

            case ExecutionStrategy::ICEBERG:
                plan = createIcebergPlan(total_size, 500);  // 500 share slices
                break;

            case ExecutionStrategy::ADAPTIVE:
                plan = createAdaptivePlan(total_size, urgency_level,
                                         avg_volume_per_minute);
                break;

            default:
                plan = createImmediatePlan(total_size);
        }

        return plan;
    }

private:
    ExecutionPlan createImmediatePlan(int total_size) const {
        ExecutionPlan plan;
        plan.slice_sizes.push_back(total_size);
        plan.slice_times.push_back(0);  // Immediate
        plan.estimated_cost = std::abs(total_size) * 0.02;  // 2 cents slippage
        plan.estimated_duration_ms = 100;  // 100ms
        return plan;
    }

    ExecutionPlan createTWAPPlan(int total_size, uint64_t duration_ms) const {
        ExecutionPlan plan;

        int num_slices = duration_ms / (60 * 1000);  // One per minute
        num_slices = std::max(1, num_slices);

        int slice_size = total_size / num_slices;
        int remainder = total_size % num_slices;

        for (int i = 0; i < num_slices; ++i) {
            int size = slice_size + (i < remainder ? 1 : 0);
            plan.slice_sizes.push_back(size);
            plan.slice_times.push_back(i * 60 * 1000);  // Every minute
        }

        plan.estimated_cost = std::abs(total_size) * 0.01;  // 1 cent per share
        plan.estimated_duration_ms = duration_ms;

        return plan;
    }

    ExecutionPlan createIcebergPlan(int total_size, int display_size) const {
        ExecutionPlan plan;

        int num_slices = (std::abs(total_size) + display_size - 1) / display_size;

        for (int i = 0; i < num_slices; ++i) {
            int remaining = std::abs(total_size) - i * display_size;
            int slice = std::min(display_size, remaining);
            if (total_size < 0) slice = -slice;

            plan.slice_sizes.push_back(slice);
            plan.slice_times.push_back(i * 5000);  // 5 seconds between slices
        }

        plan.estimated_cost = std::abs(total_size) * 0.015;  // 1.5 cents
        plan.estimated_duration_ms = num_slices * 5000;

        return plan;
    }

    ExecutionPlan createAdaptivePlan(int total_size,
                                    uint64_t urgency,
                                    double avg_volume) const {
        // High urgency → More aggressive (like immediate)
        // Low urgency → More passive (like TWAP)

        if (urgency > 0.8) {
            return createImmediatePlan(total_size);
        } else if (urgency > 0.5) {
            return createIcebergPlan(total_size, 200);
        } else {
            return createTWAPPlan(total_size, 60 * 60 * 1000);  // 1 hour
        }
    }
};

================================================================================
5. CROSS-ASSET HEDGING
================================================================================

Hedge using correlated instruments when direct hedging is expensive.

ETF HEDGING:
------------

Example: Market making in AAPL
Hedge with: QQQ (Nasdaq ETF) or XLK (Tech sector ETF)

Beta calculation:
β_AAPL,QQQ = Cov(R_AAPL, R_QQQ) / Var(R_QQQ)

Hedge ratio:
Hedge_Size_QQQ = Position_AAPL × β × (Price_AAPL / Price_QQQ)

Example:
Position: +10,000 AAPL
AAPL price: $180
QQQ price: $360
Beta: 1.2

Hedge_Size = 10,000 × 1.2 × (180/360) = 6,000 QQQ shares

FUTURES HEDGING:
----------------

Hedge with futures for better capital efficiency

Contract sizing:
Number_of_Contracts = (Position × Price) / (Contract_Multiplier × Futures_Price)

Example:
Position: 10,000 shares @ $100
Futures: $100 per point, multiplier = 100
Futures_Price: $100.50

Contracts = (10,000 × 100) / (100 × 100.50) = 99.5 ≈ 100 contracts

OPTIONS HEDGING:
----------------

Use options for non-linear hedging

Put option: Protects downside, costs premium
Call option: Protects upside (for shorts), costs premium

Example:
Position: +10,000 shares @ $100
Buy 100 put contracts (1000 shares each), strike $98
Cost: $1.50 per share × 10,000 = $15,000
Protection: If price < $98, puts gain value

C++ CROSS-ASSET HEDGER:
-----------------------

class CrossAssetHedger {
private:
    struct HedgeInstrument {
        std::string symbol;
        double beta;
        double price;
        int multiplier;  // For futures
        double correlation;
        double hedge_cost;  // Cost per share
    };

    std::unordered_map<std::string, HedgeInstrument> instruments_;

public:
    void addHedgeInstrument(const std::string& symbol,
                           double beta,
                           double price,
                           int multiplier,
                           double correlation,
                           double cost) {
        instruments_[symbol] = {symbol, beta, price, multiplier, correlation, cost};
    }

    struct HedgeRecommendation {
        std::string instrument;
        int size;  // Shares or contracts
        double cost;
        double hedge_effectiveness;  // Based on correlation
    };

    HedgeRecommendation recommendHedge(const std::string& primary_symbol,
                                      int position,
                                      double primary_price) const {
        HedgeRecommendation best;
        best.cost = std::numeric_limits<double>::max();

        // Evaluate each hedge instrument
        for (const auto& [symbol, inst] : instruments_) {
            // Calculate hedge size
            int hedge_size = static_cast<int>(
                position * inst.beta * (primary_price / inst.price)
            );

            if (inst.multiplier > 1) {
                // Futures: convert to contracts
                hedge_size = hedge_size / inst.multiplier;
            }

            // Calculate cost
            double total_cost = std::abs(hedge_size) * inst.hedge_cost;

            // Adjust for effectiveness
            double effective_cost = total_cost / (inst.correlation * inst.correlation);

            if (effective_cost < best.cost) {
                best.instrument = symbol;
                best.size = hedge_size;
                best.cost = total_cost;
                best.hedge_effectiveness = inst.correlation * inst.correlation;
            }
        }

        return best;
    }

    // Calculate portfolio delta after hedge
    double calculatePortfolioDelta(const std::string& primary_symbol,
                                  int primary_position,
                                  const std::unordered_map<std::string, int>& hedge_positions) const {
        double total_delta = primary_position;

        for (const auto& [symbol, position] : hedge_positions) {
            auto it = instruments_.find(symbol);
            if (it != instruments_.end()) {
                // Add delta contribution from hedge
                // Delta = position × beta (adjust sign for hedge)
                total_delta += position * it->second.beta;
            }
        }

        return total_delta;
    }

    // Optimize hedge across multiple instruments
    std::unordered_map<std::string, int> optimizeMultiInstrumentHedge(
        int target_delta,
        int current_delta,
        double max_cost) const {

        std::unordered_map<std::string, int> hedge_positions;

        // Simple greedy approach: use most cost-effective instrument first
        std::vector<std::pair<std::string, double>> cost_effectiveness;

        for (const auto& [symbol, inst] : instruments_) {
            double effectiveness = (inst.correlation * inst.correlation) / inst.hedge_cost;
            cost_effectiveness.push_back({symbol, effectiveness});
        }

        // Sort by effectiveness (descending)
        std::sort(cost_effectiveness.begin(), cost_effectiveness.end(),
                 [](const auto& a, const auto& b) { return a.second > b.second; });

        // Allocate hedges
        int remaining_delta = current_delta - target_delta;
        double remaining_budget = max_cost;

        for (const auto& [symbol, effectiveness] : cost_effectiveness) {
            if (std::abs(remaining_delta) < 100) break;  // Close enough

            const auto& inst = instruments_.at(symbol);

            // Calculate optimal allocation
            int hedge_size = remaining_delta / inst.beta;

            // Constrain by budget
            double cost = std::abs(hedge_size) * inst.hedge_cost;
            if (cost > remaining_budget) {
                hedge_size = remaining_budget / inst.hedge_cost;
                if (remaining_delta < 0) hedge_size = -hedge_size;
            }

            hedge_positions[symbol] = hedge_size;
            remaining_delta -= hedge_size * inst.beta;
            remaining_budget -= std::abs(hedge_size) * inst.hedge_cost;

            if (remaining_budget <= 0) break;
        }

        return hedge_positions;
    }
};

================================================================================
6. DYNAMIC HEDGING ALGORITHMS
================================================================================

PROPORTIONAL HEDGING:
---------------------

Hedge proportion of position based on urgency

Hedge_Size = Position × Hedge_Ratio

Where Hedge_Ratio ∈ [0, 1] based on:
- Position size
- Volatility
- Time since last hedge
- P&L

KALMAN FILTER HEDGING:
----------------------

Use Kalman filter to estimate optimal hedge ratio

State: [Beta, Alpha]
Measurement: Returns

Dynamically adjusts hedge ratio based on recent correlation.

REINFORCEMENT LEARNING HEDGING:
--------------------------------

Train RL agent to learn optimal hedging policy

State: [Position, Volatility, Time, P&L, ...]
Action: Hedge_Size ∈ [-Max, +Max]
Reward: P&L - Transaction_Costs

C++ DYNAMIC HEDGER:
-------------------

class DynamicHedgingAlgorithm {
private:
    double min_hedge_ratio_;
    double max_hedge_ratio_;
    double current_hedge_ratio_;

    struct MarketState {
        double volatility;
        double correlation;
        int position;
        double pnl;
        uint64_t time_since_last_hedge;
    };

public:
    DynamicHedgingAlgorithm()
        : min_hedge_ratio_(0.5)
        , max_hedge_ratio_(1.0)
        , current_hedge_ratio_(0.8) {}

    double calculateDynamicHedgeRatio(const MarketState& state) const {
        // Start with base ratio
        double ratio = current_hedge_ratio_;

        // Adjust for volatility (higher vol → more hedging)
        double vol_adjustment = (state.volatility - 0.20) / 0.20;
        ratio += 0.1 * vol_adjustment;

        // Adjust for correlation (lower corr → less hedging)
        double corr_adjustment = (state.correlation - 0.8) / 0.2;
        ratio -= 0.1 * (1.0 - corr_adjustment);

        // Adjust for position size (larger pos → more hedging)
        double pos_ratio = std::abs(static_cast<double>(state.position)) / 10000.0;
        ratio += 0.2 * pos_ratio;

        // Clamp to valid range
        return std::clamp(ratio, min_hedge_ratio_, max_hedge_ratio_);
    }

    int calculateHedgeSize(int position, const MarketState& state) const {
        double hedge_ratio = calculateDynamicHedgeRatio(state);
        return static_cast<int>(-position * hedge_ratio);
    }

    // Update hedge ratio based on performance
    void updateHedgeRatio(double realized_pnl,
                         double hedging_cost) {
        // Simple adaptive update
        double net_benefit = realized_pnl - hedging_cost;

        if (net_benefit > 0) {
            // Hedging was beneficial, maintain or increase slightly
            current_hedge_ratio_ += 0.01;
        } else {
            // Hedging was costly, reduce slightly
            current_hedge_ratio_ -= 0.02;
        }

        current_hedge_ratio_ = std::clamp(current_hedge_ratio_,
                                          min_hedge_ratio_,
                                          max_hedge_ratio_);
    }
};

================================================================================
PERFORMANCE SUMMARY
================================================================================

Hedging Effectiveness Metrics:
- Portfolio Delta: Target ±500 shares (from ±5000 unhedged)
- P&L Volatility Reduction: 60-80%
- Sharpe Ratio Improvement: +0.5 to +1.5
- Hedging Cost Ratio: 10-20% of gross revenue

Optimal Hedging Parameters:
- Frequency: 2-5 times per day
- Threshold: 3,000-5,000 shares
- Execution: TWAP for large, immediate for urgent
- Instruments: Futures (lowest cost), ETFs (good correlation)

Key Takeaways:
1. Hedge to reduce directional risk, not eliminate profit
2. Optimize frequency to balance cost and risk
3. Use cross-asset hedges when cost-effective
4. Monitor hedge effectiveness continuously
5. Adjust strategy based on market conditions

Next: Read 07_pnl_attribution.txt for P&L analysis and decomposition.

================================================================================
END OF HEDGING STRATEGIES
================================================================================
