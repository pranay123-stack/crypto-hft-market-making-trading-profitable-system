================================================================================
MARKET MAKING ANALYTICS AND METRICS
================================================================================

File: 10_mm_analytics.txt
Purpose: Performance metrics, KPIs, and analytics for market making
Topics: Fill rates, spread capture, Sharpe ratio, profitability metrics
Last Updated: 2025-11-26

TABLE OF CONTENTS:
1. Key Performance Indicators
2. Fill Rate Analysis
3. Spread Capture Metrics
4. Risk-Adjusted Returns
5. Inventory Metrics
6. Adverse Selection Metrics
7. Profitability Analysis
8. Real-Time Dashboards
9. Historical Analysis
10. C++ Analytics Engine

================================================================================
1. KEY PERFORMANCE INDICATORS (KPIs)
================================================================================

PRIMARY METRICS:
----------------

1. Net P&L
   - Daily, weekly, monthly
   - Per symbol, per strategy
   - Realized vs unrealized

2. Sharpe Ratio
   SR = E[R - Rf] / σ(R)
   - Target: > 2.5 daily
   - Top tier: > 3.5 daily
   - Monthly: > 5.0

3. Fill Rate
   FR = Fills / Quotes
   - Target: 70-90%
   - Too low: < 60% (too passive)
   - Too high: > 95% (getting picked off)

4. Spread Capture
   SC = Actual_Spread / Quoted_Spread
   - Target: > 65%
   - Excellent: > 75%
   - Poor: < 50%

5. Adverse Selection Ratio
   ASR = Losing_Trades / Total_Trades
   - Target: 45-55% (balanced)
   - Warning: > 55% (toxic flow)
   - Excellent: < 45%

6. Inventory Turnover
   IT = Daily_Volume / Avg_Position
   - Target: 20-50 turns/day
   - HFT: > 50 turns
   - Lower freq: 10-20 turns

C++ KPI TRACKER:
----------------

class KPITracker {
private:
    struct DailyMetrics {
        double net_pnl;
        int total_fills;
        int total_quotes;
        double total_spread_captured;
        double total_spread_quoted;
        int winning_trades;
        int total_trades;
        std::vector<double> hourly_pnl;
    };

    std::map<std::string, DailyMetrics> daily_data_;  // date -> metrics

public:
    void recordFill(const std::string& date, double spread_captured,
                    double spread_quoted, bool is_winning_trade) {
        auto& metrics = daily_data_[date];
        metrics.total_fills++;
        metrics.total_spread_captured += spread_captured;
        metrics.total_spread_quoted += spread_quoted;
        metrics.total_trades++;
        if (is_winning_trade) metrics.winning_trades++;
    }

    void recordQuote(const std::string& date) {
        daily_data_[date].total_quotes++;
    }

    void updatePnL(const std::string& date, double pnl, int hour) {
        auto& metrics = daily_data_[date];
        metrics.net_pnl = pnl;
        if (metrics.hourly_pnl.size() <= hour) {
            metrics.hourly_pnl.resize(hour + 1);
        }
        metrics.hourly_pnl[hour] = pnl;
    }

    double calculateFillRate(const std::string& date) const {
        auto it = daily_data_.find(date);
        if (it == daily_data_.end() || it->second.total_quotes == 0) return 0.0;
        return static_cast<double>(it->second.total_fills) / it->second.total_quotes;
    }

    double calculateSpreadCapture(const std::string& date) const {
        auto it = daily_data_.find(date);
        if (it == daily_data_.end() || it->second.total_spread_quoted == 0) return 0.0;
        return it->second.total_spread_captured / it->second.total_spread_quoted;
    }

    double calculateWinRate(const std::string& date) const {
        auto it = daily_data_.find(date);
        if (it == daily_data_.end() || it->second.total_trades == 0) return 0.5;
        return static_cast<double>(it->second.winning_trades) / it->second.total_trades;
    }

    double calculateSharpeRatio(const std::vector<std::string>& dates) const {
        std::vector<double> returns;
        for (const auto& date : dates) {
            auto it = daily_data_.find(date);
            if (it != daily_data_.end()) {
                returns.push_back(it->second.net_pnl);
            }
        }

        if (returns.size() < 2) return 0.0;

        double mean = std::accumulate(returns.begin(), returns.end(), 0.0) / returns.size();
        double sq_sum = 0.0;
        for (double r : returns) {
            sq_sum += (r - mean) * (r - mean);
        }
        double std_dev = std::sqrt(sq_sum / (returns.size() - 1));

        return (std_dev > 0) ? (mean / std_dev) : 0.0;
    }
};

================================================================================
2. PROFITABILITY ANALYSIS
================================================================================

PROFIT MARGINS:
---------------

Gross Profit Margin = Gross_Revenue / Total_Revenue
Net Profit Margin = Net_P&L / Total_Revenue

Target margins:
- Gross: 80-100%
- Net: 40-60%

RETURN ON CAPITAL:
------------------

ROC = Annual_Net_P&L / Capital_Employed

Example:
Capital: $1M
Annual P&L: $800K
ROC = 80%

Risk-Adjusted ROC = ROC / Volatility
Target: > 3.0

PROFIT PER SHARE:
-----------------

PPS = Net_P&L / Total_Volume

Target: $0.001 - $0.005 per share

Example:
Daily volume: 1M shares
Daily P&L: $3,000
PPS = $0.003

REVENUE BREAKDOWN:
------------------

Sources:
1. Spread capture: 70%
2. Rebates: 20%
3. Other: 10%

Costs:
1. Adverse selection: 30%
2. Inventory: 15%
3. Fees: 10%
4. Hedging: 5%

C++ PROFITABILITY ANALYZER:
----------------------------

class ProfitabilityAnalyzer {
private:
    struct ProfitComponents {
        double spread_revenue;
        double rebate_revenue;
        double adverse_selection_cost;
        double inventory_cost;
        double exchange_fees;
        double hedging_cost;
        int64_t volume;
    };

    std::vector<ProfitComponents> daily_profits_;

public:
    void addDay(const ProfitComponents& components) {
        daily_profits_.push_back(components);
    }

    double calculateNetMargin() const {
        if (daily_profits_.empty()) return 0.0;

        double total_revenue = 0.0;
        double total_costs = 0.0;

        for (const auto& day : daily_profits_) {
            total_revenue += day.spread_revenue + day.rebate_revenue;
            total_costs += day.adverse_selection_cost + day.inventory_cost +
                          day.exchange_fees + day.hedging_cost;
        }

        return (total_revenue > 0) ? ((total_revenue - total_costs) / total_revenue) : 0.0;
    }

    double calculateProfitPerShare() const {
        if (daily_profits_.empty()) return 0.0;

        double total_profit = 0.0;
        int64_t total_volume = 0;

        for (const auto& day : daily_profits_) {
            double net = (day.spread_revenue + day.rebate_revenue) -
                        (day.adverse_selection_cost + day.inventory_cost +
                         day.exchange_fees + day.hedging_cost);
            total_profit += net;
            total_volume += day.volume;
        }

        return (total_volume > 0) ? (total_profit / total_volume) : 0.0;
    }

    std::map<std::string, double> getRevenueBreakdown() const {
        double total_spread = 0.0, total_rebate = 0.0;

        for (const auto& day : daily_profits_) {
            total_spread += day.spread_revenue;
            total_rebate += day.rebate_revenue;
        }

        double total_revenue = total_spread + total_rebate;

        return {
            {"spread_pct", (total_revenue > 0) ? (total_spread / total_revenue * 100) : 0.0},
            {"rebate_pct", (total_revenue > 0) ? (total_rebate / total_revenue * 100) : 0.0}
        };
    }

    std::map<std::string, double> getCostBreakdown() const {
        double total_as = 0.0, total_inv = 0.0, total_fees = 0.0, total_hedge = 0.0;

        for (const auto& day : daily_profits_) {
            total_as += day.adverse_selection_cost;
            total_inv += day.inventory_cost;
            total_fees += day.exchange_fees;
            total_hedge += day.hedging_cost;
        }

        double total_costs = total_as + total_inv + total_fees + total_hedge;

        return {
            {"adverse_selection_pct", (total_costs > 0) ? (total_as / total_costs * 100) : 0.0},
            {"inventory_pct", (total_costs > 0) ? (total_inv / total_costs * 100) : 0.0},
            {"fees_pct", (total_costs > 0) ? (total_fees / total_costs * 100) : 0.0},
            {"hedging_pct", (total_costs > 0) ? (total_hedge / total_costs * 100) : 0.0}
        };
    }
};

================================================================================
3. REAL-TIME MONITORING DASHBOARD
================================================================================

DASHBOARD COMPONENTS:
---------------------

1. P&L Panel
   - Current P&L
   - High water mark
   - Drawdown
   - P&L chart (time series)

2. Position Panel
   - Current positions by symbol
   - Notional exposure
   - Delta
   - Position limits

3. Trading Activity
   - Fill rate (last hour)
   - Quote update rate
   - Volume traded
   - Number of trades

4. Risk Metrics
   - VaR (95%, 99%)
   - Sharpe ratio (rolling)
   - Max drawdown
   - Limit utilization

5. Market Making Specific
   - Spread capture
   - Adverse selection ratio
   - Inventory turnover
   - Rebate capture

6. Alerts
   - Risk limit breaches
   - Circuit breaker triggers
   - System health issues
   - Performance anomalies

C++ REALTIME DASHBOARD:
-----------------------

class RealtimeDashboard {
private:
    struct DashboardState {
        double current_pnl;
        double high_water_mark;
        double max_drawdown;
        std::map<std::string, int> positions;
        double total_notional;
        double fill_rate_1h;
        int trades_1h;
        double sharpe_ratio_daily;
        double spread_capture_1h;
        double adverse_selection_ratio_1h;
        double var_95;
        std::vector<std::string> active_alerts;
        uint64_t last_update_time;
    };

    DashboardState state_;
    std::deque<double> pnl_history_;  // For chart

public:
    void update(const KPITracker& kpi_tracker,
               const PositionLimitManager& pos_manager,
               const PnLLimitMonitor& pnl_monitor,
               const CircuitBreakerSystem& circuit_breakers) {
        // Update timestamp
        state_.last_update_time = getCurrentTime();

        // Update P&L
        // state_.current_pnl = ...
        // pnl_history_.push_back(state_.current_pnl);
        // if (pnl_history_.size() > 1000) pnl_history_.pop_front();

        // Update alerts
        state_.active_alerts.clear();
        if (pnl_monitor.shouldStopTrading()) {
            state_.active_alerts.push_back("P&L LIMIT BREACHED");
        }
        // ... add other alerts
    }

    std::string generateTextReport() const {
        std::ostringstream oss;
        oss << "========== MARKET MAKING DASHBOARD ==========\n";
        oss << "Time: " << formatTime(state_.last_update_time) << "\n\n";

        oss << "P&L:\n";
        oss << "  Current: $" << std::fixed << std::setprecision(2)
            << state_.current_pnl << "\n";
        oss << "  High Water Mark: $" << state_.high_water_mark << "\n";
        oss << "  Max Drawdown: $" << state_.max_drawdown << "\n\n";

        oss << "Trading Activity (1h):\n";
        oss << "  Fill Rate: " << std::setprecision(1)
            << (state_.fill_rate_1h * 100) << "%\n";
        oss << "  Trades: " << state_.trades_1h << "\n";
        oss << "  Spread Capture: " << (state_.spread_capture_1h * 100) << "%\n\n";

        oss << "Risk Metrics:\n";
        oss << "  Sharpe Ratio: " << std::setprecision(2)
            << state_.sharpe_ratio_daily << "\n";
        oss << "  VaR (95%): $" << state_.var_95 << "\n\n";

        if (!state_.active_alerts.empty()) {
            oss << "ALERTS:\n";
            for (const auto& alert : state_.active_alerts) {
                oss << "  ⚠ " << alert << "\n";
            }
        }

        oss << "=============================================\n";
        return oss.str();
    }

private:
    uint64_t getCurrentTime() const {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()
        ).count();
    }

    std::string formatTime(uint64_t nanos) const {
        auto t = std::chrono::system_clock::now();
        std::time_t tt = std::chrono::system_clock::to_time_t(t);
        return std::ctime(&tt);
    }
};

================================================================================
PERFORMANCE BENCHMARKS
================================================================================

Tier 1 Market Maker (Top Performer):
- Sharpe Ratio: > 3.5 daily
- Net Margin: > 50%
- Fill Rate: 80-85%
- Spread Capture: > 75%
- Win Rate: 48-52%
- Inventory Turnover: > 40/day
- ROC: > 100% annually

Tier 2 Market Maker (Above Average):
- Sharpe Ratio: 2.5-3.5 daily
- Net Margin: 40-50%
- Fill Rate: 70-80%
- Spread Capture: 65-75%
- Win Rate: 47-53%
- Inventory Turnover: 25-40/day
- ROC: 60-100% annually

Tier 3 Market Maker (Average):
- Sharpe Ratio: 1.5-2.5 daily
- Net Margin: 30-40%
- Fill Rate: 60-70%
- Spread Capture: 55-65%
- Win Rate: 45-55%
- Inventory Turnover: 15-25/day
- ROC: 30-60% annually

Optimization Priorities by Tier:
Tier 3 → Tier 2: Reduce adverse selection, improve fill rate
Tier 2 → Tier 1: Optimize rebates, perfect inventory management
Tier 1: Marginal improvements, scaling, new instruments

Next: Read 11_mm_implementation.txt for complete system implementation.

================================================================================
END OF MARKET MAKING ANALYTICS
================================================================================
