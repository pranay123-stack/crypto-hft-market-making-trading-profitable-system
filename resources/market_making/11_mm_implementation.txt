================================================================================
COMPLETE MARKET MAKER IMPLEMENTATION IN C++
================================================================================

File: 11_mm_implementation.txt
Purpose: Production-ready market making system implementation
Topics: Architecture, data structures, algorithms, optimization
Last Updated: 2025-11-26

TABLE OF CONTENTS:
1. System Architecture
2. Core Data Structures
3. Market Data Processing
4. Signal Generation
5. Quote Generation Engine
6. Order Management
7. Risk Management Integration
8. P&L Tracking
9. Performance Optimization
10. Complete Implementation

================================================================================
1. SYSTEM ARCHITECTURE
================================================================================

HIGH-LEVEL COMPONENTS:
----------------------

┌─────────────────────────────────────────────────────────────┐
│                   Market Data Feed Handler                   │
│              (TCP/UDP, Multicast, FIX Protocol)              │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                  Order Book Manager                          │
│        (L2/L3 Data, Maintains current state)                 │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                 Signal Generator                             │
│   (Fair Value, Volatility, Imbalance, Toxicity)             │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                Quote Generation Engine                       │
│       (Spread Calc, Size Opt, Placement Strategy)           │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│               Risk Management Layer                          │
│         (Position Limits, P&L Limits, Circuit Breakers)      │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              Order Management System                         │
│            (Order Lifecycle, Execution Tracking)             │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                Exchange Gateway                              │
│                  (FIX, Binary Protocol)                      │
└─────────────────────────────────────────────────────────────┘

THREAD MODEL:
-------------

Main Trading Thread (CPU 0, isolated):
- Market data processing
- Signal generation
- Quote generation
- Order submission
- Target latency: < 20μs end-to-end

Risk Thread (CPU 1):
- Risk checks
- Position monitoring
- P&L updates
- Alert generation

Analytics Thread (CPU 2, low priority):
- Metrics collection
- Dashboard updates
- Logging

I/O Thread (CPU 3):
- Network handling
- File I/O
- External communications

================================================================================
2. CORE DATA STRUCTURES
================================================================================

// Ultra-low latency order book
class OrderBook {
public:
    static constexpr int MAX_LEVELS = 10;

    struct PriceLevel {
        double price;
        int32_t size;
        uint16_t num_orders;
        uint8_t __padding[6];  // Cache line alignment
    } __attribute__((packed));

    struct Book {
        PriceLevel bids[MAX_LEVELS];
        PriceLevel asks[MAX_LEVELS];
        uint8_t num_bid_levels;
        uint8_t num_ask_levels;
        uint64_t last_update_time;
        uint64_t sequence_number;
    } __attribute__((aligned(64)));  // Cache line aligned

private:
    Book book_;

public:
    void updateBid(int level, double price, int32_t size, uint16_t num_orders) {
        if (level < MAX_LEVELS) {
            book_.bids[level] = {price, size, num_orders, {0}};
            book_.num_bid_levels = std::max(book_.num_bid_levels, static_cast<uint8_t>(level + 1));
        }
    }

    void updateAsk(int level, double price, int32_t size, uint16_t num_orders) {
        if (level < MAX_LEVELS) {
            book_.asks[level] = {price, size, num_orders, {0}};
            book_.num_ask_levels = std::max(book_.num_ask_levels, static_cast<uint8_t>(level + 1));
        }
    }

    inline double getBestBid() const { return book_.bids[0].price; }
    inline double getBestAsk() const { return book_.asks[0].price; }
    inline int32_t getBidSize() const { return book_.bids[0].size; }
    inline int32_t getAskSize() const { return book_.asks[0].size; }

    inline double getMid() const {
        return (getBestBid() + getBestAsk()) * 0.5;
    }

    inline double getMicroprice() const {
        int32_t bid_sz = getBidSize();
        int32_t ask_sz = getAskSize();
        int32_t total = bid_sz + ask_sz;
        if (total == 0) return getMid();
        return (getBestBid() * ask_sz + getBestAsk() * bid_sz) / total;
    }

    double calculateImbalance(int levels = 5) const {
        int64_t bid_vol = 0, ask_vol = 0;
        int n_bids = std::min(levels, static_cast<int>(book_.num_bid_levels));
        int n_asks = std::min(levels, static_cast<int>(book_.num_ask_levels));

        for (int i = 0; i < n_bids; ++i) bid_vol += book_.bids[i].size;
        for (int i = 0; i < n_asks; ++i) ask_vol += book_.asks[i].size;

        int64_t total = bid_vol + ask_vol;
        return (total > 0) ? static_cast<double>(bid_vol - ask_vol) / total : 0.0;
    }
};

// Position tracker
class PositionTracker {
private:
    int32_t position_;
    double avg_entry_price_;
    double realized_pnl_;
    double unrealized_pnl_;
    int64_t total_volume_;

public:
    PositionTracker() : position_(0), avg_entry_price_(0), realized_pnl_(0),
                        unrealized_pnl_(0), total_volume_(0) {}

    void addFill(int32_t size, double price, bool is_buy) {
        int32_t signed_size = is_buy ? size : -size;

        if ((position_ > 0 && signed_size < 0) || (position_ < 0 && signed_size > 0)) {
            // Closing or reducing position - realize P&L
            int32_t closing_size = std::min(std::abs(signed_size), std::abs(position_));
            double pnl = closing_size * (position_ > 0 ? (price - avg_entry_price_) :
                                                         (avg_entry_price_ - price));
            realized_pnl_ += pnl;
        }

        // Update position
        int32_t old_position = position_;
        position_ += signed_size;

        // Update average entry price
        if (old_position == 0) {
            avg_entry_price_ = price;
        } else if ((old_position > 0 && signed_size > 0) || (old_position < 0 && signed_size < 0)) {
            // Adding to position
            int32_t abs_old = std::abs(old_position);
            int32_t abs_new = std::abs(position_);
            avg_entry_price_ = (avg_entry_price_ * abs_old + price * std::abs(signed_size)) / abs_new;
        }

        total_volume_ += std::abs(signed_size);
    }

    void updateUnrealizedPnL(double current_price) {
        if (position_ == 0) {
            unrealized_pnl_ = 0.0;
        } else if (position_ > 0) {
            unrealized_pnl_ = position_ * (current_price - avg_entry_price_);
        } else {
            unrealized_pnl_ = -position_ * (avg_entry_price_ - current_price);
        }
    }

    inline int32_t getPosition() const { return position_; }
    inline double getRealizedPnL() const { return realized_pnl_; }
    inline double getUnrealizedPnL() const { return unrealized_pnl_; }
    inline double getTotalPnL() const { return realized_pnl_ + unrealized_pnl_; }
    inline int64_t getTotalVolume() const { return total_volume_; }
};

================================================================================
3. COMPLETE MARKET MAKER CLASS
================================================================================

class HighFrequencyMarketMaker {
private:
    // Configuration
    struct Config {
        std::string symbol;
        double tick_size;
        int base_quote_size;
        int max_position;
        double base_spread;
        double risk_aversion;
        double maker_rebate;
        double taker_fee;
    } config_;

    // State
    OrderBook order_book_;
    PositionTracker position_;

    // Components
    FairValueCalculator fair_value_calc_;
    AdaptiveSpreadCalculator spread_calc_;
    QuoteSizeOptimizer size_optimizer_;
    AdverseSelectionProtector as_protector_;
    PositionLimitManager limit_manager_;
    PnLLimitMonitor pnl_monitor_;
    CircuitBreakerSystem circuit_breakers_;

    // Performance
    uint64_t last_quote_time_;
    uint64_t quote_count_;
    uint64_t fill_count_;

public:
    HighFrequencyMarketMaker(const Config& config)
        : config_(config)
        , fair_value_calc_()
        , spread_calc_(config.base_spread, 10.0, 0.5, 0.2)
        , size_optimizer_(config.base_quote_size, 100, 2000)
        , as_protector_(50000, 50)
        , limit_manager_(1000000, 10000000)
        , pnl_monitor_(1000000)
        , circuit_breakers_(pnl_monitor_, limit_manager_)
        , last_quote_time_(0)
        , quote_count_(0)
        , fill_count_(0) {

        limit_manager_.setSymbolLimit(config.symbol, config.max_position,
                                      100.0, 1000000);
    }

    // Main event loop - called on every market data update
    void onMarketData(const OrderBook& new_book, uint64_t timestamp) {
        // Update order book
        order_book_ = new_book;

        // Check if we should update quotes
        if (!shouldUpdateQuotes(timestamp)) {
            return;
        }

        // Generate signals
        double fair_value = calculateFairValue();
        double volatility = estimateVolatility();
        double order_imbalance = order_book_.calculateImbalance();

        // Calculate spread
        double spread = spread_calc_.calculateSpread(
            volatility, 0.02,  // avg vol
            position_.getPosition(), config_.max_position,
            order_imbalance, 0.0
        );

        // Calculate size
        int bid_size = size_optimizer_.calculateOptimalSize(
            position_.getPosition(), config_.max_position,
            volatility, 0.02, 0.3  // toxicity estimate
        );
        int ask_size = bid_size;

        // Adjust for inventory
        if (position_.getPosition() > 0) {
            ask_size = config_.base_quote_size;
            bid_size = config_.base_quote_size / 2;
        } else if (position_.getPosition() < 0) {
            bid_size = config_.base_quote_size;
            ask_size = config_.base_quote_size / 2;
        }

        // Calculate skew
        double skew = -0.005 * position_.getPosition() / config_.max_position;

        // Generate quotes
        double bid_price = fair_value - spread / 2.0 + skew;
        double ask_price = fair_value + spread / 2.0 + skew;

        // Align to tick
        bid_price = std::floor(bid_price / config_.tick_size) * config_.tick_size;
        ask_price = std::ceil(ask_price / config_.tick_size) * config_.tick_size;

        // Risk checks
        std::string rejection_reason;
        if (!limit_manager_.checkOrderAllowed(config_.symbol, bid_size,
                                             bid_price, rejection_reason)) {
            // Can't quote bid
            bid_size = 0;
        }

        if (!limit_manager_.checkOrderAllowed(config_.symbol, -ask_size,
                                             ask_price, rejection_reason)) {
            // Can't quote ask
            ask_size = 0;
        }

        // Circuit breaker check
        auto action = circuit_breakers_.checkAll(
            position_.getTotalPnL(), 0.0, 75, 50
        );

        if (action == CircuitBreakerSystem::Action::FLATTEN_POSITIONS) {
            // Emergency: flatten everything
            cancelAllOrders();
            return;
        } else if (action == CircuitBreakerSystem::Action::STOP_NEW_ORDERS) {
            // Stop quoting
            cancelAllOrders();
            return;
        }

        // Submit quotes
        if (bid_size > 0 && ask_size > 0) {
            submitQuotes(bid_price, bid_size, ask_price, ask_size, timestamp);
        }

        last_quote_time_ = timestamp;
        quote_count_++;
    }

    void onFill(int32_t size, double price, bool is_buy, uint64_t timestamp) {
        // Update position
        position_.addFill(size, price, is_buy);

        // Update unrealized P&L
        position_.updateUnrealizedPnL(order_book_.getMid());

        // Update P&L monitor
        pnl_monitor_.updatePnL(position_.getRealizedPnL(),
                              position_.getUnrealizedPnL());

        // Record fill for analytics
        fill_count_++;

        // Check if need immediate hedge
        if (std::abs(position_.getPosition()) > config_.max_position * 0.8) {
            // Consider hedging
            initiateHedge();
        }
    }

private:
    double calculateFairValue() const {
        return fair_value_calc_.calculateMicroprice(
            order_book_.getBestBid(), order_book_.getBidSize(),
            order_book_.getBestAsk(), order_book_.getAskSize()
        );
    }

    double estimateVolatility() const {
        // Simplified - in production use proper vol estimator
        return 0.02;  // 2% daily vol
    }

    bool shouldUpdateQuotes(uint64_t current_time) const {
        // Rate limiting: update at most every 1ms
        if (current_time - last_quote_time_ < 1'000'000) {
            return false;
        }

        // Always update if no quotes active
        if (last_quote_time_ == 0) {
            return true;
        }

        // Update if fair value moved significantly
        double old_fv = calculateFairValue();  // Would cache this
        double new_fv = order_book_.getMid();
        if (std::abs(new_fv - old_fv) > config_.tick_size) {
            return true;
        }

        // Update if aged out (5 seconds)
        if (current_time - last_quote_time_ > 5'000'000'000) {
            return true;
        }

        return false;
    }

    void submitQuotes(double bid_price, int bid_size,
                     double ask_price, int ask_size,
                     uint64_t timestamp) {
        // In production: send FIX messages or binary protocol
        // This is a stub
    }

    void cancelAllOrders() {
        // In production: send cancel messages
        // This is a stub
    }

    void initiateHedge() {
        // In production: execute hedging strategy
        // Could use futures, ETFs, or opposite side trades
    }
};

================================================================================
4. PERFORMANCE OPTIMIZATION TECHNIQUES
================================================================================

OPTIMIZATION 1: CACHE-FRIENDLY DATA STRUCTURES
-----------------------------------------------

// Align to cache line (64 bytes)
struct __attribute__((aligned(64))) HotPathData {
    double fair_value;
    double spread;
    int32_t position;
    uint32_t sequence;
    uint64_t timestamp;
    // ... other frequently accessed data
    uint8_t padding[24];  // Pad to 64 bytes
};

OPTIMIZATION 2: BRANCH PREDICTION
----------------------------------

// Use likely/unlikely macros
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)

if (likely(price > 0 && size > 0)) {
    // Common path
} else {
    // Rare path
}

OPTIMIZATION 3: SIMD FOR CALCULATIONS
--------------------------------------

#include <immintrin.h>

void calculateWeightedPrices(const double* prices, const int* sizes,
                             double* results, int n) {
    for (int i = 0; i < n; i += 4) {
        __m256d p = _mm256_loadu_pd(&prices[i]);
        __m256d s = _mm256_cvtepi32_pd(_mm_loadu_si128((__m128i*)&sizes[i]));
        __m256d r = _mm256_mul_pd(p, s);
        _mm256_storeu_pd(&results[i], r);
    }
}

OPTIMIZATION 4: LOCK-FREE DATA STRUCTURES
------------------------------------------

template<typename T>
class LockFreeQueue {
private:
    struct Node {
        T data;
        std::atomic<Node*> next;
    };

    std::atomic<Node*> head_;
    std::atomic<Node*> tail_;

public:
    void push(const T& value) {
        Node* new_node = new Node{value, nullptr};
        Node* old_tail = tail_.exchange(new_node);
        old_tail->next.store(new_node);
    }

    bool pop(T& result) {
        Node* old_head = head_.load();
        Node* next = old_head->next.load();
        if (next == nullptr) return false;
        result = next->data;
        head_.store(next);
        delete old_head;
        return true;
    }
};

OPTIMIZATION 5: MEMORY POOL
----------------------------

class OrderPool {
private:
    static constexpr int POOL_SIZE = 10000;
    struct Order { /* ... */ };
    Order pool_[POOL_SIZE];
    std::stack<Order*> free_list_;

public:
    OrderPool() {
        for (int i = 0; i < POOL_SIZE; ++i) {
            free_list_.push(&pool_[i]);
        }
    }

    Order* allocate() {
        if (free_list_.empty()) return nullptr;
        Order* order = free_list_.top();
        free_list_.pop();
        return order;
    }

    void deallocate(Order* order) {
        free_list_.push(order);
    }
};

================================================================================
PERFORMANCE TARGETS
================================================================================

Latency (99th percentile):
- Market data to signal: < 1μs
- Signal to quote generation: < 2μs
- Quote generation to risk check: < 1μs
- Risk check to order submission: < 1μs
- Total end-to-end: < 10μs

Throughput:
- Market data messages: > 1M/sec
- Quote updates: > 100K/sec
- Risk checks: > 1M/sec

Memory:
- Hot path data: < 1KB (fits in L1 cache)
- Order book: < 8KB (fits in L2 cache)
- Total system: < 100MB

CPU Utilization:
- Main thread: 60-80%
- Risk thread: 10-20%
- Analytics: < 5%

Next: Read 12_mm_optimization.txt for parameter tuning and ML optimization.

================================================================================
END OF IMPLEMENTATION
================================================================================
