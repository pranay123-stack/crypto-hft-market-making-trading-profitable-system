================================================================================
MARKET MAKING STRATEGIES
================================================================================

File: 05_mm_strategies.txt
Purpose: Different market making approaches and strategy selection
Topics: Passive, aggressive, hybrid strategies, parameter optimization
Last Updated: 2025-11-26

================================================================================
TABLE OF CONTENTS
================================================================================

1. Strategy Classification Overview
2. Passive Market Making
3. Aggressive Market Making
4. Hybrid Strategies
5. Liquidity Rebate Strategies
6. Market-Neutral Strategies
7. Directional Market Making
8. Statistical Arbitrage Market Making
9. Strategy Selection and Switching
10. C++ Strategy Framework

================================================================================
1. STRATEGY CLASSIFICATION OVERVIEW
================================================================================

Market making strategies can be classified along several dimensions:

AGGRESSIVENESS SPECTRUM:
------------------------

Passive ←───────────────────────────────→ Aggressive

Passive:
- Post orders away from touch
- Earn wider spreads
- Lower fill rate
- Less adverse selection

Aggressive:
- Post at or inside touch
- Earn narrower spreads
- Higher fill rate
- Higher adverse selection

DIRECTIONAL BIAS:
-----------------

Market Neutral ←────────────────────→ Directional

Market Neutral:
- Target position: 0
- Pure spread capture
- Minimize inventory risk

Directional:
- Allow position accumulation
- Benefit from price trends
- Accept directional risk

TIMING:
-------

Continuous ←────────────────────→ Episodic

Continuous:
- Always in market
- Constant liquidity provision
- May have obligations

Episodic:
- Selective participation
- Trade during favorable conditions
- No obligations

STRATEGY PERFORMANCE COMPARISON:
---------------------------------

Strategy      | Sharpe | Fill Rate | Spread | AS Risk | Capital
--------------|--------|-----------|--------|---------|----------
Passive       | 3.0    | 60%       | Wide   | Low     | Medium
Aggressive    | 2.5    | 90%       | Narrow | High    | High
Hybrid        | 3.5    | 75%       | Medium | Medium  | Medium
Rebate-Focused| 2.8    | 85%       | Narrow | Medium  | High
Directional   | 3.2    | 70%       | Medium | Medium  | Medium

================================================================================
2. PASSIVE MARKET MAKING
================================================================================

CORE PRINCIPLES:
----------------

1. Post orders away from best bid/ask
2. Earn wider spreads
3. Lower fill frequency
4. Better adverse selection protection
5. Longer holding periods

TYPICAL PARAMETERS:
-------------------

Distance from touch: 2-5 ticks
Quote size: Large (500-2000 shares)
Update frequency: Low (1-10 seconds)
Inventory target: Neutral (0)
Max position: Conservative (0.5% ADV)

ADVANTAGES:
-----------

+ Lower adverse selection risk
+ Wider profit margins per trade
+ Less competition
+ Lower messaging costs
+ More stable P&L

DISADVANTAGES:
--------------

- Lower fill rates
- Slower inventory turnover
- Less volume
- May miss opportunities
- Capital underutilization

WHEN TO USE:
------------

- High-volatility environments
- Stocks with high information asymmetry
- When adverse selection is elevated
- During news events
- Illiquid securities

C++ PASSIVE MARKET MAKER:
--------------------------

class PassiveMarketMaker {
private:
    // Configuration
    int ticks_away_from_touch_;
    int quote_size_;
    double min_spread_;
    double tick_size_;

public:
    PassiveMarketMaker(int ticks_away, int quote_size,
                      double min_spread, double tick_size)
        : ticks_away_from_touch_(ticks_away)
        , quote_size_(quote_size)
        , min_spread_(min_spread)
        , tick_size_(tick_size) {}

    struct PassiveQuote {
        double bid_price;
        double ask_price;
        int bid_size;
        int ask_size;
        double expected_spread;
    };

    PassiveQuote generateQuote(double best_bid,
                              double best_ask,
                              double fair_value,
                              int position,
                              int max_position) const {
        PassiveQuote quote;

        // Calculate base prices (away from touch)
        double distance = ticks_away_from_touch_ * tick_size_;
        quote.bid_price = best_bid - distance;
        quote.ask_price = best_ask + distance;

        // Ensure minimum spread
        double current_spread = quote.ask_price - quote.bid_price;
        if (current_spread < min_spread_) {
            double mid = (quote.bid_price + quote.ask_price) / 2.0;
            quote.bid_price = mid - min_spread_ / 2.0;
            quote.ask_price = mid + min_spread_ / 2.0;
        }

        // Adjust for inventory (light skewing)
        double skew = -0.2 * (static_cast<double>(position) / max_position) *
                     tick_size_;
        quote.bid_price += skew;
        quote.ask_price += skew;

        // Determine sizes
        quote.bid_size = quote_size_;
        quote.ask_size = quote_size_;

        // Reduce size if position is large
        double pos_ratio = std::abs(static_cast<double>(position)) / max_position;
        if (pos_ratio > 0.5) {
            double size_factor = 1.0 - 0.5 * (pos_ratio - 0.5);
            quote.bid_size = static_cast<int>(quote_size_ * size_factor);
            quote.ask_size = static_cast<int>(quote_size_ * size_factor);
        }

        quote.expected_spread = quote.ask_price - quote.bid_price;

        return quote;
    }

    // Calculate expected profit per quote cycle
    double calculateExpectedProfit(const PassiveQuote& quote,
                                  double fill_probability) const {
        // Expected profit = P(both fill) × Spread - P(one fill) × Risk
        double spread_profit = quote.expected_spread * quote_size_;
        double expected_profit = fill_probability * fill_probability *
                                spread_profit;

        // Discount for one-sided fills (inventory risk)
        double one_sided_prob = 2 * fill_probability * (1 - fill_probability);
        double inventory_risk = 0.02 * quote_size_;  // Risk cost
        expected_profit -= one_sided_prob * inventory_risk;

        return expected_profit;
    }

    // Decide whether to quote based on conditions
    bool shouldQuote(double volatility,
                    double avg_volatility,
                    double toxicity,
                    int position,
                    int max_position) const {
        // Don't quote in extreme volatility
        if (volatility > 2.0 * avg_volatility) {
            return false;
        }

        // Don't quote with high toxicity
        if (toxicity > 0.7) {
            return false;
        }

        // Don't quote at position limits
        if (std::abs(position) > 0.9 * max_position) {
            return false;
        }

        return true;
    }
};

================================================================================
3. AGGRESSIVE MARKET MAKING
================================================================================

CORE PRINCIPLES:
----------------

1. Post at or inside best bid/ask
2. Penny jump competitors
3. Maximize fill rate
4. High inventory turnover
5. Tight spreads

TYPICAL PARAMETERS:
-------------------

Distance from touch: 0 to +1 tick (inside)
Quote size: Moderate (100-500 shares)
Update frequency: Very high (milliseconds)
Inventory target: Neutral but flexible
Max position: Larger (1-2% ADV)

ADVANTAGES:
-----------

+ High fill rates (80-95%)
+ High inventory turnover
+ Maximum volume
+ Better rebate capture
+ Efficient capital usage

DISADVANTAGES:
--------------

- Higher adverse selection
- Narrow profit margins
- High competition
- High messaging costs
- Requires ultra-low latency

WHEN TO USE:
------------

- Low-volatility environments
- Highly liquid securities
- Maker-taker fee structures
- When spreads are wide
- Low information asymmetry

C++ AGGRESSIVE MARKET MAKER:
-----------------------------

class AggressiveMarketMaker {
private:
    double tick_size_;
    int base_quote_size_;
    uint64_t min_update_interval_ns_;
    uint64_t last_update_time_;

public:
    AggressiveMarketMaker(double tick_size, int base_size)
        : tick_size_(tick_size)
        , base_quote_size_(base_size)
        , min_update_interval_ns_(1'000'000)  // 1ms
        , last_update_time_(0) {}

    struct AggressiveQuote {
        double bid_price;
        double ask_price;
        int bid_size;
        int ask_size;
        bool is_inside;  // Inside current touch
    };

    AggressiveQuote generateQuote(double best_bid,
                                 double best_ask,
                                 double fair_value,
                                 int best_bid_size,
                                 int best_ask_size,
                                 int position,
                                 int max_position) const {
        AggressiveQuote quote;

        // Default: at-the-touch
        quote.bid_price = best_bid;
        quote.ask_price = best_ask;
        quote.is_inside = false;

        // Calculate current spread
        double current_spread = best_ask - best_bid;

        // If spread is wide (> 2 ticks), go inside
        if (current_spread > 2 * tick_size_) {
            quote.bid_price = best_bid + tick_size_;
            quote.ask_price = best_ask - tick_size_;
            quote.is_inside = true;
        }

        // Adjust for inventory with aggressive skewing
        double skew_factor = 1.0;
        double pos_ratio = static_cast<double>(position) / max_position;

        if (position > max_position * 0.5) {
            // Large long position: very aggressive on ask
            quote.ask_price = best_ask - tick_size_;
            quote.bid_price = best_bid - tick_size_;
            skew_factor = 2.0;
        } else if (position < -max_position * 0.5) {
            // Large short position: very aggressive on bid
            quote.bid_price = best_bid + tick_size_;
            quote.ask_price = best_ask + tick_size_;
            skew_factor = 2.0;
        }

        // Size determination
        quote.bid_size = base_quote_size_;
        quote.ask_size = base_quote_size_;

        // Adjust sizes based on position
        if (position > 0) {
            // Long: large ask size, small bid size
            quote.ask_size = static_cast<int>(base_quote_size_ * skew_factor);
            quote.bid_size = base_quote_size_ / 2;
        } else if (position < 0) {
            // Short: large bid size, small ask size
            quote.bid_size = static_cast<int>(base_quote_size_ * skew_factor);
            quote.ask_size = base_quote_size_ / 2;
        }

        return quote;
    }

    // Fast quote update decision
    bool shouldUpdateQuote(double new_fair_value,
                          double old_fair_value,
                          double best_bid,
                          double best_ask,
                          double our_bid,
                          double our_ask,
                          uint64_t current_time) {
        // Rate limiting
        if (current_time - last_update_time_ < min_update_interval_ns_) {
            return false;
        }

        // Update if fair value moved significantly
        if (std::abs(new_fair_value - old_fair_value) > tick_size_ * 0.5) {
            last_update_time_ = current_time;
            return true;
        }

        // Update if we're no longer at the touch
        if (our_bid < best_bid || our_ask > best_ask) {
            last_update_time_ = current_time;
            return true;
        }

        // Update if someone jumped us
        if (best_bid > our_bid || best_ask < our_ask) {
            last_update_time_ = current_time;
            return true;
        }

        return false;
    }

    // Calculate profitability with rebates
    double calculateProfitability(double spread,
                                 double maker_rebate,
                                 double taker_fee,
                                 double adverse_selection_cost) const {
        // Revenue per share
        double revenue = spread / 2.0 + maker_rebate;

        // Costs
        double costs = adverse_selection_cost;

        // Net profit per share
        return revenue - costs;
    }
};

================================================================================
4. HYBRID STRATEGIES
================================================================================

Combine passive and aggressive approaches based on market conditions.

ADAPTIVE HYBRID:
----------------

Switch between passive and aggressive based on:
- Volatility regime
- Spread width
- Position
- Time of day
- Toxicity

C++ HYBRID MARKET MAKER:
-------------------------

class HybridMarketMaker {
private:
    PassiveMarketMaker passive_mm_;
    AggressiveMarketMaker aggressive_mm_;

    enum class Mode {
        PASSIVE,
        AGGRESSIVE,
        MIXED
    };

public:
    HybridMarketMaker(const PassiveMarketMaker& passive,
                     const AggressiveMarketMaker& aggressive)
        : passive_mm_(passive)
        , aggressive_mm_(aggressive) {}

    struct HybridQuote {
        double bid_price;
        double ask_price;
        int bid_size;
        int ask_size;
        Mode mode_used;
    };

    HybridQuote generateQuote(const MarketState& market,
                             int position,
                             int max_position) {
        HybridQuote quote;

        // Determine mode based on conditions
        Mode mode = selectMode(market, position, max_position);

        quote.mode_used = mode;

        switch (mode) {
            case Mode::PASSIVE: {
                auto pq = passive_mm_.generateQuote(
                    market.best_bid, market.best_ask, market.fair_value,
                    position, max_position
                );
                quote.bid_price = pq.bid_price;
                quote.ask_price = pq.ask_price;
                quote.bid_size = pq.bid_size;
                quote.ask_size = pq.ask_size;
                break;
            }

            case Mode::AGGRESSIVE: {
                auto aq = aggressive_mm_.generateQuote(
                    market.best_bid, market.best_ask, market.fair_value,
                    market.bid_size, market.ask_size,
                    position, max_position
                );
                quote.bid_price = aq.bid_price;
                quote.ask_price = aq.ask_price;
                quote.bid_size = aq.bid_size;
                quote.ask_size = aq.ask_size;
                break;
            }

            case Mode::MIXED: {
                // Aggressive on one side, passive on other
                auto aq = aggressive_mm_.generateQuote(
                    market.best_bid, market.best_ask, market.fair_value,
                    market.bid_size, market.ask_size,
                    position, max_position
                );
                auto pq = passive_mm_.generateQuote(
                    market.best_bid, market.best_ask, market.fair_value,
                    position, max_position
                );

                if (position > 0) {
                    // Long: aggressive ask, passive bid
                    quote.ask_price = aq.ask_price;
                    quote.ask_size = aq.ask_size;
                    quote.bid_price = pq.bid_price;
                    quote.bid_size = pq.bid_size;
                } else {
                    // Short: aggressive bid, passive ask
                    quote.bid_price = aq.bid_price;
                    quote.bid_size = aq.bid_size;
                    quote.ask_price = pq.ask_price;
                    quote.ask_size = pq.ask_size;
                }
                break;
            }
        }

        return quote;
    }

private:
    Mode selectMode(const MarketState& market,
                   int position,
                   int max_position) const {
        double spread = market.best_ask - market.best_bid;
        double pos_ratio = std::abs(static_cast<double>(position)) / max_position;
        double vol_ratio = market.volatility / market.avg_volatility;

        // Use passive mode in high volatility
        if (vol_ratio > 1.5 || market.toxicity > 0.6) {
            return Mode::PASSIVE;
        }

        // Use mixed mode with large position
        if (pos_ratio > 0.6) {
            return Mode::MIXED;
        }

        // Use aggressive mode in tight spreads and low vol
        if (spread < 3 * market.tick_size && vol_ratio < 1.2) {
            return Mode::AGGRESSIVE;
        }

        // Default to mixed
        return Mode::MIXED;
    }
};

================================================================================
5. LIQUIDITY REBATE STRATEGIES
================================================================================

Optimize for exchange rebates in maker-taker fee structures.

REBATE-FOCUSED STRATEGY:
-------------------------

Objective: Maximize maker rebates while maintaining profitability

Key Principles:
1. Post large sizes to capture more rebates
2. Accept narrower spreads
3. High fill rate target
4. Minimize taker fees

Profitability:
Net = Rebate + Spread/2 - Adverse_Selection - Taker_Fees

Example:
Rebate: $0.0020/share
Spread captured: $0.01/share
Adverse selection: -$0.008/share
Net: $0.0020 + $0.005 - $0.008 = -$0.001 per share

But with volume:
10M shares/day × (-$0.001) = -$10,000/day

Not profitable! Need better:
- Spread capture: $0.015/share
- Lower adverse selection: -$0.006/share
- Net: $0.0020 + $0.0075 - $0.006 = $0.0035/share
- 10M shares × $0.0035 = $35,000/day profit

C++ REBATE OPTIMIZER:
---------------------

class RebateOptimizingMarketMaker {
private:
    double maker_rebate_per_share_;
    double taker_fee_per_share_;
    double target_net_per_share_;

public:
    RebateOptimizingMarketMaker(double maker_rebate, double taker_fee)
        : maker_rebate_per_share_(maker_rebate)
        , taker_fee_per_share_(taker_fee)
        , target_net_per_share_(0.002) {}

    struct RebateQuote {
        double bid_price;
        double ask_price;
        int bid_size;
        int ask_size;
        double expected_rebate;
        double expected_net;
    };

    RebateQuote generateQuote(double fair_value,
                             double best_bid,
                             double best_ask,
                             double expected_adverse_selection,
                             double fill_probability) const {
        RebateQuote quote;

        // Target spread to hit profitability
        // Net = Rebate + Spread/2 - AS
        // Spread = 2 × (Target_Net - Rebate + AS)
        double required_spread = 2.0 * (target_net_per_share_ -
                                       maker_rebate_per_share_ +
                                       expected_adverse_selection);

        // Ensure minimum spread
        required_spread = std::max(required_spread, 0.01);

        // Post at touch to maximize fill rate
        quote.bid_price = best_bid;
        quote.ask_price = best_ask;

        // But ensure we get required spread
        double current_spread = best_ask - best_bid;
        if (current_spread < required_spread) {
            // Widen from fair value
            quote.bid_price = fair_value - required_spread / 2.0;
            quote.ask_price = fair_value + required_spread / 2.0;
        }

        // Large sizes to maximize rebate capture
        int base_size = 1000;
        quote.bid_size = base_size;
        quote.ask_size = base_size;

        // Calculate expected values
        quote.expected_rebate = fill_probability * base_size *
                               maker_rebate_per_share_;

        double spread_revenue = fill_probability * base_size *
                               (quote.ask_price - quote.bid_price) / 2.0;
        double as_cost = fill_probability * base_size *
                        expected_adverse_selection;

        quote.expected_net = quote.expected_rebate + spread_revenue - as_cost;

        return quote;
    }

    // Calculate tier-based rebate (higher volume = higher rebate)
    double calculateTieredRebate(int64_t monthly_volume) const {
        if (monthly_volume < 1'000'000) {
            return 0.0015;  // Tier 1
        } else if (monthly_volume < 10'000'000) {
            return 0.0020;  // Tier 2
        } else if (monthly_volume < 100'000'000) {
            return 0.0025;  // Tier 3
        } else {
            return 0.0030;  // Tier 4
        }
    }

    // Optimize for reaching next tier
    bool shouldIncreaseVolumeForTier(int64_t current_monthly_volume,
                                    double current_sharpe) const {
        int64_t next_tier_threshold = 0;
        double next_tier_rebate = 0;

        if (current_monthly_volume < 1'000'000) {
            next_tier_threshold = 1'000'000;
            next_tier_rebate = 0.0020;
        } else if (current_monthly_volume < 10'000'000) {
            next_tier_threshold = 10'000'000;
            next_tier_rebate = 0.0025;
        } else {
            return false;  // Already at top tier
        }

        // Calculate benefit of reaching next tier
        int64_t remaining_volume = next_tier_threshold - current_monthly_volume;
        double rebate_increase = next_tier_rebate -
                                calculateTieredRebate(current_monthly_volume);

        // Benefit = Additional rebate × Remaining month volume
        int remaining_days = 20;  // Assume 20 trading days left
        int64_t daily_volume = current_monthly_volume / (250 / 12);  // Monthly to daily

        double monthly_benefit = rebate_increase * next_tier_threshold;

        // Cost = Reduced profitability from forcing more volume
        // Simple heuristic: Worth it if benefit > 10% of current daily P&L
        return monthly_benefit > 0.1 * daily_volume * target_net_per_share_;
    }
};

================================================================================
6. STATISTICAL ARBITRAGE MARKET MAKING
================================================================================

Combine market making with stat arb signals.

PRINCIPLES:
-----------

1. Use statistical models to predict short-term moves
2. Skew quotes in predicted direction
3. Allow controlled directional exposure
4. Hedge with correlated instruments

EXAMPLE SIGNALS:
----------------

- Mean reversion from fair value
- Pairs trading signals
- Index arbitrage opportunities
- Cross-venue arbitrage

C++ STAT ARB MARKET MAKER:
---------------------------

class StatArbMarketMaker {
private:
    double mean_reversion_half_life_;
    double signal_confidence_threshold_;

public:
    StatArbMarketMaker(double half_life, double confidence_threshold)
        : mean_reversion_half_life_(half_life)
        , signal_confidence_threshold_(confidence_threshold) {}

    struct StatArbSignal {
        double predicted_return;
        double confidence;
        int target_position;
    };

    StatArbSignal generateSignal(double current_price,
                                 double fair_value,
                                 double volatility) const {
        StatArbSignal signal;

        // Mean reversion signal
        double deviation = current_price - fair_value;
        double normalized_dev = deviation / volatility;

        // Predicted return to fair value
        signal.predicted_return = -normalized_dev * volatility;

        // Confidence based on deviation size
        signal.confidence = std::min(std::abs(normalized_dev) / 2.0, 1.0);

        // Target position
        if (signal.confidence > signal_confidence_threshold_) {
            // Size proportional to signal strength
            signal.target_position = static_cast<int>(
                -normalized_dev * 1000  // 1000 shares per std dev
            );
            signal.target_position = std::clamp(signal.target_position,
                                               -5000, 5000);
        } else {
            signal.target_position = 0;  // Market neutral
        }

        return signal;
    }

    struct StatArbQuote {
        double bid_price;
        double ask_price;
        int bid_size;
        int ask_size;
        int target_position;
    };

    StatArbQuote generateQuote(double fair_value,
                              double best_bid,
                              double best_ask,
                              int current_position,
                              const StatArbSignal& signal,
                              double base_spread) const {
        StatArbQuote quote;

        // Calculate spread with signal adjustment
        double spread = base_spread;

        // Skew quotes based on signal
        double skew = 0.3 * signal.predicted_return * signal.confidence;

        quote.bid_price = fair_value - spread/2 + skew;
        quote.ask_price = fair_value + spread/2 + skew;

        // Adjust sizes based on target position
        int position_diff = signal.target_position - current_position;

        if (position_diff > 0) {
            // Want to buy: larger bid, smaller ask
            quote.bid_size = 1000;
            quote.ask_size = 500;
        } else if (position_diff < 0) {
            // Want to sell: smaller bid, larger ask
            quote.bid_size = 500;
            quote.ask_size = 1000;
        } else {
            // At target: balanced
            quote.bid_size = 750;
            quote.ask_size = 750;
        }

        quote.target_position = signal.target_position;

        return quote;
    }
};

================================================================================
PERFORMANCE SUMMARY & BEST PRACTICES
================================================================================

Strategy Selection Guidelines:
-------------------------------

High Volatility → Passive
Low Volatility → Aggressive
Wide Spreads → Aggressive
Narrow Spreads → Passive
High Toxicity → Passive
Large Position → Hybrid (Mixed)
Near Close → Aggressive (unwind)
Maker-Taker Fees → Rebate-Focused

Performance Targets:
--------------------

Passive MM:
- Sharpe Ratio: > 3.0
- Fill Rate: 60-70%
- Spread Capture: > 75%

Aggressive MM:
- Sharpe Ratio: > 2.5
- Fill Rate: 85-95%
- Spread Capture: 50-65%

Hybrid MM:
- Sharpe Ratio: > 3.5
- Fill Rate: 75-85%
- Spread Capture: 65-75%

Next: Read 06_hedging_strategies.txt for portfolio risk management.

================================================================================
END OF MARKET MAKING STRATEGIES
================================================================================
