================================================================================
MARKET MAKING FUNDAMENTALS
================================================================================

File: 01_mm_fundamentals.txt
Purpose: Comprehensive guide to market making basics and theory
Topics: Spread earning, liquidity provision, market microstructure
Last Updated: 2025-11-26

================================================================================
TABLE OF CONTENTS
================================================================================

1. What is Market Making?
2. The Economics of Market Making
3. Bid-Ask Spread Dynamics
4. Market Microstructure Theory
5. Order Book Mechanics
6. Queue Position and Priority Rules
7. Price Discovery and Fair Value
8. Market Impact and Liquidity
9. Profit and Loss Mechanics
10. Key Performance Indicators
11. C++ Implementation Examples

================================================================================
1. WHAT IS MARKET MAKING?
================================================================================

Market making is a trading strategy where a firm (the market maker) continuously
provides liquidity by simultaneously posting buy (bid) and sell (ask) quotes in
a financial instrument. The market maker stands ready to trade with other market
participants, earning profits primarily from the bid-ask spread.

CORE CONCEPTS:
--------------

Bid Price: The price at which the market maker is willing to BUY
Ask Price: The price at which the market maker is willing to SELL
Spread: The difference between Ask and Bid (Ask - Bid)

Example:
--------
Stock XYZ trading at $100
Market Maker Posts:
- Bid: $99.95 for 1000 shares
- Ask: $100.05 for 1000 shares
- Spread: $0.10

If both orders fill:
- Buy 1000 @ $99.95 = -$99,950
- Sell 1000 @ $100.05 = +$100,050
- Gross Profit = $100

TYPES OF MARKET MAKERS:
-----------------------

1. Designated Market Makers (DMM)
   - Exchange-appointed with obligations
   - Required to maintain quotes
   - May receive rebates/incentives
   - Examples: NYSE specialists

2. High-Frequency Market Makers (HFMM)
   - Voluntary liquidity provision
   - Ultra-low latency systems
   - Multiple venues simultaneously
   - Examples: Citadel Securities, Virtu

3. Registered Market Makers
   - Registered with exchanges
   - May have reduced fees
   - Some minimum quoting obligations
   - Common in options markets

4. Wholesalers
   - Execute retail order flow
   - Payment for order flow (PFOF)
   - Compete with exchanges
   - Examples: Citadel, Virtu, Two Sigma

MARKET MAKING VS. OTHER STRATEGIES:
------------------------------------

Market Making:
- Provides liquidity (passive orders)
- Earns spread
- Short holding periods (seconds to minutes)
- Delta-neutral target
- High win rate, small profits per trade

Statistical Arbitrage:
- Takes liquidity (aggressive orders)
- Exploits mispricings
- Medium holding periods (hours to days)
- Directional bias
- Lower win rate, larger profits per trade

Momentum Trading:
- Takes liquidity
- Follows trends
- Variable holding periods
- Strongly directional
- Lower win rate, much larger profits

================================================================================
2. THE ECONOMICS OF MARKET MAKING
================================================================================

REVENUE SOURCES:
----------------

1. Bid-Ask Spread
   Primary revenue source
   Revenue = (Ask - Bid) × Volume / 2

   Assuming 50% fill on each side:
   Daily Revenue = Spread × Daily_Volume / 2

2. Exchange Rebates
   Maker-taker fee structure
   Rebate = $0.0015 - $0.0030 per share (typical)

   For 1M shares/day at $0.002 rebate:
   Daily Rebate Revenue = $2,000

3. Payment for Order Flow (retail market making)
   Wholesalers receive payment for executing retail orders
   Typical: $0.001 - $0.003 per share

4. Market Data Revenue (some DMMs)
   Compensation for data contributions

COST STRUCTURE:
---------------

1. Adverse Selection Costs
   Loss from trading with informed counterparties
   Estimated: 20-40% of spread revenue

   When informed trader buys:
   - MM sells at ask
   - Price moves up immediately
   - MM's short position loses money

2. Inventory Risk Costs
   Risk of holding positions
   Cost = Risk_Aversion × Volatility × Position²

   For position of 10,000 shares:
   - If stock drops $0.10: Loss = $1,000
   - Uncertainty cost proportional to σ² × q²

3. Exchange Fees
   Taker fees when removing liquidity
   Typical: $0.0030 per share

   If 20% of orders take liquidity:
   Daily Fee = 0.20 × Volume × $0.0030

4. Technology Costs
   - Colocation fees: $10K-$50K/month/venue
   - Market data: $50K-$500K/month
   - Infrastructure: $1M-$10M/year
   - Development: $500K-$5M/year/strategy

5. Regulatory and Compliance
   - Registration fees
   - Reporting requirements
   - Capital requirements
   - Legal and compliance staff

PROFITABILITY MODEL:
--------------------

Net P&L = Spread_Revenue + Rebates - Adverse_Selection - Inventory_Risk - Fees - Costs

Example: Single Stock Market Maker
-----------------------------------
Daily Volume: 1,000,000 shares
Average Spread: $0.02
Fill Rate: 75%
Adverse Selection: 30% of spread
Rebate: $0.002/share
Fee: $0.003/share (when taking)
Taker Ratio: 20%

Calculations:
Spread Revenue = ($0.02 / 2) × 1,000,000 × 0.75 = $7,500
Rebate Revenue = 1,000,000 × 0.80 × $0.002 = $1,600
Adverse Selection = $7,500 × 0.30 = -$2,250
Taker Fees = 1,000,000 × 0.20 × $0.003 = -$600
Net Daily P&L = $7,500 + $1,600 - $2,250 - $600 = $6,250

Annual P&L (250 trading days): $1,562,500
Return on Capital (assuming $1M capital): 156%

ECONOMIES OF SCALE:
-------------------

Market making benefits significantly from scale:

1. Technology Costs
   - Fixed infrastructure amortized over volume
   - $10M system for 1 stock vs. 1000 stocks

2. Information Advantages
   - Cross-asset signals
   - Better fair value estimation
   - Improved toxicity detection

3. Risk Diversification
   - Uncorrelated positions reduce risk
   - Natural hedging across instruments
   - Lower capital requirements

4. Negotiating Power
   - Better fee rates at high volumes
   - Preferential treatment from exchanges
   - Market data discounts

================================================================================
3. BID-ASK SPREAD DYNAMICS
================================================================================

The bid-ask spread compensates market makers for three primary risks:

SPREAD COMPONENTS (ROLL MODEL):
--------------------------------

S = Spread Width
S = Order_Processing_Cost + Adverse_Selection_Cost + Inventory_Cost

1. Order Processing Cost
   - Technology and operational costs
   - Exchange fees
   - Fixed component: typically 1-3 ticks

2. Adverse Selection Component
   - Cost of trading with informed traders
   - Increases with information asymmetry
   - Variable with market conditions

3. Inventory Holding Cost
   - Risk of price movement while holding position
   - Increases with volatility and position size
   - Decreases with hedging opportunities

MATHEMATICAL MODELS:
--------------------

Roll Model (1984):
------------------
Estimates spread from transaction price changes

ΔP_t = P_t - P_{t-1}
Spread = 2√(-Cov(ΔP_t, ΔP_{t-1}))

Intuition: Prices bounce between bid and ask
Buy: P_t = Ask
Next Sell: P_{t+1} = Bid
Change: ΔP = -(Ask - Bid) = -Spread

Glosten-Harris Model (1988):
----------------------------
Separates transitory and permanent price impacts

ΔP_t = c + λQ_t + θΔQ_t + ε_t

Where:
- c = constant
- λ = permanent price impact (adverse selection)
- θ = transitory impact (spread/2)
- Q_t = trade direction (+1 buy, -1 sell)
- ΔQ_t = change in trade direction

Huang-Stoll Model (1997):
-------------------------
Decomposes spread into three components

S = S_order_processing + S_adverse_selection + S_inventory

S_adverse_selection / S = α
S_inventory / S = β
S_order_processing / S = 1 - α - β

Typical values:
α ≈ 0.30-0.40 (adverse selection)
β ≈ 0.10-0.20 (inventory)
1-α-β ≈ 0.40-0.60 (order processing)

SPREAD DETERMINANTS:
--------------------

1. Volatility (σ)
   Higher volatility → Wider spreads
   Relationship: S ∝ σ²

   During calm: Spread = $0.01
   During volatility spike: Spread = $0.05+

2. Trading Volume
   Higher volume → Tighter spreads
   Relationship: S ∝ 1/√Volume

   Competition increases with volume
   More trading = better price discovery

3. Price Level
   Higher price → Wider absolute spread
   But: Percentage spread may be constant

   $10 stock: Spread = $0.01 (0.10%)
   $100 stock: Spread = $0.10 (0.10%)

4. Tick Size
   Minimum spread = 1 tick

   For $0.01 tick:
   Minimum spread = $0.01
   Effective: Often 1-2 ticks

5. Competition
   More market makers → Tighter spreads

   Single MM: Spread = $0.05
   10 MMs competing: Spread = $0.01

6. Information Asymmetry
   Higher asymmetry → Wider spreads

   Pre-earnings: Spread widens
   Post-announcement: Spread normalizes

OPTIMAL SPREAD CALCULATION:
---------------------------

From Avellaneda-Stoikov model:

δ_bid + δ_ask = γσ²(T-t) + (2/γ)ln(1 + γ/κ)

Where:
- δ_bid = distance from mid to bid
- δ_ask = distance from mid to ask
- γ = risk aversion
- σ = volatility
- T-t = time remaining
- κ = order arrival rate

Simplified practical version:

Half-Spread = Base_Spread + Volatility_Component + Inventory_Component

Half-Spread = s_0 + λσ²(T-t) + μ|q|

Where:
- s_0 = minimum spread (e.g., 0.5 ticks)
- λ = volatility sensitivity
- σ = recent volatility
- μ = inventory penalty
- q = current position

C++ IMPLEMENTATION:
-------------------

class SpreadCalculator {
private:
    double base_spread_;           // Minimum spread
    double volatility_multiplier_; // λ parameter
    double inventory_penalty_;     // μ parameter

public:
    SpreadCalculator(double base, double vol_mult, double inv_pen)
        : base_spread_(base)
        , volatility_multiplier_(vol_mult)
        , inventory_penalty_(inv_pen) {}

    // Calculate half-spread (distance from mid to bid/ask)
    double calculateHalfSpread(double volatility,
                               int position,
                               int max_position,
                               double time_to_close) const {
        // Base component
        double spread = base_spread_;

        // Volatility component (risk aversion)
        spread += volatility_multiplier_ * volatility * volatility * time_to_close;

        // Inventory component (holding cost)
        double position_ratio = static_cast<double>(std::abs(position)) / max_position;
        spread += inventory_penalty_ * position_ratio;

        return spread;
    }

    // Alternative: Full Avellaneda-Stoikov formula
    double calculateOptimalSpread(double gamma,        // risk aversion
                                  double sigma,        // volatility
                                  double time_remain,  // T-t
                                  double kappa) const { // arrival rate
        double term1 = gamma * sigma * sigma * time_remain;
        double term2 = (2.0 / gamma) * std::log(1.0 + gamma / kappa);
        return term1 + term2;
    }
};

// Example usage
SpreadCalculator calc(0.005, 10.0, 0.010);
double vol = 0.02; // 2% annual volatility
int position = 5000;
int max_pos = 10000;
double time_to_close = 1.0; // 1 hour

double half_spread = calc.calculateHalfSpread(vol, position, max_pos, time_to_close);
// Result: half_spread ≈ 0.01 (so full spread = 0.02)

================================================================================
4. MARKET MICROSTRUCTURE THEORY
================================================================================

Market microstructure studies the process and outcomes of exchanging assets
under specific trading rules. For market makers, understanding microstructure
is essential for optimal strategy design.

KEY CONCEPTS:
-------------

1. PRICE FORMATION

   Efficient Market Price:
   P_t = E[V | Ω_t]

   Where:
   - V = fundamental value
   - Ω_t = information set at time t

   Components:
   - Fundamental value (long-term)
   - Transitory noise (microstructure)
   - Information shocks

2. ORDER FLOW INFORMATION

   Kyle's Lambda (1985):
   ΔP = λ × Q

   Where:
   - ΔP = price change
   - Q = signed order flow
   - λ = price impact coefficient

   Measures information content of trades

3. INVENTORY MODELS

   Ho-Stoll Framework:
   Market makers set prices to manage inventory

   Bid = V - α × Position
   Ask = V + α × Position

   Where:
   - V = fundamental value
   - α = inventory adjustment speed

4. INFORMATION MODELS

   Glosten-Milgrom:
   Market makers face informed and uninformed traders

   P_bid = E[V | sell order]
   P_ask = E[V | buy order]

   Spread reflects adverse selection risk

EMPIRICAL MICROSTRUCTURE FINDINGS:
-----------------------------------

1. Bid-Ask Bounce
   Transaction prices bounce between bid and ask
   Creates negative autocorrelation at high frequency

   Cor(ΔP_t, ΔP_{t-1}) < 0

2. Price Impact
   Large orders move prices
   Temporary and permanent components

   Temporary: Reverts within seconds/minutes
   Permanent: Reflects information content

3. Volume and Volatility
   Positive correlation between volume and volatility
   U-shaped intraday pattern

   High volume → High volatility → Wide spreads

4. Quote Clustering
   Quotes cluster at round numbers and ticks
   Strategic placement near best bid/ask

5. Order Arrival
   Non-uniform distribution through time
   Clustering around events
   Poisson process approximation

ORDER BOOK DYNAMICS:
--------------------

The limit order book evolves through:

1. Limit Orders
   - Add liquidity
   - Create queue at price level
   - May get filled immediately if aggressive

2. Market Orders
   - Remove liquidity
   - Execute against best available price
   - May walk the book

3. Cancellations
   - Remove liquidity
   - Strategic cancellation to avoid adverse fills
   - High cancellation rate (>90% of orders)

Order Book State:
-----------------

Book = {(P_i, Q_i, OrderList_i)} for i = 1,...,N price levels

Where:
- P_i = price at level i
- Q_i = total quantity at level i
- OrderList_i = queue of orders at level i

Queue Priority Rules:
- Price-time priority (most common)
- Pro-rata allocation (some venues)
- Size priority (rare)

MARKET MAKING IN ORDER BOOK:
-----------------------------

Optimal strategy depends on:

1. Queue Position
   Front of queue: Higher fill probability
   Back of queue: Lower fill probability

   Strategic joining:
   - Join queue when thin
   - Create new level when thick

2. Order Size
   Large size: Better queue position but harder to fill
   Small size: Easier fill but less profit

   Optimal size: Balance fill probability and profit

3. Cancellation Strategy
   Cancel when:
   - Fair value moves away
   - Adverse order flow detected
   - Large opposite order arrives

MEASURING MARKET QUALITY:
--------------------------

1. Quoted Spread
   Spread = Ask - Bid

2. Effective Spread
   ES = 2 × |P_trade - P_mid|

   Measures actual cost of trading

3. Realized Spread
   RS = 2 × (P_trade - P_mid+τ) × Direction

   Measures MM profit after τ time

4. Price Impact
   PI = P_mid+τ - P_mid

   Measures permanent price change

5. Depth
   Total quantity at best bid and ask
   Or: Volume within X% of mid

C++ MICROSTRUCTURE ANALYTICS:
------------------------------

class MicrostructureMetrics {
private:
    struct Trade {
        double price;
        int size;
        int direction; // +1 buy, -1 sell
        uint64_t timestamp;
    };

    std::deque<Trade> recent_trades_;
    static constexpr int MAX_TRADES = 1000;

public:
    // Calculate Roll's spread estimator
    double calculateRollSpread() const {
        if (recent_trades_.size() < 2) return 0.0;

        // Calculate price changes
        std::vector<double> price_changes;
        for (size_t i = 1; i < recent_trades_.size(); ++i) {
            price_changes.push_back(
                recent_trades_[i].price - recent_trades_[i-1].price
            );
        }

        // Calculate autocovariance
        double mean = 0.0;
        for (double dp : price_changes) mean += dp;
        mean /= price_changes.size();

        double cov = 0.0;
        for (size_t i = 1; i < price_changes.size(); ++i) {
            cov += (price_changes[i] - mean) * (price_changes[i-1] - mean);
        }
        cov /= (price_changes.size() - 1);

        // Roll's estimator: Spread = 2 * sqrt(-cov)
        return (cov < 0) ? 2.0 * std::sqrt(-cov) : 0.0;
    }

    // Calculate Kyle's lambda (price impact)
    double calculateKyleLambda() const {
        if (recent_trades_.size() < 10) return 0.0;

        // Regression: ΔP = λ × Q
        double sum_q = 0.0, sum_dp = 0.0, sum_q2 = 0.0, sum_q_dp = 0.0;
        int n = 0;

        for (size_t i = 1; i < recent_trades_.size(); ++i) {
            double dp = recent_trades_[i].price - recent_trades_[i-1].price;
            double q = recent_trades_[i].direction * recent_trades_[i].size;

            sum_q += q;
            sum_dp += dp;
            sum_q2 += q * q;
            sum_q_dp += q * dp;
            n++;
        }

        // λ = Cov(ΔP, Q) / Var(Q)
        double mean_q = sum_q / n;
        double mean_dp = sum_dp / n;
        double cov = (sum_q_dp / n) - (mean_q * mean_dp);
        double var_q = (sum_q2 / n) - (mean_q * mean_q);

        return (var_q > 0) ? (cov / var_q) : 0.0;
    }

    // Calculate effective spread
    double calculateEffectiveSpread(double trade_price,
                                    double mid_price,
                                    int direction) const {
        return 2.0 * std::abs(trade_price - mid_price);
    }

    // Calculate realized spread (MM profit)
    double calculateRealizedSpread(double trade_price,
                                   double mid_price_now,
                                   double mid_price_later,
                                   int direction) const {
        // Spread captured by MM
        double eff_spread = 2.0 * std::abs(trade_price - mid_price_now);

        // Price movement (adverse selection)
        double price_impact = std::abs(mid_price_later - mid_price_now);

        // Realized spread = Effective spread - Price impact
        return eff_spread - price_impact;
    }

    void addTrade(double price, int size, int direction, uint64_t timestamp) {
        recent_trades_.push_back({price, size, direction, timestamp});
        if (recent_trades_.size() > MAX_TRADES) {
            recent_trades_.pop_front();
        }
    }
};

================================================================================
5. ORDER BOOK MECHANICS
================================================================================

Understanding order book mechanics is crucial for market making success.

ORDER BOOK STRUCTURE:
---------------------

Typical Level 2 Market Data:

ASK SIDE (Sell Orders)
Price    | Size  | Orders | Implied
---------|-------|--------|--------
100.05   | 1500  |   3    | ←  Ask
100.04   | 2000  |   5    |
100.03   | 3500  |   8    |
100.02   | 5000  |  12    |
======================================
         MID = 100.00
======================================
100.00   | 4500  |  10    |
99.99    | 3000  |   7    |
99.98    | 2500  |   6    |
99.97    | 1800  |   4    | ←  Bid
BID SIDE (Buy Orders)

Key Metrics:
- Quoted Spread: 100.05 - 99.97 = $0.08
- Best Bid: $99.97
- Best Ask: $100.05
- Mid Price: $100.01 (average)
- Microprice: (99.97×1500 + 100.05×1800)/(1500+1800) = $100.01

BOOK IMBALANCE:
---------------

Order imbalance predicts short-term price movement:

Imbalance = (Bid_Size - Ask_Size) / (Bid_Size + Ask_Size)

At best: OIB_1 = (1800 - 1500) / (1800 + 1500) = 0.09

Multi-level imbalance (more robust):

OIB_n = (Σ Bid_Size_i - Σ Ask_Size_i) / (Σ Bid_Size_i + Σ Ask_Size_i)
        for i = 1 to n

Typical: n = 5 levels

Empirical finding:
Positive OIB → Prices likely to move up
Negative OIB → Prices likely to move down

Correlation: Cor(OIB_t, ΔP_{t+1}) ≈ 0.1-0.3

QUEUE POSITION MODELS:
----------------------

Fill probability depends on queue position:

P(fill) = f(queue_position, total_size, order_flow)

Simple Model:
P(fill | position=k, total=N, incoming_size=S) = max(0, (S - k + 1) / S)

Example:
- You're 500th in queue of 2000
- Market order for 1000 arrives
- P(fill) = (1000 - 500 + 1) / 1000 = 50.1%

Advanced Model (Exponential decay):
P(fill | t) = 1 - exp(-λt × priority_factor)

Where:
- λ = base fill rate
- priority_factor = (N - k + 1) / N
- t = time

BOOK IMBALANCE PREDICTION:
---------------------------

class OrderBookImbalance {
private:
    static constexpr int NUM_LEVELS = 5;

public:
    // Calculate multi-level order imbalance
    double calculateImbalance(const OrderBook& book) const {
        double bid_volume = 0.0;
        double ask_volume = 0.0;

        // Sum top N levels
        for (int i = 0; i < NUM_LEVELS && i < book.num_bid_levels; ++i) {
            bid_volume += book.bids[i].size;
        }

        for (int i = 0; i < NUM_LEVELS && i < book.num_ask_levels; ++i) {
            ask_volume += book.asks[i].size;
        }

        double total = bid_volume + ask_volume;
        if (total < 0.0001) return 0.0;

        return (bid_volume - ask_volume) / total;
    }

    // Weighted imbalance (closer levels matter more)
    double calculateWeightedImbalance(const OrderBook& book) const {
        double bid_volume = 0.0;
        double ask_volume = 0.0;

        // Exponential weights: closer levels get higher weight
        for (int i = 0; i < NUM_LEVELS && i < book.num_bid_levels; ++i) {
            double weight = std::exp(-0.5 * i); // Decay factor
            bid_volume += book.bids[i].size * weight;
        }

        for (int i = 0; i < NUM_LEVELS && i < book.num_ask_levels; ++i) {
            double weight = std::exp(-0.5 * i);
            ask_volume += book.asks[i].size * weight;
        }

        double total = bid_volume + ask_volume;
        if (total < 0.0001) return 0.0;

        return (bid_volume - ask_volume) / total;
    }

    // Predict price change from imbalance
    double predictPriceMove(double imbalance, double volatility) const {
        // Empirical: ΔP ≈ β × Imbalance × σ
        constexpr double beta = 0.5; // Calibrated parameter
        return beta * imbalance * volatility;
    }
};

================================================================================
6. QUEUE POSITION AND PRIORITY RULES
================================================================================

PRICE-TIME PRIORITY:
--------------------

Most exchanges use price-time priority:
1. Best price gets filled first
2. Within same price, earliest order first

Example Queue at $100.00:
Order | Time    | Size | Position
------|---------|------|----------
A     | 09:30:00| 500  | 1
B     | 09:30:05| 1000 | 2
C     | 09:30:10| 750  | 3  ← Your order
D     | 09:30:15| 500  | 4

Total at level: 2750 shares
Your position: 1500 shares ahead

Market order for 2000 shares arrives:
- Order A: Fully filled (500)
- Order B: Fully filled (1000)
- Order C: Partially filled (500/750)
- Order D: No fill

QUEUE JUMPING STRATEGIES:
--------------------------

1. Penny Jumping
   - Post order 1 tick better than current best
   - Become new best bid/ask
   - Risk: Others may jump you

2. Size Improvement
   - On pro-rata exchanges
   - Larger orders get proportionally more fills
   - Trade-off: Capital tied up

3. Order Refresh
   - Cancel and resubmit at same price
   - Lose queue position
   - Only when expecting adverse move

HIDDEN ORDERS:
--------------

Some venues allow hidden/iceberg orders:
- Displayed size: Small (e.g., 100)
- Hidden size: Large (e.g., 10,000)
- Refills automatically when displayed fills

Advantages:
- Don't reveal full size
- Maintain queue position

Disadvantages:
- Lower priority than visible orders
- May lose fills to visible orders

C++ QUEUE POSITION TRACKING:
-----------------------------

class QueuePositionEstimator {
private:
    struct QueueState {
        double price;
        int64_t total_size;
        int64_t position_ahead;  // Size ahead of our order
        uint64_t join_time;
        int our_size;
    };

    std::unordered_map<std::string, QueueState> positions_; // symbol -> state

public:
    // Update queue position when order book changes
    void updateQueue(const std::string& symbol,
                     const OrderBook& book,
                     double our_price,
                     int our_size,
                     bool is_bid) {
        QueueState& state = positions_[symbol];
        state.price = our_price;
        state.our_size = our_size;

        // Find our price level
        const auto& levels = is_bid ? book.bids : book.asks;

        int64_t ahead = 0;
        bool found = false;

        for (const auto& level : levels) {
            if (std::abs(level.price - our_price) < 0.0001) {
                // This is our level
                // Assume we're at the back (conservative)
                ahead = level.size - our_size;
                found = true;
                break;
            }
        }

        if (found) {
            state.total_size = ahead + our_size;
            state.position_ahead = ahead;
        }
    }

    // Estimate fill probability
    double estimateFillProbability(const std::string& symbol,
                                   int expected_order_size) const {
        auto it = positions_.find(symbol);
        if (it == positions_.end()) return 0.0;

        const QueueState& state = it->second;

        // Simple model: linear fill probability
        if (expected_order_size <= state.position_ahead) {
            return 0.0; // Won't reach us
        }

        if (expected_order_size >= state.position_ahead + state.our_size) {
            return 1.0; // Full fill
        }

        // Partial fill
        double fillable = expected_order_size - state.position_ahead;
        return fillable / state.our_size;
    }

    // Estimate expected fill time
    double estimateFillTime(const std::string& symbol,
                           double avg_fill_rate_per_sec) const {
        auto it = positions_.find(symbol);
        if (it == positions_.end()) return std::numeric_limits<double>::max();

        const QueueState& state = it->second;

        if (avg_fill_rate_per_sec < 0.0001) {
            return std::numeric_limits<double>::max();
        }

        // Time = Position / Fill_Rate
        return state.position_ahead / avg_fill_rate_per_sec;
    }

    // Should we cancel and rejoin?
    bool shouldRefresh(const std::string& symbol,
                      double expected_move,
                      double our_edge) const {
        auto it = positions_.find(symbol);
        if (it == positions_.end()) return false;

        const QueueState& state = it->second;

        // If expected move exceeds our edge, cancel
        if (std::abs(expected_move) > our_edge) {
            return true;
        }

        // If position too far back and move expected, cancel
        double position_ratio = static_cast<double>(state.position_ahead) /
                               state.total_size;
        if (position_ratio > 0.8 && std::abs(expected_move) > 0.0001) {
            return true;
        }

        return false;
    }
};

================================================================================
7. PRICE DISCOVERY AND FAIR VALUE
================================================================================

Accurate fair value estimation is critical for market making profitability.

FAIR VALUE METHODS:
-------------------

1. Mid Price (Simple)
   FV = (Bid + Ask) / 2

   Pros: Simple, always available
   Cons: Ignores size, susceptible to manipulation

2. Microprice (Better)
   FV = (Bid × AskSize + Ask × BidSize) / (BidSize + AskSize)

   Pros: Accounts for liquidity imbalance
   Cons: Only uses top of book

3. Weighted Microprice (Best for short-term)
   FV = Σ(P_i × W_i) / Σ(W_i)

   Where weights based on:
   - Size at level
   - Distance from mid
   - Recent trade intensity

4. Last Trade Price
   FV = Last_Trade_Price

   Pros: Reflects actual execution
   Cons: Stale, affected by order type

5. VWAP (Volume Weighted Average Price)
   FV = Σ(P_i × V_i) / Σ(V_i)

   Over recent window (e.g., last 10 seconds)

6. Time-Weighted Average
   FV = Σ(P_i × T_i) / Σ(T_i)

   Gives more weight to stable prices

MULTI-VENUE AGGREGATION:
-------------------------

When trading on multiple venues:

FV = Σ(FV_i × Weight_i)

Weights based on:
- Venue liquidity
- Venue reliability
- Latency to venue
- Fee structure

National Best Bid and Offer (NBBO):
- Best bid across all venues
- Best ask across all venues
- Regulatory requirement to match/better

C++ FAIR VALUE CALCULATOR:
---------------------------

class FairValueCalculator {
private:
    struct PriceLevel {
        double price;
        int64_t size;
    };

    static constexpr int MAX_LEVELS = 10;

public:
    // Simple mid price
    double calculateMid(double bid, double ask) const {
        return (bid + ask) * 0.5;
    }

    // Microprice with top of book
    double calculateMicroprice(double bid, int64_t bid_size,
                              double ask, int64_t ask_size) const {
        int64_t total_size = bid_size + ask_size;
        if (total_size == 0) return (bid + ask) * 0.5;

        return (bid * ask_size + ask * bid_size) / total_size;
    }

    // Weighted microprice with multiple levels
    double calculateWeightedMicroprice(
        const std::vector<PriceLevel>& bids,
        const std::vector<PriceLevel>& asks) const {

        double weighted_sum = 0.0;
        double weight_sum = 0.0;

        // Process bid levels
        for (size_t i = 0; i < bids.size() && i < MAX_LEVELS; ++i) {
            double weight = bids[i].size * std::exp(-0.3 * i);
            weighted_sum += bids[i].price * weight;
            weight_sum += weight;
        }

        // Process ask levels
        for (size_t i = 0; i < asks.size() && i < MAX_LEVELS; ++i) {
            double weight = asks[i].size * std::exp(-0.3 * i);
            weighted_sum += asks[i].price * weight;
            weight_sum += weight;
        }

        return (weight_sum > 0) ? (weighted_sum / weight_sum) : 0.0;
    }

    // VWAP over recent trades
    double calculateVWAP(const std::deque<Trade>& recent_trades,
                        uint64_t window_ns) const {
        uint64_t now = getCurrentTimestamp();
        uint64_t cutoff = now - window_ns;

        double value_sum = 0.0;
        int64_t volume_sum = 0;

        for (const auto& trade : recent_trades) {
            if (trade.timestamp >= cutoff) {
                value_sum += trade.price * trade.size;
                volume_sum += trade.size;
            }
        }

        return (volume_sum > 0) ? (value_sum / volume_sum) : 0.0;
    }

    // Exponentially weighted moving average
    double calculateEWMA(double current_fv,
                        double new_price,
                        double alpha) const {
        // FV_new = α × Price_new + (1-α) × FV_old
        return alpha * new_price + (1.0 - alpha) * current_fv;
    }

    // Kalman filter for fair value
    struct KalmanState {
        double estimate;      // Current fair value estimate
        double error_cov;     // Estimation error covariance
        double process_var;   // Process noise variance
        double measure_var;   // Measurement noise variance
    };

    double updateKalman(KalmanState& state, double measurement) const {
        // Prediction step
        double predicted_estimate = state.estimate;
        double predicted_cov = state.error_cov + state.process_var;

        // Update step
        double kalman_gain = predicted_cov / (predicted_cov + state.measure_var);
        state.estimate = predicted_estimate +
                        kalman_gain * (measurement - predicted_estimate);
        state.error_cov = (1.0 - kalman_gain) * predicted_cov;

        return state.estimate;
    }

private:
    uint64_t getCurrentTimestamp() const {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()
        ).count();
    }
};

// Example usage
FairValueCalculator fv_calc;

// Method 1: Simple mid
double mid = fv_calc.calculateMid(99.95, 100.05);

// Method 2: Microprice
double micro = fv_calc.calculateMicroprice(99.95, 1000, 100.05, 1500);

// Method 3: Multi-level weighted
std::vector<FairValueCalculator::PriceLevel> bids = {
    {99.95, 1000}, {99.94, 1500}, {99.93, 2000}
};
std::vector<FairValueCalculator::PriceLevel> asks = {
    {100.05, 1500}, {100.06, 2000}, {100.07, 1000}
};
double weighted = fv_calc.calculateWeightedMicroprice(bids, asks);

================================================================================
8. MARKET IMPACT AND LIQUIDITY
================================================================================

Understanding market impact is crucial for optimal order sizing and execution.

MARKET IMPACT MODELS:
---------------------

1. Linear Impact (Kyle 1985)
   ΔP = λ × Q

   Where:
   - ΔP = price change
   - λ = price impact coefficient (Kyle's lambda)
   - Q = order size

2. Square-Root Impact (Almgren et al. 2005)
   ΔP = σ × √(Q / V)

   Where:
   - σ = volatility
   - Q = order size
   - V = daily volume

3. Power-Law Impact
   ΔP = α × Q^β

   Typical: β ≈ 0.5-0.7

TEMPORARY VS PERMANENT IMPACT:
-------------------------------

Total Impact = Temporary + Permanent

Temporary Impact:
- Reverts quickly (seconds to minutes)
- Due to order book depletion
- Recovers as book refills

Permanent Impact:
- Persists
- Due to information content
- Reflects true price discovery

Decomposition:
Impact(t) = Permanent + Temporary × exp(-λt)

LIQUIDITY MEASURES:
-------------------

1. Quoted Spread
   Spread = Ask - Bid

2. Effective Spread
   ES = 2 × |P_trade - P_mid|

3. Dollar Depth
   Depth = $ Volume within X% of mid

   Example: Within 0.1% = $500,000

4. Amihud Illiquidity
   ILLIQ = |Return| / Volume

   Higher = less liquid

5. Roll Measure
   Spread = 2√(-Cov(ΔP_t, ΔP_{t-1}))

C++ MARKET IMPACT ESTIMATOR:
-----------------------------

class MarketImpactModel {
private:
    double lambda_;     // Kyle's lambda
    double sigma_;      // Volatility
    double alpha_;      // Power law coefficient
    double beta_;       // Power law exponent

    struct ImpactEstimate {
        double temporary;
        double permanent;
        double total;
    };

public:
    MarketImpactModel(double lambda, double sigma,
                     double alpha = 0.0, double beta = 0.5)
        : lambda_(lambda), sigma_(sigma), alpha_(alpha), beta_(beta) {}

    // Linear impact model
    double estimateLinearImpact(int order_size) const {
        return lambda_ * order_size;
    }

    // Square-root impact model
    double estimateSqrtImpact(int order_size, int daily_volume) const {
        if (daily_volume <= 0) return 0.0;
        return sigma_ * std::sqrt(static_cast<double>(order_size) / daily_volume);
    }

    // Power-law impact model
    double estimatePowerLawImpact(int order_size) const {
        return alpha_ * std::pow(order_size, beta_);
    }

    // Decompose into temporary and permanent
    ImpactEstimate estimateImpactComponents(int order_size,
                                           double information_ratio = 0.5) const {
        ImpactEstimate est;
        est.total = estimateLinearImpact(order_size);
        est.permanent = est.total * information_ratio;
        est.temporary = est.total * (1.0 - information_ratio);
        return est;
    }

    // Estimate decay of temporary impact
    double temporaryImpactDecay(double initial_impact,
                               double time_seconds,
                               double decay_rate = 0.1) const {
        return initial_impact * std::exp(-decay_rate * time_seconds);
    }

    // Optimal order size given max acceptable impact
    int optimalOrderSize(double max_impact) const {
        if (lambda_ <= 0) return 0;
        return static_cast<int>(max_impact / lambda_);
    }

    // Calibrate lambda from historical data
    void calibrateLambda(const std::vector<Trade>& trades) {
        if (trades.size() < 2) return;

        // Regression: ΔP = λ × Q
        double sum_q = 0.0, sum_dp = 0.0, sum_q2 = 0.0, sum_q_dp = 0.0;
        int n = 0;

        for (size_t i = 1; i < trades.size(); ++i) {
            double dp = trades[i].price - trades[i-1].price;
            double q = trades[i].direction * trades[i].size;

            sum_q += q;
            sum_dp += dp;
            sum_q2 += q * q;
            sum_q_dp += q * dp;
            n++;
        }

        double mean_q = sum_q / n;
        double mean_dp = sum_dp / n;
        double cov = (sum_q_dp / n) - (mean_q * mean_dp);
        double var_q = (sum_q2 / n) - (mean_q * mean_q);

        if (var_q > 0) {
            lambda_ = cov / var_q;
        }
    }
};

================================================================================
PERFORMANCE SUMMARY
================================================================================

Key takeaways from market making fundamentals:

1. Market makers earn bid-ask spread while managing risks
2. Profitability = Spread Revenue - Adverse Selection - Inventory Risk + Rebates
3. Fair value estimation critical for quote placement
4. Order book imbalance predicts short-term price moves
5. Queue position affects fill probability significantly
6. Market impact limits optimal order size
7. Microstructure understanding provides edge

Next: Read 02_inventory_management.txt for position control strategies.

================================================================================
END OF MARKET MAKING FUNDAMENTALS
================================================================================
