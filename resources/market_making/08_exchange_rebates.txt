================================================================================
EXCHANGE REBATES AND MAKER-TAKER FEES
================================================================================

File: 08_exchange_rebates.txt
Purpose: Understanding and optimizing exchange fee structures
Topics: Maker-taker models, rebate optimization, tier management
Last Updated: 2025-11-26

================================================================================
TABLE OF CONTENTS
================================================================================

1. Maker-Taker Fee Model
2. Exchange Fee Structures
3. Rebate Optimization Strategies
4. Volume Tier Management
5. Cross-Venue Rebate Arbitrage
6. Payment for Order Flow (PFOF)
7. Rebate Sensitivity Analysis
8. C++ Rebate Optimization System

================================================================================
1. MAKER-TAKER FEE MODEL
================================================================================

CORE CONCEPT:
-============

Maker (Liquidity Provider):
- Posts limit orders that add liquidity
- RECEIVES rebate from exchange
- Typical: +$0.0015 to +$0.0030 per share

Taker (Liquidity Consumer):
- Sends market orders that remove liquidity
- PAYS fee to exchange
- Typical: -$0.0030 to -$0.0050 per share

Exchange Revenue = Taker_Fees - Maker_Rebates

EXAMPLE TRANSACTION:
--------------------

Maker posts: Bid $100.00 for 1000 shares
Taker sends: Market sell 1000 shares

Maker:
- Buys 1000 @ $100.00 = -$100,000
- Receives rebate: +$0.0020 × 1000 = +$2.00
- Net cost: -$99,998.00

Taker:
- Sells 1000 @ $100.00 = +$100,000
- Pays fee: -$0.0030 × 1000 = -$3.00
- Net proceeds: +$99,997.00

Exchange:
- Net revenue: $3.00 - $2.00 = $1.00

WHY MAKER-TAKER EXISTS:
-----------------------

1. Incentivize Liquidity Provision
   - Rebates attract market makers
   - More liquidity → Better market quality

2. Exchange Competition
   - Higher rebates attract more MMs
   - More MMs → Tighter spreads → More volume

3. Revenue Model
   - Profitable for exchanges
   - Taker fees exceed maker rebates

REBATE IMPACT ON PROFITABILITY:
--------------------------------

Without Rebates:
Spread = $0.10, Volume = 1M shares
Revenue = $0.10 × 1M / 2 = $50,000

With Rebates ($0.0020/share):
Spread = $0.10, Volume = 1M shares
Spread_Revenue = $50,000
Rebate_Revenue = $0.0020 × 1M = $2,000
Total_Revenue = $52,000 (+4%)

But with tighter competition:
Spread = $0.08 (tighter due to rebates)
Spread_Revenue = $40,000
Rebate_Revenue = $2,000
Total_Revenue = $42,000

Rebates enable profitability even with narrow spreads!

================================================================================
2. EXCHANGE FEE STRUCTURES
================================================================================

TYPICAL FEE SCHEDULES:
----------------------

Exchange A (e.g., Nasdaq):
Tier 1: < 10M shares/month
  Maker: +$0.0015/share
  Taker: -$0.0030/share

Tier 2: 10M - 50M shares/month
  Maker: +$0.0020/share
  Taker: -$0.0030/share

Tier 3: 50M - 200M shares/month
  Maker: +$0.0025/share
  Taker: -$0.0028/share

Tier 4: > 200M shares/month
  Maker: +$0.0030/share
  Taker: -$0.0026/share

Exchange B (e.g., NYSE):
Flat Rate:
  Maker: +$0.0018/share
  Taker: -$0.0029/share

Inverted: Some venues offer inverted fees
  Maker: -$0.0005/share (pay to make)
  Taker: +$0.0010/share (rebate for taking)

OPTIONS MARKETS:
----------------

Higher rebates due to wider spreads:
  Maker: +$0.10 to +$0.50 per contract
  Taker: -$0.20 to -$1.00 per contract

FUTURES MARKETS:
----------------

Lower rebates, tighter spreads:
  Maker: +$0.10 to +$0.30 per contract
  Taker: -$0.40 to -$0.80 per contract

C++ FEE STRUCTURE MODEL:
------------------------

class ExchangeFeeStructure {
public:
    struct FeeTier {
        int64_t volume_threshold;
        double maker_rebate;
        double taker_fee;
    };

private:
    std::string exchange_name_;
    std::vector<FeeTier> tiers_;
    bool is_inverted_;

public:
    ExchangeFeeStructure(const std::string& name, bool inverted = false)
        : exchange_name_(name), is_inverted_(inverted) {}

    void addTier(int64_t threshold, double maker_rebate, double taker_fee) {
        tiers_.push_back({threshold, maker_rebate, taker_fee});
        // Sort by threshold
        std::sort(tiers_.begin(), tiers_.end(),
                 [](const FeeTier& a, const FeeTier& b) {
                     return a.volume_threshold < b.volume_threshold;
                 });
    }

    FeeTier getCurrentTier(int64_t monthly_volume) const {
        if (tiers_.empty()) {
            return {0, 0.0020, -0.0030};  // Default
        }

        // Find applicable tier
        for (auto it = tiers_.rbegin(); it != tiers_.rend(); ++it) {
            if (monthly_volume >= it->volume_threshold) {
                return *it;
            }
        }

        return tiers_[0];  // Lowest tier
    }

    double calculateMakerRevenue(int64_t volume, int64_t monthly_volume) const {
        auto tier = getCurrentTier(monthly_volume);
        return volume * tier.maker_rebate;
    }

    double calculateTakerCost(int64_t volume, int64_t monthly_volume) const {
        auto tier = getCurrentTier(monthly_volume);
        return volume * tier.taker_fee;
    }

    // Calculate net benefit of reaching next tier
    struct TierUpgradeAnalysis {
        int64_t current_volume;
        int64_t next_threshold;
        int64_t additional_volume_needed;
        double current_rebate_rate;
        double next_rebate_rate;
        double monthly_benefit;
        bool worth_upgrading;
    };

    TierUpgradeAnalysis analyzeTierUpgrade(int64_t current_monthly_volume,
                                          int remaining_days) const {
        TierUpgradeAnalysis analysis;
        analysis.current_volume = current_monthly_volume;

        auto current_tier = getCurrentTier(current_monthly_volume);
        analysis.current_rebate_rate = current_tier.maker_rebate;

        // Find next tier
        bool found_next = false;
        for (const auto& tier : tiers_) {
            if (tier.volume_threshold > current_monthly_volume) {
                analysis.next_threshold = tier.volume_threshold;
                analysis.next_rebate_rate = tier.maker_rebate;
                found_next = true;
                break;
            }
        }

        if (!found_next) {
            analysis.worth_upgrading = false;
            return analysis;
        }

        analysis.additional_volume_needed = analysis.next_threshold - current_monthly_volume;

        // Calculate benefit
        double rebate_increase = analysis.next_rebate_rate - analysis.current_rebate_rate;

        // Benefit applies to ALL volume at new tier
        int estimated_total_volume = analysis.next_threshold +
                                    (analysis.additional_volume_needed / 2);  // Conservative
        analysis.monthly_benefit = rebate_increase * estimated_total_volume;

        // Cost of generating additional volume (wider spreads, more risk)
        double marginal_cost_per_share = 0.001;  // Assume $0.001/share cost
        double cost = analysis.additional_volume_needed * marginal_cost_per_share;

        analysis.worth_upgrading = (analysis.monthly_benefit > cost * 1.5);  // 50% margin

        return analysis;
    }
};

================================================================================
3. REBATE OPTIMIZATION STRATEGIES
================================================================================

STRATEGY 1: MAXIMIZE MAKER RATIO
---------------------------------

Post more limit orders, take fewer market orders

Maker_Ratio = Maker_Volume / (Maker_Volume + Taker_Volume)

Target: > 90% maker ratio

Tactics:
- Always post limit orders
- Use POST_ONLY order type
- Cancel rather than take
- Wait for fills rather than chase

STRATEGY 2: VOLUME TIER OPTIMIZATION
-------------------------------------

Increase volume strategically to reach next tier

Analysis:
1. Calculate distance to next tier
2. Estimate additional rebate revenue
3. Compare to cost of generating volume
4. Decide if worth pushing volume

Example:
Current: 45M shares/month at $0.0020 rebate
Next tier: 50M at $0.0025 rebate
Remaining days: 10
Daily volume: 1.5M shares

Needed: 5M additional shares
Per day: 500K additional shares (33% increase)

Benefit: $0.0005 × 50M = $25,000/month
Cost: Lower spread capture, higher risk ≈ $15,000
Net benefit: $10,000/month

Decision: Worth it!

STRATEGY 3: QUOTE AT MULTIPLE VENUES
-------------------------------------

Post quotes at venues with highest rebates

Venue A: $0.0020 rebate
Venue B: $0.0025 rebate
Venue C: $0.0015 rebate

Priority: Quote at Venue B first

Allocate capital to maximize rebate-weighted volume

STRATEGY 4: SIZE OPTIMIZATION
------------------------------

Post larger sizes at high-rebate venues

Rebate per fill = Size × Rebate_Rate

Venue with $0.0025 rebate:
- Post 1000 shares → $2.50 per fill
Venue with $0.0015 rebate:
- Post 500 shares → $0.75 per fill

Focus liquidity where rebates are highest

C++ REBATE OPTIMIZER:
---------------------

class RebateOptimizer {
private:
    std::unordered_map<std::string, ExchangeFeeStructure> exchanges_;
    std::unordered_map<std::string, int64_t> monthly_volumes_;

public:
    void addExchange(const std::string& name,
                    const ExchangeFeeStructure& fee_structure) {
        exchanges_[name] = fee_structure;
        monthly_volumes_[name] = 0;
    }

    void updateVolume(const std::string& exchange, int64_t volume) {
        monthly_volumes_[exchange] += volume;
    }

    // Rank exchanges by current rebate rate
    std::vector<std::pair<std::string, double>> rankExchangesByRebate() const {
        std::vector<std::pair<std::string, double>> rankings;

        for (const auto& [name, exchange] : exchanges_) {
            auto tier = exchange.getCurrentTier(monthly_volumes_.at(name));
            rankings.push_back({name, tier.maker_rebate});
        }

        std::sort(rankings.begin(), rankings.end(),
                 [](const auto& a, const auto& b) { return a.second > b.second; });

        return rankings;
    }

    // Calculate optimal volume allocation
    struct VolumeAllocation {
        std::unordered_map<std::string, int64_t> allocations;
        double expected_total_rebate;
    };

    VolumeAllocation optimizeVolumeAllocation(int64_t total_target_volume,
                                             int remaining_days) const {
        VolumeAllocation result;

        // For each exchange, check if close to next tier
        std::vector<std::tuple<std::string, double, int64_t>> priorities;

        for (const auto& [name, exchange] : exchanges_) {
            auto current_volume = monthly_volumes_.at(name);
            auto analysis = exchange.analyzeTierUpgrade(current_volume, remaining_days);

            if (analysis.worth_upgrading) {
                // Priority = benefit per additional share
                double priority = analysis.monthly_benefit /
                                 analysis.additional_volume_needed;
                priorities.push_back({name, priority, analysis.additional_volume_needed});
            }
        }

        // Sort by priority
        std::sort(priorities.begin(), priorities.end(),
                 [](const auto& a, const auto& b) { return std::get<1>(a) > std::get<1>(b); });

        // Allocate volume
        int64_t remaining_volume = total_target_volume;

        for (const auto& [exchange, priority, needed] : priorities) {
            int64_t allocation = std::min(needed, remaining_volume);
            result.allocations[exchange] = allocation;
            remaining_volume -= allocation;

            if (remaining_volume == 0) break;
        }

        // Allocate remaining volume to highest rebate exchanges
        if (remaining_volume > 0) {
            auto rankings = rankExchangesByRebate();
            for (const auto& [exchange, rebate] : rankings) {
                int64_t allocation = remaining_volume / rankings.size();
                result.allocations[exchange] += allocation;
            }
        }

        // Calculate expected rebate
        result.expected_total_rebate = 0.0;
        for (const auto& [exchange, volume] : result.allocations) {
            auto new_monthly = monthly_volumes_.at(exchange) + volume;
            auto tier = exchanges_.at(exchange).getCurrentTier(new_monthly);
            result.expected_total_rebate += volume * tier.maker_rebate;
        }

        return result;
    }

    // Calculate current monthly rebate projection
    double projectMonthlyRebate() const {
        double total = 0.0;
        for (const auto& [name, exchange] : exchanges_) {
            auto volume = monthly_volumes_.at(name);
            auto tier = exchange.getCurrentTier(volume);
            total += volume * tier.maker_rebate;
        }
        return total;
    }
};

================================================================================
4. PAYMENT FOR ORDER FLOW (PFOF)
================================================================================

PFOF OVERVIEW:
--------------

Retail brokers route orders to wholesalers
Wholesalers pay for the order flow
Typical payment: $0.001 - $0.003 per share

Example:
Broker sends 1M shares of retail orders to Wholesaler
Wholesaler pays: $0.002 × 1M = $2,000 to Broker
Wholesaler earns: Spread capture on orders

WHY PFOF IS PROFITABLE:
-----------------------

Retail orders are "uninformed" (low adverse selection)
- No institutional information
- Small sizes
- Easier to manage inventory

Wholesaler can:
- Quote tighter spreads
- Higher fill rates
- Lower adverse selection costs

Net profitability often higher than lit market making

C++ PFOF ANALYZER:
------------------

class PFOFAnalyzer {
private:
    double payment_per_share_;
    double average_spread_;
    double adverse_selection_rate_;

public:
    PFOFAnalyzer(double payment, double spread, double as_rate)
        : payment_per_share_(payment)
        , average_spread_(spread)
        , adverse_selection_rate_(as_rate) {}

    struct PFOFProfitability {
        double revenue_per_share;
        double cost_per_share;
        double net_per_share;
        bool is_profitable;
    };

    PFOFProfitability analyzeProfitability() const {
        PFOFProfitability result;

        // Revenue
        result.revenue_per_share = average_spread_ / 2.0;  // Capture half spread

        // Costs
        double as_cost = adverse_selection_rate_ * 0.05;  // 5 cents per adverse trade
        double payment_cost = payment_per_share_;  // Pay broker

        result.cost_per_share = as_cost + payment_cost;
        result.net_per_share = result.revenue_per_share - result.cost_per_share;
        result.is_profitable = result.net_per_share > 0;

        return result;
    }

    // Calculate break-even payment rate
    double calculateBreakEvenPayment() const {
        double revenue = average_spread_ / 2.0;
        double as_cost = adverse_selection_rate_ * 0.05;
        return revenue - as_cost;
    }
};

================================================================================
PERFORMANCE SUMMARY
================================================================================

Rebate Optimization Impact:
- Rebate revenue: 15-25% of gross revenue
- Tier optimization: +$10K-$50K per month
- Venue selection: +5-10% rebate capture
- Maker ratio optimization: +10-20% net P&L

Key Metrics:
- Maker Ratio: Target > 90%
- Average Rebate Rate: Target > $0.0022/share
- Tier Utilization: Stay in top 2 tiers
- Volume Growth: 10-20% monthly to reach next tier

Best Practices:
1. Monitor monthly volume daily
2. Push volume strategically near tier thresholds
3. Quote at high-rebate venues first
4. Use POST_ONLY to maximize maker ratio
5. Analyze tier upgrade economics monthly

Next: Read 09_mm_risk_management.txt for risk controls.

================================================================================
END OF EXCHANGE REBATES
================================================================================
