================================================================================
FPGA ACCELERATION FOR HIGH-FREQUENCY TRADING
Field-Programmable Gate Arrays for Ultra-Low Latency
================================================================================

INTRODUCTION
================================================================================

FPGAs (Field-Programmable Gate Arrays) are reconfigurable hardware devices that
can be programmed to perform specific tasks with nanosecond-level latency. In
HFT, FPGAs are used to process market data, execute trading strategies, and
send orders faster than any software-based solution.

KEY ADVANTAGES:
- Latency: 300-1000 nanoseconds (vs 1-50 microseconds for optimized software)
- Determinism: Consistent performance, no jitter
- Parallelism: True parallel processing
- Throughput: Process multiple streams simultaneously

KEY CHALLENGES:
- Complexity: Requires hardware engineering skills (VHDL/Verilog)
- Development Time: 6-18 months for production-ready system
- Cost: $100K-500K hardware + $500K-2M development
- Flexibility: Changes require recompilation (hours to days)

FPGA BASICS FOR SOFTWARE ENGINEERS
================================================================================

WHAT IS AN FPGA?
----------------

Unlike CPUs (sequential instruction execution) or GPUs (parallel floating-point),
FPGAs are arrays of configurable logic blocks that can be wired together to
create custom circuits.

Analogy:
- CPU: General-purpose calculator, flexible but not optimized
- GPU: Parallel calculators, optimized for math, not general-purpose
- FPGA: Custom circuit built for your exact use case, maximum efficiency

FPGA vs CPU Comparison:

Aspect              | CPU           | FPGA
--------------------|---------------|------------------
Latency             | 1-50 us       | 0.3-1 us
Clock Speed         | 2-5 GHz       | 200-500 MHz
Parallelism         | Limited cores | Massive parallelism
Power               | 50-150W       | 20-60W
Flexibility         | High          | Low (reconfigurable)
Development         | Easy          | Hard
Cost                | $500-5K       | $5K-50K

FPGA ARCHITECTURE
-----------------

Main components:

1. LOGIC BLOCKS (LUTs - Look-Up Tables)
   - Basic building blocks
   - Implement boolean functions
   - 6-input LUTs typical
   - Thousands to millions per FPGA

2. PROGRAMMABLE INTERCONNECTS
   - Wires connecting logic blocks
   - Configured at load time
   - Critical for performance
   - Can be optimized for routing

3. BLOCK RAM (BRAM)
   - On-chip memory
   - Fast access (< 5 ns)
   - Limited size (few MB)
   - Used for buffers, lookup tables

4. DSP SLICES
   - Dedicated arithmetic units
   - Multiply-accumulate operations
   - High-speed math
   - Used for price calculations

5. I/O BLOCKS
   - Interface with external world
   - High-speed serial (10G/25G/100G Ethernet)
   - PCIe for host communication
   - GPIO for other interfaces

6. HARD CORES
   - Fixed-function blocks
   - Ethernet MAC, PCIe controllers
   - ARM processors (in some FPGAs)
   - Cannot be reconfigured

PROGRAMMING MODEL
-----------------

FPGAs are NOT programmed like CPUs. Instead of sequential instructions, you
describe hardware circuits.

Languages:
1. VHDL (VHSIC Hardware Description Language)
   - Verbose, strongly typed
   - Industry standard
   - Better for large teams

2. Verilog/SystemVerilog
   - More concise
   - C-like syntax
   - Popular in US

3. High-Level Synthesis (HLS)
   - C/C++ to RTL conversion
   - Easier for software engineers
   - Tools: Xilinx Vitis HLS, Intel HLS
   - Trade-off: Less optimal than hand-coded

Example VHDL snippet (simplified order entry):
```vhdl
-- Order validation state machine
process(clk)
begin
    if rising_edge(clk) then
        case state is
            when IDLE =>
                if order_valid = '1' then
                    state <= CHECK_PRICE;
                end if;

            when CHECK_PRICE =>
                if price > max_price then
                    state <= REJECT;
                elsif price < min_price then
                    state <= REJECT;
                else
                    state <= CHECK_QUANTITY;
                end if;

            when CHECK_QUANTITY =>
                if quantity > max_quantity then
                    state <= REJECT;
                else
                    state <= SEND_ORDER;
                end if;

            when SEND_ORDER =>
                order_output <= '1';
                state <= IDLE;

            when REJECT =>
                reject_output <= '1';
                state <= IDLE;
        end case;
    end if;
end process;
```

LATENCY BREAKDOWN
-----------------

Typical path: Market data in -> Decision -> Order out

1. Network Interface: 100-200 ns
   - Packet reception
   - Checksum validation
   - Header parsing

2. Protocol Decode: 50-150 ns
   - FIX parsing or binary protocol
   - Field extraction
   - Timestamp capture

3. Market Data Processing: 100-300 ns
   - Order book update
   - Spread calculation
   - Trigger detection

4. Strategy Execution: 50-200 ns
   - Price calculation
   - Risk checks
   - Order decision

5. Order Formatting: 50-100 ns
   - FIX message creation
   - Sequence numbering
   - Checksum calculation

6. Network Transmission: 100-200 ns
   - Packet assembly
   - MAC/PHY interface
   - Physical transmission

TOTAL: 450-1150 nanoseconds (0.45-1.15 microseconds)

Compare to software: 1,000-50,000 nanoseconds (1-50 microseconds)

Speedup: 10-100x

FPGA USE CASES IN HFT
================================================================================

USE CASE 1: MARKET DATA PARSING
--------------------------------

Problem: Software parsing of market data feeds is slow
- FIX protocol: String parsing, field lookup
- Binary protocols: Still require CPU cycles
- Cache misses, branch mispredictions

FPGA Solution:
- Parse protocol in hardware
- Parallel extraction of all fields
- No memory hierarchy delays
- Deterministic latency

Example: NYSE BQT Feed
- Software: 5-10 microseconds per message
- FPGA: 200-400 nanoseconds per message
- Speedup: 25-50x

Implementation:
1. Ethernet MAC receives packet
2. Protocol header parsing (100 ns)
3. Parallel field extraction (50 ns)
4. Order book update in BRAM (100 ns)
5. Notification to strategy logic (50 ns)

Total: 300 nanoseconds

USE CASE 2: ORDER MATCHING ENGINE
----------------------------------

Problem: Matching orders requires:
- Maintaining order books
- Price-time priority
- Fast lookup and matching

FPGA Solution:
- Order book in BRAM
- Parallel price level checking
- Hardware-based matching algorithm
- Sub-microsecond matching

Example: Internal Dark Pool
- Software matching: 10-50 microseconds
- FPGA matching: 500-1000 nanoseconds
- Speedup: 20-50x

Order book structure:
- Price levels in sorted array
- Each level has order queue
- Fast insert/delete/match
- Timestamp in hardware

USE CASE 3: LATENCY ARBITRAGE
------------------------------

Problem: Detect price discrepancies between venues and react
- Receive data from multiple feeds
- Compare prices
- Send orders to multiple venues

FPGA Solution:
- Multi-feed processing in parallel
- Hardware comparison logic
- Simultaneous order generation
- All in < 1 microsecond

Example: ETF Arbitrage
- Monitor ETF price and basket prices
- Detect mispricings
- Generate basket orders
- FPGA: 800 nanoseconds total
- Software: 20-50 microseconds

USE CASE 4: RISK CHECKS
------------------------

Problem: Every order needs risk validation
- Position limits
- Exposure limits
- Rate limits
- Credit checks

Software bottleneck: 1-5 microseconds per order

FPGA Solution:
- Parallel risk check pipeline
- Hardware counters for positions
- Threshold comparisons in logic
- Result in 50-100 nanoseconds

Risk checks in parallel:
- Position limit: 30 ns
- Daily volume: 30 ns
- Rate limiter: 20 ns
- Price collar: 20 ns
- Total: 100 ns (all parallel)

USE CASE 5: TICK-TO-TRADE
--------------------------

Complete path: Market data -> Strategy -> Order

This is the holy grail of FPGA HFT: entire trading loop in hardware.

Implementation:
1. Market data ingestion (200 ns)
2. Order book update (100 ns)
3. Strategy evaluation (200 ns)
4. Risk checks (100 ns)
5. Order generation (100 ns)
6. Order transmission (200 ns)

Total: 900 nanoseconds

Software equivalent: 10-50 microseconds
Speedup: 11-55x

USE CASE 6: TIMESTAMP AND AUDIT TRAIL
--------------------------------------

Regulatory requirement: Precise timestamps for all events

FPGA advantage:
- Hardware timestamp (GPS/PTP synchronized)
- Nanosecond accuracy
- No OS jitter
- Deterministic capture

Example: Order lifecycle tracking
- Order received: HW timestamp
- Risk check: HW timestamp
- Order sent: HW timestamp
- All timestamps synchronized to exchange clock

Accuracy: +/- 10 nanoseconds
Software accuracy: +/- 1000 nanoseconds

FPGA PRODUCTS AND VENDORS
================================================================================

XILINX (AMD)
------------

PRODUCT: Alveo U50 (Entry-level)
Price: $2,000-3,000
Specs:
- FPGA: Virtex UltraScale+ XCU50
- Logic Cells: 872K
- Memory: 8GB DDR4
- Network: PCIe Gen4 x16
- Power: 75W
Use case: Development, small-scale deployment

PRODUCT: Alveo U250 (Mid-range)
Price: $5,000-8,000
Specs:
- FPGA: Virtex UltraScale+ XCU250
- Logic Cells: 1.3M
- Memory: 64GB DDR4
- Network: Dual 100GbE QSFP28
- Power: 225W
Use case: Market data processing, strategy execution

PRODUCT: Alveo U280 (High-end)
Price: $10,000-15,000
Specs:
- FPGA: Virtex UltraScale+ XCU280
- Logic Cells: 1.3M
- Memory: 8GB HBM2 + 32GB DDR4
- Network: Dual 100GbE QSFP28
- Power: 225W
Use case: Complex strategies, multiple feed processing

DEVELOPMENT TOOLS: Vivado Design Suite
Price: $3,000-30,000/year (edition dependent)
Features:
- HDL synthesis
- Place and route
- Simulation
- Debugging

HLS TOOL: Vitis HLS
Price: Included with Vivado
Features:
- C/C++ to RTL
- Performance analysis
- Verification

INTEL (FPGA Division, formerly Altera)
---------------------------------------

PRODUCT: Stratix 10 GX FPGA (PAC D5005)
Price: $10,000-20,000
Specs:
- Logic Elements: 2.8M
- Memory: 16GB DDR4
- Network: Dual 100GbE QSFP28
- PCIe Gen3 x16
- Power: 215W
Use case: High-performance trading

PRODUCT: Agilex FPGA (Latest generation)
Price: $15,000-30,000
Specs:
- Second-generation 10nm
- Lower latency than Stratix 10
- Better power efficiency
- Integrated AI engines
Use case: Next-gen deployments

DEVELOPMENT TOOLS: Quartus Prime
Price: $3,000-30,000/year
Features:
- Similar to Xilinx Vivado
- Synthesis and place & route
- Simulation

HLS TOOL: Intel HLS Compiler
Price: Included
Features:
- C++ to RTL
- Integration with Quartus

COMPARISON: XILINX VS INTEL
----------------------------

Aspect          | Xilinx              | Intel
----------------|---------------------|--------------------
Market Share    | ~50%                | ~30%
Performance     | Slightly better     | Competitive
Tools           | More mature         | Catching up
HLS             | Better              | Good
Ecosystem       | Larger              | Growing
Price           | Lower               | Higher
Support         | Excellent           | Excellent
HFT Adoption    | Dominant            | Significant

Recommendation: Start with Xilinx (industry standard), consider Intel for
specific features or multi-sourcing strategy.

SOLARFLARE (Xilinx)
-------------------

PRODUCT: X2522 (10GbE)
Price: $2,000-3,000
Features:
- Integrated FPGA
- Onload acceleration
- Application-level processing
- Low-latency NIC

PRODUCT: X2542 (10/25GbE)
Price: $3,000-5,000
Features:
- Larger FPGA
- More logic for applications
- HFT-optimized

Use case: Simplified FPGA deployment, combined NIC + acceleration

NAPATECH
--------

PRODUCT: Link Capture Software + FPGA SmartNIC
Price: $5,000-15,000
Features:
- Packet capture and filtering
- FPGA for custom processing
- Time synchronization
- Traffic generation

Use case: Hybrid approach, packet capture + FPGA acceleration

CUSTOM FPGA BOARDS
------------------

Some firms design custom FPGA boards:
- Maximum performance optimization
- Tailored to specific requirements
- Complete control over design
- Cost: $100K-1M NRE, $5K-20K per unit

Examples:
- Custom PCIe cards
- Mezzanine cards
- Line-rate processing
- Multi-FPGA systems

FPGA DEVELOPMENT PROCESS
================================================================================

PHASE 1: REQUIREMENTS (2-4 Weeks)
----------------------------------

1. Define functionality
   - What will run in FPGA vs CPU?
   - Latency requirements
   - Throughput requirements
   - Protocol support

2. Resource estimation
   - Logic utilization
   - Memory requirements
   - I/O bandwidth
   - Power budget

3. Select FPGA platform
   - Xilinx vs Intel
   - Specific model
   - Development board vs production card

PHASE 2: HIGH-LEVEL DESIGN (4-8 Weeks)
---------------------------------------

1. Architecture design
   - Block diagram
   - Data flow
   - Interface definitions
   - Clocking strategy

2. Partition hardware/software
   - What goes in FPGA?
   - What stays in CPU?
   - Interface between them

3. Risk identification
   - Technical risks
   - Resource constraints
   - Timing closure challenges

PHASE 3: RTL CODING (8-16 Weeks)
---------------------------------

1. HDL implementation
   - Write VHDL/Verilog
   - Or use HLS for some modules
   - Reuse IP cores where possible

2. Simulation
   - Functional verification
   - Testbenches
   - Code coverage

3. Lint and code review
   - Static analysis
   - Team review
   - Best practices

PHASE 4: SYNTHESIS AND IMPLEMENTATION (4-8 Weeks)
--------------------------------------------------

1. Synthesis
   - Convert RTL to netlist
   - Optimize for area or speed
   - Check resource utilization

2. Place and Route
   - Map logic to FPGA fabric
   - Optimize for timing
   - Achieve timing closure

3. Iteration
   - Constraints refinement
   - Floorplanning
   - Pipeline optimization

4. Bitstream generation
   - Final FPGA configuration file
   - Load into FPGA

PHASE 5: VERIFICATION AND TESTING (4-8 Weeks)
----------------------------------------------

1. FPGA testing
   - Load bitstream
   - Functional testing
   - Performance measurement

2. System integration
   - Connect to servers
   - Network configuration
   - Software/firmware interface

3. Stress testing
   - Max throughput
   - Edge cases
   - Error conditions

PHASE 6: PRODUCTION DEPLOYMENT (2-4 Weeks)
-------------------------------------------

1. Production bitstream
   - Final version
   - Signed and verified
   - Backup copies

2. Deployment
   - Load onto production FPGAs
   - Parallel testing
   - Gradual rollout

3. Monitoring
   - Performance metrics
   - Error logging
   - Health checks

TOTAL TIME: 6-12 MONTHS for first version

ITERATIVE DEVELOPMENT
----------------------

After initial deployment, changes are common:
- Strategy tweaks
- Bug fixes
- Performance improvements
- New features

Each change requires:
- RTL modification: 1-5 days
- Simulation: 1-2 days
- Synthesis & P&R: 4-12 hours
- Testing: 1-3 days
- Deployment: 0.5-1 day

Total: 3-10 days per change

This is MUCH slower than software changes (hours), a key trade-off.

DEVELOPMENT TEAM STRUCTURE
==========================

Typical FPGA team for HFT project:

1. FPGA Architect (1-2 people)
   - System design
   - Architecture decisions
   - Technical leadership

2. RTL Engineers (2-4 people)
   - HDL coding
   - Module development
   - Timing optimization

3. Verification Engineers (1-2 people)
   - Testbench development
   - Simulation
   - Formal verification

4. Software Engineers (1-2 people)
   - Host application
   - FPGA interface
   - Driver development

5. Network Engineers (1 person)
   - Protocol implementation
   - Network interface
   - Traffic analysis

Total team: 6-11 people

Team cost: $1M-2M/year (including overhead)

Project cost: $500K-2M for first implementation
Maintenance: $200K-500K/year

PERFORMANCE OPTIMIZATION TECHNIQUES
================================================================================

PIPELINING
----------

Break computation into stages, each taking one clock cycle.

Example: Order validation
Without pipelining:
- Check price: 3 cycles
- Check quantity: 2 cycles
- Check risk: 4 cycles
- Total: 9 cycles for one order
- Throughput: 1 order / 9 cycles

With pipelining:
- Stage 1: Check price (3 cycle latency)
- Stage 2: Check quantity (2 cycle latency)
- Stage 3: Check risk (4 cycle latency)
- Total latency: 9 cycles
- Throughput: 1 order / cycle (after pipeline fill)

Result: 9x throughput increase with same latency.

PARALLELISM
-----------

Process multiple data streams simultaneously.

Example: Multi-feed market data
- 4 market data feeds
- Sequential processing: 4x latency
- Parallel processing: 4 independent pipelines, same latency

Cost: 4x resources, but FPGA has plenty for this use case.

RESOURCE SHARING
----------------

Trade latency for area by reusing logic.

Example: Arithmetic units
- Dedicated: Fast but uses more logic
- Shared: Slower but uses less logic

Use dedicated for critical path, shared for non-critical.

TIMING OPTIMIZATION
-------------------

Techniques to meet timing closure:

1. Register insertion
   - Break long combinational paths
   - Add pipeline stages

2. Floorplanning
   - Place related logic near each other
   - Reduce routing delay

3. Clock domain crossing
   - Properly handle multiple clock domains
   - Use FIFOs or handshaking

4. Constraint refinement
   - Accurate timing constraints
   - False path marking
   - Multi-cycle paths

MEMORY OPTIMIZATION
-------------------

FPGA memory is precious:

1. Use BRAM efficiently
   - Bank memory appropriately
   - Dual-port for simultaneous access
   - Simple dual-port for read/write

2. Distributed RAM
   - Use LUTs for small memories
   - Lower latency than BRAM
   - Limited size

3. External memory
   - DDR4 for large data
   - Higher latency (100-200 ns)
   - Use for non-critical data

Example: Order book storage
- Top 10 levels: BRAM (fast access)
- Deeper levels: DDR4 (slower but larger)
- Hot symbols: On-chip
- Cold symbols: Off-chip

POWER OPTIMIZATION
------------------

FPGAs can consume significant power (50-225W).

Techniques:
1. Clock gating
   - Disable unused logic
   - Save dynamic power

2. Voltage scaling
   - Lower voltage for non-critical paths
   - Reduce power consumption

3. Resource minimization
   - Use only needed resources
   - Smaller FPGAs consume less

CASE STUDIES
================================================================================

CASE STUDY 1: MARKET MAKING FIRM
---------------------------------

Challenge:
- Software latency: 15 microseconds (tick-to-trade)
- Competitors: 2-5 microseconds
- Losing market share

Solution:
- FPGA-based market data processing and order generation
- Xilinx Alveo U250
- Custom VHDL development
- 6-month project

Results:
- New latency: 1.2 microseconds
- 12x improvement
- Regained competitive advantage
- ROI: 18 months

Investment:
- Hardware: $40K (5 cards)
- Development: $800K (team + tools)
- Total: $840K

Benefit:
- Increased market share by 15%
- $1.2M additional annual profit
- Payback in < 12 months

CASE STUDY 2: LATENCY ARBITRAGE
--------------------------------

Challenge:
- Exploit price discrepancies between venues
- Window of opportunity: 5-10 microseconds
- Software too slow: 20+ microseconds

Solution:
- FPGA receives feeds from 3 venues
- Parallel price comparison
- Simultaneous order generation to all venues
- All in < 2 microseconds

Results:
- Capture arbitrage opportunities
- 500+ trades per day
- Average profit: $20 per trade
- $10K daily profit = $2.5M annually

Investment:
- Hardware: $60K
- Development: $1.2M (complex strategy)
- Total: $1.26M

Benefit:
- $2.5M annual profit
- Payback in 6 months

CASE STUDY 3: COMPLIANCE AND RISK
----------------------------------

Challenge:
- Regulatory requirement for sub-microsecond risk checks
- Software risk checks: 2-5 microseconds
- High message rate: 1M orders/sec
- Bottleneck in system

Solution:
- FPGA-based risk engine
- Parallel risk checks
- Hardware counters for positions
- Result in 150 nanoseconds

Results:
- Meets regulatory requirements
- Enables higher throughput
- No bottleneck
- Scales to 10M orders/sec

Investment:
- Hardware: $30K
- Development: $500K (simpler than trading logic)
- Total: $530K

Benefit:
- Compliance achieved
- Increased capacity
- Future-proofed system
- Enabled new strategies

PITFALLS AND LESSONS LEARNED
================================================================================

COMMON MISTAKES
---------------

1. UNDERESTIMATING COMPLEXITY
   - FPGA development is hard
   - Takes longer than software
   - Need experienced team

2. INSUFFICIENT TESTING
   - Hardware bugs are expensive to fix
   - Comprehensive testbenches critical
   - Simulate, simulate, simulate

3. POOR RESOURCE PLANNING
   - Running out of FPGA resources mid-project
   - Need headroom for features
   - Start with larger FPGA than minimum

4. IGNORING TIMING CLOSURE
   - Timing violations cause incorrect behavior
   - Intermittent bugs hard to debug
   - Allocate time for optimization

5. LACK OF FLEXIBILITY
   - Hardcoding limits future changes
   - Parameterize designs
   - Plan for reconfiguration

6. INADEQUATE MONITORING
   - Can't debug what you can't observe
   - Built-in diagnostics essential
   - Hardware debug interfaces

LESSONS LEARNED
---------------

1. Start simple
   - Implement core functionality first
   - Add features incrementally
   - Prove concept before scaling

2. Reuse IP
   - Don't reinvent the wheel
   - Use vendor IP cores
   - Leverage open-source (carefully)

3. Hardware/software co-design
   - Not everything needs FPGA
   - Software for flexibility
   - Hardware for performance
   - Clear interfaces

4. Version control and testing
   - Treat HDL like software
   - Automated builds
   - Regression testing
   - CI/CD for FPGA

5. Documentation
   - Architecture docs
   - Interface specs
   - Register maps
   - Essential for maintenance

6. Plan for updates
   - Strategy changes
   - Protocol updates
   - Bug fixes
   - Remote update capability

FUTURE TRENDS
================================================================================

EMERGING TECHNOLOGIES
---------------------

1. HIGH-LEVEL SYNTHESIS MATURITY
   - Better C++ to RTL translation
   - Approaching hand-coded performance
   - Easier for software engineers
   - Timeline: Available now, improving

2. PARTIAL RECONFIGURATION
   - Update part of FPGA without full reload
   - Faster strategy changes
   - Timeline: Available but complex

3. VERSAL ACAP (Xilinx)
   - Adaptive Compute Acceleration Platform
   - FPGA + ARM cores + AI engines
   - More flexible
   - Timeline: Available now

4. INTEL AGILEX WITH CXL
   - Compute Express Link
   - Better CPU-FPGA coherency
   - Lower latency
   - Timeline: 2024-2025

5. OPTICAL NETWORKING
   - Direct optical FPGA interfaces
   - Eliminate electrical conversion
   - Lower latency
   - Timeline: 5+ years

6. 3D IC INTEGRATION
   - Stacked dies
   - Higher bandwidth
   - Lower latency
   - Timeline: 3-5 years

INDUSTRY EVOLUTION
------------------

1. Commodity FPGAs
   - More firms using FPGAs
   - Lowering barrier to entry
   - But still requires expertise

2. FPGA-as-a-Service
   - Cloud providers offering FPGAs
   - But latency too high for HFT
   - Useful for development/testing

3. Standardization
   - Common interfaces emerging
   - Easier to switch vendors
   - More portable designs

CONCLUSION
================================================================================

FPGAs provide unmatched latency and determinism for HFT applications. The
10-100x speedup justifies the complexity and cost for latency-sensitive
strategies. Key considerations:

WHEN TO USE FPGAs:
- Latency requirements < 10 microseconds
- High-throughput requirements (1M+ msg/sec)
- Deterministic performance critical
- Competitive necessity

WHEN TO AVOID FPGAs:
- Latency requirements > 50 microseconds (software sufficient)
- Rapidly changing strategies
- Limited budget (< $500K)
- No hardware expertise

SUCCESS FACTORS:
- Experienced team
- Clear requirements
- Adequate budget and timeline
- Long-term commitment
- Hybrid architecture (FPGA + software)

ROI ANALYSIS:
- High upfront cost ($500K-2M)
- Long development time (6-18 months)
- But significant latency advantage (10-100x)
- Payback typically 12-24 months for active strategies

The decision to use FPGAs is strategic. It's an arms race: if competitors use
them, you may need to as well. Evaluate based on your strategy, budget, and
competitive landscape.

Document version: 1.0
Last updated: 2025-01-15
