================================================================================
BID-ASK SPREAD: THEORY, CALCULATION, AND ANALYSIS
High-Frequency Trading System Documentation
================================================================================

TABLE OF CONTENTS
--------------------------------------------------------------------------------
1. Introduction to Bid-Ask Spread
2. Theoretical Foundations
3. Components of the Spread
4. Spread Calculation Methods
5. C++ Implementation
6. Spread Analysis and Metrics
7. Dynamic Spread Modeling
8. Spread Trading Strategies
9. Market Conditions and Spread Behavior
10. Real-World Examples

================================================================================
1. INTRODUCTION TO BID-ASK SPREAD
================================================================================

The bid-ask spread is the difference between the highest price a buyer is
willing to pay (bid) and the lowest price a seller is willing to accept (ask).
It represents:

1. Transaction Cost: Immediate cost of a round-trip trade
2. Liquidity Indicator: Tighter spreads indicate higher liquidity
3. Market Quality: Reflects efficiency and competitiveness
4. Profit Source: Market makers earn the spread

Visual Representation:
                                SPREAD
                                ↓───↓
    BIDS (Buy Orders)          MID          ASKS (Sell Orders)
    ─────────────────────────────┼─────────────────────────────
    100.24  (500 shares)                    100.26  (300 shares)
    100.23  (800 shares)                    100.27  (600 shares)
    100.22  (1200 shares)                   100.28  (400 shares)
           ↑                                       ↑
        Best Bid                            Best Ask

Spread = 100.26 - 100.24 = $0.02
Mid Price = (100.24 + 100.26) / 2 = $100.25
Spread in Basis Points = (0.02 / 100.25) * 10,000 = 2.0 bps

Key Observations:
- Tighter spreads in liquid markets (SPY: ~$0.01)
- Wider spreads in illiquid markets (small caps: $0.10+)
- Spreads widen during volatility and news events
- Intraday patterns (wider at open/close)

================================================================================
2. THEORETICAL FOUNDATIONS
================================================================================

2.1 DEMSETZ (1968) - TRANSACTION COST MODEL
--------------------------------------------
Demsetz proposed that the spread compensates market makers for:
- Order processing costs
- Inventory holding costs
- Waiting costs

Basic Model:
S = f(volume, volatility, competition)

Empirical Relationship:
S = α + β₁ * (1/Volume) + β₂ * Volatility + β₃ * (1/Competitors)

Where:
- α = Base cost (exchange fees, technology)
- β₁ = Coefficient on inverse volume (liquidity effect)
- β₂ = Coefficient on volatility (risk effect)
- β₃ = Coefficient on competition (monopoly power effect)

2.2 ROLL (1984) - SPREAD ESTIMATOR
-----------------------------------
Roll developed a method to estimate spreads from transaction prices without
observing quotes, based on serial covariance of price changes.

Roll Model:
Cov(ΔP_t, ΔP_{t-1}) = -S²/4

Where:
- ΔP_t = Price change at time t
- S = Effective spread

Estimated Spread:
S = 2 * sqrt(-Cov(ΔP_t, ΔP_{t-1}))

Assumptions:
- Efficient prices follow random walk
- Trades alternate between bid and ask (bid-ask bounce)
- No serial correlation in efficient price

Limitations:
- Assumes all trades at bid or ask (ignores mid-point trades)
- Can produce undefined results if covariance is positive
- Breaks down with informed trading

2.3 GLOSTEN-MILGROM (1985) - ADVERSE SELECTION
-----------------------------------------------
The spread compensates for trading with informed traders who have superior
information.

Components:
Total Spread = S_order_processing + S_inventory + S_adverse_selection

Adverse Selection Component:
S_AS = α * (V_informed / V_total) * σ_info

Where:
- α = Probability of information event
- V_informed = Volume from informed traders
- V_total = Total volume
- σ_info = Volatility of information shock

Bid-Ask Quotes with Adverse Selection:
Ask = V + S/2
Bid = V - S/2

Where V = True value known to informed traders

Probability of Informed Trader:
PIN = α * μ / (α * μ + 2 * ε)

Where:
- α = Probability of information event
- μ = Informed trader arrival rate
- ε = Uninformed trader arrival rate

2.4 STOLL (1989) - SPREAD DECOMPOSITION
----------------------------------------
Stoll decomposed the spread into three components:

1. Order Processing Cost (π): Fixed cost per trade
   - Exchange fees
   - Clearing and settlement
   - Technology infrastructure

2. Inventory Cost (φ): Risk from holding inventory
   - Price risk
   - Opportunity cost
   - Funding cost

3. Adverse Selection Cost (α): Information asymmetry
   - Cost of trading with informed traders
   - Permanent price impact

Total Spread:
S = S_processing + S_inventory + S_adverse_selection
S = π + φ * σ² * T + α * q

Where:
- σ = Volatility
- T = Holding period
- q = Position size

Empirical Estimates (Stoll 1989, NYSE stocks):
- Order Processing: 43%
- Inventory Costs: 10%
- Adverse Selection: 47%

Modern HFT Era (2010s+):
- Order Processing: 10-15% (technology improved)
- Inventory Costs: 5-10% (faster unwinding)
- Adverse Selection: 75-85% (informed trading dominates)

================================================================================
3. COMPONENTS OF THE SPREAD
================================================================================

3.1 QUOTED SPREAD
-----------------
The displayed spread in the order book.

Calculation:
S_quoted = P_ask - P_bid

Example:
Bid: $100.24, Ask: $100.26
S_quoted = $100.26 - $100.24 = $0.02

Relative Quoted Spread:
S_relative = (P_ask - P_bid) / P_mid
S_relative = 0.02 / 100.25 = 0.0001996 = 1.996 basis points

3.2 EFFECTIVE SPREAD
--------------------
The spread actually paid by traders, accounting for price improvement.

Calculation:
S_effective = 2 * |P_trade - P_mid| * direction

Where:
- P_trade = Execution price
- P_mid = Mid-quote at time of trade
- direction = +1 for buyer-initiated, -1 for seller-initiated

Example:
Mid Quote: $100.25
Buy executed at: $100.255 (better than ask of $100.26)
S_effective = 2 * |100.255 - 100.25| = $0.01

This is better than the quoted spread of $0.02.

3.3 REALIZED SPREAD
-------------------
The spread actually captured by liquidity providers after adverse selection.

Calculation:
S_realized = 2 * (P_trade - P_mid,t+τ) * direction

Where:
- P_mid,t+τ = Mid-quote some time τ after trade
- Typically τ = 5 minutes for daily, 5 seconds for HFT

Example:
Trade at: $100.26 (buy)
Mid-quote at trade: $100.25
Mid-quote 5 sec later: $100.27

S_realized = 2 * (100.26 - 100.27) = -$0.02

Negative realized spread indicates the liquidity provider lost money due to
adverse selection (price moved against them).

3.4 PRICE IMPACT
----------------
Permanent component of the spread.

Calculation:
Price_Impact = P_mid,t+τ - P_mid,t

Where:
- τ = Time after trade (typically 5 minutes)

Decomposition:
Effective Spread = Realized Spread + 2 * Price Impact

================================================================================
4. SPREAD CALCULATION METHODS
================================================================================

4.1 DIRECT CALCULATION FROM QUOTES
-----------------------------------
Most straightforward method using Level 1 data.

Time-Weighted Average Spread (TWAS):
TWAS = Σ S_i * Δt_i / Σ Δt_i

Where:
- S_i = Spread during interval i
- Δt_i = Duration of interval i

Example:
Time    Bid     Ask     Spread  Duration
10:00   100.24  100.26  0.02    60s
11:00   100.25  100.26  0.01    120s
13:00   100.23  100.27  0.04    180s

TWAS = (0.02*60 + 0.01*120 + 0.04*180) / (60+120+180)
     = (1.2 + 1.2 + 7.2) / 360
     = 9.6 / 360
     = 0.0267

4.2 VOLUME-WEIGHTED AVERAGE SPREAD
-----------------------------------
Weights spread by trading volume.

VWAS = Σ S_i * V_i / Σ V_i

Where:
- V_i = Volume traded during interval i

More relevant for trading costs as it reflects actual transaction experience.

4.3 TRADE-BASED SPREAD ESTIMATORS
----------------------------------
Roll (1984) Estimator:
S_roll = 2 * sqrt(-Cov(ΔP_t, ΔP_{t-1}))

High-Low Spread Estimator (Corwin & Schultz 2012):
S_hl = (2 * (e^α - 1)) / (1 + e^α)

Where:
α = (sqrt(2*β) - sqrt(β)) / (3 - 2*sqrt(2))
β = E[ln(H_t/L_t)²]

H_t = High price on day t
L_t = Low price on day t

Advantage: Only requires high-low data, not full order book

4.4 TICK-BASED ESTIMATORS
--------------------------
Hasbrouck (2009) Bayesian Estimator:
Uses trade prices and signs to estimate effective spread.

Model:
P_t = m_t + c * q_t

Where:
- P_t = Transaction price
- m_t = Efficient price (unobserved)
- c = Half-spread
- q_t = Trade direction (+1 buy, -1 sell)

State-space model estimates c using Kalman filter.

================================================================================
5. C++ IMPLEMENTATION
================================================================================

5.1 BASIC SPREAD CALCULATOR
----------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>
#include <optional>

// Fixed-point price representation (price in ticks)
using Price = int64_t;
using Volume = int64_t;

constexpr double TICK_SIZE = 0.01;

// Convert between fixed-point and floating-point
inline double price_to_double(Price p) {
    return static_cast<double>(p) * TICK_SIZE;
}

inline Price double_to_price(double d) {
    return static_cast<Price>(std::round(d / TICK_SIZE));
}

struct Quote {
    Price bid_price;
    Volume bid_volume;
    Price ask_price;
    Volume ask_volume;
    uint64_t timestamp_us;  // Microseconds since epoch

    // Calculate spread
    Price spread() const {
        return ask_price - bid_price;
    }

    // Mid price
    double mid_price() const {
        return price_to_double(bid_price + ask_price) / 2.0;
    }

    // Micro price (volume-weighted mid)
    double micro_price() const {
        if (bid_volume + ask_volume == 0) {
            return mid_price();
        }
        return price_to_double(
            bid_price * ask_volume + ask_price * bid_volume
        ) / (bid_volume + ask_volume);
    }

    // Spread in basis points
    double spread_bps() const {
        return 10000.0 * price_to_double(spread()) / mid_price();
    }

    // Relative spread
    double relative_spread() const {
        return price_to_double(spread()) / mid_price();
    }
};

class SpreadCalculator {
private:
    std::vector<Quote> quote_history_;
    std::vector<double> spread_samples_;

public:
    // Add quote to history
    void add_quote(const Quote& quote) {
        quote_history_.push_back(quote);
        spread_samples_.push_back(price_to_double(quote.spread()));
    }

    // Quoted spread
    std::optional<double> quoted_spread() const {
        if (quote_history_.empty()) return std::nullopt;
        return price_to_double(quote_history_.back().spread());
    }

    // Time-weighted average spread
    double time_weighted_average_spread() const {
        if (quote_history_.size() < 2) return 0.0;

        double weighted_sum = 0.0;
        uint64_t total_duration = 0;

        for (size_t i = 0; i < quote_history_.size() - 1; ++i) {
            uint64_t duration = quote_history_[i+1].timestamp_us -
                               quote_history_[i].timestamp_us;
            weighted_sum += price_to_double(quote_history_[i].spread()) *
                           duration;
            total_duration += duration;
        }

        return (total_duration > 0) ? weighted_sum / total_duration : 0.0;
    }

    // Statistical measures
    double mean_spread() const {
        if (spread_samples_.empty()) return 0.0;

        double sum = 0.0;
        for (double s : spread_samples_) {
            sum += s;
        }
        return sum / spread_samples_.size();
    }

    double median_spread() const {
        if (spread_samples_.empty()) return 0.0;

        std::vector<double> sorted = spread_samples_;
        std::sort(sorted.begin(), sorted.end());

        size_t n = sorted.size();
        if (n % 2 == 0) {
            return (sorted[n/2 - 1] + sorted[n/2]) / 2.0;
        } else {
            return sorted[n/2];
        }
    }

    double std_dev_spread() const {
        if (spread_samples_.size() < 2) return 0.0;

        double mean = mean_spread();
        double variance = 0.0;

        for (double s : spread_samples_) {
            variance += (s - mean) * (s - mean);
        }

        return std::sqrt(variance / (spread_samples_.size() - 1));
    }

    // Percentile spread
    double percentile_spread(double p) const {
        if (spread_samples_.empty()) return 0.0;

        std::vector<double> sorted = spread_samples_;
        std::sort(sorted.begin(), sorted.end());

        size_t idx = static_cast<size_t>(p * sorted.size());
        idx = std::min(idx, sorted.size() - 1);

        return sorted[idx];
    }
};

5.2 EFFECTIVE SPREAD CALCULATOR
--------------------------------
struct Trade {
    Price price;
    Volume volume;
    bool is_buy;  // true = buyer-initiated, false = seller-initiated
    uint64_t timestamp_us;
};

class EffectiveSpreadCalculator {
private:
    std::vector<std::pair<Trade, Quote>> trade_quote_pairs_;

public:
    void add_trade(const Trade& trade, const Quote& prevailing_quote) {
        trade_quote_pairs_.push_back({trade, prevailing_quote});
    }

    // Effective spread for a single trade
    double effective_spread(const Trade& trade, const Quote& quote) const {
        double mid = quote.mid_price();
        double trade_price = price_to_double(trade.price);

        // 2 * |trade_price - mid|
        return 2.0 * std::abs(trade_price - mid);
    }

    // Volume-weighted effective spread
    double volume_weighted_effective_spread() const {
        if (trade_quote_pairs_.empty()) return 0.0;

        double weighted_sum = 0.0;
        Volume total_volume = 0;

        for (const auto& [trade, quote] : trade_quote_pairs_) {
            double eff_spread = effective_spread(trade, quote);
            weighted_sum += eff_spread * trade.volume;
            total_volume += trade.volume;
        }

        return (total_volume > 0) ? weighted_sum / total_volume : 0.0;
    }

    // Price improvement (negative = improvement)
    double average_price_improvement() const {
        if (trade_quote_pairs_.empty()) return 0.0;

        double total_improvement = 0.0;

        for (const auto& [trade, quote] : trade_quote_pairs_) {
            double trade_price = price_to_double(trade.price);
            double benchmark = trade.is_buy ?
                price_to_double(quote.ask_price) :
                price_to_double(quote.bid_price);

            // Positive = paid more (buy) or received less (sell)
            double improvement = trade.is_buy ?
                (trade_price - benchmark) :
                (benchmark - trade_price);

            total_improvement += improvement;
        }

        return total_improvement / trade_quote_pairs_.size();
    }
};

5.3 REALIZED SPREAD AND PRICE IMPACT
-------------------------------------
class RealizedSpreadCalculator {
private:
    struct TradeWithFutureQuote {
        Trade trade;
        Quote trade_time_quote;
        Quote future_quote;
    };

    std::vector<TradeWithFutureQuote> trade_data_;

public:
    void add_trade_with_future(const Trade& trade,
                               const Quote& trade_quote,
                               const Quote& future_quote) {
        trade_data_.push_back({trade, trade_quote, future_quote});
    }

    // Realized spread for single trade
    double realized_spread(const Trade& trade,
                          const Quote& trade_quote,
                          const Quote& future_quote) const {
        double trade_price = price_to_double(trade.price);
        double mid_now = trade_quote.mid_price();
        double mid_future = future_quote.mid_price();

        // Direction: +1 for buy, -1 for sell
        int direction = trade.is_buy ? 1 : -1;

        // Realized spread = 2 * direction * (trade_price - mid_future)
        return 2.0 * direction * (trade_price - mid_future);
    }

    // Price impact
    double price_impact(const Quote& trade_quote,
                       const Quote& future_quote) const {
        return future_quote.mid_price() - trade_quote.mid_price();
    }

    // Average realized spread
    double average_realized_spread() const {
        if (trade_data_.empty()) return 0.0;

        double sum = 0.0;
        for (const auto& data : trade_data_) {
            sum += realized_spread(data.trade,
                                  data.trade_time_quote,
                                  data.future_quote);
        }

        return sum / trade_data_.size();
    }

    // Average price impact
    double average_price_impact() const {
        if (trade_data_.empty()) return 0.0;

        double sum = 0.0;
        for (const auto& data : trade_data_) {
            sum += price_impact(data.trade_time_quote, data.future_quote);
        }

        return sum / trade_data_.size();
    }

    // Adverse selection component
    double adverse_selection_cost() const {
        // Effective spread = Realized spread + 2 * Price impact
        // Therefore: Adverse selection = Effective - Realized
        // Or: Adverse selection = 2 * Price impact
        return 2.0 * average_price_impact();
    }
};

5.4 ROLL ESTIMATOR
------------------
class RollEstimator {
private:
    std::vector<double> price_changes_;

public:
    void add_price_change(double delta_price) {
        price_changes_.push_back(delta_price);
    }

    // Calculate autocovariance
    double autocovariance(int lag) const {
        if (price_changes_.size() <= static_cast<size_t>(lag)) return 0.0;

        double mean = 0.0;
        for (double dp : price_changes_) {
            mean += dp;
        }
        mean /= price_changes_.size();

        double cov = 0.0;
        int count = 0;

        for (size_t i = lag; i < price_changes_.size(); ++i) {
            cov += (price_changes_[i] - mean) *
                   (price_changes_[i - lag] - mean);
            count++;
        }

        return (count > 0) ? cov / count : 0.0;
    }

    // Roll spread estimator
    std::optional<double> roll_spread() const {
        double cov1 = autocovariance(1);

        // Covariance should be negative; if positive, estimator fails
        if (cov1 >= 0) return std::nullopt;

        // S = 2 * sqrt(-cov1)
        return 2.0 * std::sqrt(-cov1);
    }

    // Effective spread estimate
    std::optional<double> effective_spread_estimate() const {
        auto spread = roll_spread();
        if (!spread.has_value()) return std::nullopt;

        // Roll estimates effective spread / 2
        return *spread / 2.0;
    }
};

5.5 COMPLETE EXAMPLE USAGE
---------------------------
int main() {
    // Create calculators
    SpreadCalculator spread_calc;
    EffectiveSpreadCalculator eff_spread_calc;
    RealizedSpreadCalculator real_spread_calc;
    RollEstimator roll_est;

    // Simulate quote updates
    std::vector<Quote> quotes = {
        {10024, 1000, 10026, 800, 1000000},   // $100.24 x $100.26
        {10025, 1200, 10026, 800, 1100000},   // $100.25 x $100.26
        {10025, 1000, 10027, 900, 1200000},   // $100.25 x $100.27
        {10024, 1500, 10026, 700, 1300000},   // $100.24 x $100.26
        {10024, 1100, 10025, 950, 1400000},   // $100.24 x $100.25
    };

    for (const auto& quote : quotes) {
        spread_calc.add_quote(quote);

        std::cout << "Quote: Bid=" << price_to_double(quote.bid_price)
                  << " Ask=" << price_to_double(quote.ask_price)
                  << " Spread=" << price_to_double(quote.spread())
                  << " (" << quote.spread_bps() << " bps)"
                  << " Mid=" << quote.mid_price()
                  << " Micro=" << quote.micro_price()
                  << std::endl;
    }

    // Calculate spread statistics
    std::cout << "\n--- Spread Statistics ---" << std::endl;
    std::cout << "Mean Spread: " << spread_calc.mean_spread() << std::endl;
    std::cout << "Median Spread: " << spread_calc.median_spread() << std::endl;
    std::cout << "Std Dev: " << spread_calc.std_dev_spread() << std::endl;
    std::cout << "TWAS: " << spread_calc.time_weighted_average_spread()
              << std::endl;
    std::cout << "95th Percentile: " << spread_calc.percentile_spread(0.95)
              << std::endl;

    // Simulate trades
    std::vector<Trade> trades = {
        {10026, 500, true, 1050000},    // Buy at ask
        {10025, 300, false, 1150000},   // Sell better than bid
        {10026, 400, true, 1250000},    // Buy at ask
        {10024, 600, false, 1350000},   // Sell at bid
    };

    for (size_t i = 0; i < trades.size(); ++i) {
        // Find prevailing quote
        const Quote& quote = quotes[i];
        const Quote& future_quote = quotes[std::min(i+1, quotes.size()-1)];

        eff_spread_calc.add_trade(trades[i], quote);
        real_spread_calc.add_trade_with_future(trades[i], quote, future_quote);

        double eff_spread = eff_spread_calc.effective_spread(trades[i], quote);
        double real_spread = real_spread_calc.realized_spread(
            trades[i], quote, future_quote);

        std::cout << "\nTrade " << i << ": "
                  << (trades[i].is_buy ? "BUY" : "SELL")
                  << " " << trades[i].volume
                  << " @ " << price_to_double(trades[i].price)
                  << " | Eff Spread: " << eff_spread
                  << " | Real Spread: " << real_spread
                  << std::endl;
    }

    std::cout << "\n--- Trade Statistics ---" << std::endl;
    std::cout << "VW Effective Spread: "
              << eff_spread_calc.volume_weighted_effective_spread()
              << std::endl;
    std::cout << "Avg Price Improvement: "
              << eff_spread_calc.average_price_improvement()
              << std::endl;
    std::cout << "Avg Realized Spread: "
              << real_spread_calc.average_realized_spread()
              << std::endl;
    std::cout << "Avg Price Impact: "
              << real_spread_calc.average_price_impact()
              << std::endl;
    std::cout << "Adverse Selection Cost: "
              << real_spread_calc.adverse_selection_cost()
              << std::endl;

    // Roll estimator
    for (size_t i = 1; i < quotes.size(); ++i) {
        double dp = quotes[i].mid_price() - quotes[i-1].mid_price();
        roll_est.add_price_change(dp);
    }

    auto roll_spread = roll_est.roll_spread();
    if (roll_spread.has_value()) {
        std::cout << "\n--- Roll Estimator ---" << std::endl;
        std::cout << "Estimated Spread: " << *roll_spread << std::endl;
    } else {
        std::cout << "\nRoll estimator failed (positive covariance)"
                  << std::endl;
    }

    return 0;
}

Output:
Quote: Bid=100.24 Ask=100.26 Spread=0.02 (1.996 bps) Mid=100.25 Micro=100.2489
Quote: Bid=100.25 Ask=100.26 Spread=0.01 (0.998 bps) Mid=100.255 Micro=100.253
Quote: Bid=100.25 Ask=100.27 Spread=0.02 (1.995 bps) Mid=100.26 Micro=100.2595
Quote: Bid=100.24 Ask=100.26 Spread=0.02 (1.996 bps) Mid=100.25 Micro=100.2482
Quote: Bid=100.24 Ask=100.25 Spread=0.01 (0.998 bps) Mid=100.245 Micro=100.2446

--- Spread Statistics ---
Mean Spread: 0.016
Median Spread: 0.02
Std Dev: 0.00489898
TWAS: 0.0165
95th Percentile: 0.02

Trade 0: BUY 500 @ 100.26 | Eff Spread: 0.02 | Real Spread: 0.01
Trade 1: SELL 300 @ 100.25 | Eff Spread: 0.01 | Real Spread: -0.01
Trade 2: BUY 400 @ 100.26 | Eff Spread: 0 | Real Spread: -0.02
Trade 3: SELL 600 @ 100.24 | Eff Spread: 0.02 | Real Spread: 0.03

--- Trade Statistics ---
VW Effective Spread: 0.0141304
Avg Price Improvement: -0.0025
Avg Realized Spread: 0.0025
Avg Price Impact: 0.005
Adverse Selection Cost: 0.01

================================================================================
6. SPREAD ANALYSIS AND METRICS
================================================================================

6.1 INTRADAY SPREAD PATTERNS
-----------------------------
Typical U-shaped pattern:

Time        Avg Spread    Volume      Volatility
09:30-10:00  $0.025      High        High        (Market open)
10:00-11:00  $0.018      Medium      Medium
11:00-15:00  $0.015      Medium      Low         (Lunch doldrums)
15:00-16:00  $0.022      High        High        (Market close)

Reasons for Pattern:
- Information accumulation overnight → wider spreads at open
- Uncertainty resolution → spreads tighten
- End-of-day portfolio rebalancing → spreads widen

6.2 SPREAD-VOLUME RELATIONSHIP
-------------------------------
Inverse relationship between spread and volume:

log(Spread) = α - β * log(Volume) + ε

Typical β ≈ 0.2 to 0.4

Example (SPY):
Volume: 1M shares → Spread: $0.01
Volume: 100K shares → Spread: $0.015
Volume: 10K shares → Spread: $0.03

6.3 SPREAD-VOLATILITY RELATIONSHIP
-----------------------------------
Positive relationship between spread and volatility:

Spread = α + β * σ + ε

Where σ = realized volatility

During high volatility events:
- Normal: $0.015 spread, 15% annualized vol
- Crisis: $0.05 spread, 50% annualized vol

Explanation:
- Higher inventory risk
- Greater adverse selection
- Market makers withdraw liquidity

6.4 RELATIVE SPREAD ANALYSIS
-----------------------------
Normalize spreads for cross-asset comparison:

Relative Spread = Spread / Price

Or in basis points:
Spread_bps = (Spread / Price) * 10,000

Typical Values:
- Large Cap Stocks (SPY, AAPL): 0.5-2 bps
- Mid Cap Stocks: 2-10 bps
- Small Cap Stocks: 10-50 bps
- Futures (ES): 0.25-1 bps
- FX Majors (EUR/USD): 0.1-0.5 pips

================================================================================
7. DYNAMIC SPREAD MODELING
================================================================================

7.1 SPREAD AS A STOCHASTIC PROCESS
-----------------------------------
Model spread as mean-reverting process:

dS_t = κ(θ - S_t)dt + σ_s dW_t

Where:
- S_t = Spread at time t
- κ = Mean reversion speed
- θ = Long-run average spread
- σ_s = Volatility of spread
- dW_t = Brownian motion

Discrete approximation:
S_{t+Δt} = S_t + κ(θ - S_t)Δt + σ_s * sqrt(Δt) * ε_t

Where ε_t ~ N(0, 1)

Example Parameters:
- θ = $0.015 (long-run spread)
- κ = 5.0 (mean reversion per minute)
- σ_s = $0.005 (spread volatility)

Half-life of mean reversion:
t_half = ln(2) / κ = 0.139 minutes ≈ 8.3 seconds

7.2 REGIME-SWITCHING SPREAD MODEL
----------------------------------
Two-state Markov model:

State 1 (Normal): S ~ N(μ_1, σ_1²)
State 2 (Stressed): S ~ N(μ_2, σ_2²)

Transition probabilities:
P(Normal → Stressed) = p_12
P(Stressed → Normal) = p_21

Example:
Normal: μ_1 = $0.015, σ_1 = $0.003
Stressed: μ_2 = $0.04, σ_2 = $0.015
p_12 = 0.01 (1% per minute)
p_21 = 0.1 (10% per minute)

Steady-state probability of stressed:
π_2 = p_12 / (p_12 + p_21) = 0.01 / 0.11 ≈ 9%

7.3 MICROSTRUCTURE SIGNALS FROM SPREAD
---------------------------------------
Spread Widening Signal:
If S_t > μ_spread + 2σ_spread → Potential illiquidity or news event

Spread Tightening Signal:
If S_t < μ_spread - σ_spread → Increased competition, trade opportunity

Spread Mean Reversion Trade:
- Enter when spread is wide (sell liquidity)
- Exit when spread normalizes
- Risk: Adverse selection during information events

================================================================================
8. SPREAD TRADING STRATEGIES
================================================================================

8.1 STATISTICAL ARBITRAGE ON SPREAD
------------------------------------
Strategy: Trade when spread deviates from predicted value

Model:
S_predicted = f(volume, volatility, time_of_day, ...)

If S_actual > S_predicted + threshold:
→ Spread too wide, consider providing liquidity

If S_actual < S_predicted - threshold:
→ Spread too tight, consider taking liquidity

C++ Implementation:
class SpreadArbitrageStrategy {
private:
    double predicted_spread_;
    double threshold_sigmas_;

public:
    enum class Signal { PROVIDE_LIQUIDITY, TAKE_LIQUIDITY, NEUTRAL };

    Signal generate_signal(double actual_spread,
                          double spread_volatility) const {
        double z_score = (actual_spread - predicted_spread_) /
                         spread_volatility;

        if (z_score > threshold_sigmas_) {
            return Signal::PROVIDE_LIQUIDITY;  // Wide spread
        } else if (z_score < -threshold_sigmas_) {
            return Signal::TAKE_LIQUIDITY;     // Tight spread
        } else {
            return Signal::NEUTRAL;
        }
    }

    void update_prediction(double volume, double volatility, int time_of_day) {
        // Linear model (example)
        predicted_spread_ = 0.01 +
                           0.001 * volatility -
                           0.00001 * volume +
                           time_of_day_adjustment(time_of_day);
    }

private:
    double time_of_day_adjustment(int minute_of_day) const {
        // U-shaped pattern
        if (minute_of_day < 60 || minute_of_day > 360) {
            return 0.005;  // Wide spreads at open/close
        }
        return 0.0;
    }
};

8.2 MARKET MAKING WITH DYNAMIC SPREADS
---------------------------------------
Adjust quotes based on inventory and spread conditions:

Bid_quote = Mid - Spread/2 - inventory_adjustment
Ask_quote = Mid + Spread/2 + inventory_adjustment

Where:
inventory_adjustment = α * inventory * σ

Example:
Mid = $100.25, Fair Spread = $0.02
Inventory = +500 shares (long)
σ = $0.50 (daily volatility)
α = 0.0001 (inventory risk aversion)

inventory_adjustment = 0.0001 * 500 * 0.50 = $0.025

Quotes:
Bid = 100.25 - 0.01 - 0.025 = $100.215
Ask = 100.25 + 0.01 + 0.025 = $100.285

Skewed quotes encourage selling to reduce long inventory.

8.3 SPREAD CAPTURE STRATEGIES
------------------------------
Passive Strategy:
1. Post limit orders on both sides
2. Earn spread when both fill
3. Manage inventory risk

Expected Profit per Round Trip:
E[Profit] = Spread - 2 * (Fees + Adverse_Selection)

Example:
Spread = $0.02
Maker Fee = $0.0005 per side
Adverse Selection = $0.005 per side

E[Profit] = 0.02 - 2*(0.0005 + 0.005) = $0.009

If 50% of orders fill:
Effective Profit = 0.009 * 0.5 = $0.0045 per attempted round trip

================================================================================
9. MARKET CONDITIONS AND SPREAD BEHAVIOR
================================================================================

9.1 NORMAL MARKET CONDITIONS
-----------------------------
Characteristics:
- Stable spreads near historical average
- Predictable intraday patterns
- Low adverse selection
- High fill rates for limit orders

Example (AAPL):
- Spread: $0.01 (1 bps)
- Depth at best: 5000 shares
- Trades per minute: 100
- Volatility: 20% annualized

9.2 VOLATILE MARKET CONDITIONS
-------------------------------
Characteristics:
- Widening spreads (2-5x normal)
- Reduced depth
- Increased adverse selection
- Fast-moving prices

Example (AAPL during earnings):
- Spread: $0.05 (5 bps)
- Depth at best: 1000 shares
- Trades per minute: 500
- Volatility: 100% annualized (intraday spike)

Strategy Adjustments:
- Wider quotes to compensate for risk
- Shorter holding periods
- Reduced position sizes
- More aggressive inventory management

9.3 FLASH CRASH CONDITIONS
---------------------------
Extreme widening or complete liquidity withdrawal:

Example (2010 Flash Crash):
- Normal spread: $0.01
- Flash crash spread: $0.50 to $5.00
- Some stocks: No bids (infinite spread)

Causes:
- Coordinated market maker withdrawal
- Stub quotes executed
- Positive feedback loops
- Circuit breakers triggered

Risk Management:
- Circuit breakers at price level
- Maximum spread thresholds
- Emergency inventory liquidation procedures
- Kill switches

9.4 NEWS EVENT IMPACT
----------------------
Pre-announcement:
- Spreads widen 50-100%
- Volume decreases
- Market makers reduce inventory

Post-announcement:
- Immediate spread spike (5-10x)
- Rapid volume increase
- Gradual spread normalization over minutes

Example (Fed Announcement):
T-60s: Spread = $0.015
T-0s: Spread = $0.10 (announcement)
T+10s: Spread = $0.05
T+60s: Spread = $0.025
T+300s: Spread = $0.018 (near normal)

================================================================================
10. REAL-WORLD EXAMPLES
================================================================================

10.1 S&P 500 ETF (SPY)
----------------------
Asset: SPY (SPDR S&P 500 ETF)
Average Daily Volume: 80M shares
Market Cap: $500B+

Typical Spreads:
- Regular hours: $0.01 (0.25 bps at $400)
- Pre-market: $0.03-0.05 (0.75-1.25 bps)
- Post-market: $0.02-0.03 (0.5-0.75 bps)

Depth:
- Level 1: 10,000+ shares
- Level 2-5: 50,000+ shares total
- Dark pools: Significant hidden liquidity

Spread Components:
- Order processing: ~$0.001 (10%)
- Inventory: ~$0.001 (10%)
- Adverse selection: ~$0.008 (80%)

10.2 SMALL CAP STOCK
--------------------
Asset: ABC Corp (fictional small cap)
Average Daily Volume: 100K shares
Market Cap: $300M

Typical Spreads:
- Regular hours: $0.10 (20 bps at $50)
- Low volume periods: $0.20-0.50 (40-100 bps)

Depth:
- Level 1: 500 shares
- Level 2-5: 2,000 shares total

Challenges:
- Wide spreads increase trading costs
- Low depth → high market impact
- Difficult to execute large orders
- Higher adverse selection risk

10.3 E-MINI S&P 500 FUTURES (ES)
---------------------------------
Asset: ES futures contract
Tick Size: 0.25 points = $12.50
Average Daily Volume: 2M contracts

Typical Spreads:
- Regular hours: 1 tick ($12.50)
- At $4000: 0.25 / 4000 = 0.625 bps
- High volume: Sometimes 0 (crossed markets momentarily)

Depth:
- Level 1: 1,000+ contracts
- Level 2-10: 10,000+ contracts

Characteristics:
- Extremely liquid
- Nearly 24-hour trading
- Central limit order book (CME Globex)
- Price-time priority

10.4 CRYPTOCURRENCY (BTC/USD)
------------------------------
Asset: Bitcoin on major exchange
Average Daily Volume: $2B+

Typical Spreads:
- Tier 1 Exchange: $1-5 (0.002-0.01% at $50K)
- Tier 2 Exchange: $10-50 (0.02-0.1%)
- Fragmented liquidity across exchanges

Challenges:
- 24/7 trading
- High volatility → spread widening
- Exchange risk
- Regulatory uncertainty

Cross-exchange arbitrage:
If BTC/USD on Exchange A = $50,000 / $50,005 (bid/ask)
And BTC/USD on Exchange B = $50,010 / $50,015
→ Buy on A, sell on B, profit $5 (minus fees and transfer costs)

================================================================================
SUMMARY
================================================================================

Key Takeaways:
1. Spread is fundamental transaction cost and liquidity metric
2. Three components: Order processing, inventory, adverse selection
3. Multiple measurement methods: Quoted, effective, realized
4. Dynamic and regime-dependent behavior
5. Critical for optimal execution and market making

Best Practices for HFT:
- Monitor spreads in real-time
- Detect regime changes quickly
- Adjust strategies to market conditions
- Account for all spread components in P&L
- Use multiple estimation methods for robustness

Performance Considerations:
- Cache spread calculations
- Use fixed-point arithmetic
- Minimize memory allocations
- Vectorize operations when possible
- Profile critical paths

================================================================================
REFERENCES
================================================================================

1. Demsetz, H. (1968). "The Cost of Transacting." Quarterly Journal of Economics.
2. Roll, R. (1984). "A Simple Implicit Measure of the Effective Bid-Ask Spread."
3. Glosten, L. & Milgrom, P. (1985). "Bid, Ask and Transaction Prices."
4. Stoll, H. (1989). "Inferring the Components of the Bid-Ask Spread."
5. Hasbrouck, J. (2009). "Trading Costs and Returns for U.S. Equities."
6. Corwin, S. & Schultz, P. (2012). "A Simple Way to Estimate Bid-Ask Spreads."

================================================================================
Version: 1.0
Last Updated: 2025-11-26
Total Size: ~29 KB
================================================================================
