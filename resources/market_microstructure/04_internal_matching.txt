================================================================================
INTERNAL MATCHING AND DARK POOLS
High-Frequency Trading System Documentation
================================================================================

TABLE OF CONTENTS
--------------------------------------------------------------------------------
1. Introduction to Internal Matching
2. Dark Pool Mechanics
3. Internal Crossing Algorithms
4. Information Leakage and Privacy
5. C++ Implementation
6. Regulatory Framework
7. Interaction Models
8. Performance and Optimization
9. Risk Management
10. Real-World Examples

================================================================================
1. INTRODUCTION TO INTERNAL MATCHING
================================================================================

Internal matching (also called internalization or crossing) occurs when a
broker matches buy and sell orders from its own clients without sending
them to public exchanges. Benefits include:

- Reduced market impact
- Price improvement opportunities
- Lower exchange fees
- Information privacy
- Faster execution

Types of Internal Matching:
1. Broker-Dealer Internalization
   - Retail broker matches customer orders
   - May trade against own inventory
   - Example: Citadel, Virtu matching retail flow

2. Dark Pools
   - Private matching venues
   - No pre-trade transparency
   - Institutional-focused
   - Example: Liquidnet, IEX, NYSE Arca

3. Crossing Networks
   - Periodic batch auctions
   - Match at reference price (e.g., midpoint)
   - Example: ITG POSIT, Instinet CrossFinder

Market Share:
- US Equities: ~35-40% off-exchange (ATS + OTC)
- Dark Pools: ~15% of US equity volume
- Internalization: ~20-25% of US equity volume

================================================================================
2. DARK POOL MECHANICS
================================================================================

2.1 DARK POOL TYPES
-------------------
Independent Dark Pools:
- Operated by broker-dealers
- Multiple participants
- Various matching algorithms
- Examples: Liquidnet, IEX

Broker-Owned Pools:
- Single broker internalizes flow
- May include bank proprietary flow
- Examples: Goldman Sachs Sigma X, Morgan Stanley MS Pool

Consortium Pools:
- Owned by multiple brokers
- Shared liquidity
- Examples: Level ATS (now defunct)

Exchange-Owned Pools:
- Operated by exchanges
- Alternative to lit market
- Examples: NYSE American Equities, Nasdaq PSX

2.2 MATCHING MECHANISMS
-----------------------
Continuous Matching:
- Orders matched immediately upon arrival
- Similar to exchange matching
- Fast execution

Periodic Auctions:
- Orders collected over interval
- Match at single price
- Reduces gaming, more stability
- Example: IEX discrete pricing

Midpoint Matching:
- Execute at NBBO midpoint
- No price discovery
- Fair to both sides
- Most common dark pool mechanism

Reference Price Matching:
- Match at external reference (VWAP, arrival price)
- Reduces information leakage
- Common for large orders

2.3 MINIMUM SIZE REQUIREMENTS
------------------------------
Many dark pools have minimum size requirements to attract institutional flow
and deter HFT predators.

Typical Minimums:
- Small Dark Pools: 5,000 shares or $50,000
- Mid-Tier Pools: 10,000 shares or $100,000
- Block-Focused Pools: 50,000 shares (1 block)

Size-Based Priority:
Some pools give priority to larger orders to incentivize block trading.

2.4 INFORMATION LEAKAGE
-----------------------
Major concern: Does routing to dark pool reveal trading intent?

Information Leakage Channels:
1. Failed dark pool attempts → Predictable exchange routing
2. Partial fills reveal order size
3. Routing patterns reveal strategy
4. Timing of submissions

Mitigation Strategies:
- Randomize routing order
- Vary order sizes
- Use child order obfuscation
- Delay between submissions

================================================================================
3. INTERNAL CROSSING ALGORITHMS
================================================================================

3.1 SIMPLE MIDPOINT CROSSING
-----------------------------
Match orders at NBBO midpoint when both sides are available.

class MidpointCrossingEngine {
private:
    struct CrossOrder {
        OrderId order_id;
        Volume volume;
        bool is_buy;
        uint64_t timestamp_us;
        Price limit_price;  // Optional
    };

    std::vector<CrossOrder> buy_orders_;
    std::vector<CrossOrder> sell_orders_;

public:
    void add_order(const CrossOrder& order) {
        if (order.is_buy) {
            buy_orders_.push_back(order);
        } else {
            sell_orders_.push_back(order);
        }

        // Attempt to match
        attempt_crossing();
    }

    struct CrossResult {
        std::vector<Fill> fills;
        Volume matched_volume;
    };

    CrossResult attempt_crossing() {
        CrossResult result;

        if (buy_orders_.empty() || sell_orders_.empty()) {
            return result;
        }

        // Get NBBO midpoint
        Price midpoint = get_nbbo_midpoint();

        // Match orders at midpoint (FIFO)
        auto buy_it = buy_orders_.begin();
        auto sell_it = sell_orders_.begin();

        while (buy_it != buy_orders_.end() && sell_it != sell_orders_.end()) {
            // Check if orders willing to trade at midpoint
            if (buy_it->limit_price < midpoint ||
                sell_it->limit_price > midpoint) {
                break;
            }

            Volume match_volume = std::min(buy_it->volume, sell_it->volume);

            // Create fills
            uint64_t timestamp = get_timestamp_us();

            result.fills.push_back({
                buy_it->order_id,
                midpoint,
                match_volume,
                timestamp
            });

            result.fills.push_back({
                sell_it->order_id,
                midpoint,
                match_volume,
                timestamp
            });

            result.matched_volume += match_volume;

            // Update volumes
            buy_it->volume -= match_volume;
            sell_it->volume -= match_volume;

            // Remove fully filled orders
            if (buy_it->volume == 0) {
                buy_it = buy_orders_.erase(buy_it);
            }
            if (sell_it->volume == 0) {
                sell_it = sell_orders_.erase(sell_it);
            }
        }

        return result;
    }

private:
    Price get_nbbo_midpoint() {
        // Query external NBBO feed
        // Return midpoint price
        return 10025;  // Example: $100.25
    }

    uint64_t get_timestamp_us() {
        auto now = std::chrono::steady_clock::now();
        return std::chrono::duration_cast<std::chrono::microseconds>(
            now.time_since_epoch()).count();
    }
};

3.2 SIZE-PRIORITY CROSSING
---------------------------
Give priority to larger orders to encourage block trading.

class SizePriorityCrossingEngine {
private:
    struct SizedOrder {
        OrderId order_id;
        Volume volume;
        bool is_buy;
        uint64_t timestamp_us;
        Price limit_price;

        // Sort by size (descending), then time
        bool operator<(const SizedOrder& other) const {
            if (volume != other.volume) {
                return volume > other.volume;  // Larger first
            }
            return timestamp_us < other.timestamp_us;  // Earlier first
        }
    };

    std::vector<SizedOrder> buy_orders_;
    std::vector<SizedOrder> sell_orders_;

public:
    void add_order(const SizedOrder& order) {
        if (order.is_buy) {
            buy_orders_.push_back(order);
            std::sort(buy_orders_.begin(), buy_orders_.end());
        } else {
            sell_orders_.push_back(order);
            std::sort(sell_orders_.begin(), sell_orders_.end());
        }

        attempt_crossing();
    }

    std::vector<Fill> attempt_crossing() {
        std::vector<Fill> fills;

        Price midpoint = get_nbbo_midpoint();

        // Match largest orders first
        auto buy_it = buy_orders_.begin();
        auto sell_it = sell_orders_.begin();

        while (buy_it != buy_orders_.end() && sell_it != sell_orders_.end()) {
            if (buy_it->limit_price < midpoint ||
                sell_it->limit_price > midpoint) {
                ++buy_it;
                ++sell_it;
                continue;
            }

            Volume match_volume = std::min(buy_it->volume, sell_it->volume);
            uint64_t timestamp = get_timestamp_us();

            fills.push_back({buy_it->order_id, midpoint, match_volume, timestamp});
            fills.push_back({sell_it->order_id, midpoint, match_volume, timestamp});

            buy_it->volume -= match_volume;
            sell_it->volume -= match_volume;

            if (buy_it->volume == 0) {
                buy_it = buy_orders_.erase(buy_it);
            } else {
                ++buy_it;
            }

            if (sell_it->volume == 0) {
                sell_it = sell_orders_.erase(sell_it);
            } else {
                ++sell_it;
            }
        }

        return fills;
    }

private:
    Price get_nbbo_midpoint() { return 10025; }
    uint64_t get_timestamp_us() {
        return std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
    }
};

3.3 PERIODIC AUCTION CROSSING
------------------------------
Batch orders and match at single clearing price.

class PeriodicAuctionEngine {
private:
    struct AuctionOrder {
        OrderId order_id;
        Volume volume;
        bool is_buy;
        Price limit_price;
    };

    std::vector<AuctionOrder> pending_orders_;
    uint64_t last_auction_time_ = 0;
    uint64_t auction_interval_us_ = 100000;  // 100ms

public:
    void add_order(const AuctionOrder& order) {
        pending_orders_.push_back(order);
    }

    bool should_run_auction() {
        uint64_t now = get_timestamp_us();
        return (now - last_auction_time_) >= auction_interval_us_;
    }

    struct AuctionResult {
        Price clearing_price;
        Volume matched_volume;
        std::vector<Fill> fills;
    };

    AuctionResult run_auction() {
        AuctionResult result;

        if (pending_orders_.empty()) {
            return result;
        }

        // Find clearing price that maximizes volume
        result.clearing_price = find_clearing_price(pending_orders_);

        // Match orders at clearing price
        auto fills = match_at_price(pending_orders_, result.clearing_price);
        result.fills = fills;

        for (const auto& fill : fills) {
            result.matched_volume += fill.volume;
        }

        // Remove matched orders
        remove_matched_orders(fills);

        last_auction_time_ = get_timestamp_us();

        return result;
    }

private:
    Price find_clearing_price(const std::vector<AuctionOrder>& orders) {
        // Build supply and demand curves
        std::map<Price, Volume> buy_volume;
        std::map<Price, Volume> sell_volume;

        for (const auto& order : orders) {
            if (order.is_buy) {
                buy_volume[order.limit_price] += order.volume;
            } else {
                sell_volume[order.limit_price] += order.volume;
            }
        }

        // Find price that maximizes matched volume
        Price best_price = 0;
        Volume max_volume = 0;

        // Cumulative volumes
        Volume cum_buy = 0;
        Volume cum_sell = 0;

        // Scan prices
        std::set<Price> all_prices;
        for (const auto& [price, vol] : buy_volume) all_prices.insert(price);
        for (const auto& [price, vol] : sell_volume) all_prices.insert(price);

        for (Price price : all_prices) {
            // Calculate cumulative buy volume at this price or higher
            cum_buy = 0;
            for (const auto& [p, v] : buy_volume) {
                if (p >= price) cum_buy += v;
            }

            // Calculate cumulative sell volume at this price or lower
            cum_sell = 0;
            for (const auto& [p, v] : sell_volume) {
                if (p <= price) cum_sell += v;
            }

            Volume matchable = std::min(cum_buy, cum_sell);
            if (matchable > max_volume) {
                max_volume = matchable;
                best_price = price;
            }
        }

        // If no crossing, use midpoint
        if (best_price == 0) {
            best_price = get_nbbo_midpoint();
        }

        return best_price;
    }

    std::vector<Fill> match_at_price(const std::vector<AuctionOrder>& orders,
                                     Price clearing_price) {
        std::vector<Fill> fills;

        // Separate buy and sell orders willing to trade at clearing price
        std::vector<const AuctionOrder*> buyers;
        std::vector<const AuctionOrder*> sellers;

        for (const auto& order : orders) {
            if (order.is_buy && order.limit_price >= clearing_price) {
                buyers.push_back(&order);
            } else if (!order.is_buy && order.limit_price <= clearing_price) {
                sellers.push_back(&order);
            }
        }

        // Match pro-rata
        Volume total_buy = 0;
        for (auto* buyer : buyers) total_buy += buyer->volume;

        Volume total_sell = 0;
        for (auto* seller : sellers) total_sell += seller->volume;

        Volume total_matched = std::min(total_buy, total_sell);

        uint64_t timestamp = get_timestamp_us();

        // Allocate proportionally
        for (auto* buyer : buyers) {
            Volume fill_volume = (buyer->volume * total_matched) / total_buy;
            fills.push_back({buyer->order_id, clearing_price, fill_volume, timestamp});
        }

        for (auto* seller : sellers) {
            Volume fill_volume = (seller->volume * total_matched) / total_sell;
            fills.push_back({seller->order_id, clearing_price, fill_volume, timestamp});
        }

        return fills;
    }

    void remove_matched_orders(const std::vector<Fill>& fills) {
        std::unordered_set<OrderId> filled_orders;
        for (const auto& fill : fills) {
            filled_orders.insert(fill.order_id);
        }

        pending_orders_.erase(
            std::remove_if(pending_orders_.begin(), pending_orders_.end(),
                [&filled_orders](const AuctionOrder& order) {
                    return filled_orders.count(order.order_id) > 0;
                }),
            pending_orders_.end()
        );
    }

    Price get_nbbo_midpoint() { return 10025; }
    uint64_t get_timestamp_us() {
        return std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
    }
};

================================================================================
4. INFORMATION LEAKAGE AND PRIVACY
================================================================================

4.1 QUANTIFYING INFORMATION LEAKAGE
------------------------------------
Measure price impact after dark pool submission.

class InformationLeakageAnalyzer {
private:
    struct SubmissionEvent {
        uint64_t timestamp_us;
        Volume volume;
        bool is_buy;
        Price pre_mid;
        Price post_mid;
    };

    std::vector<SubmissionEvent> history_;

public:
    void record_submission(Volume volume, bool is_buy,
                          Price pre_mid, Price post_mid) {
        history_.push_back({
            get_timestamp_us(),
            volume,
            is_buy,
            pre_mid,
            post_mid
        });
    }

    // Calculate average information leakage
    double calculate_leakage_bps() {
        if (history_.empty()) return 0.0;

        double total_impact_bps = 0.0;

        for (const auto& event : history_) {
            double mid_change = (event.post_mid - event.pre_mid) * TICK_SIZE;
            int direction = event.is_buy ? 1 : -1;

            double impact = direction * mid_change;
            double impact_bps = (impact / (event.pre_mid * TICK_SIZE)) * 10000.0;

            total_impact_bps += impact_bps;
        }

        return total_impact_bps / history_.size();
    }

    // Probability of adverse price movement
    double adverse_selection_probability() {
        if (history_.empty()) return 0.0;

        int adverse_count = 0;

        for (const auto& event : history_) {
            bool adverse = (event.is_buy && event.post_mid > event.pre_mid) ||
                          (!event.is_buy && event.post_mid < event.pre_mid);

            if (adverse) adverse_count++;
        }

        return static_cast<double>(adverse_count) / history_.size();
    }

private:
    uint64_t get_timestamp_us() {
        return std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
    }
};

4.2 PRIVACY-PRESERVING TECHNIQUES
----------------------------------
Randomized Submission Timing:
class RandomizedRouter {
private:
    std::mt19937_64 rng_;
    std::uniform_int_distribution<uint64_t> delay_dist_;

public:
    RandomizedRouter()
        : rng_(std::random_device{}()),
          delay_dist_(0, 50000)  // 0-50ms random delay
    {}

    void submit_with_random_delay(const Order& order) {
        uint64_t delay_us = delay_dist_(rng_);

        // Schedule submission
        std::this_thread::sleep_for(std::chrono::microseconds(delay_us));

        // Submit order
        submit_order(order);
    }

private:
    void submit_order(const Order& order) {
        // Actual submission logic
    }
};

Order Size Obfuscation:
class SizeObfuscator {
public:
    std::vector<Volume> split_order(Volume total_size, int num_slices) {
        std::vector<Volume> slices;

        std::mt19937_64 rng(std::random_device{}());
        std::exponential_distribution<double> dist(1.0);

        // Generate random weights
        std::vector<double> weights;
        for (int i = 0; i < num_slices; ++i) {
            weights.push_back(dist(rng));
        }

        double sum_weights = std::accumulate(weights.begin(), weights.end(), 0.0);

        // Allocate volumes proportional to weights
        Volume remaining = total_size;
        for (int i = 0; i < num_slices - 1; ++i) {
            Volume slice = static_cast<Volume>(total_size * weights[i] / sum_weights);
            slices.push_back(slice);
            remaining -= slice;
        }
        slices.push_back(remaining);  // Last slice gets remainder

        return slices;
    }
};

================================================================================
5. SMART ORDER ROUTING WITH DARK POOLS
================================================================================

class SmartOrderRouter {
private:
    struct Venue {
        std::string name;
        bool is_dark_pool;
        double fill_rate;  // Historical fill probability
        uint64_t latency_us;
        double fee_per_share;
        Volume min_size;
    };

    std::vector<Venue> venues_;

public:
    SmartOrderRouter() {
        // Initialize venues
        venues_ = {
            {"NYSE", false, 0.95, 200, 0.0030, 1},
            {"NASDAQ", false, 0.93, 180, 0.0030, 1},
            {"IEX", false, 0.85, 300, 0.0009, 1},
            {"Sigma X", true, 0.35, 150, 0.0000, 5000},
            {"Liquidnet", true, 0.15, 400, 0.0000, 10000},
        };
    }

    struct RoutingPlan {
        std::vector<std::pair<std::string, Volume>> allocations;
        double expected_fill_rate;
        double expected_cost;
    };

    RoutingPlan create_routing_plan(Volume total_size, bool is_urgent) {
        RoutingPlan plan;

        Volume remaining = total_size;

        // Strategy: Try dark pools first for large orders
        if (total_size >= 10000 && !is_urgent) {
            for (const auto& venue : venues_) {
                if (!venue.is_dark_pool) continue;
                if (remaining < venue.min_size) continue;

                // Allocate portion to dark pool
                Volume allocation = std::min(remaining, total_size / 4);
                plan.allocations.push_back({venue.name, allocation});
                remaining -= allocation;

                if (remaining == 0) break;
            }
        }

        // Route remaining to lit venues
        for (const auto& venue : venues_) {
            if (venue.is_dark_pool) continue;

            Volume allocation = remaining / 2;  // Split between venues
            if (allocation > 0) {
                plan.allocations.push_back({venue.name, allocation});
                remaining -= allocation;
            }

            if (remaining == 0) break;
        }

        // Calculate expected metrics
        plan.expected_fill_rate = calculate_expected_fill_rate(plan);
        plan.expected_cost = calculate_expected_cost(plan);

        return plan;
    }

private:
    double calculate_expected_fill_rate(const RoutingPlan& plan) {
        double weighted_fill_rate = 0.0;
        Volume total = 0;

        for (const auto& [venue_name, volume] : plan.allocations) {
            auto venue_it = std::find_if(venues_.begin(), venues_.end(),
                [&venue_name](const Venue& v) { return v.name == venue_name; });

            if (venue_it != venues_.end()) {
                weighted_fill_rate += venue_it->fill_rate * volume;
                total += volume;
            }
        }

        return (total > 0) ? weighted_fill_rate / total : 0.0;
    }

    double calculate_expected_cost(const RoutingPlan& plan) {
        double total_cost = 0.0;

        for (const auto& [venue_name, volume] : plan.allocations) {
            auto venue_it = std::find_if(venues_.begin(), venues_.end(),
                [&venue_name](const Venue& v) { return v.name == venue_name; });

            if (venue_it != venues_.end()) {
                total_cost += venue_it->fee_per_share * volume;
            }
        }

        return total_cost;
    }
};

================================================================================
6. REGULATORY FRAMEWORK
================================================================================

6.1 REGULATION ATS (ALTERNATIVE TRADING SYSTEMS)
-------------------------------------------------
Dark pools in the US are regulated as Alternative Trading Systems under
SEC Regulation ATS.

Key Requirements:
1. Registration: File Form ATS with SEC
2. Fair Access: Cannot unfairly discriminate
3. Capacity: Maintain adequate system capacity
4. Disclosure: Disclose material information to subscribers
5. Order Display: Display orders if >5% of volume (Rule 301)
6. Recordkeeping: Maintain records for 3 years

Reporting Requirements:
- Form ATS quarterly
- Form ATS-N for initial operation and amendments
- Volume statistics to FINRA
- Trade reporting to consolidated tape

6.2 MIFID II (EUROPE)
----------------------
Markets in Financial Instruments Directive II

Dark Pool Volume Caps:
- Per venue cap: 4% of total volume
- EU-wide cap: 8% of total volume
- Measured over 12 months
- Waiver suspensions if exceeded

Large-in-Scale (LIS) Exemption:
Orders above size threshold exempt from caps.

Example LIS Thresholds (EUR):
- ADV < €500K: €50K minimum
- ADV €500K-€1M: €100K minimum
- ADV > €100M: €5M minimum

6.3 BEST EXECUTION REQUIREMENTS
--------------------------------
Brokers must seek best execution when routing to dark pools.

Factors Considered:
1. Price
2. Cost
3. Speed
4. Likelihood of execution
5. Likelihood of settlement
6. Size of order
7. Nature of order

Documentation Requirements:
- Execution quality statistics
- Regular reviews of routing logic
- Disclosure to clients
- Annual best execution reports

class BestExecutionMonitor {
private:
    struct ExecutionMetrics {
        std::string venue;
        double avg_fill_rate;
        double avg_price_improvement_bps;
        double avg_latency_ms;
        uint64_t order_count;
    };

    std::map<std::string, ExecutionMetrics> venue_metrics_;

public:
    void record_execution(const std::string& venue,
                         bool filled,
                         double price_improvement_bps,
                         double latency_ms) {
        auto& metrics = venue_metrics_[venue];

        double alpha = 0.1;  // EMA smoothing

        metrics.avg_fill_rate = alpha * (filled ? 1.0 : 0.0) +
                               (1 - alpha) * metrics.avg_fill_rate;

        if (filled) {
            metrics.avg_price_improvement_bps =
                alpha * price_improvement_bps +
                (1 - alpha) * metrics.avg_price_improvement_bps;
        }

        metrics.avg_latency_ms = alpha * latency_ms +
                                (1 - alpha) * metrics.avg_latency_ms;

        metrics.order_count++;
    }

    std::string get_best_venue(double required_fill_rate) {
        std::string best_venue;
        double best_score = -1.0;

        for (const auto& [venue, metrics] : venue_metrics_) {
            if (metrics.avg_fill_rate < required_fill_rate) {
                continue;  // Doesn't meet fill rate requirement
            }

            // Score: price improvement / latency
            double score = metrics.avg_price_improvement_bps /
                          (metrics.avg_latency_ms + 1.0);

            if (score > best_score) {
                best_score = score;
                best_venue = venue;
            }
        }

        return best_venue;
    }

    void print_statistics() {
        std::cout << "=== Best Execution Statistics ===" << std::endl;
        for (const auto& [venue, metrics] : venue_metrics_) {
            std::cout << venue << ":" << std::endl;
            std::cout << "  Fill Rate: " << metrics.avg_fill_rate * 100 << "%" << std::endl;
            std::cout << "  Price Improvement: " << metrics.avg_price_improvement_bps << " bps" << std::endl;
            std::cout << "  Latency: " << metrics.avg_latency_ms << " ms" << std::endl;
            std::cout << "  Orders: " << metrics.order_count << std::endl;
        }
    }
};

================================================================================
7. INTERACTION MODELS
================================================================================

7.1 PREDATORY TRADING IN DARK POOLS
------------------------------------
HFT firms may detect large orders in dark pools through:
- Ping orders (small orders to detect liquidity)
- Latency arbitrage
- Venue correlation

Detection Strategy:
class PingDetector {
private:
    struct PingPattern {
        uint64_t timestamp_us;
        Volume size;
        bool filled;
    };

    std::vector<PingPattern> recent_pings_;

public:
    bool detect_predatory_behavior() {
        if (recent_pings_.size() < 5) return false;

        // Check for rapid small orders
        int small_order_count = 0;
        uint64_t time_window = 1000000;  // 1 second

        uint64_t now = get_timestamp_us();

        for (const auto& ping : recent_pings_) {
            if (now - ping.timestamp_us > time_window) continue;

            if (ping.size < 500) {  // Small size threshold
                small_order_count++;
            }
        }

        // If many small orders in short time, likely pinging
        return small_order_count >= 5;
    }

    void add_order(Volume size, bool filled) {
        recent_pings_.push_back({get_timestamp_us(), size, filled});

        // Keep only recent history
        if (recent_pings_.size() > 100) {
            recent_pings_.erase(recent_pings_.begin());
        }
    }

private:
    uint64_t get_timestamp_us() {
        return std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
    }
};

7.2 ANTI-GAMING MECHANISMS
---------------------------
Dark pools implement various protections:

Minimum Resting Time:
Orders must rest in pool for minimum duration before matching.

class MinimumRestTimeEnforcer {
private:
    struct RestingOrder {
        OrderId order_id;
        uint64_t submission_time_us;
        Volume volume;
        bool is_buy;
    };

    std::vector<RestingOrder> resting_orders_;
    uint64_t min_rest_time_us_ = 100000;  // 100ms

public:
    void add_order(const Order& order) {
        resting_orders_.push_back({
            order.order_id,
            get_timestamp_us(),
            order.volume,
            order.is_buy
        });
    }

    std::vector<const RestingOrder*> get_matchable_orders() {
        std::vector<const RestingOrder*> matchable;
        uint64_t now = get_timestamp_us();

        for (const auto& order : resting_orders_) {
            if (now - order.submission_time_us >= min_rest_time_us_) {
                matchable.push_back(&order);
            }
        }

        return matchable;
    }

private:
    uint64_t get_timestamp_us() {
        return std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
    }
};

================================================================================
8. REAL-WORLD EXAMPLES
================================================================================

8.1 IEX (INVESTORS EXCHANGE)
-----------------------------
Features:
- 350μs "speed bump" coil delays orders
- Prevents latency arbitrage
- Discrete pricing (midpoint only)
- Crumbling quote indicator

Speed Bump Impact:
class IEXSpeedBump {
private:
    static constexpr uint64_t SPEED_BUMP_US = 350;

    struct DelayedOrder {
        Order order;
        uint64_t arrival_time_us;
    };

    std::deque<DelayedOrder> delayed_queue_;

public:
    void submit_order(const Order& order) {
        delayed_queue_.push_back({order, get_timestamp_us()});
    }

    std::vector<Order> get_released_orders() {
        std::vector<Order> released;
        uint64_t now = get_timestamp_us();

        while (!delayed_queue_.empty()) {
            const auto& delayed = delayed_queue_.front();

            if (now - delayed.arrival_time_us >= SPEED_BUMP_US) {
                released.push_back(delayed.order);
                delayed_queue_.pop_front();
            } else {
                break;  // Queue is time-ordered
            }
        }

        return released;
    }

private:
    uint64_t get_timestamp_us() {
        return std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
    }
};

8.2 LIQUIDNET
--------------
Block-focused institutional dark pool.

Features:
- Minimum 5,000 share orders
- Member-to-member negotiation
- Large institutional clients only
- High touch service

================================================================================
SUMMARY
================================================================================

Internal matching and dark pools provide:
- Reduced market impact for large orders
- Privacy from predatory traders
- Cost savings on exchange fees
- Price improvement opportunities

Key considerations:
- Information leakage risk
- Regulatory compliance (ATS, MiFID II)
- Best execution requirements
- Anti-gaming protections

Implementation requires:
- Efficient matching algorithms
- Privacy-preserving routing
- Latency monitoring
- Fill rate tracking
- Regulatory reporting

================================================================================
Version: 1.0
Last Updated: 2025-11-26
Total Size: ~25 KB
================================================================================
