================================================================================
MARKET PROFILE AND TPO ANALYSIS
High-Frequency Trading System Documentation
================================================================================

TABLE OF CONTENTS
1. Market Profile Concepts
2. Time Price Opportunity (TPO)
3. Profile Shapes and Patterns
4. Initial Balance and Range Extension
5. C++ Implementation
6. Trading Applications
7. Profile Statistics
8. Real-World Examples

================================================================================
1. MARKET PROFILE CONCEPTS
================================================================================

Market Profile organizes price and time data to show where the market spent time.
Created by J. Peter Steidlmayer at the Chicago Board of Trade.

Key Concepts:
- TPO (Time Price Opportunity): Unit of time at a price
- Initial Balance: First hour's range
- Value Area: 70% of TPOs
- Point of Control: Price with most TPOs
- Profile Types: Normal, trending, neutral

TPO Structure:
Price   09:30  09:45  10:00  10:15  10:30  TPOs
100.50    A                              1
100.49    A      B                       2
100.48    A      B      C                3
100.47    A      B      C      D         4  <- POC
100.46    A      B      C      D    E    5
100.45           B      C      D    E    4
100.44                  C      D    E    3
100.43                         D    E    2

class MarketProfile {
private:
    struct TPOData {
        int64_t price;
        char letter;  // A, B, C, etc. for each time period
        uint64_t timestamp;
    };
    
    std::vector<TPOData> tpos_;
    std::map<int64_t, int> tpo_count_;  // Price -> TPO count
    
    uint64_t session_start_;
    static constexpr uint64_t TPO_PERIOD_US = 30 * 60 * 1000000;  // 30 minutes
    
public:
    void add_price(int64_t price, uint64_t timestamp) {
        uint64_t period_index = (timestamp - session_start_) / TPO_PERIOD_US;
        char letter = 'A' + static_cast<char>(period_index % 26);
        
        tpos_.push_back({price, letter, timestamp});
        tpo_count_[price]++;
    }
    
    int64_t get_poc() const {
        if (tpo_count_.empty()) return 0;
        
        auto max_it = std::max_element(
            tpo_count_.begin(), tpo_count_.end(),
            [](const auto& a, const auto& b) { return a.second < b.second; }
        );
        
        return max_it->first;
    }
    
    struct ValueArea {
        int64_t val;  // Value Area Low
        int64_t vah;  // Value Area High
        int64_t poc;  // Point of Control
        int total_tpos;
    };
    
    ValueArea calculate_value_area() const {
        int total_tpos = tpos_.size();
        int target_tpos = static_cast<int>(total_tpos * 0.70);
        
        int64_t poc = get_poc();
        int current_tpos = tpo_count_.at(poc);
        
        int64_t val = poc;
        int64_t vah = poc;
        
        // Expand value area similar to volume profile
        // (Implementation details omitted for brevity)
        
        return {val, vah, poc, total_tpos};
    }
    
    void print_profile() const {
        if (tpo_count_.empty()) return;
        
        std::cout << "=== Market Profile ===" << std::endl;
        std::cout << "Price    TPOs" << std::endl;
        
        std::vector<std::pair<int64_t, int>> sorted(
            tpo_count_.begin(), tpo_count_.end());
        std::sort(sorted.begin(), sorted.end(),
                 [](const auto& a, const auto& b) { return a.first > b.first; });
        
        for (const auto& [price, count] : sorted) {
            std::cout << std::fixed << std::setprecision(2)
                     << (price * 0.01) << "    ";
            for (int i = 0; i < count; ++i) {
                std::cout << "#";
            }
            std::cout << " (" << count << ")" << std::endl;
        }
    }
};

================================================================================
2. TIME PRICE OPPORTUNITY (TPO)
================================================================================

TPO Count = Number of time periods price traded at that level

Higher TPO count = More acceptance at that price
Lower TPO count = Less acceptance (potential breakout point)

class TPOAnalyzer {
public:
    struct TPOStats {
        int64_t highest_tpo_count;
        int64_t lowest_tpo_count;
        double avg_tpo_count;
        int64_t poc_price;
    };
    
    static TPOStats analyze(const MarketProfile& profile) {
        // Calculate statistics
        // (Implementation details)
        return TPOStats{};
    }
    
    static bool is_high_volume_node(int tpo_count, double avg_count) {
        return tpo_count > avg_count * 1.5;
    }
    
    static bool is_low_volume_node(int tpo_count, double avg_count) {
        return tpo_count < avg_count * 0.5;
    }
};

================================================================================
3. PROFILE SHAPES AND PATTERNS
================================================================================

Profile Shapes:
1. Normal Distribution (Bell Curve)
   - Balanced market
   - Value area in middle
   - Mean reversion likely

2. P-Shape (Rotational)
   - Value area at top
   - Tested highs multiple times
   - Potential reversal down

3. b-Shape  
   - Value area at bottom
   - Tested lows multiple times
   - Potential reversal up

4. Trend Day
   - Value area at one end
   - Limited two-way trade
   - Continuation likely

class ProfileShape {
public:
    enum class Shape {
        NORMAL,      // Bell curve
        P_SHAPE,     // Value at top
        B_SHAPE,     // Value at bottom
        TREND_UP,    // Trending higher
        TREND_DOWN,  // Trending lower
        NEUTRAL      // Unidentified
    };
    
    static Shape classify(const MarketProfile::ValueArea& va,
                         int64_t session_high,
                         int64_t session_low) {
        int64_t range = session_high - session_low;
        if (range == 0) return Shape::NEUTRAL;
        
        // Calculate VA position in range
        double va_center = (va.val + va.vah) / 2.0;
        double range_position = (va_center - session_low) / (double)range;
        
        if (range_position > 0.7) {
            return Shape::P_SHAPE;  // VA near top
        } else if (range_position < 0.3) {
            return Shape::B_SHAPE;  // VA near bottom
        } else if (std::abs(range_position - 0.5) < 0.2) {
            return Shape::NORMAL;   // VA near middle
        }
        
        return Shape::NEUTRAL;
    }
    
    static const char* shape_to_string(Shape s) {
        switch(s) {
            case Shape::NORMAL: return "NORMAL";
            case Shape::P_SHAPE: return "P_SHAPE";
            case Shape::B_SHAPE: return "B_SHAPE";
            case Shape::TREND_UP: return "TREND_UP";
            case Shape::TREND_DOWN: return "TREND_DOWN";
            default: return "NEUTRAL";
        }
    }
};

================================================================================
4. INITIAL BALANCE AND RANGE EXTENSION
================================================================================

Initial Balance (IB): Range established in first trading period (usually first hour).

Range Extension: Price moves beyond IB
- If price extends up/down significantly → Trending day likely
- If price stays in IB → Range-bound day

class InitialBalance {
private:
    int64_t ib_high_ = 0;
    int64_t ib_low_ = 0;
    bool ib_set_ = false;
    uint64_t ib_end_time_;
    
public:
    explicit InitialBalance(uint64_t ib_duration_us = 3600 * 1000000) 
        : ib_end_time_(ib_duration_us) {}
    
    void update(int64_t price, uint64_t timestamp_from_open) {
        if (timestamp_from_open <= ib_end_time_) {
            if (!ib_set_) {
                ib_high_ = ib_low_ = price;
                ib_set_ = true;
            } else {
                ib_high_ = std::max(ib_high_, price);
                ib_low_ = std::min(ib_low_, price);
            }
        }
    }
    
    enum class Extension { NONE, UPWARD, DOWNWARD, BOTH };
    
    Extension check_extension(int64_t current_price) const {
        if (!ib_set_) return Extension::NONE;
        
        bool above = current_price > ib_high_;
        bool below = current_price < ib_low_;
        
        if (above && below) return Extension::BOTH;
        if (above) return Extension::UPWARD;
        if (below) return Extension::DOWNWARD;
        return Extension::NONE;
    }
    
    double ib_width_bps() const {
        if (!ib_set_ || ib_low_ == 0) return 0.0;
        return ((double)(ib_high_ - ib_low_) / ib_low_) * 10000.0;
    }
    
    bool is_narrow_ib(double threshold_bps = 50.0) const {
        return ib_width_bps() < threshold_bps;
    }
};

================================================================================
SUMMARY
================================================================================

Market Profile provides:
- Visual representation of price acceptance
- Time-based price analysis
- Value area identification
- Balance vs. imbalance detection

Key Components:
- TPO: Time spent at each price
- Initial Balance: First hour range
- Value Area: 70% of activity
- POC: Maximum acceptance price

Trading Applications:
- Mean reversion within value area
- Breakout trades from IB
- Fade extensions back to VA
- Trend identification from profile shape

Profile Shapes:
- Normal: Balanced, mean reversion
- P/b-Shape: Potential reversal
- Trending: Continuation likely

Implementation Considerations:
- 30-minute TPO periods standard
- Real-time profile updates
- Multiple timeframe profiles
- Profile comparison (day-over-day)

================================================================================
Version: 1.0
Last Updated: 2025-11-26
Total Size: ~20 KB
================================================================================
