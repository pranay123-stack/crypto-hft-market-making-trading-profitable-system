================================================================================
ORDER BOOK DEPTH: ANALYSIS AND IMPLEMENTATION
High-Frequency Trading System Documentation
================================================================================

TABLE OF CONTENTS
--------------------------------------------------------------------------------
1. Introduction to Order Book Depth
2. Depth of Market Concepts
3. Mathematical Foundations
4. C++ Data Structures
5. Depth Metrics and Analysis
6. Depth-Based Trading Signals
7. Market Impact and Depth
8. Dynamic Depth Modeling
9. Implementation Examples
10. Real-World Applications

================================================================================
1. INTRODUCTION TO ORDER BOOK DEPTH
================================================================================

Order book depth (Depth of Market - DOM) represents the quantity of buy and
sell orders at various price levels. It provides crucial information about:

- Available liquidity at different prices
- Potential price impact of orders
- Support and resistance levels
- Market sentiment and conviction
- Hidden liquidity patterns

Visual Representation of Order Book:
------------------------------------------------------------
ASKS (Sell Orders)                    Cumulative Volume
------------------------------------------------------------
$100.29    500  shares   ▐███          2,300 shares
$100.28    600  shares   ▐████         1,800 shares
$100.27    700  shares   ▐████▌        1,200 shares
$100.26    500  shares   ▐███           500 shares
------------------------------------------------------------
              MID-PRICE: $100.25
------------------------------------------------------------
$100.24    600  shares   ▐████          600 shares
$100.23    800  shares   ▐█████▌      1,400 shares
$100.22    900  shares   ▐██████      2,300 shares
$100.21    700  shares   ▐████▌       3,000 shares
------------------------------------------------------------
BIDS (Buy Orders)                     Cumulative Volume

Key Observations:
1. Best Bid: $100.24 (600 shares)
2. Best Ask: $100.26 (500 shares)
3. Spread: $0.02
4. Total Bid Volume (4 levels): 3,000 shares
5. Total Ask Volume (4 levels): 2,300 shares
6. Imbalance: Bid-heavy → potential upward pressure

================================================================================
2. DEPTH OF MARKET CONCEPTS
================================================================================

2.1 LEVELS OF DEPTH
-------------------
Level 1 (Top of Book):
- Best Bid Price and Size
- Best Ask Price and Size
- Last Trade Price and Size
- Most basic market data

Level 2 (Full Depth):
- All visible limit orders
- Multiple price levels on each side
- Aggregate volume at each price
- Number of orders per level

Level 3 (Order-Level):
- Individual order identities
- Order modifications and cancellations
- Full audit trail
- Typically restricted to market makers

2.2 DISPLAYED VS. HIDDEN LIQUIDITY
-----------------------------------
Displayed Liquidity:
- Visible limit orders in order book
- Price and size shown to all participants
- Subject to queue priority

Hidden Liquidity:
- Iceberg orders (partial display)
- Reserve orders (minimum quantity shown)
- Dark pool orders (not displayed)
- Can be 2-10x displayed liquidity

Total Available Liquidity = Displayed + Hidden + Latent

Latent Liquidity:
- Orders placed in response to price moves
- Market maker refresh orders
- Algorithmic order placement
- Most difficult to measure

2.3 BOOK IMBALANCE
------------------
Measures relative pressure between bid and ask sides.

Simple Volume Imbalance:
OBI = (V_bid - V_ask) / (V_bid + V_ask)

Where:
- V_bid = Total volume on bid side
- V_ask = Total volume on ask side

Value Range: [-1, +1]
- OBI > 0: Bid pressure (bullish)
- OBI < 0: Ask pressure (bearish)
- OBI ≈ 0: Balanced

Weighted Imbalance (Distance-Weighted):
OBI_w = Σ(V_bid_i / (P_mid - P_bid_i)) - Σ(V_ask_i / (P_ask_i - P_mid))

Gives more weight to orders near the mid-price.

2.4 DEPTH RESILIENCE
--------------------
Speed at which depth replenishes after being consumed.

Resilience Metric:
R = ΔDepth / Δt

Where:
- ΔDepth = Change in available depth
- Δt = Time elapsed

High Resilience:
- Depth quickly replenishes after trades
- Many market makers active
- Robust liquidity provision

Low Resilience:
- Depth depletes and stays low
- Limited market makers
- Potential liquidity crisis

================================================================================
3. MATHEMATICAL FOUNDATIONS
================================================================================

3.1 DEPTH AS A MEASURE OF MARKET IMPACT
----------------------------------------
Kyle's Lambda (Price Impact Coefficient):

λ = dP / dQ

Where:
- dP = Price change
- dQ = Order size

Inverse relationship with depth:
D = 1 / λ

Market Depth:
D = Q / dP

The volume needed to move price by dP.

Example:
To move price by $0.01, need to trade 5,000 shares
→ D = 5,000 / 0.01 = 500,000 shares per dollar

3.2 PRICE IMPACT FUNCTION
--------------------------
Square-root model (empirically validated):

ΔP = λ * sqrt(Q / V_avg)

Where:
- ΔP = Expected price impact
- λ = Impact coefficient
- Q = Order size
- V_avg = Average daily volume

Linear model (small orders):
ΔP = λ * Q

Power-law model (general):
ΔP = λ * Q^β

Typically: β ≈ 0.5 (square root) for large orders
          β ≈ 1.0 (linear) for small orders

3.3 DEPTH PROFILE FUNCTION
---------------------------
Cumulative depth as function of price deviation:

D(δ) = Σ V_i  for all levels where |P_i - P_mid| ≤ δ

Where:
- δ = Price deviation from mid
- V_i = Volume at level i
- P_i = Price at level i

Example:
D($0.01) = 1,100 shares (within 1 cent of mid)
D($0.05) = 5,500 shares (within 5 cents of mid)
D($0.10) = 12,000 shares (within 10 cents of mid)

Shape of D(δ) indicates liquidity structure:
- Steep: Concentrated liquidity near mid
- Flat: Liquidity spread across price levels

3.4 OPTIMAL ORDER PLACEMENT
----------------------------
Probability of execution vs. adverse selection tradeoff.

Place limit order at price P_limit:
- Higher P_limit (buy) / Lower P_limit (sell) → More likely to fill
- But more adverse selection risk

Optimal placement (Cont & Kukanov 2017):
P_limit^* = P_mid + α * Spread + β * (Queue_position / Total_depth)

Where:
- α = Aggressiveness parameter (0 to 0.5)
- β = Queue position penalty

Alpha values:
- α = 0: Place at mid (passive)
- α = 0.5: Place at far touch (aggressive)
- α > 0.5: Take liquidity (market order)

================================================================================
4. C++ DATA STRUCTURES
================================================================================

4.1 PRICE LEVEL STRUCTURE
--------------------------
#include <iostream>
#include <map>
#include <list>
#include <vector>
#include <optional>

using Price = int64_t;    // Fixed-point: price in ticks
using Volume = int64_t;    // Number of shares/contracts
using OrderId = uint64_t;

constexpr double TICK_SIZE = 0.01;

struct Order {
    OrderId order_id;
    Price price;
    Volume volume;
    uint64_t timestamp_us;
    bool is_buy;
};

struct PriceLevel {
    Price price;
    Volume total_volume;
    size_t order_count;
    std::list<Order> orders;  // FIFO queue

    PriceLevel() : price(0), total_volume(0), order_count(0) {}

    explicit PriceLevel(Price p) : price(p), total_volume(0), order_count(0) {}

    void add_order(const Order& order) {
        orders.push_back(order);
        total_volume += order.volume;
        order_count++;
    }

    bool remove_order(OrderId order_id) {
        for (auto it = orders.begin(); it != orders.end(); ++it) {
            if (it->order_id == order_id) {
                total_volume -= it->volume;
                orders.erase(it);
                order_count--;
                return true;
            }
        }
        return false;
    }

    bool modify_order(OrderId order_id, Volume new_volume) {
        for (auto& order : orders) {
            if (order.order_id == order_id) {
                total_volume = total_volume - order.volume + new_volume;
                order.volume = new_volume;
                return true;
            }
        }
        return false;
    }

    bool is_empty() const {
        return orders.empty();
    }
};

4.2 ORDER BOOK STRUCTURE
-------------------------
class OrderBook {
private:
    // Use map for ordered price levels
    // Bids: highest price first (reverse order)
    // Asks: lowest price first (normal order)
    std::map<Price, PriceLevel, std::greater<Price>> bids_;  // Descending
    std::map<Price, PriceLevel> asks_;                        // Ascending

    // Track orders for fast lookup
    std::unordered_map<OrderId, Price> order_to_price_;

public:
    // Add order to book
    void add_order(const Order& order) {
        if (order.is_buy) {
            bids_[order.price].add_order(order);
        } else {
            asks_[order.price].add_order(order);
        }
        order_to_price_[order.order_id] = order.price;
    }

    // Remove order from book
    bool remove_order(OrderId order_id) {
        auto it = order_to_price_.find(order_id);
        if (it == order_to_price_.end()) {
            return false;
        }

        Price price = it->second;
        bool removed = false;

        // Try bids
        auto bid_it = bids_.find(price);
        if (bid_it != bids_.end()) {
            removed = bid_it->second.remove_order(order_id);
            if (bid_it->second.is_empty()) {
                bids_.erase(bid_it);
            }
        }

        // Try asks
        if (!removed) {
            auto ask_it = asks_.find(price);
            if (ask_it != asks_.end()) {
                removed = ask_it->second.remove_order(order_id);
                if (ask_it->second.is_empty()) {
                    asks_.erase(ask_it);
                }
            }
        }

        if (removed) {
            order_to_price_.erase(it);
        }

        return removed;
    }

    // Modify order volume
    bool modify_order(OrderId order_id, Volume new_volume) {
        auto it = order_to_price_.find(order_id);
        if (it == order_to_price_.end()) {
            return false;
        }

        Price price = it->second;

        // Try bids
        auto bid_it = bids_.find(price);
        if (bid_it != bids_.end()) {
            return bid_it->second.modify_order(order_id, new_volume);
        }

        // Try asks
        auto ask_it = asks_.find(price);
        if (ask_it != asks_.end()) {
            return ask_it->second.modify_order(order_id, new_volume);
        }

        return false;
    }

    // Best bid and ask
    std::optional<PriceLevel> best_bid() const {
        if (bids_.empty()) return std::nullopt;
        return bids_.begin()->second;
    }

    std::optional<PriceLevel> best_ask() const {
        if (asks_.empty()) return std::nullopt;
        return asks_.begin()->second;
    }

    // Mid price
    std::optional<double> mid_price() const {
        auto bb = best_bid();
        auto ba = best_ask();
        if (!bb || !ba) return std::nullopt;

        return (bb->price + ba->price) * TICK_SIZE / 2.0;
    }

    // Spread
    std::optional<Price> spread() const {
        auto bb = best_bid();
        auto ba = best_ask();
        if (!bb || !ba) return std::nullopt;

        return ba->price - bb->price;
    }

    // Access levels
    const std::map<Price, PriceLevel, std::greater<Price>>& bids() const {
        return bids_;
    }

    const std::map<Price, PriceLevel>& asks() const {
        return asks_;
    }

    // Book statistics
    size_t bid_level_count() const { return bids_.size(); }
    size_t ask_level_count() const { return asks_.size(); }

    Volume total_bid_volume() const {
        Volume total = 0;
        for (const auto& [price, level] : bids_) {
            total += level.total_volume;
        }
        return total;
    }

    Volume total_ask_volume() const {
        Volume total = 0;
        for (const auto& [price, level] : asks_) {
            total += level.total_volume;
        }
        return total;
    }
};

4.3 DEPTH CALCULATOR
--------------------
class DepthCalculator {
private:
    const OrderBook& book_;

public:
    explicit DepthCalculator(const OrderBook& book) : book_(book) {}

    // Volume within N ticks of mid
    Volume depth_at_distance(int ticks) const {
        auto mid = book_.mid_price();
        if (!mid) return 0;

        Price mid_price = static_cast<Price>(std::round(*mid / TICK_SIZE));
        Price range = ticks;

        Volume bid_volume = 0;
        for (const auto& [price, level] : book_.bids()) {
            if (mid_price - price <= range) {
                bid_volume += level.total_volume;
            } else {
                break;  // Bids are sorted descending
            }
        }

        Volume ask_volume = 0;
        for (const auto& [price, level] : book_.asks()) {
            if (price - mid_price <= range) {
                ask_volume += level.total_volume;
            } else {
                break;  // Asks are sorted ascending
            }
        }

        return bid_volume + ask_volume;
    }

    // Volume in top N levels
    Volume depth_top_levels(int n) const {
        Volume bid_volume = 0;
        int count = 0;
        for (const auto& [price, level] : book_.bids()) {
            if (count++ >= n) break;
            bid_volume += level.total_volume;
        }

        Volume ask_volume = 0;
        count = 0;
        for (const auto& [price, level] : book_.asks()) {
            if (count++ >= n) break;
            ask_volume += level.total_volume;
        }

        return bid_volume + ask_volume;
    }

    // Cumulative depth profile
    struct DepthProfile {
        std::vector<Price> prices;
        std::vector<Volume> cumulative_bid_volume;
        std::vector<Volume> cumulative_ask_volume;
    };

    DepthProfile get_depth_profile(int max_levels = 10) const {
        DepthProfile profile;

        // Bid side
        Volume cum_bid = 0;
        int count = 0;
        for (const auto& [price, level] : book_.bids()) {
            if (count++ >= max_levels) break;
            cum_bid += level.total_volume;
            profile.prices.push_back(price);
            profile.cumulative_bid_volume.push_back(cum_bid);
        }

        // Ask side
        Volume cum_ask = 0;
        count = 0;
        for (const auto& [price, level] : book_.asks()) {
            if (count++ >= max_levels) break;
            cum_ask += level.total_volume;
            profile.prices.push_back(price);
            profile.cumulative_ask_volume.push_back(cum_ask);
        }

        return profile;
    }

    // Volume-weighted average price for given volume
    struct VWAPResult {
        double vwap;
        Volume volume_available;
        int levels_consumed;
    };

    VWAPResult calculate_vwap_for_volume(Volume target_volume,
                                         bool is_buy) const {
        Volume remaining = target_volume;
        Volume total_volume = 0;
        double weighted_sum = 0.0;
        int levels = 0;

        if (is_buy) {
            // Walk up ask side
            for (const auto& [price, level] : book_.asks()) {
                Volume vol = std::min(remaining, level.total_volume);
                weighted_sum += price_to_double(price) * vol;
                total_volume += vol;
                remaining -= vol;
                levels++;

                if (remaining == 0) break;
            }
        } else {
            // Walk down bid side
            for (const auto& [price, level] : book_.bids()) {
                Volume vol = std::min(remaining, level.total_volume);
                weighted_sum += price_to_double(price) * vol;
                total_volume += vol;
                remaining -= vol;
                levels++;

                if (remaining == 0) break;
            }
        }

        double vwap = (total_volume > 0) ? weighted_sum / total_volume : 0.0;
        return {vwap, total_volume, levels};
    }

private:
    double price_to_double(Price p) const {
        return static_cast<double>(p) * TICK_SIZE;
    }
};

================================================================================
5. DEPTH METRICS AND ANALYSIS
================================================================================

5.1 ORDER BOOK IMBALANCE (OBI)
-------------------------------
class ImbalanceCalculator {
private:
    const OrderBook& book_;

public:
    explicit ImbalanceCalculator(const OrderBook& book) : book_(book) {}

    // Simple volume imbalance
    double volume_imbalance() const {
        Volume bid_vol = book_.total_bid_volume();
        Volume ask_vol = book_.total_ask_volume();

        if (bid_vol + ask_vol == 0) return 0.0;

        return static_cast<double>(bid_vol - ask_vol) /
               static_cast<double>(bid_vol + ask_vol);
    }

    // Imbalance in top N levels
    double volume_imbalance_top_n(int n) const {
        Volume bid_vol = 0;
        int count = 0;
        for (const auto& [price, level] : book_.bids()) {
            if (count++ >= n) break;
            bid_vol += level.total_volume;
        }

        Volume ask_vol = 0;
        count = 0;
        for (const auto& [price, level] : book_.asks()) {
            if (count++ >= n) break;
            ask_vol += level.total_volume;
        }

        if (bid_vol + ask_vol == 0) return 0.0;

        return static_cast<double>(bid_vol - ask_vol) /
               static_cast<double>(bid_vol + ask_vol);
    }

    // Distance-weighted imbalance
    double weighted_imbalance() const {
        auto mid = book_.mid_price();
        if (!mid) return 0.0;

        double bid_weighted = 0.0;
        for (const auto& [price, level] : book_.bids()) {
            double distance = *mid - price * TICK_SIZE;
            if (distance > 0) {
                bid_weighted += level.total_volume / distance;
            }
        }

        double ask_weighted = 0.0;
        for (const auto& [price, level] : book_.asks()) {
            double distance = price * TICK_SIZE - *mid;
            if (distance > 0) {
                ask_weighted += level.total_volume / distance;
            }
        }

        if (bid_weighted + ask_weighted == 0) return 0.0;

        return (bid_weighted - ask_weighted) / (bid_weighted + ask_weighted);
    }

    // Order count imbalance
    double order_count_imbalance() const {
        size_t bid_orders = 0;
        for (const auto& [price, level] : book_.bids()) {
            bid_orders += level.order_count;
        }

        size_t ask_orders = 0;
        for (const auto& [price, level] : book_.asks()) {
            ask_orders += level.order_count;
        }

        if (bid_orders + ask_orders == 0) return 0.0;

        return static_cast<double>(bid_orders - ask_orders) /
               static_cast<double>(bid_orders + ask_orders);
    }
};

Example Output:
Volume Imbalance: 0.13 (13% more bid volume)
Top 3 Imbalance: 0.08 (8% more bid volume at top)
Weighted Imbalance: 0.21 (21% more bid pressure weighted by distance)
Order Count Imbalance: 0.05 (5% more bid orders)

Interpretation:
- Positive imbalance suggests buying pressure
- Imbalance > 0.3 is significant
- Combined with price action for confirmation

5.2 DEPTH SKEWNESS
------------------
Measures asymmetry in depth distribution:

Skew = (Depth_Ask - Depth_Bid) / (Depth_Ask + Depth_Bid)

Positive Skew: More ask depth → Potential downward pressure
Negative Skew: More bid depth → Potential upward pressure

class DepthMetrics {
public:
    double depth_skewness(const OrderBook& book, int levels = 5) {
        Volume bid_depth = 0;
        int count = 0;
        for (const auto& [price, level] : book.bids()) {
            if (count++ >= levels) break;
            bid_depth += level.total_volume;
        }

        Volume ask_depth = 0;
        count = 0;
        for (const auto& [price, level] : book.asks()) {
            if (count++ >= levels) break;
            ask_depth += level.total_volume;
        }

        if (bid_depth + ask_depth == 0) return 0.0;

        return static_cast<double>(ask_depth - bid_depth) /
               static_cast<double>(ask_depth + bid_depth);
    }

    // Depth concentration (how much is in top level vs total)
    double depth_concentration(const OrderBook& book) {
        auto bb = book.best_bid();
        auto ba = book.best_ask();
        if (!bb || !ba) return 0.0;

        Volume top_level = bb->total_volume + ba->total_volume;
        Volume total = book.total_bid_volume() + book.total_ask_volume();

        if (total == 0) return 0.0;

        return static_cast<double>(top_level) / static_cast<double>(total);
    }

    // Depth decay rate (how fast depth falls off with distance)
    double depth_decay_rate(const OrderBook& book) {
        auto profile = DepthCalculator(book).get_depth_profile(5);

        if (profile.cumulative_bid_volume.size() < 2) return 0.0;

        // Fit exponential decay: D(n) = D_0 * exp(-λ * n)
        // log(D(n)) = log(D_0) - λ * n
        // Use linear regression on log(depth)

        double sum_x = 0, sum_y = 0, sum_xy = 0, sum_xx = 0;
        int n = 0;

        for (size_t i = 0; i < profile.cumulative_bid_volume.size(); ++i) {
            if (profile.cumulative_bid_volume[i] > 0) {
                double x = static_cast<double>(i);
                double y = std::log(profile.cumulative_bid_volume[i]);
                sum_x += x;
                sum_y += y;
                sum_xy += x * y;
                sum_xx += x * x;
                n++;
            }
        }

        if (n < 2) return 0.0;

        // Slope = decay rate
        double slope = (n * sum_xy - sum_x * sum_y) /
                      (n * sum_xx - sum_x * sum_x);

        return -slope;  // Negative slope = positive decay rate
    }
};

================================================================================
6. DEPTH-BASED TRADING SIGNALS
================================================================================

6.1 IMBALANCE SIGNAL
--------------------
class ImbalanceSignal {
public:
    enum class Signal { STRONG_BUY, BUY, NEUTRAL, SELL, STRONG_SELL };

    Signal generate_signal(double imbalance) {
        if (imbalance > 0.5) return Signal::STRONG_BUY;
        if (imbalance > 0.2) return Signal::BUY;
        if (imbalance < -0.5) return Signal::STRONG_SELL;
        if (imbalance < -0.2) return Signal::SELL;
        return Signal::NEUTRAL;
    }

    // Multi-level imbalance signal
    Signal generate_composite_signal(const OrderBook& book) {
        ImbalanceCalculator calc(book);

        double imb1 = calc.volume_imbalance_top_n(1);
        double imb3 = calc.volume_imbalance_top_n(3);
        double imb5 = calc.volume_imbalance_top_n(5);
        double weighted = calc.weighted_imbalance();

        // Weighted average with more weight on near levels
        double composite = 0.4 * imb1 + 0.3 * imb3 + 0.2 * imb5 +
                          0.1 * weighted;

        return generate_signal(composite);
    }
};

6.2 DEPTH DEPLETION SIGNAL
---------------------------
Detects when depth is being aggressively consumed.

class DepthDepletionDetector {
private:
    struct DepthSnapshot {
        uint64_t timestamp_us;
        Volume bid_depth;
        Volume ask_depth;
    };

    std::vector<DepthSnapshot> history_;
    static constexpr size_t MAX_HISTORY = 100;

public:
    void add_snapshot(const OrderBook& book, uint64_t timestamp) {
        Volume bid = book.total_bid_volume();
        Volume ask = book.total_ask_volume();

        history_.push_back({timestamp, bid, ask});

        if (history_.size() > MAX_HISTORY) {
            history_.erase(history_.begin());
        }
    }

    // Detect rapid depth depletion
    bool is_depleting(bool bid_side, double threshold_pct = 0.2) const {
        if (history_.size() < 2) return false;

        const auto& current = history_.back();
        const auto& previous = history_[history_.size() - 2];

        Volume curr_depth = bid_side ? current.bid_depth : current.ask_depth;
        Volume prev_depth = bid_side ? previous.bid_depth : previous.ask_depth;

        if (prev_depth == 0) return false;

        double change_pct = static_cast<double>(curr_depth - prev_depth) /
                           static_cast<double>(prev_depth);

        return change_pct < -threshold_pct;  // Negative = depletion
    }

    // Depletion rate (volume per second)
    double depletion_rate(bool bid_side) const {
        if (history_.size() < 10) return 0.0;

        // Use last 10 snapshots
        size_t start_idx = history_.size() - 10;
        const auto& start = history_[start_idx];
        const auto& end = history_.back();

        Volume start_depth = bid_side ? start.bid_depth : end.ask_depth;
        Volume end_depth = bid_side ? end.bid_depth : end.ask_depth;

        uint64_t time_diff_us = end.timestamp_us - start.timestamp_us;
        if (time_diff_us == 0) return 0.0;

        double time_diff_s = time_diff_us / 1e6;
        return static_cast<double>(start_depth - end_depth) / time_diff_s;
    }
};

6.3 BOOK PRESSURE SIGNAL
-------------------------
Combines multiple depth metrics into unified pressure indicator.

class BookPressureIndicator {
public:
    struct Pressure {
        double buy_pressure;   // [0, 1]
        double sell_pressure;  // [0, 1]
        double net_pressure;   // [-1, 1]
    };

    Pressure calculate_pressure(const OrderBook& book) {
        ImbalanceCalculator imb_calc(book);
        DepthMetrics depth_metrics;

        // Component signals
        double vol_imb = imb_calc.volume_imbalance();
        double weighted_imb = imb_calc.weighted_imbalance();
        double order_imb = imb_calc.order_count_imbalance();
        double skew = depth_metrics.depth_skewness(book);

        // Combine signals (normalized to [0, 1])
        double buy_score = 0.0;
        double sell_score = 0.0;

        // Volume imbalance component
        if (vol_imb > 0) {
            buy_score += 0.3 * vol_imb;
        } else {
            sell_score += 0.3 * (-vol_imb);
        }

        // Weighted imbalance component
        if (weighted_imb > 0) {
            buy_score += 0.3 * weighted_imb;
        } else {
            sell_score += 0.3 * (-weighted_imb);
        }

        // Order count component
        if (order_imb > 0) {
            buy_score += 0.2 * order_imb;
        } else {
            sell_score += 0.2 * (-order_imb);
        }

        // Skewness component (inverted: negative skew = buy pressure)
        if (skew < 0) {
            buy_score += 0.2 * (-skew);
        } else {
            sell_score += 0.2 * skew;
        }

        double net = buy_score - sell_score;

        return {buy_score, sell_score, net};
    }
};

================================================================================
7. MARKET IMPACT AND DEPTH
================================================================================

7.1 ESTIMATED MARKET IMPACT FROM DEPTH
---------------------------------------
class MarketImpactEstimator {
public:
    // Walk the book to estimate impact
    double estimate_impact(const OrderBook& book,
                          Volume order_size,
                          bool is_buy) {
        DepthCalculator calc(book);
        auto result = calc.calculate_vwap_for_volume(order_size, is_buy);

        if (result.volume_available < order_size) {
            // Not enough liquidity
            return std::numeric_limits<double>::infinity();
        }

        auto mid = book.mid_price();
        if (!mid) return 0.0;

        // Impact = VWAP - Mid
        return is_buy ? (result.vwap - *mid) : (*mid - result.vwap);
    }

    // Estimate impact using power law
    double estimate_impact_power_law(double order_size,
                                    double avg_daily_volume,
                                    double volatility,
                                    double lambda = 0.5) {
        // ΔP = λ * σ * (Q / V)^β
        double participation = order_size / avg_daily_volume;
        double impact = lambda * volatility * std::pow(participation, 0.5);
        return impact;
    }

    // Immediate vs. permanent impact
    struct ImpactComponents {
        double temporary_impact;
        double permanent_impact;
        double total_impact;
    };

    ImpactComponents decompose_impact(double total_impact,
                                     double alpha = 0.3) {
        // Typical: 30% permanent, 70% temporary
        double permanent = alpha * total_impact;
        double temporary = (1.0 - alpha) * total_impact;

        return {temporary, permanent, total_impact};
    }
};

Example Usage:
OrderBook book;
// ... populate book ...

MarketImpactEstimator estimator;
Volume order_size = 10000;  // 10K shares

double impact = estimator.estimate_impact(book, order_size, true);
std::cout << "Estimated impact for " << order_size << " shares: $"
          << impact << std::endl;

auto components = estimator.decompose_impact(impact);
std::cout << "Temporary: $" << components.temporary_impact << std::endl;
std::cout << "Permanent: $" << components.permanent_impact << std::endl;

7.2 OPTIMAL ORDER SIZING
-------------------------
class OptimalOrderSizer {
public:
    // Size order to keep impact below threshold
    Volume calculate_max_size(const OrderBook& book,
                             bool is_buy,
                             double max_impact_bps) {
        auto mid = book.mid_price();
        if (!mid) return 0;

        double max_impact_dollars = (*mid * max_impact_bps) / 10000.0;

        // Walk the book
        Volume cumulative_volume = 0;
        double cumulative_cost = 0.0;

        if (is_buy) {
            for (const auto& [price, level] : book.asks()) {
                double price_dbl = price * TICK_SIZE;
                double impact = price_dbl - *mid;

                if (impact > max_impact_dollars) {
                    break;
                }

                cumulative_volume += level.total_volume;
                cumulative_cost += price_dbl * level.total_volume;
            }
        } else {
            for (const auto& [price, level] : book.bids()) {
                double price_dbl = price * TICK_SIZE;
                double impact = *mid - price_dbl;

                if (impact > max_impact_dollars) {
                    break;
                }

                cumulative_volume += level.total_volume;
                cumulative_cost += price_dbl * level.total_volume;
            }
        }

        return cumulative_volume;
    }

    // Size order as percentage of available depth
    Volume size_by_depth_percentage(const OrderBook& book,
                                   bool is_buy,
                                   double pct = 0.1) {
        Volume available = is_buy ? book.total_ask_volume() :
                                   book.total_bid_volume();

        return static_cast<Volume>(available * pct);
    }
};

================================================================================
8. DYNAMIC DEPTH MODELING
================================================================================

8.1 DEPTH REPLENISHMENT MODEL
------------------------------
Model how quickly depth returns after being consumed.

class DepthReplenishmentModel {
private:
    struct Event {
        uint64_t timestamp_us;
        Volume depth_consumed;
        Volume depth_before;
        Volume depth_after;
    };

    std::vector<Event> history_;

public:
    void record_event(uint64_t timestamp,
                     Volume consumed,
                     Volume before,
                     Volume after) {
        history_.push_back({timestamp, consumed, before, after});
    }

    // Exponential replenishment model: D(t) = D_∞ * (1 - e^(-λt))
    double estimate_replenishment_rate() const {
        if (history_.size() < 10) return 0.0;

        // Fit exponential model to data
        double sum_log_ratio = 0.0;
        double sum_time = 0.0;
        int count = 0;

        for (size_t i = 1; i < history_.size(); ++i) {
            const auto& prev = history_[i-1];
            const auto& curr = history_[i];

            if (prev.depth_after > 0 && curr.depth_after > 0) {
                double time_diff_s = (curr.timestamp_us - prev.timestamp_us)
                                    / 1e6;
                double ratio = static_cast<double>(curr.depth_after) /
                              static_cast<double>(prev.depth_after);

                if (ratio > 1.0) {  // Replenishment occurred
                    sum_log_ratio += std::log(ratio);
                    sum_time += time_diff_s;
                    count++;
                }
            }
        }

        if (count == 0 || sum_time == 0) return 0.0;

        // λ = ln(D_after / D_before) / time
        return sum_log_ratio / sum_time;
    }

    // Predict depth at future time
    Volume predict_depth(Volume current_depth,
                        double replenishment_rate,
                        double time_seconds,
                        Volume equilibrium_depth) {
        // D(t) = D_eq - (D_eq - D_0) * e^(-λt)
        double predicted = equilibrium_depth -
                          (equilibrium_depth - current_depth) *
                          std::exp(-replenishment_rate * time_seconds);

        return static_cast<Volume>(std::max(0.0, predicted));
    }
};

8.2 DEPTH RESILIENCE METRIC
----------------------------
class ResilienceCalculator {
public:
    // Resilience = Rate of depth recovery / Rate of depth depletion
    double calculate_resilience(const DepthReplenishmentModel& model,
                               double depletion_rate) {
        double replenishment_rate = model.estimate_replenishment_rate();

        if (depletion_rate == 0) return std::numeric_limits<double>::infinity();

        return replenishment_rate / depletion_rate;
    }

    // Classification
    enum class ResilienceClass {
        VERY_LOW,    // < 0.5
        LOW,         // 0.5 - 1.0
        MEDIUM,      // 1.0 - 2.0
        HIGH,        // 2.0 - 5.0
        VERY_HIGH    // > 5.0
    };

    ResilienceClass classify(double resilience) {
        if (resilience < 0.5) return ResilienceClass::VERY_LOW;
        if (resilience < 1.0) return ResilienceClass::LOW;
        if (resilience < 2.0) return ResilienceClass::MEDIUM;
        if (resilience < 5.0) return ResilienceClass::HIGH;
        return ResilienceClass::VERY_HIGH;
    }
};

================================================================================
9. IMPLEMENTATION EXAMPLES
================================================================================

9.1 COMPLETE DEPTH ANALYSIS SYSTEM
-----------------------------------
#include <iostream>
#include <iomanip>

class DepthAnalysisSystem {
private:
    OrderBook book_;
    ImbalanceCalculator imbalance_calc_;
    DepthCalculator depth_calc_;
    MarketImpactEstimator impact_estimator_;

public:
    DepthAnalysisSystem(const OrderBook& book)
        : book_(book),
          imbalance_calc_(book),
          depth_calc_(book),
          impact_estimator_() {}

    void print_analysis() {
        std::cout << "========== DEPTH ANALYSIS ==========" << std::endl;

        // Basic metrics
        auto mid = book_.mid_price();
        auto spread = book_.spread();

        if (mid && spread) {
            std::cout << std::fixed << std::setprecision(2);
            std::cout << "Mid Price: $" << *mid << std::endl;
            std::cout << "Spread: $" << (*spread * TICK_SIZE) << std::endl;
        }

        std::cout << "\nDepth Statistics:" << std::endl;
        std::cout << "Total Bid Volume: " << book_.total_bid_volume()
                  << std::endl;
        std::cout << "Total Ask Volume: " << book_.total_ask_volume()
                  << std::endl;
        std::cout << "Bid Levels: " << book_.bid_level_count() << std::endl;
        std::cout << "Ask Levels: " << book_.ask_level_count() << std::endl;

        // Imbalance metrics
        std::cout << "\nImbalance Metrics:" << std::endl;
        std::cout << std::setprecision(3);
        std::cout << "Volume Imbalance: "
                  << imbalance_calc_.volume_imbalance() << std::endl;
        std::cout << "Top 3 Imbalance: "
                  << imbalance_calc_.volume_imbalance_top_n(3) << std::endl;
        std::cout << "Weighted Imbalance: "
                  << imbalance_calc_.weighted_imbalance() << std::endl;

        // Depth at various distances
        std::cout << "\nDepth at Distance:" << std::endl;
        for (int ticks : {1, 5, 10, 20}) {
            Volume depth = depth_calc_.depth_at_distance(ticks);
            std::cout << "  " << ticks << " ticks: " << depth
                      << " shares" << std::endl;
        }

        // Market impact estimates
        std::cout << "\nEstimated Market Impact:" << std::endl;
        for (Volume size : {1000, 5000, 10000, 50000}) {
            double buy_impact = impact_estimator_.estimate_impact(
                book_, size, true);
            double sell_impact = impact_estimator_.estimate_impact(
                book_, size, false);

            std::cout << "  " << size << " shares:" << std::endl;
            std::cout << "    Buy Impact: $" << buy_impact << std::endl;
            std::cout << "    Sell Impact: $" << sell_impact << std::endl;
        }

        // Book pressure
        BookPressureIndicator pressure_calc;
        auto pressure = pressure_calc.calculate_pressure(book_);

        std::cout << "\nBook Pressure:" << std::endl;
        std::cout << "  Buy Pressure: " << pressure.buy_pressure << std::endl;
        std::cout << "  Sell Pressure: " << pressure.sell_pressure << std::endl;
        std::cout << "  Net Pressure: " << pressure.net_pressure << std::endl;
    }

    // Detect trading opportunities
    struct Opportunity {
        enum class Type { BUY, SELL, NONE };
        Type type;
        double confidence;  // [0, 1]
        std::string reason;
    };

    Opportunity detect_opportunity() {
        double imbalance = imbalance_calc_.volume_imbalance();
        double weighted_imb = imbalance_calc_.weighted_imbalance();

        // Strong buy signal
        if (imbalance > 0.3 && weighted_imb > 0.4) {
            return {Opportunity::Type::BUY, 0.8,
                   "Strong bid imbalance detected"};
        }

        // Strong sell signal
        if (imbalance < -0.3 && weighted_imb < -0.4) {
            return {Opportunity::Type::SELL, 0.8,
                   "Strong ask imbalance detected"};
        }

        // Moderate signals
        if (imbalance > 0.2) {
            return {Opportunity::Type::BUY, 0.5,
                   "Moderate bid imbalance"};
        }

        if (imbalance < -0.2) {
            return {Opportunity::Type::SELL, 0.5,
                   "Moderate ask imbalance"};
        }

        return {Opportunity::Type::NONE, 0.0, "No clear signal"};
    }
};

int main() {
    // Create and populate order book
    OrderBook book;

    // Add some sample orders
    book.add_order({1, 10024, 600, 1000000, true});
    book.add_order({2, 10023, 800, 1000100, true});
    book.add_order({3, 10022, 900, 1000200, true});
    book.add_order({4, 10021, 700, 1000300, true});

    book.add_order({5, 10026, 500, 1000400, false});
    book.add_order({6, 10027, 700, 1000500, false});
    book.add_order({7, 10028, 600, 1000600, false});
    book.add_order({8, 10029, 500, 1000700, false});

    // Analyze
    DepthAnalysisSystem analyzer(book);
    analyzer.print_analysis();

    auto opportunity = analyzer.detect_opportunity();
    std::cout << "\n========== TRADING OPPORTUNITY ==========" << std::endl;
    std::cout << "Type: ";
    switch (opportunity.type) {
        case DepthAnalysisSystem::Opportunity::Type::BUY:
            std::cout << "BUY";
            break;
        case DepthAnalysisSystem::Opportunity::Type::SELL:
            std::cout << "SELL";
            break;
        case DepthAnalysisSystem::Opportunity::Type::NONE:
            std::cout << "NONE";
            break;
    }
    std::cout << std::endl;
    std::cout << "Confidence: " << opportunity.confidence << std::endl;
    std::cout << "Reason: " << opportunity.reason << std::endl;

    return 0;
}

================================================================================
10. REAL-WORLD APPLICATIONS
================================================================================

10.1 MARKET MAKING
------------------
Use depth analysis to:
- Size quotes based on available depth
- Adjust spreads when depth is thin
- Skew quotes based on imbalance
- Manage inventory using depth signals

10.2 OPTIMAL EXECUTION
----------------------
- Split large orders based on depth profile
- Time orders to minimize impact
- Route to venues with better depth
- Adapt to changing depth conditions

10.3 LIQUIDITY PROVISION
------------------------
- Identify opportunities to earn spread
- Avoid adverse selection in thin books
- Provide liquidity when depth is low (higher spreads)
- Withdraw when risk is high

10.4 RISK MANAGEMENT
--------------------
- Monitor depth depletion as risk signal
- Use depth resilience for position sizing
- Detect liquidity crises early
- Implement depth-based circuit breakers

================================================================================
SUMMARY
================================================================================

Order book depth is critical for:
- Assessing available liquidity
- Estimating market impact
- Generating trading signals
- Managing execution risk

Key implementations provided:
- Efficient order book data structures
- Depth calculation and metrics
- Imbalance indicators
- Market impact estimation
- Complete analysis system

Performance considerations:
- Use cache-friendly data structures
- Minimize memory allocations
- Optimize hot paths
- Profile and benchmark

================================================================================
Version: 1.0
Last Updated: 2025-11-26
Total Size: ~30 KB
================================================================================
