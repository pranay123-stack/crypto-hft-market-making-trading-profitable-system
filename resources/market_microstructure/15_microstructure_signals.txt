================================================================================
MICROSTRUCTURE TRADING SIGNALS
High-Frequency Trading System Documentation
================================================================================

Microstructure signals exploit order book and trade flow information for
sub-second to minute-level predictions.

SIGNAL CATEGORIES:

1. ORDER BOOK SIGNALS:
   - Imbalance
   - Depth pressure
   - Queue position
   - Level changes

2. TRADE FLOW SIGNALS:
   - Order flow toxicity (VPIN)
   - Trade classification (buy/sell)
   - Volume delta
   - Trade size distribution

3. PRICE SIGNALS:
   - Microprice
   - Quote updates
   - Spread changes
   - Tick momentum

4. HYBRID SIGNALS:
   - Combined indicators
   - Machine learning features
   - Multi-timeframe analysis

================================================================================
1. ORDER BOOK IMBALANCE SIGNAL
================================================================================

class ImbalanceSignal {
public:
    struct Signal {
        enum class Direction { BUY, SELL, NEUTRAL };
        Direction direction;
        double strength;  // [0, 1]
        double confidence;  // [0, 1]
    };
    
    static Signal generate(int64_t bid_vol, int64_t ask_vol,
                          int num_levels = 1) {
        if (bid_vol + ask_vol == 0) {
            return {Signal::Direction::NEUTRAL, 0.0, 0.0};
        }
        
        double imbalance = (double)(bid_vol - ask_vol) / (bid_vol + ask_vol);
        
        Signal::Direction dir = Signal::Direction::NEUTRAL;
        if (imbalance > 0.2) dir = Signal::Direction::BUY;
        else if (imbalance < -0.2) dir = Signal::Direction::SELL;
        
        double strength = std::abs(imbalance);
        double confidence = std::min(1.0, strength * 2.0);
        
        return {dir, strength, confidence};
    }
    
    // Multi-level imbalance
    static Signal generate_multilevel(
        const std::vector<int64_t>& bid_volumes,
        const std::vector<int64_t>& ask_volumes
    ) {
        int64_t total_bid = std::accumulate(bid_volumes.begin(), 
                                           bid_volumes.end(), 0LL);
        int64_t total_ask = std::accumulate(ask_volumes.begin(),
                                           ask_volumes.end(), 0LL);
        
        return generate(total_bid, total_ask, bid_volumes.size());
    }
};

================================================================================
2. VPIN SIGNAL (VOLUME-SYNCHRONIZED PIN)
================================================================================

class VPINSignal {
private:
    double vpin_value_;
    static constexpr double HIGH_TOXICITY_THRESHOLD = 0.7;
    static constexpr double MEDIUM_TOXICITY_THRESHOLD = 0.5;
    
public:
    enum class ToxicityLevel { LOW, MEDIUM, HIGH, EXTREME };
    
    struct Signal {
        ToxicityLevel toxicity;
        bool should_provide_liquidity;
        bool should_take_liquidity;
        double vpin;
    };
    
    Signal generate(double vpin) {
        vpin_value_ = vpin;
        
        ToxicityLevel level = ToxicityLevel::LOW;
        if (vpin > 0.8) level = ToxicityLevel::EXTREME;
        else if (vpin > HIGH_TOXICITY_THRESHOLD) level = ToxicityLevel::HIGH;
        else if (vpin > MEDIUM_TOXICITY_THRESHOLD) level = ToxicityLevel::MEDIUM;
        
        bool provide_liquidity = (vpin < MEDIUM_TOXICITY_THRESHOLD);
        bool take_liquidity = (vpin < HIGH_TOXICITY_THRESHOLD);
        
        return {level, provide_liquidity, take_liquidity, vpin};
    }
};

================================================================================
3. MICROPRICE MOMENTUM SIGNAL
================================================================================

class MicropriceSignal {
private:
    std::deque<double> microprice_history_;
    size_t window_size_;
    
public:
    explicit MicropriceSignal(size_t window = 100) : window_size_(window) {}
    
    void update(double bid, double ask, int64_t bid_vol, int64_t ask_vol) {
        double micro = (bid * ask_vol + ask * bid_vol) / (bid_vol + ask_vol);
        microprice_history_.push_back(micro);
        
        if (microprice_history_.size() > window_size_) {
            microprice_history_.pop_front();
        }
    }
    
    struct Signal {
        double momentum;  // [-1, 1]
        double velocity;  // Price change per second
        bool is_bullish;
        bool is_bearish;
    };
    
    Signal generate() const {
        if (microprice_history_.size() < 2) {
            return {0.0, 0.0, false, false};
        }
        
        // Calculate momentum as recent price change
        double current = microprice_history_.back();
        double previous = microprice_history_[microprice_history_.size() - 11];
        
        double momentum = (current - previous) / previous;
        double velocity = momentum * 100.0;  // Normalized
        
        bool bullish = momentum > 0.0001;  // 1 bps
        bool bearish = momentum < -0.0001;
        
        return {momentum, velocity, bullish, bearish};
    }
};

================================================================================
4. TRADE FLOW SIGNAL
================================================================================

class TradeFlowSignal {
private:
    int64_t buy_volume_ = 0;
    int64_t sell_volume_ = 0;
    std::deque<int> recent_directions_;  // +1 for buy, -1 for sell
    
public:
    void add_trade(int64_t volume, bool is_buy) {
        if (is_buy) {
            buy_volume_ += volume;
            recent_directions_.push_back(1);
        } else {
            sell_volume_ += volume;
            recent_directions_.push_back(-1);
        }
        
        if (recent_directions_.size() > 100) {
            recent_directions_.pop_front();
        }
    }
    
    struct Signal {
        double flow_ratio;  // [-1, 1]
        int consecutive_direction;  // Streak length
        bool aggressive_buying;
        bool aggressive_selling;
    };
    
    Signal generate() const {
        int64_t total = buy_volume_ + sell_volume_;
        double ratio = (total > 0) ? 
                      (double)(buy_volume_ - sell_volume_) / total : 0.0;
        
        // Calculate consecutive trades in same direction
        int consecutive = 0;
        int last_dir = 0;
        for (auto it = recent_directions_.rbegin(); 
             it != recent_directions_.rend(); ++it) {
            if (last_dir == 0) {
                last_dir = *it;
                consecutive = 1;
            } else if (*it == last_dir) {
                consecutive++;
            } else {
                break;
            }
        }
        
        bool agg_buying = ratio > 0.3 && consecutive > 5;
        bool agg_selling = ratio < -0.3 && consecutive > 5;
        
        return {ratio, consecutive, agg_buying, agg_selling};
    }
};

================================================================================
5. SPREAD REVERSION SIGNAL
================================================================================

class SpreadReversionSignal {
private:
    double avg_spread_ = 0.0;
    double spread_std_ = 0.0;
    int sample_count_ = 0;
    
public:
    void update_statistics(double spread) {
        // Online mean and std calculation
        sample_count_++;
        double delta = spread - avg_spread_;
        avg_spread_ += delta / sample_count_;
        double delta2 = spread - avg_spread_;
        spread_std_ = std::sqrt((spread_std_ * spread_std_ * (sample_count_ - 1) + 
                                 delta * delta2) / sample_count_);
    }
    
    struct Signal {
        bool spread_too_wide;
        bool spread_too_tight;
        double z_score;
        bool mean_reversion_opportunity;
    };
    
    Signal generate(double current_spread) const {
        if (sample_count_ < 30 || spread_std_ == 0) {
            return {false, false, 0.0, false};
        }
        
        double z = (current_spread - avg_spread_) / spread_std_;
        
        bool too_wide = z > 2.0;   // 2 std above mean
        bool too_tight = z < -2.0;  // 2 std below mean
        bool mean_rev = std::abs(z) > 1.5;
        
        return {too_wide, too_tight, z, mean_rev};
    }
};

================================================================================
6. COMPOSITE SIGNAL GENERATOR
================================================================================

class CompositeSignalGenerator {
private:
    ImbalanceSignal imbalance_;
    VPINSignal vpin_;
    MicropriceSignal microprice_;
    TradeFlowSignal trade_flow_;
    SpreadReversionSignal spread_;
    
public:
    CompositeSignalGenerator() : microprice_(100) {}
    
    struct CompositeSignal {
        double score;  // [-1, 1]: negative=sell, positive=buy
        double confidence;  // [0, 1]
        std::string rationale;
    };
    
    struct Weights {
        double imbalance = 0.25;
        double vpin = 0.20;
        double microprice = 0.25;
        double trade_flow = 0.20;
        double spread = 0.10;
    };
    
    CompositeSignal generate(const Weights& weights = Weights()) {
        // Collect individual signals
        // (Assume all components have been updated)
        
        double score = 0.0;
        std::vector<std::string> reasons;
        
        // Imbalance component
        // (Implementation would aggregate all signals)
        
        // Calculate confidence based on agreement
        double confidence = 0.5;  // Baseline
        
        // Generate rationale
        std::string rationale = "Composite signal: ";
        
        return {score, confidence, rationale};
    }
};

================================================================================
7. MACHINE LEARNING FEATURES
================================================================================

class MLFeatureExtractor {
public:
    struct FeatureVector {
        // Order book features
        double obi_level1;
        double obi_level5;
        double weighted_obi;
        double bid_depth;
        double ask_depth;
        double depth_ratio;
        
        // Trade flow features
        double vpin;
        double trade_flow_ratio;
        double buy_volume;
        double sell_volume;
        
        // Price features
        double microprice;
        double mid_price;
        double spread_bps;
        double spread_zscore;
        
        // Momentum features
        double price_momentum_1s;
        double price_momentum_5s;
        double volume_momentum;
        
        // Volatility features
        double realized_vol;
        double vol_ratio;
        
        static constexpr size_t NUM_FEATURES = 18;
    };
    
    static FeatureVector extract(/* market data */) {
        FeatureVector features{};
        // Extract all features from current market state
        return features;
    }
    
    static std::vector<double> to_vector(const FeatureVector& features) {
        return {
            features.obi_level1,
            features.obi_level5,
            features.weighted_obi,
            features.bid_depth,
            features.ask_depth,
            features.depth_ratio,
            features.vpin,
            features.trade_flow_ratio,
            features.buy_volume,
            features.sell_volume,
            features.microprice,
            features.mid_price,
            features.spread_bps,
            features.spread_zscore,
            features.price_momentum_1s,
            features.price_momentum_5s,
            features.volume_momentum,
            features.realized_vol
        };
    }
};

================================================================================
8. SIGNAL VALIDATION AND BACKTESTING
================================================================================

class SignalValidator {
private:
    struct SignalOutcome {
        double signal_strength;
        double actual_return;  // Forward return after signal
        uint64_t timestamp_us;
    };
    
    std::vector<SignalOutcome> history_;
    
public:
    void record_signal(double strength, double forward_return, 
                      uint64_t timestamp) {
        history_.push_back({strength, forward_return, timestamp});
    }
    
    struct ValidationMetrics {
        double hit_rate;  // % correct direction
        double sharpe_ratio;
        double average_return;
        double max_drawdown;
        int signal_count;
    };
    
    ValidationMetrics calculate_metrics() const {
        if (history_.empty()) {
            return {0.0, 0.0, 0.0, 0.0, 0};
        }
        
        int correct = 0;
        double sum_returns = 0.0;
        double sum_squared_returns = 0.0;
        
        for (const auto& outcome : history_) {
            bool correct_direction = (outcome.signal_strength > 0 && 
                                     outcome.actual_return > 0) ||
                                    (outcome.signal_strength < 0 && 
                                     outcome.actual_return < 0);
            if (correct_direction) correct++;
            
            sum_returns += outcome.actual_return;
            sum_squared_returns += outcome.actual_return * outcome.actual_return;
        }
        
        double hit_rate = (double)correct / history_.size();
        double avg_return = sum_returns / history_.size();
        double variance = (sum_squared_returns / history_.size()) - 
                         (avg_return * avg_return);
        double sharpe = (variance > 0) ? avg_return / std::sqrt(variance) : 0.0;
        
        return {hit_rate, sharpe, avg_return, 0.0, (int)history_.size()};
    }
};

================================================================================
TRADING STRATEGY INTEGRATION
================================================================================

class MicrostructureStrategy {
private:
    CompositeSignalGenerator signal_gen_;
    SignalValidator validator_;
    
    double entry_threshold_ = 0.5;
    double exit_threshold_ = 0.1;
    
public:
    enum class Action { BUY, SELL, HOLD, EXIT };
    
    struct Decision {
        Action action;
        double confidence;
        int64_t recommended_size;
    };
    
    Decision make_decision() {
        auto signal = signal_gen_.generate();
        
        if (signal.confidence < 0.3) {
            return {Action::HOLD, signal.confidence, 0};
        }
        
        if (signal.score > entry_threshold_) {
            return {Action::BUY, signal.confidence, 1000};
        } else if (signal.score < -entry_threshold_) {
            return {Action::SELL, signal.confidence, 1000};
        } else if (std::abs(signal.score) < exit_threshold_) {
            return {Action::EXIT, signal.confidence, 0};
        }
        
        return {Action::HOLD, signal.confidence, 0};
    }
};

================================================================================
SUMMARY
================================================================================

Microstructure signals provide high-frequency trading edges:
- Order book imbalance predicts short-term moves
- VPIN detects toxic order flow
- Microprice captures fine-grained price changes
- Trade flow reveals institutional activity
- Spread reversion identifies mean reversion opportunities

Implementation:
- Sub-microsecond signal calculation
- Real-time feature extraction
- Machine learning integration
- Rigorous backtesting
- Continuous validation

Best Practices:
- Combine multiple signals
- Validate on out-of-sample data
- Monitor signal degradation
- Adapt to regime changes
- Account for transaction costs

================================================================================
Version: 1.0 | Size: ~23 KB
================================================================================
