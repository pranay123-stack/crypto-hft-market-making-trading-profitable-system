================================================================================
PRICE DISCOVERY AND FORMATION
High-Frequency Trading System Documentation
================================================================================

Price discovery is the process by which markets determine asset prices through
supply and demand interaction.

KEY CONCEPTS:

1. EFFICIENT MARKETS HYPOTHESIS (EMH):
- Weak form: Prices reflect all historical information
- Semi-strong: Prices reflect all public information
- Strong form: Prices reflect all public and private information

HFT's Role:
- Faster price discovery (information → price in milliseconds)
- Improved price efficiency
- Reduced arbitrage opportunities
- Tighter bid-ask spreads

2. INFORMATION AGGREGATION:
Markets aggregate dispersed information through trading.

Price_t = E[Fundamental_Value | Information_t]

class InformationContent {
public:
    static double measure_info_share(
        double price_variance,
        double public_info_variance,
        double private_info_variance
    ) {
        double total_info_variance = public_info_variance + private_info_variance;
        if (total_info_variance == 0) return 0.0;
        
        return public_info_variance / total_info_variance;
    }
};

3. HASBROUCK INFORMATION SHARE:
Measures venue's contribution to price discovery.

IS_venue = Var(venue_innovation) / Var(total_innovation)

For two venues (exchange 1, exchange 2):
IS_1 = ψ_1² / (ψ_1² + ψ_2² + 2ψ_1ψ_2ρ)

Where:
- ψ_i = Permanent innovation variance
- ρ = Correlation between innovations

class HasbrouckInformationShare {
private:
    double variance_venue1_;
    double variance_venue2_;
    double correlation_;
    
public:
    void calibrate(const std::vector<double>& returns1,
                  const std::vector<double>& returns2) {
        // Calculate variances and correlation
        // (Statistical calculation omitted)
        
        variance_venue1_ = calculate_variance(returns1);
        variance_venue2_ = calculate_variance(returns2);
        correlation_ = calculate_correlation(returns1, returns2);
    }
    
    double information_share_venue1() const {
        double numerator = variance_venue1_;
        double denominator = variance_venue1_ + variance_venue2_ + 
                           2 * std::sqrt(variance_venue1_ * variance_venue2_) * 
                           correlation_;
        
        if (denominator == 0) return 0.5;
        return numerator / denominator;
    }
    
    double information_share_venue2() const {
        return 1.0 - information_share_venue1();
    }
    
private:
    double calculate_variance(const std::vector<double>& data) const {
        if (data.size() < 2) return 0.0;
        
        double mean = std::accumulate(data.begin(), data.end(), 0.0) / data.size();
        double sq_sum = 0.0;
        for (double x : data) {
            sq_sum += (x - mean) * (x - mean);
        }
        return sq_sum / (data.size() - 1);
    }
    
    double calculate_correlation(const std::vector<double>& x,
                                const std::vector<double>& y) const {
        // Pearson correlation calculation
        // (Implementation omitted for brevity)
        return 0.0;
    }
};

4. PRICE LEADERSHIP:
One market leads, others follow.

Lead-Lag Relationship:
Price_follower,t = α + β × Price_leader,t-lag + ε_t

class LeadLagAnalyzer {
private:
    std::deque<double> venue1_prices_;
    std::deque<double> venue2_prices_;
    size_t max_lag_;
    
public:
    explicit LeadLagAnalyzer(size_t max_lag = 100) : max_lag_(max_lag) {}
    
    void add_prices(double venue1_price, double venue2_price) {
        venue1_prices_.push_back(venue1_price);
        venue2_prices_.push_back(venue2_price);
        
        if (venue1_prices_.size() > max_lag_) {
            venue1_prices_.pop_front();
            venue2_prices_.pop_front();
        }
    }
    
    struct LeadLagResult {
        int optimal_lag;  // Negative if venue2 leads
        double correlation;
    };
    
    LeadLagResult analyze() const {
        double max_corr = -1.0;
        int best_lag = 0;
        
        // Try different lags
        for (int lag = -10; lag <= 10; ++lag) {
            double corr = calculate_lagged_correlation(lag);
            if (std::abs(corr) > std::abs(max_corr)) {
                max_corr = corr;
                best_lag = lag;
            }
        }
        
        return {best_lag, max_corr};
    }
    
private:
    double calculate_lagged_correlation(int lag) const {
        // Calculate correlation with lag
        // (Implementation specific)
        return 0.0;
    }
};

5. WEIGHTED PRICE CONTRIBUTION (WPC):
Measures venue's importance in price formation.

WPC_i = (Volume_i / Total_Volume) × (1 / Latency_i)

class WeightedPriceContribution {
public:
    struct VenueStats {
        std::string name;
        int64_t volume;
        double latency_ms;
        double information_share;
    };
    
    static std::map<std::string, double> calculate_wpc(
        const std::vector<VenueStats>& venues
    ) {
        std::map<std::string, double> wpc;
        
        int64_t total_volume = 0;
        for (const auto& v : venues) {
            total_volume += v.volume;
        }
        
        double total_weighted = 0.0;
        for (const auto& v : venues) {
            double weight = (double)v.volume / total_volume;
            double latency_factor = 1.0 / (1.0 + v.latency_ms);
            double contrib = weight * latency_factor;
            
            wpc[v.name] = contrib;
            total_weighted += contrib;
        }
        
        // Normalize
        for (auto& [name, contrib] : wpc) {
            contrib /= total_weighted;
        }
        
        return wpc;
    }
};

6. COMMON EFFICIENT PRICE:
The "true" price underlying all venues.

P_venue = P_common + ε_venue

Where:
- P_common = Common efficient price
- ε_venue = Venue-specific noise

class CommonEfficientPrice {
private:
    std::map<std::string, double> venue_prices_;
    std::map<std::string, double> venue_weights_;
    
public:
    void update_price(const std::string& venue, double price, double weight = 1.0) {
        venue_prices_[venue] = price;
        venue_weights_[venue] = weight;
    }
    
    double calculate_common_price() const {
        double weighted_sum = 0.0;
        double total_weight = 0.0;
        
        for (const auto& [venue, price] : venue_prices_) {
            double weight = venue_weights_.at(venue);
            weighted_sum += price * weight;
            total_weight += weight;
        }
        
        return (total_weight > 0) ? weighted_sum / total_weight : 0.0;
    }
    
    double venue_deviation(const std::string& venue) const {
        double common = calculate_common_price();
        auto it = venue_prices_.find(venue);
        if (it == venue_prices_.end()) return 0.0;
        
        return it->second - common;
    }
};

MICROSTRUCTURE NOISE:
Observed Price = Efficient Price + Noise

P_t^obs = P_t^eff + ε_t

Noise Sources:
- Bid-ask bounce
- Discrete prices
- Market microstructure frictions

class MicrostructureNoiseEstimator {
public:
    static double estimate_noise_variance(const std::vector<double>& prices) {
        if (prices.size() < 2) return 0.0;
        
        // Roll (1984) estimator
        double sum_squared_diffs = 0.0;
        for (size_t i = 1; i < prices.size(); ++i) {
            double diff = prices[i] - prices[i-1];
            sum_squared_diffs += diff * diff;
        }
        
        // Noise variance = -0.5 * E[ΔP²]
        double avg_squared_diff = sum_squared_diffs / (prices.size() - 1);
        double noise_var = -0.5 * avg_squared_diff;
        
        return std::max(0.0, noise_var);  // Can't be negative
    }
};

TRADING APPLICATIONS:

1. Latency Arbitrage:
Exploit slow price discovery between venues.

class LatencyArbitrage {
public:
    struct Opportunity {
        std::string buy_venue;
        std::string sell_venue;
        double profit_bps;
        bool is_valid;
    };
    
    static Opportunity detect(
        const std::map<std::string, double>& venue_prices
    ) {
        if (venue_prices.size() < 2) {
            return {"", "", 0.0, false};
        }
        
        auto min_it = std::min_element(
            venue_prices.begin(), venue_prices.end(),
            [](const auto& a, const auto& b) { return a.second < b.second; }
        );
        
        auto max_it = std::max_element(
            venue_prices.begin(), venue_prices.end(),
            [](const auto& a, const auto& b) { return a.second < b.second; }
        );
        
        double profit_bps = ((max_it->second - min_it->second) / 
                            min_it->second) * 10000.0;
        
        // Need to exceed transaction costs
        bool is_valid = profit_bps > 2.0;  // 2 bps threshold
        
        return {min_it->first, max_it->first, profit_bps, is_valid};
    }
};

2. Information-Based Trading:
Trade based on which venue is leading price discovery.

3. Smart Order Routing:
Route to venues with best price discovery.

================================================================================
Version: 1.0 | Size: ~21 KB
================================================================================
