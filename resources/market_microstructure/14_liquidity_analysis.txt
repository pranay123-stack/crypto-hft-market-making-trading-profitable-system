================================================================================
LIQUIDITY ANALYSIS AND MEASUREMENT
High-Frequency Trading System Documentation
================================================================================

Liquidity is the ability to trade large size quickly with minimal price impact.

KEY DIMENSIONS OF LIQUIDITY:

1. Tightness: Bid-ask spread
2. Depth: Volume available at various prices
3. Immediacy: Speed of execution
4. Resilience: Speed of recovery after large trade

LIQUIDITY MEASURES:

1. BID-ASK SPREAD:
Quoted Spread = Ask - Bid
Relative Spread = (Ask - Bid) / Mid × 100%

class SpreadAnalyzer {
public:
    static double quoted_spread(double bid, double ask) {
        return ask - bid;
    }
    
    static double relative_spread_pct(double bid, double ask) {
        double mid = (bid + ask) / 2.0;
        if (mid == 0) return 0.0;
        return ((ask - bid) / mid) * 100.0;
    }
    
    static double spread_bps(double bid, double ask) {
        return relative_spread_pct(bid, ask) * 100.0;
    }
};

2. EFFECTIVE SPREAD:
Measures actual transaction cost.

Effective Spread = 2 × |Trade Price - Mid|

class EffectiveSpreadMeasure {
private:
    struct Trade {
        double price;
        double mid_at_trade;
        int64_t volume;
    };
    
    std::deque<Trade> trades_;
    
public:
    void add_trade(double price, double mid, int64_t volume) {
        trades_.push_back({price, mid, volume});
        if (trades_.size() > 1000) trades_.pop_front();
    }
    
    double average_effective_spread() const {
        if (trades_.empty()) return 0.0;
        
        double sum = 0.0;
        for (const auto& trade : trades_) {
            sum += 2.0 * std::abs(trade.price - trade.mid_at_trade);
        }
        return sum / trades_.size();
    }
    
    double volume_weighted_effective_spread() const {
        if (trades_.empty()) return 0.0;
        
        double weighted_sum = 0.0;
        int64_t total_volume = 0;
        
        for (const auto& trade : trades_) {
            double eff_spread = 2.0 * std::abs(trade.price - trade.mid_at_trade);
            weighted_sum += eff_spread * trade.volume;
            total_volume += trade.volume;
        }
        
        return (total_volume > 0) ? weighted_sum / total_volume : 0.0;
    }
};

3. MARKET DEPTH:
Volume available within specified price range.

Depth(δ) = Σ Volume at prices within δ of mid

class DepthAnalyzer {
public:
    struct DepthProfile {
        std::map<double, int64_t> price_to_volume;  // Price → Cumulative volume
    };
    
    static int64_t depth_at_distance(
        const std::vector<std::pair<double, int64_t>>& bids,
        const std::vector<std::pair<double, int64_t>>& asks,
        double mid_price,
        double distance_dollars
    ) {
        int64_t depth = 0;
        
        for (const auto& [price, volume] : bids) {
            if (mid_price - price <= distance_dollars) {
                depth += volume;
            }
        }
        
        for (const auto& [price, volume] : asks) {
            if (price - mid_price <= distance_dollars) {
                depth += volume;
            }
        }
        
        return depth;
    }
    
    static DepthProfile calculate_cumulative_depth(
        const std::vector<std::pair<double, int64_t>>& levels,
        bool is_bid
    ) {
        DepthProfile profile;
        int64_t cumulative = 0;
        
        for (const auto& [price, volume] : levels) {
            cumulative += volume;
            profile.price_to_volume[price] = cumulative;
        }
        
        return profile;
    }
};

4. AMIHUD ILLIQUIDITY RATIO:
Price impact per dollar of volume.

ILLIQ = |Return| / Volume

Higher value = Less liquid

class AmihudIlliquidity {
private:
    struct DailyData {
        double abs_return;
        double volume_dollars;
    };
    
    std::deque<DailyData> daily_data_;
    
public:
    void add_day(double abs_return, double volume_dollars) {
        daily_data_.push_back({abs_return, volume_dollars});
        if (daily_data_.size() > 252) daily_data_.pop_front();  // Keep 1 year
    }
    
    double calculate() const {
        if (daily_data_.empty()) return 0.0;
        
        double sum = 0.0;
        int count = 0;
        
        for (const auto& day : daily_data_) {
            if (day.volume_dollars > 0) {
                sum += day.abs_return / day.volume_dollars;
                count++;
            }
        }
        
        return (count > 0) ? sum / count : 0.0;
    }
};

5. KYLE'S LAMBDA:
Price impact coefficient.

λ = ΔP / Q

Where:
- ΔP = Price change
- Q = Order size

class KylesLambda {
private:
    struct TradeImpact {
        int64_t order_size;
        double price_change;
    };
    
    std::vector<TradeImpact> history_;
    
public:
    void record_trade(int64_t size, double price_before, double price_after) {
        history_.push_back({size, price_after - price_before});
    }
    
    double estimate_lambda() const {
        if (history_.size() < 10) return 0.0;
        
        // Linear regression: ΔP = λ * Q
        double sum_x = 0.0;    // order size
        double sum_y = 0.0;    // price change
        double sum_xy = 0.0;
        double sum_xx = 0.0;
        
        for (const auto& trade : history_) {
            sum_x += trade.order_size;
            sum_y += trade.price_change;
            sum_xy += trade.order_size * trade.price_change;
            sum_xx += trade.order_size * trade.order_size;
        }
        
        int n = history_.size();
        double lambda = (n * sum_xy - sum_x * sum_y) / 
                       (n * sum_xx - sum_x * sum_x);
        
        return lambda;
    }
    
    double market_depth() const {
        double lambda = estimate_lambda();
        return (lambda != 0) ? 1.0 / lambda : 0.0;
    }
};

6. LIQUIDITY SCORE:
Composite measure combining multiple factors.

Score = w1×Tightness + w2×Depth + w3×Resilience

class LiquidityScore {
public:
    struct Weights {
        double tightness = 0.4;
        double depth = 0.4;
        double resilience = 0.2;
    };
    
    struct Metrics {
        double spread_bps;
        int64_t depth_shares;
        double resilience_rate;
    };
    
    static double calculate(const Metrics& metrics, const Weights& weights = Weights()) {
        // Normalize each component to [0, 1]
        
        // Tightness: Lower spread = Higher score
        double tightness_score = 1.0 / (1.0 + metrics.spread_bps / 10.0);
        
        // Depth: More depth = Higher score
        double depth_score = std::tanh(metrics.depth_shares / 10000.0);
        
        // Resilience: Faster recovery = Higher score
        double resilience_score = std::tanh(metrics.resilience_rate / 100.0);
        
        return weights.tightness * tightness_score +
               weights.depth * depth_score +
               weights.resilience * resilience_score;
    }
    
    enum class LiquidityClass { VERY_LOW, LOW, MEDIUM, HIGH, VERY_HIGH };
    
    static LiquidityClass classify(double score) {
        if (score >= 0.8) return LiquidityClass::VERY_HIGH;
        if (score >= 0.6) return LiquidityClass::HIGH;
        if (score >= 0.4) return LiquidityClass::MEDIUM;
        if (score >= 0.2) return LiquidityClass::LOW;
        return LiquidityClass::VERY_LOW;
    }
};

INTRADAY LIQUIDITY PATTERNS:

class IntradayLiquidityPattern {
private:
    struct TimeSlot {
        int hour;
        int minute;
        double avg_spread;
        int64_t avg_depth;
        int sample_count;
    };
    
    std::map<int, TimeSlot> time_slots_;  // Minute of day → Stats
    
public:
    void update(int minute_of_day, double spread, int64_t depth) {
        auto& slot = time_slots_[minute_of_day];
        
        // Exponential moving average
        double alpha = 0.1;
        slot.avg_spread = alpha * spread + (1 - alpha) * slot.avg_spread;
        slot.avg_depth = static_cast<int64_t>(
            alpha * depth + (1 - alpha) * slot.avg_depth);
        slot.sample_count++;
    }
    
    double expected_spread(int minute_of_day) const {
        auto it = time_slots_.find(minute_of_day);
        return (it != time_slots_.end()) ? it->second.avg_spread : 0.0;
    }
    
    bool is_high_liquidity_time(int minute_of_day) const {
        // Typically: Market open (first hour) and close (last hour)
        int hour = minute_of_day / 60;
        return (hour == 9 || hour == 15);  // 9:30-10:30, 15:00-16:00
    }
};

LIQUIDITY RISK MANAGEMENT:

class LiquidityRiskManager {
private:
    LiquidityScore::Metrics current_metrics_;
    
public:
    void update_metrics(const LiquidityScore::Metrics& metrics) {
        current_metrics_ = metrics;
    }
    
    struct RiskAssessment {
        bool safe_to_trade;
        double max_recommended_size;
        std::string reason;
    };
    
    RiskAssessment assess_trade(int64_t intended_size, double price) {
        double score = LiquidityScore::calculate(current_metrics_);
        
        if (score < 0.3) {
            return {false, 0, "Liquidity too low"};
        }
        
        // Max size = 10% of available depth
        int64_t max_size = current_metrics_.depth_shares / 10;
        
        if (intended_size > max_size) {
            return {false, max_size, "Order size exceeds safe limit"};
        }
        
        return {true, intended_size, "Trade approved"};
    }
};

APPLICATIONS:

1. Execution Quality:
   - Trade during high liquidity periods
   - Avoid low liquidity times
   - Adjust order sizes based on depth

2. Market Making:
   - Wider spreads in low liquidity
   - Tighter spreads in high liquidity
   - Inventory management based on resilience

3. Risk Management:
   - Position limits based on liquidity
   - Stress testing liquidity shocks
   - Contingency liquidation plans

================================================================================
Version: 1.0 | Size: ~21 KB
================================================================================
