================================================================================
VWAP CALCULATION: IMPLEMENTATION AND ANALYSIS
High-Frequency Trading System Documentation
================================================================================

TABLE OF CONTENTS
--------------------------------------------------------------------------------
1. Introduction to VWAP
2. Mathematical Foundation
3. VWAP Calculation Methods
4. C++ Implementation
5. Rolling VWAP
6. Anchored VWAP
7. VWAP Bands and Deviation
8. Trading Strategies
9. Performance Optimization
10. Real-World Applications

================================================================================
1. INTRODUCTION TO VWAP
================================================================================

Volume-Weighted Average Price (VWAP) is the average price weighted by volume.
It's one of the most important benchmarks in trading:

VWAP = Σ(Price_i × Volume_i) / Σ(Volume_i)

Uses:
- Execution quality benchmark
- Intraday support/resistance
- Institutional order benchmarking
- Algorithm performance measurement
- Mean reversion trading signals

Advantages:
- Represents "fair" average price
- Accounts for liquidity distribution
- Industry-standard benchmark
- Simple to calculate and interpret

Disadvantages:
- Lagging indicator
- Can be manipulated
- Reset daily (traditional VWAP)
- Doesn't account for order size distribution

================================================================================
2. MATHEMATICAL FOUNDATION
===============================================================================

2.1 BASIC VWAP FORMULA
----------------------
For N trades:

VWAP = (P₁V₁ + P₂V₂ + ... + P_NV_N) / (V₁ + V₂ + ... + V_N)

     = Σᵢ₌₁ᴺ (Pᵢ × Vᵢ) / Σᵢ₌₁ᴺ Vᵢ

Where:
- Pᵢ = Price of trade i
- Vᵢ = Volume of trade i
- N = Number of trades

Example:
Time    Price   Volume  Price×Volume
09:30   100.00  1000    100,000
09:31   100.50  2000    201,000
09:32   100.25  1500    150,375
----------------------------------------
Totals          4500    451,375

VWAP = 451,375 / 4,500 = 100.306

2.2 INCREMENTAL VWAP UPDATE
----------------------------
Efficient online calculation:

VWAP_new = (VWAP_old × Volume_total + Price_new × Volume_new) /
           (Volume_total + Volume_new)

Or equivalently:

Σ(PV)_new = Σ(PV)_old + Price_new × Volume_new
ΣV_new = ΣV_old + Volume_new
VWAP_new = Σ(PV)_new / ΣV_new

This allows O(1) updates instead of recomputing entire sum.

2.3 VWAP DEVIATION
------------------
Measure how far price deviates from VWAP:

Deviation = (Current_Price - VWAP) / VWAP × 100%

Or in basis points:
Deviation_bps = (Current_Price - VWAP) / VWAP × 10,000

Standard Deviation from VWAP:
σ = sqrt(Σ(Price - VWAP)² × Volume / Σ Volume)

================================================================================
3. VWAP CALCULATION METHODS
================================================================================

3.1 TRADE-BASED VWAP
---------------------
Calculate from executed trades (most common):

class TradeBasedVWAP {
private:
    double cumulative_pv_ = 0.0;  // Price × Volume sum
    int64_t cumulative_volume_ = 0;

public:
    void add_trade(double price, int64_t volume) {
        cumulative_pv_ += price * volume;
        cumulative_volume_ += volume;
    }

    double get_vwap() const {
        if (cumulative_volume_ == 0) return 0.0;
        return cumulative_pv_ / cumulative_volume_;
    }

    int64_t get_total_volume() const {
        return cumulative_volume_;
    }

    void reset() {
        cumulative_pv_ = 0.0;
        cumulative_volume_ = 0;
    }
};

3.2 BAR-BASED VWAP
------------------
Calculate from OHLC bars:

struct Bar {
    double open;
    double high;
    double low;
    double close;
    int64_t volume;
    uint64_t timestamp_ms;
};

class BarBasedVWAP {
private:
    double cumulative_pv_ = 0.0;
    int64_t cumulative_volume_ = 0;

public:
    void add_bar(const Bar& bar) {
        // Use typical price: (H+L+C)/3
        double typical_price = (bar.high + bar.low + bar.close) / 3.0;

        cumulative_pv_ += typical_price * bar.volume;
        cumulative_volume_ += bar.volume;
    }

    double get_vwap() const {
        if (cumulative_volume_ == 0) return 0.0;
        return cumulative_pv_ / cumulative_volume_;
    }
};

3.3 TICK-BASED VWAP
-------------------
Calculate from every price change:

class TickBasedVWAP {
private:
    double cumulative_pv_ = 0.0;
    int64_t cumulative_volume_ = 0;
    double last_price_ = 0.0;

public:
    void on_quote_update(double bid, double ask, int64_t bid_vol, int64_t ask_vol) {
        double mid = (bid + ask) / 2.0;
        int64_t total_vol = bid_vol + ask_vol;

        cumulative_pv_ += mid * total_vol;
        cumulative_volume_ += total_vol;

        last_price_ = mid;
    }

    double get_vwap() const {
        if (cumulative_volume_ == 0) return 0.0;
        return cumulative_pv_ / cumulative_volume_;
    }
};

================================================================================
4. C++ IMPLEMENTATION
================================================================================

4.1 COMPLETE VWAP ENGINE
------------------------
#include <iostream>
#include <vector>
#include <cmath>
#include <optional>

struct Trade {
    double price;
    int64_t volume;
    uint64_t timestamp_us;
    bool is_buy;  // Optional: track direction
};

class VWAPCalculator {
private:
    double cumulative_pv_ = 0.0;
    int64_t cumulative_volume_ = 0;
    uint64_t start_time_us_ = 0;
    std::vector<Trade> trades_;  // Optional: store for analysis

public:
    void reset(uint64_t timestamp_us = 0) {
        cumulative_pv_ = 0.0;
        cumulative_volume_ = 0;
        start_time_us_ = timestamp_us;
        trades_.clear();
    }

    void add_trade(const Trade& trade) {
        cumulative_pv_ += trade.price * trade.volume;
        cumulative_volume_ += trade.volume;
        trades_.push_back(trade);

        if (start_time_us_ == 0) {
            start_time_us_ = trade.timestamp_us;
        }
    }

    double vwap() const {
        if (cumulative_volume_ == 0) return 0.0;
        return cumulative_pv_ / cumulative_volume_;
    }

    int64_t total_volume() const {
        return cumulative_volume_;
    }

    // Distance from VWAP in basis points
    double deviation_bps(double current_price) const {
        double v = vwap();
        if (v == 0.0) return 0.0;
        return ((current_price - v) / v) * 10000.0;
    }

    // Standard deviation of prices from VWAP
    double price_std_dev() const {
        if (trades_.empty()) return 0.0;

        double v = vwap();
        double variance_sum = 0.0;

        for (const auto& trade : trades_) {
            double diff = trade.price - v;
            variance_sum += diff * diff * trade.volume;
        }

        double variance = variance_sum / cumulative_volume_;
        return std::sqrt(variance);
    }

    // VWAP bands (±N standard deviations)
    struct VWAPBands {
        double vwap;
        double upper_1std;
        double lower_1std;
        double upper_2std;
        double lower_2std;
    };

    VWAPBands get_bands() const {
        double v = vwap();
        double std = price_std_dev();

        return {
            v,
            v + std,
            v - std,
            v + 2 * std,
            v - 2 * std
        };
    }

    // Percentage of volume above/below VWAP
    struct VolumeDistribution {
        int64_t volume_above_vwap;
        int64_t volume_below_vwap;
        double pct_above;
        double pct_below;
    };

    VolumeDistribution get_volume_distribution() const {
        double v = vwap();
        int64_t vol_above = 0;
        int64_t vol_below = 0;

        for (const auto& trade : trades_) {
            if (trade.price > v) {
                vol_above += trade.volume;
            } else if (trade.price < v) {
                vol_below += trade.volume;
            }
        }

        return {
            vol_above,
            vol_below,
            (cumulative_volume_ > 0) ? (100.0 * vol_above / cumulative_volume_) : 0.0,
            (cumulative_volume_ > 0) ? (100.0 * vol_below / cumulative_volume_) : 0.0
        };
    }

    uint64_t start_time() const { return start_time_us_; }
    size_t trade_count() const { return trades_.size(); }
};

4.2 MULTI-TIMEFRAME VWAP
-------------------------
Track VWAP across multiple timeframes simultaneously:

class MultiTimeframeVWAP {
private:
    std::map<std::string, VWAPCalculator> vwaps_;

public:
    void add_timeframe(const std::string& name) {
        vwaps_[name] = VWAPCalculator();
    }

    void add_trade(const Trade& trade) {
        for (auto& [name, calc] : vwaps_) {
            calc.add_trade(trade);
        }
    }

    std::optional<double> get_vwap(const std::string& name) const {
        auto it = vwaps_.find(name);
        if (it == vwaps_.end()) return std::nullopt;
        return it->second.vwap();
    }

    void reset_timeframe(const std::string& name, uint64_t timestamp_us = 0) {
        auto it = vwaps_.find(name);
        if (it != vwaps_.end()) {
            it->second.reset(timestamp_us);
        }
    }

    void print_all() const {
        std::cout << "=== Multi-Timeframe VWAP ===" << std::endl;
        for (const auto& [name, calc] : vwaps_) {
            std::cout << name << ": $" << calc.vwap()
                     << " (Vol: " << calc.total_volume() << ")" << std::endl;
        }
    }
};

================================================================================
5. ROLLING VWAP
================================================================================

5.1 TIME-BASED ROLLING WINDOW
------------------------------
VWAP over sliding time window (e.g., last 5 minutes):

class RollingVWAP {
private:
    struct WeightedPrice {
        double price;
        int64_t volume;
        uint64_t timestamp_us;
    };

    std::deque<WeightedPrice> window_;
    uint64_t window_duration_us_;

    double cumulative_pv_ = 0.0;
    int64_t cumulative_volume_ = 0;

public:
    explicit RollingVWAP(uint64_t window_duration_us)
        : window_duration_us_(window_duration_us) {}

    void add_trade(double price, int64_t volume, uint64_t timestamp_us) {
        // Add new trade
        window_.push_back({price, volume, timestamp_us});
        cumulative_pv_ += price * volume;
        cumulative_volume_ += volume;

        // Remove old trades outside window
        while (!window_.empty()) {
            const auto& oldest = window_.front();
            if (timestamp_us - oldest.timestamp_us > window_duration_us_) {
                cumulative_pv_ -= oldest.price * oldest.volume;
                cumulative_volume_ -= oldest.volume;
                window_.pop_front();
            } else {
                break;  // Window is sorted by time
            }
        }
    }

    double vwap() const {
        if (cumulative_volume_ == 0) return 0.0;
        return cumulative_pv_ / cumulative_volume_;
    }

    int64_t volume() const {
        return cumulative_volume_;
    }

    size_t trade_count() const {
        return window_.size();
    }
};

5.2 VOLUME-BASED ROLLING WINDOW
--------------------------------
VWAP over last N shares traded:

class VolumeRollingVWAP {
private:
    struct WeightedPrice {
        double price;
        int64_t volume;
    };

    std::deque<WeightedPrice> window_;
    int64_t target_volume_;

    double cumulative_pv_ = 0.0;
    int64_t cumulative_volume_ = 0;

public:
    explicit VolumeRollingVWAP(int64_t target_volume)
        : target_volume_(target_volume) {}

    void add_trade(double price, int64_t volume) {
        window_.push_back({price, volume});
        cumulative_pv_ += price * volume;
        cumulative_volume_ += volume;

        // Remove oldest trades until within target volume
        while (cumulative_volume_ > target_volume_ && !window_.empty()) {
            const auto& oldest = window_.front();
            cumulative_pv_ -= oldest.price * oldest.volume;
            cumulative_volume_ -= oldest.volume;
            window_.pop_front();
        }
    }

    double vwap() const {
        if (cumulative_volume_ == 0) return 0.0;
        return cumulative_pv_ / cumulative_volume_;
    }

    int64_t volume() const {
        return cumulative_volume_;
    }
};

================================================================================
6. ANCHORED VWAP
================================================================================

Anchored VWAP starts from a specific event or time:

class AnchoredVWAP {
private:
    VWAPCalculator calc_;
    std::string anchor_description_;
    uint64_t anchor_time_us_;
    bool is_active_ = false;

public:
    void anchor(const std::string& description, uint64_t timestamp_us) {
        calc_.reset(timestamp_us);
        anchor_description_ = description;
        anchor_time_us_ = timestamp_us;
        is_active_ = true;
    }

    void add_trade(const Trade& trade) {
        if (is_active_) {
            calc_.add_trade(trade);
        }
    }

    double vwap() const {
        return calc_.vwap();
    }

    bool is_active() const { return is_active_; }

    std::string description() const {
        return anchor_description_;
    }

    // Anchor at specific events
    void anchor_at_high(double price, uint64_t timestamp_us) {
        anchor("Daily High", timestamp_us);
    }

    void anchor_at_low(double price, uint64_t timestamp_us) {
        anchor("Daily Low", timestamp_us);
    }

    void anchor_at_open(uint64_t timestamp_us) {
        anchor("Market Open", timestamp_us);
    }
};

================================================================================
7. VWAP BANDS AND DEVIATION
================================================================================

7.1 BOLLINGER-STYLE VWAP BANDS
-------------------------------
class VWAPBands {
private:
    VWAPCalculator vwap_calc_;
    double num_std_devs_ = 2.0;

public:
    void set_std_devs(double num_std) {
        num_std_devs_ = num_std;
    }

    void add_trade(const Trade& trade) {
        vwap_calc_.add_trade(trade);
    }

    struct Bands {
        double vwap;
        double upper_band;
        double lower_band;
        double bandwidth;  // upper - lower
    };

    Bands get_bands() const {
        double v = vwap_calc_.vwap();
        double std = vwap_calc_.price_std_dev();

        double upper = v + num_std_devs_ * std;
        double lower = v - num_std_devs_ * std;

        return {v, upper, lower, upper - lower};
    }

    // Band squeeze detection (low volatility)
    bool is_squeeze(double threshold_pct = 2.0) const {
        auto bands = get_bands();
        double bandwidth_pct = (bands.bandwidth / bands.vwap) * 100.0;
        return bandwidth_pct < threshold_pct;
    }

    // Band expansion detection (high volatility)
    bool is_expansion(double threshold_pct = 5.0) const {
        auto bands = get_bands();
        double bandwidth_pct = (bands.bandwidth / bands.vwap) * 100.0;
        return bandwidth_pct > threshold_pct;
    }
};

================================================================================
8. TRADING STRATEGIES
================================================================================

8.1 VWAP REVERSION STRATEGY
----------------------------
Trade when price deviates significantly from VWAP:

class VWAPReversionStrategy {
private:
    VWAPCalculator vwap_;
    double entry_threshold_bps_ = 50.0;   // 5 bps
    double exit_threshold_bps_ = 10.0;    // 1 bps

public:
    enum class Signal { BUY, SELL, HOLD, EXIT_LONG, EXIT_SHORT };

    Signal generate_signal(double current_price) {
        double v = vwap_.vwap();
        if (v == 0.0) return Signal::HOLD;

        double dev_bps = ((current_price - v) / v) * 10000.0;

        // Price below VWAP → Buy (expect reversion up)
        if (dev_bps < -entry_threshold_bps_) {
            return Signal::BUY;
        }

        // Price above VWAP → Sell (expect reversion down)
        if (dev_bps > entry_threshold_bps_) {
            return Signal::SELL;
        }

        // Close to VWAP → Exit positions
        if (std::abs(dev_bps) < exit_threshold_bps_) {
            return Signal::EXIT_LONG;  // Or EXIT_SHORT depending on position
        }

        return Signal::HOLD;
    }

    void add_trade(const Trade& trade) {
        vwap_.add_trade(trade);
    }
};

8.2 VWAP CROSSOVER STRATEGY
----------------------------
Trade on rolling VWAP crossovers:

class VWAPCrossoverStrategy {
private:
    RollingVWAP fast_vwap_;  // e.g., 5 min
    RollingVWAP slow_vwap_;  // e.g., 15 min

    double last_fast_vwap_ = 0.0;
    double last_slow_vwap_ = 0.0;

public:
    VWAPCrossoverStrategy(uint64_t fast_window_us, uint64_t slow_window_us)
        : fast_vwap_(fast_window_us), slow_vwap_(slow_window_us) {}

    enum class Signal { BUY, SELL, HOLD };

    Signal add_trade_and_check(double price, int64_t volume, uint64_t timestamp_us) {
        fast_vwap_.add_trade(price, volume, timestamp_us);
        slow_vwap_.add_trade(price, volume, timestamp_us);

        double fast = fast_vwap_.vwap();
        double slow = slow_vwap_.vwap();

        Signal signal = Signal::HOLD;

        // Detect crossover
        if (last_fast_vwap_ != 0.0 && last_slow_vwap_ != 0.0) {
            // Fast crosses above slow → Bullish
            if (last_fast_vwap_ <= last_slow_vwap_ && fast > slow) {
                signal = Signal::BUY;
            }
            // Fast crosses below slow → Bearish
            else if (last_fast_vwap_ >= last_slow_vwap_ && fast < slow) {
                signal = Signal::SELL;
            }
        }

        last_fast_vwap_ = fast;
        last_slow_vwap_ = slow;

        return signal;
    }

    double fast_vwap() const { return fast_vwap_.vwap(); }
    double slow_vwap() const { return slow_vwap_.vwap(); }
};

================================================================================
9. PERFORMANCE OPTIMIZATION
================================================================================

9.1 FIXED-POINT ARITHMETIC
---------------------------
Use integers for price/volume to avoid floating-point errors:

class FastVWAP {
private:
    int64_t cumulative_pv_ = 0;  // Price × Volume in ticks
    int64_t cumulative_volume_ = 0;

    static constexpr int64_t TICK_SIZE_INT = 1;  // 1 tick = 0.01
    static constexpr double TICK_SIZE_DOUBLE = 0.01;

public:
    void add_trade(int64_t price_ticks, int64_t volume) {
        cumulative_pv_ += price_ticks * volume;
        cumulative_volume_ += volume;
    }

    double vwap_double() const {
        if (cumulative_volume_ == 0) return 0.0;
        return (static_cast<double>(cumulative_pv_) / cumulative_volume_) *
               TICK_SIZE_DOUBLE;
    }

    int64_t vwap_ticks() const {
        if (cumulative_volume_ == 0) return 0;
        return cumulative_pv_ / cumulative_volume_;
    }
};

9.2 SIMD VECTORIZATION
----------------------
Process multiple VWAP calculations in parallel:

#include <immintrin.h>  // AVX2

class VectorizedVWAP {
public:
    // Calculate 4 VWAPs simultaneously
    static void calculate_batch(
        const double* prices,
        const int64_t* volumes,
        size_t count,
        double* vwaps,
        size_t num_vwaps
    ) {
        // Use AVX2 for parallel computation
        // (Simplified example)

        for (size_t v = 0; v < num_vwaps; v += 4) {
            __m256d pv_sum = _mm256_setzero_pd();
            __m256d vol_sum = _mm256_setzero_pd();

            for (size_t i = 0; i < count; ++i) {
                __m256d price = _mm256_set1_pd(prices[i]);
                __m256d volume = _mm256_set1_pd(static_cast<double>(volumes[i]));

                __m256d pv = _mm256_mul_pd(price, volume);
                pv_sum = _mm256_add_pd(pv_sum, pv);
                vol_sum = _mm256_add_pd(vol_sum, volume);
            }

            __m256d vwap = _mm256_div_pd(pv_sum, vol_sum);
            _mm256_storeu_pd(&vwaps[v], vwap);
        }
    }
};

================================================================================
10. REAL-WORLD APPLICATIONS
================================================================================

10.1 EXECUTION QUALITY MEASUREMENT
-----------------------------------
Compare execution price to VWAP:

class ExecutionAnalyzer {
private:
    VWAPCalculator market_vwap_;

public:
    void add_market_trade(const Trade& trade) {
        market_vwap_.add_trade(trade);
    }

    struct ExecutionMetrics {
        double avg_fill_price;
        double market_vwap;
        double slippage_bps;
        double slippage_dollars;
    };

    ExecutionMetrics analyze_execution(
        const std::vector<Trade>& fills,
        int64_t total_target_volume
    ) {
        double total_fill_pv = 0.0;
        int64_t total_filled = 0;

        for (const auto& fill : fills) {
            total_fill_pv += fill.price * fill.volume;
            total_filled += fill.volume;
        }

        double avg_fill = (total_filled > 0) ? total_fill_pv / total_filled : 0.0;
        double m_vwap = market_vwap_.vwap();

        double slippage_bps = ((avg_fill - m_vwap) / m_vwap) * 10000.0;
        double slippage_dollars = (avg_fill - m_vwap) * total_filled;

        return {avg_fill, m_vwap, slippage_bps, slippage_dollars};
    }
};

10.2 VWAP EXECUTION ALGORITHM
------------------------------
Execute order to match VWAP:

class VWAPExecutionAlgorithm {
private:
    int64_t target_volume_;
    int64_t executed_volume_ = 0;
    uint64_t start_time_us_;
    uint64_t end_time_us_;

    VWAPCalculator my_vwap_;
    VWAPCalculator market_vwap_;

public:
    VWAPExecutionAlgorithm(int64_t target_volume,
                          uint64_t start_time,
                          uint64_t end_time)
        : target_volume_(target_volume),
          start_time_us_(start_time),
          end_time_us_(end_time) {}

    int64_t calculate_slice_size(uint64_t current_time_us) {
        // Pace execution to match market volume profile
        uint64_t elapsed = current_time_us - start_time_us_;
        uint64_t total_duration = end_time_us_ - start_time_us_;

        if (total_duration == 0) return target_volume_;

        double progress = static_cast<double>(elapsed) / total_duration;
        int64_t target_executed = static_cast<int64_t>(target_volume_ * progress);

        return std::max(int64_t(0), target_executed - executed_volume_);
    }

    void record_fill(double price, int64_t volume) {
        Trade trade{price, volume, 0, true};
        my_vwap_.add_trade(trade);
        executed_volume_ += volume;
    }

    void record_market_trade(const Trade& trade) {
        market_vwap_.add_trade(trade);
    }

    double tracking_error_bps() const {
        double my_v = my_vwap_.vwap();
        double market_v = market_vwap_.vwap();

        if (market_v == 0.0) return 0.0;

        return ((my_v - market_v) / market_v) * 10000.0;
    }

    bool is_complete() const {
        return executed_volume_ >= target_volume_;
    }

    double completion_pct() const {
        return (100.0 * executed_volume_) / target_volume_;
    }
};

================================================================================
SUMMARY
================================================================================

VWAP is a fundamental benchmark for trading:
- Industry standard for execution quality
- Simple and efficient to calculate
- Useful for mean reversion strategies
- Essential for algorithm development

Key implementations provided:
- Basic VWAP calculator
- Rolling VWAP (time and volume windows)
- Anchored VWAP
- VWAP bands and deviation
- Trading strategies
- Execution algorithms

Best practices:
- Use incremental updates for efficiency
- Consider multiple timeframes
- Account for gaps and holidays
- Validate against external sources
- Monitor for calculation errors

Performance considerations:
- O(1) updates with running sums
- Fixed-point arithmetic for accuracy
- SIMD vectorization for batch processing
- Lock-free for concurrent access

================================================================================
Version: 1.0
Last Updated: 2025-11-26
Total Size: ~26 KB
================================================================================
