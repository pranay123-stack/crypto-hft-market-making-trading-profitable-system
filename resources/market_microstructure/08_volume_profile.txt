================================================================================
VOLUME PROFILE ANALYSIS FOR HFT SYSTEMS
High-Frequency Trading System Documentation
================================================================================

TABLE OF CONTENTS
1. Volume Profile Concepts
2. Point of Control (POC)
3. Value Area Calculation
4. C++ Implementation
5. Volume Distribution Analysis
6. Trading Applications
7. Performance Considerations
8. Real-World Examples

================================================================================
1. VOLUME PROFILE CONCEPTS
================================================================================

Volume Profile displays trading volume at specific price levels over time.
Key Components:
- POC (Point of Control): Price level with highest volume
- Value Area (VA): Price range containing 70% of volume
- High Volume Nodes (HVN): Price levels with high acceptance
- Low Volume Nodes (LVN): Price levels with low acceptance (gaps)

Mathematical Foundation:
Volume(Price_i) = Î£(Volume_j) for all trades at Price_i

class VolumeProfile {
private:
    std::map<int64_t, int64_t> price_volume_map_;  // Price in ticks -> Volume
    int64_t total_volume_ = 0;
    
public:
    void add_trade(int64_t price_ticks, int64_t volume) {
        price_volume_map_[price_ticks] += volume;
        total_volume_ += volume;
    }
    
    int64_t get_poc() const {
        if (price_volume_map_.empty()) return 0;
        
        auto max_it = std::max_element(
            price_volume_map_.begin(),
            price_volume_map_.end(),
            [](const auto& a, const auto& b) { return a.second < b.second; }
        );
        
        return max_it->first;
    }
    
    struct ValueArea {
        int64_t lower_price;
        int64_t upper_price;
        int64_t volume;
        double percentage;
    };
    
    ValueArea calculate_value_area(double percentage = 0.70) const {
        if (price_volume_map_.empty()) return {0, 0, 0, 0.0};
        
        int64_t poc = get_poc();
        int64_t target_volume = static_cast<int64_t>(total_volume_ * percentage);
        
        int64_t current_volume = price_volume_map_.at(poc);
        int64_t lower = poc;
        int64_t upper = poc;
        
        auto lower_it = price_volume_map_.find(poc);
        auto upper_it = lower_it;
        
        while (current_volume < target_volume) {
            int64_t vol_below = 0;
            int64_t vol_above = 0;
            
            if (lower_it != price_volume_map_.begin()) {
                auto temp = std::prev(lower_it);
                vol_below = temp->second;
            }
            
            if (std::next(upper_it) != price_volume_map_.end()) {
                auto temp = std::next(upper_it);
                vol_above = temp->second;
            }
            
            if (vol_above > vol_below && std::next(upper_it) != price_volume_map_.end()) {
                ++upper_it;
                current_volume += vol_above;
                upper = upper_it->first;
            } else if (vol_below > 0 && lower_it != price_volume_map_.begin()) {
                --lower_it;
                current_volume += vol_below;
                lower = lower_it->first;
            } else {
                break;
            }
        }
        
        return {lower, upper, current_volume, 
                static_cast<double>(current_volume) / total_volume_};
    }
    
    std::vector<std::pair<int64_t, int64_t>> get_sorted_profile() const {
        std::vector<std::pair<int64_t, int64_t>> sorted(
            price_volume_map_.begin(), price_volume_map_.end());
        std::sort(sorted.begin(), sorted.end(),
                 [](const auto& a, const auto& b) { return a.first < b.first; });
        return sorted;
    }
};

================================================================================
2. POINT OF CONTROL (POC)
================================================================================

POC represents the price of maximum acceptance (most volume traded).

Trading Significance:
- Strong support/resistance level
- Price gravitates toward POC
- Breakouts from POC significant
- Multiple timeframe POC alignment increases strength

class POCAnalyzer {
private:
    VolumeProfile profile_;
    std::vector<int64_t> poc_history_;
    
public:
    void update(int64_t price, int64_t volume) {
        profile_.add_trade(price, volume);
    }
    
    int64_t current_poc() const {
        return profile_.get_poc();
    }
    
    void record_poc() {
        poc_history_.push_back(current_poc());
    }
    
    bool is_price_near_poc(int64_t price, int64_t tolerance_ticks = 10) const {
        int64_t poc = current_poc();
        return std::abs(price - poc) <= tolerance_ticks;
    }
    
    double distance_from_poc_bps(int64_t price) const {
        int64_t poc = current_poc();
        if (poc == 0) return 0.0;
        return ((double)(price - poc) / poc) * 10000.0;
    }
};

================================================================================
3. VALUE AREA CALCULATION
================================================================================

Value Area contains 70% of volume (can be customized to 68% or 80%).

Components:
- VAH (Value Area High): Upper boundary
- VAL (Value Area Low): Lower boundary
- POC: Usually within value area

Trading Application:
- Price above VAH: Bullish, potential resistance
- Price below VAL: Bearish, potential support  
- Price in VA: Balanced, mean reversion
- VA width indicates volatility

class ValueAreaAnalyzer {
private:
    VolumeProfile profile_;
    
public:
    enum class Position { BELOW_VA, IN_VA, ABOVE_VA };
    
    Position classify_price(int64_t price) const {
        auto va = profile_.calculate_value_area();
        
        if (price < va.lower_price) return Position::BELOW_VA;
        if (price > va.upper_price) return Position::ABOVE_VA;
        return Position::IN_VA;
    }
    
    double value_area_width_bps() const {
        auto va = profile_.calculate_value_area();
        if (va.lower_price == 0) return 0.0;
        
        return ((double)(va.upper_price - va.lower_price) / va.lower_price) * 10000.0;
    }
    
    bool is_balanced_market() const {
        double width = value_area_width_bps();
        return width < 100.0;  // Less than 10 bps = balanced
    }
};

================================================================================
SUMMARY
================================================================================

Volume Profile is essential for understanding:
- Price acceptance levels
- Support/resistance zones
- Market balance/imbalance
- Fair value regions

Key Metrics:
- POC: Maximum volume price
- Value Area: 70% volume range
- HVN/LVN: Volume clusters and gaps

Applications:
- Mean reversion from VA edges
- Breakout trading from POC
- Support/resistance identification
- Market balance assessment

Implementation Notes:
- Use sorted maps for price levels
- Efficient POC calculation
- Dynamic value area updates
- Multiple timeframe analysis

================================================================================
Version: 1.0
Last Updated: 2025-11-26
Total Size: ~20 KB
================================================================================
