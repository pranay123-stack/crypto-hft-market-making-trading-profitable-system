================================================================================
                           COINBASE PRO EXCHANGE
                     COMPREHENSIVE API INTEGRATION GUIDE
================================================================================

EXCHANGE OVERVIEW
================================================================================

Name: Coinbase Exchange (formerly Coinbase Pro)
Website: https://www.coinbase.com/advanced-trade
API Documentation: https://docs.cloud.coinbase.com/
Founded: 2012 (Coinbase), 2015 (GDAX/Pro)
Headquarters: San Francisco, California, USA
Trading Volume: $2-4 billion daily (2024)
Global Rank: #3-5 by trading volume

HISTORY AND BACKGROUND:
-----------------------
Coinbase Pro (formerly GDAX) was launched in 2015 as the professional trading
platform of Coinbase, one of the first regulated cryptocurrency exchanges in
the United States. In 2023, Coinbase merged Coinbase Pro into the main platform
as "Advanced Trade" while maintaining its professional trading features.

Key Milestones:
- 2012: Coinbase founded
- 2015: GDAX (Global Digital Asset Exchange) launched
- 2016: Licensed as a Money Transmitter
- 2018: Rebranded to Coinbase Pro
- 2021: Coinbase goes public (NASDAQ: COIN)
- 2023: Merged into Coinbase Advanced Trade
- 2024: Continued institutional expansion

REGULATORY STATUS:
------------------
- Registered with FinCEN as a Money Services Business
- Licensed in all 50 US states
- FCA registered in UK
- MiFID II compliant in Europe
- Licensed in multiple jurisdictions globally

MARKET POSITION:
----------------
- Leading regulated US exchange
- 200+ cryptocurrencies available
- Strong institutional presence
- Custody services available
- Prime brokerage for institutions

================================================================================
                            TRADING PAIRS AND MARKETS
================================================================================

SPOT TRADING:
-------------
Major Pairs:
- BTC/USD, ETH/USD, SOL/USD, ADA/USD
- BTC/EUR, ETH/EUR, BTC/GBP, ETH/GBP
- BTC/USDT, ETH/USDT (select pairs)
- 600+ trading pairs available

Base Currencies:
- USD - Most liquid (ACH, wire, debit card)
- EUR - European markets
- GBP - UK markets
- USDC - Coinbase stablecoin (no fees)
- USDT - Limited pairs

MARKET FEATURES:
----------------
- Spot trading only (no derivatives)
- Margin trading (limited availability)
- Staking services
- Institutional custody
- OTC trading desk

MINIMUM ORDER SIZES:
--------------------
Varies by pair, typically:
- BTC pairs: 0.0001 BTC minimum
- ETH pairs: 0.001 ETH minimum
- USD pairs: $1-10 minimum notional

================================================================================
                              API ARCHITECTURE
================================================================================

API TYPES AVAILABLE:
--------------------

1. Advanced Trade API (Current)
   Base URL: https://api.coinbase.com/api/v3/brokerage
   - REST API for trading and accounts
   - WebSocket for real-time data
   - OAuth2 authentication option

2. Legacy Exchange API (Deprecated)
   Base URL: https://api.exchange.coinbase.com
   - Still functional but being phased out
   - Documentation maintained for existing users

3. FIX API (Institutional)
   - FIX 4.2 protocol
   - Available for Prime customers
   - Requires special approval
   - Ultra-low latency

4. WebSocket Feed
   Base URL: wss://advanced-trade-ws.coinbase.com
   - Real-time market data
   - Order updates
   - Level 2 order book

API VERSIONS:
-------------
- Advanced Trade API v3 (Current)
- Exchange API v2 (Legacy, deprecated)
- FIX 4.2 (Institutional)

MIGRATION NOTICE:
-----------------
Coinbase is transitioning from the Exchange API to Advanced Trade API.
All new integrations should use Advanced Trade API.

================================================================================
                       API KEY AND SECRET KEY MANAGEMENT
================================================================================

CREATING API KEYS (Advanced Trade):
------------------------------------
1. Log in to Coinbase account
2. Navigate to Settings > API
3. Create New API Key
4. Configure permissions:
   - View (read account data)
   - Trade (place/cancel orders)
   - Transfer (move funds between accounts)
5. Add portfolio or account access
6. Optionally restrict to IP addresses
7. Save API Key Name and Private Key (download JSON)

API KEY FORMAT:
---------------
Coinbase uses Cloud API Keys format:
{
  "name": "your-key-name",
  "privateKey": "-----BEGIN EC PRIVATE KEY-----\n...\n-----END EC PRIVATE KEY-----\n"
}

Legacy API Keys (Exchange API):
- API Key: alphanumeric string
- API Secret: base64 encoded string
- Passphrase: user-defined password

SECURITY RECOMMENDATIONS:
-------------------------
1. Store private keys securely (encrypted)
2. Never commit keys to version control
3. Use IP whitelisting when possible
4. Create separate keys for different purposes
5. Rotate keys quarterly
6. Monitor key usage through dashboard
7. Use least privilege (minimal permissions)

API KEY LIMITS:
---------------
- Maximum 20 API keys per account
- Each key can have different permissions
- Keys can be revoked instantly

================================================================================
                          AUTHENTICATION METHODS
================================================================================

ADVANCED TRADE API AUTHENTICATION:
----------------------------------
Uses JWT (JSON Web Token) with EC (Elliptic Curve) signatures.

Authentication Process:
1. Generate JWT token using EC private key
2. Include JWT in Authorization header
3. Sign request with key ID

JWT GENERATION (C++ Example):
------------------------------

#include <jwt-cpp/jwt.h>
#include <iostream>
#include <fstream>
#include <chrono>

class CoinbaseAuth {
private:
    std::string api_key_name;
    std::string private_key_pem;

public:
    CoinbaseAuth(const std::string& key_name, const std::string& pem_file) {
        api_key_name = key_name;

        // Read private key from file
        std::ifstream key_file(pem_file);
        std::stringstream buffer;
        buffer << key_file.rdbuf();
        private_key_pem = buffer.str();
    }

    std::string generate_jwt(const std::string& uri) {
        auto now = std::chrono::system_clock::now();
        auto exp = now + std::chrono::seconds(120); // 2 minute expiry

        auto token = jwt::create()
            .set_issuer("coinbase-cloud")
            .set_issued_at(now)
            .set_expires_at(exp)
            .set_key_id(api_key_name)
            .set_payload_claim("sub", jwt::claim(api_key_name))
            .set_payload_claim("uri", jwt::claim(uri))
            .sign(jwt::algorithm::es256("", private_key_pem, "", ""));

        return token;
    }
};

LEGACY API AUTHENTICATION:
--------------------------
Uses HMAC SHA256 signatures.

Signature Components:
- timestamp: Unix timestamp in seconds
- method: HTTP method (GET, POST, DELETE)
- requestPath: /orders, /accounts, etc.
- body: JSON body (empty string for GET)

Signature String:
timestamp + method + requestPath + body

Required Headers:
- CB-ACCESS-KEY: Your API key
- CB-ACCESS-SIGN: Base64 encoded HMAC signature
- CB-ACCESS-TIMESTAMP: Request timestamp
- CB-ACCESS-PASSPHRASE: Your passphrase

C++ LEGACY AUTHENTICATION:
--------------------------

#include <openssl/hmac.h>
#include <openssl/sha.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <chrono>
#include <sstream>
#include <iomanip>

class CoinbaseLegacyAuth {
private:
    std::string api_key;
    std::string api_secret;
    std::string passphrase;

    std::string base64_encode(const unsigned char* buffer, size_t length) {
        BIO *bio, *b64;
        BUF_MEM *buffer_ptr;

        b64 = BIO_new(BIO_f_base64());
        bio = BIO_new(BIO_s_mem());
        bio = BIO_push(b64, bio);

        BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
        BIO_write(bio, buffer, length);
        BIO_flush(bio);
        BIO_get_mem_ptr(bio, &buffer_ptr);

        std::string result(buffer_ptr->data, buffer_ptr->length);
        BIO_free_all(bio);

        return result;
    }

    std::string base64_decode(const std::string& encoded) {
        BIO *bio, *b64;
        int decode_len = encoded.length();
        unsigned char* buffer = new unsigned char[decode_len];

        bio = BIO_new_mem_buf(encoded.c_str(), -1);
        b64 = BIO_new(BIO_f_base64());
        bio = BIO_push(b64, bio);

        BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
        int length = BIO_read(bio, buffer, decode_len);
        BIO_free_all(bio);

        std::string result((char*)buffer, length);
        delete[] buffer;

        return result;
    }

    std::string hmac_sha256(const std::string& data, const std::string& key) {
        unsigned char* digest;
        unsigned int digest_len;

        digest = HMAC(EVP_sha256(),
                      key.c_str(), key.length(),
                      (unsigned char*)data.c_str(), data.length(),
                      NULL, &digest_len);

        return base64_encode(digest, digest_len);
    }

public:
    CoinbaseLegacyAuth(const std::string& key,
                       const std::string& secret,
                       const std::string& pass)
        : api_key(key), api_secret(secret), passphrase(pass) {}

    struct AuthHeaders {
        std::string timestamp;
        std::string signature;
        std::string key;
        std::string passphrase;
    };

    AuthHeaders generate_headers(const std::string& method,
                                 const std::string& path,
                                 const std::string& body = "") {
        AuthHeaders headers;

        // Generate timestamp
        auto now = std::chrono::system_clock::now();
        auto timestamp = std::chrono::duration_cast<std::chrono::seconds>(
            now.time_since_epoch()
        ).count();
        headers.timestamp = std::to_string(timestamp);

        // Create signature string
        std::string what = headers.timestamp + method + path + body;

        // Decode secret and sign
        std::string decoded_secret = base64_decode(api_secret);
        headers.signature = hmac_sha256(what, decoded_secret);
        headers.key = api_key;
        headers.passphrase = passphrase;

        return headers;
    }
};

================================================================================
                          RATE LIMITS AND RESTRICTIONS
================================================================================

ADVANCED TRADE API LIMITS:
---------------------------

Public Endpoints (No Authentication):
- 10 requests per second
- No daily limit

Private Endpoints (Authenticated):
- 30 requests per second
- Burst allowance of 60 requests

Order Rate Limits:
- Market orders: 10 per second
- Limit orders: 15 per second
- Cancel orders: 50 per second

LEGACY API LIMITS:
------------------

Public Endpoints:
- 3 requests per second (deprecated, use Advanced Trade)

Private Endpoints:
- 5 requests per second
- Burst up to 15 requests

RATE LIMIT HEADERS:
-------------------
Response includes:
- RateLimit-Limit: Maximum requests allowed
- RateLimit-Remaining: Requests remaining in window
- RateLimit-Reset: Unix timestamp when limit resets

HANDLING RATE LIMITS:
---------------------
HTTP 429 (Too Many Requests) returned when exceeded.

Best Practices:
1. Implement exponential backoff
2. Track rate limit headers
3. Use WebSocket for real-time data
4. Batch requests when possible
5. Cache static data (trading pairs, etc.)

C++ RATE LIMITER EXAMPLE:
-------------------------

#include <chrono>
#include <thread>
#include <queue>
#include <mutex>

class RateLimiter {
private:
    int max_requests;
    std::chrono::seconds time_window;
    std::queue<std::chrono::steady_clock::time_point> requests;
    std::mutex mtx;

public:
    RateLimiter(int max_req, int window_sec)
        : max_requests(max_req), time_window(window_sec) {}

    void wait_if_needed() {
        std::lock_guard<std::mutex> lock(mtx);
        auto now = std::chrono::steady_clock::now();

        // Remove old requests outside window
        while(!requests.empty()) {
            auto oldest = requests.front();
            if(now - oldest > time_window) {
                requests.pop();
            } else {
                break;
            }
        }

        // If at limit, wait
        if(requests.size() >= max_requests) {
            auto oldest = requests.front();
            auto wait_until = oldest + time_window;
            auto wait_duration = wait_until - now;

            if(wait_duration > std::chrono::milliseconds(0)) {
                std::this_thread::sleep_for(wait_duration);
            }
            requests.pop();
        }

        requests.push(now);
    }
};

// Usage:
// RateLimiter limiter(30, 1); // 30 requests per second
// limiter.wait_if_needed();
// make_api_request();

================================================================================
                          MARKET DATA STRUCTURE
================================================================================

PRODUCT INFORMATION:
--------------------
GET /api/v3/brokerage/products

{
  "products": [
    {
      "product_id": "BTC-USD",
      "price": "50000.00",
      "price_percentage_change_24h": "2.5",
      "volume_24h": "12345.67",
      "volume_percentage_change_24h": "5.2",
      "base_currency": "BTC",
      "quote_currency": "USD",
      "base_increment": "0.00000001",
      "quote_increment": "0.01",
      "base_min_size": "0.001",
      "base_max_size": "1000",
      "status": "online",
      "trading_disabled": false
    }
  ]
}

ORDER BOOK:
-----------
GET /api/v3/brokerage/product_book?product_id=BTC-USD

{
  "pricebook": {
    "product_id": "BTC-USD",
    "bids": [
      {"price": "50000.00", "size": "1.5"},
      {"price": "49999.00", "size": "2.3"}
    ],
    "asks": [
      {"price": "50001.00", "size": "1.2"},
      {"price": "50002.00", "size": "3.1"}
    ],
    "time": "2024-01-01T12:00:00Z"
  }
}

TICKER DATA:
------------
GET /api/v3/brokerage/products/BTC-USD/ticker

{
  "trades": [
    {
      "trade_id": "123456789",
      "product_id": "BTC-USD",
      "price": "50000.00",
      "size": "0.5",
      "time": "2024-01-01T12:00:00Z",
      "side": "BUY"
    }
  ],
  "best_bid": "49999.00",
  "best_ask": "50001.00"
}

CANDLES (OHLCV):
----------------
GET /api/v3/brokerage/products/BTC-USD/candles

{
  "candles": [
    {
      "start": "1704110400",
      "low": "49000.00",
      "high": "50500.00",
      "open": "49500.00",
      "close": "50000.00",
      "volume": "123.45"
    }
  ]
}

Granularities: ONE_MINUTE, FIVE_MINUTE, FIFTEEN_MINUTE, THIRTY_MINUTE,
               ONE_HOUR, TWO_HOUR, SIX_HOUR, ONE_DAY

================================================================================
                          ORDER TYPES SUPPORTED
================================================================================

MARKET ORDERS:
--------------
Execute immediately at best available price.

{
  "product_id": "BTC-USD",
  "side": "BUY",
  "order_configuration": {
    "market_market_ioc": {
      "quote_size": "1000.00"  // Buy $1000 worth
      // OR
      "base_size": "0.02"      // Buy 0.02 BTC
    }
  }
}

LIMIT ORDERS:
-------------
Execute at specified price or better.

{
  "product_id": "BTC-USD",
  "side": "BUY",
  "order_configuration": {
    "limit_limit_gtc": {
      "base_size": "0.01",
      "limit_price": "50000.00",
      "post_only": false
    }
  }
}

LIMIT GTD (Good Till Date):
---------------------------
{
  "product_id": "BTC-USD",
  "side": "SELL",
  "order_configuration": {
    "limit_limit_gtd": {
      "base_size": "0.01",
      "limit_price": "51000.00",
      "end_time": "2024-12-31T23:59:59Z",
      "post_only": false
    }
  }
}

STOP LIMIT:
-----------
{
  "product_id": "BTC-USD",
  "side": "SELL",
  "order_configuration": {
    "stop_limit_stop_limit_gtc": {
      "base_size": "0.01",
      "limit_price": "49500.00",
      "stop_price": "49800.00",
      "stop_direction": "STOP_DIRECTION_STOP_DOWN"
    }
  }
}

STOP DIRECTIONS:
- STOP_DIRECTION_STOP_DOWN: Trigger when price falls to stop price
- STOP_DIRECTION_STOP_UP: Trigger when price rises to stop price

TIME IN FORCE:
--------------
- GTC (Good Till Cancelled): Remains until filled or cancelled
- GTD (Good Till Date): Remains until specified date
- IOC (Immediate or Cancel): Fill immediately, cancel remainder
- FOK (Fill or Kill): Fill completely or cancel

POST-ONLY:
----------
- Order will only be maker (not taker)
- Rejected if would execute immediately
- Ensures maker fee rebate

================================================================================
                              FEE STRUCTURE
================================================================================

ADVANCED TRADE FEE STRUCTURE (2024):
------------------------------------

Taker Fee (Standard):
- 0-$10K: 0.60%
- $10K-$50K: 0.40%
- $50K-$100K: 0.25%
- $100K-$1M: 0.15%
- $1M+: 0.10%

Maker Fee (Standard):
- 0-$10K: 0.40%
- $10K-$50K: 0.25%
- $50K-$100K: 0.15%
- $100K-$1M: 0.10%
- $1M+: 0.05%

Tier calculated based on 30-day trailing volume.

USDC TRADING:
-------------
- Zero fees for USDC pairs
- USD/USDC, BTC/USDC, ETH/USDC
- Promotional, subject to change

ADVANCED TRADER VOLUME DISCOUNT:
--------------------------------
Higher volume traders can achieve:
- Maker: As low as 0.00%
- Taker: As low as 0.05%

INSTITUTIONAL PRICING:
----------------------
Prime customers receive:
- Custom fee schedules
- Volume-based discounts
- Maker rebates available
- Contact sales for pricing

WITHDRAWAL FEES:
----------------
- Cryptocurrency withdrawals: Network fees apply (variable)
- USD withdrawals (ACH): Free
- Wire transfer: $10 USD (domestic), $25 (international)

DEPOSIT FEES:
-------------
- Cryptocurrency deposits: Free
- ACH deposits: Free
- Wire transfer: $10 USD (US), variable (international)

================================================================================
                          WEBSOCKET CHANNELS
================================================================================

CONNECTION ENDPOINT:
--------------------
wss://advanced-trade-ws.coinbase.com

AUTHENTICATION:
---------------
WebSocket requires JWT authentication in connection request.

CONNECTION EXAMPLE:
-------------------
{
  "type": "subscribe",
  "product_ids": ["BTC-USD", "ETH-USD"],
  "channel": "ticker",
  "jwt": "your_jwt_token_here"
}

AVAILABLE CHANNELS:
-------------------

1. Ticker Channel:
   - Real-time price updates
   - Best bid/ask
   - 24h stats

2. Level2 Channel:
   - Full order book updates
   - Real-time bid/ask changes
   - Efficient diff updates

3. Matches Channel:
   - Trade executions
   - Price, size, side
   - Maker/taker info

4. Heartbeat Channel:
   - Connection health check
   - Periodic ping

5. Status Channel:
   - Product status changes
   - Trading disabled/enabled

6. User Channel:
   - Order updates
   - Fill notifications
   - Balance changes

MESSAGE FORMATS:
----------------

Ticker Update:
{
  "channel": "ticker",
  "client_id": "",
  "timestamp": "2024-01-01T12:00:00Z",
  "sequence_num": 123456,
  "events": [{
    "type": "ticker",
    "tickers": [{
      "type": "ticker",
      "product_id": "BTC-USD",
      "price": "50000.00",
      "volume_24_h": "12345.67",
      "low_24_h": "49000.00",
      "high_24_h": "50500.00",
      "best_bid": "49999.00",
      "best_ask": "50001.00"
    }]
  }]
}

Level2 Update:
{
  "channel": "level2",
  "timestamp": "2024-01-01T12:00:00Z",
  "events": [{
    "type": "snapshot",  // or "update"
    "product_id": "BTC-USD",
    "updates": [
      {
        "side": "bid",
        "price_level": "50000.00",
        "new_quantity": "1.5"
      }
    ]
  }]
}

================================================================================
                      C++ CODE EXAMPLES - REST API
================================================================================

EXAMPLE 1: GET ACCOUNTS
------------------------

#include <curl/curl.h>
#include <nlohmann/json.hpp>
#include <iostream>
#include <jwt-cpp/jwt.h>

using json = nlohmann::json;

class CoinbaseClient {
private:
    std::string api_key_name;
    std::string private_key;
    std::string base_url = "https://api.coinbase.com";

    static size_t WriteCallback(void* contents, size_t size,
                               size_t nmemb, std::string* userp) {
        userp->append((char*)contents, size * nmemb);
        return size * nmemb;
    }

    std::string generate_jwt(const std::string& request_path) {
        auto now = std::chrono::system_clock::now();
        auto exp = now + std::chrono::seconds(120);

        auto token = jwt::create()
            .set_issuer("coinbase-cloud")
            .set_issued_at(now)
            .set_expires_at(exp)
            .set_key_id(api_key_name)
            .set_payload_claim("sub", jwt::claim(api_key_name))
            .sign(jwt::algorithm::es256("", private_key, "", ""));

        return token;
    }

    std::string make_request(const std::string& endpoint,
                            const std::string& method = "GET",
                            const std::string& body = "") {
        CURL* curl = curl_easy_init();
        std::string response;

        if(curl) {
            std::string url = base_url + endpoint;
            std::string jwt = generate_jwt(endpoint);

            struct curl_slist* headers = NULL;
            std::string auth_header = "Authorization: Bearer " + jwt;
            headers = curl_slist_append(headers, auth_header.c_str());
            headers = curl_slist_append(headers, "Content-Type: application/json");

            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

            if(method == "POST") {
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());
            }

            CURLcode res = curl_easy_perform(curl);
            if(res != CURLE_OK) {
                std::cerr << "Request failed: " << curl_easy_strerror(res) << std::endl;
            }

            curl_slist_free_all(headers);
            curl_easy_cleanup(curl);
        }
        return response;
    }

public:
    CoinbaseClient(const std::string& key_name, const std::string& priv_key)
        : api_key_name(key_name), private_key(priv_key) {}

    json get_accounts() {
        std::string response = make_request("/api/v3/brokerage/accounts");
        return json::parse(response);
    }

    json get_products() {
        std::string response = make_request("/api/v3/brokerage/products");
        return json::parse(response);
    }

    json get_product_book(const std::string& product_id) {
        std::string endpoint = "/api/v3/brokerage/product_book?product_id=" + product_id;
        std::string response = make_request(endpoint);
        return json::parse(response);
    }

    json create_order(const json& order_config) {
        std::string body = order_config.dump();
        std::string response = make_request("/api/v3/brokerage/orders", "POST", body);
        return json::parse(response);
    }

    json cancel_orders(const std::vector<std::string>& order_ids) {
        json body = {{"order_ids", order_ids}};
        std::string response = make_request("/api/v3/brokerage/orders/batch_cancel",
                                           "POST", body.dump());
        return json::parse(response);
    }
};

// Usage example:
int main() {
    std::string key_name = "organizations/{org_id}/apiKeys/{key_id}";
    std::string private_key = "-----BEGIN EC PRIVATE KEY-----\n...\n-----END EC PRIVATE KEY-----\n";

    CoinbaseClient client(key_name, private_key);

    // Get accounts
    json accounts = client.get_accounts();
    std::cout << "Accounts:\n" << accounts.dump(2) << std::endl;

    // Create limit order
    json order = {
        {"product_id", "BTC-USD"},
        {"side", "BUY"},
        {"order_configuration", {
            {"limit_limit_gtc", {
                {"base_size", "0.001"},
                {"limit_price", "45000.00"},
                {"post_only", false}
            }}
        }}
    };

    json order_result = client.create_order(order);
    std::cout << "Order result:\n" << order_result.dump(2) << std::endl;

    return 0;
}


================================================================================
                    C++ CODE EXAMPLES - WEBSOCKET API
================================================================================

EXAMPLE 2: WEBSOCKET TICKER STREAM
-----------------------------------

#include <websocketpp/config/asio_client.hpp>
#include <websocketpp/client.hpp>
#include <nlohmann/json.hpp>
#include <jwt-cpp/jwt.h>

typedef websocketpp::client<websocketpp::config::asio_tls_client> ws_client;

class CoinbaseWebSocket {
private:
    ws_client client;
    std::string api_key_name;
    std::string private_key;

    std::string generate_jwt() {
        auto now = std::chrono::system_clock::now();
        auto exp = now + std::chrono::seconds(120);

        return jwt::create()
            .set_issuer("coinbase-cloud")
            .set_issued_at(now)
            .set_expires_at(exp)
            .set_key_id(api_key_name)
            .set_payload_claim("sub", jwt::claim(api_key_name))
            .sign(jwt::algorithm::es256("", private_key, "", ""));
    }

    void on_message(websocketpp::connection_hdl hdl, ws_client::message_ptr msg) {
        try {
            json j = json::parse(msg->get_payload());

            if(j.contains("events")) {
                for(auto& event : j["events"]) {
                    if(event["type"] == "ticker") {
                        for(auto& ticker : event["tickers"]) {
                            std::cout << "Ticker: " << ticker["product_id"]
                                     << " Price: " << ticker["price"]
                                     << " Volume: " << ticker["volume_24_h"]
                                     << std::endl;
                        }
                    }
                }
            }
        } catch(std::exception& e) {
            std::cerr << "Error: " << e.what() << std::endl;
        }
    }

    void on_open(websocketpp::connection_hdl hdl) {
        std::cout << "Connected to Coinbase WebSocket" << std::endl;

        // Subscribe to ticker
        json subscribe_msg = {
            {"type", "subscribe"},
            {"product_ids", {"BTC-USD", "ETH-USD"}},
            {"channel", "ticker"},
            {"jwt", generate_jwt()}
        };

        client.send(hdl, subscribe_msg.dump(), websocketpp::frame::opcode::text);
    }

public:
    CoinbaseWebSocket(const std::string& key_name, const std::string& priv_key)
        : api_key_name(key_name), private_key(priv_key) {

        client.init_asio();
        client.set_message_handler(bind(&CoinbaseWebSocket::on_message, this, ::_1, ::_2));
        client.set_open_handler(bind(&CoinbaseWebSocket::on_open, this, ::_1));
    }

    void connect() {
        std::string uri = "wss://advanced-trade-ws.coinbase.com";
        websocketpp::lib::error_code ec;

        ws_client::connection_ptr con = client.get_connection(uri, ec);
        if(ec) {
            std::cout << "Connection error: " << ec.message() << std::endl;
            return;
        }

        client.connect(con);
        client.run();
    }
};

================================================================================
                            BEST PRACTICES
================================================================================

1. SECURITY:
------------
- Store private keys in encrypted files
- Use environment variables for key paths
- Enable IP whitelisting
- Implement API key rotation
- Monitor API key usage
- Use read-only keys for market data

2. ERROR HANDLING:
------------------
- Parse error responses properly
- Implement exponential backoff
- Handle rate limits gracefully
- Retry failed requests with limits
- Log all errors with context

3. PERFORMANCE:
---------------
- Use WebSocket for real-time data
- Cache product information
- Implement connection pooling
- Monitor response latencies
- Use bulk operations when available

4. COMPLIANCE:
--------------
- Maintain transaction records
- Implement AML monitoring
- Follow jurisdiction requirements
- Report suspicious activity
- Keep audit logs

================================================================================
                        GEOGRAPHIC RESTRICTIONS
================================================================================

SUPPORTED REGIONS:
------------------
- United States (all 50 states)
- United Kingdom
- European Economic Area (EEA)
- Canada (except Ontario for some features)
- Singapore
- Australia
- Many other jurisdictions

RESTRICTED REGIONS:
-------------------
- Countries under US sanctions
- Some features restricted by region
- Check local regulations

================================================================================
                          KYC REQUIREMENTS
================================================================================

INDIVIDUAL ACCOUNTS:
--------------------
- Full name
- Date of birth
- Residential address
- Government-issued ID
- Selfie verification
- SSN/Tax ID (US customers)

INSTITUTIONAL ACCOUNTS:
-----------------------
- Company formation documents
- Beneficial owner information
- Financial statements
- Source of funds documentation
- Enhanced due diligence

================================================================================
                          SUPPORT RESOURCES
================================================================================

DOCUMENTATION:
--------------
- Main Docs: https://docs.cloud.coinbase.com/
- API Reference: https://docs.cloud.coinbase.com/advanced-trade-api/docs
- GitHub: https://github.com/coinbase

SUPPORT:
--------
- Help Center: https://help.coinbase.com
- Status Page: https://status.coinbase.com
- Email Support: support@coinbase.com
- Phone Support: Available for verified accounts

COMMUNITY:
----------
- Reddit: r/CoinBase
- Twitter: @CoinbaseSupport
- Developer Forum

================================================================================
                              END OF DOCUMENT
================================================================================
