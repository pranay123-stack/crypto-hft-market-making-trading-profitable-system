================================================================================
                              KRAKEN EXCHANGE
                     COMPREHENSIVE API INTEGRATION GUIDE
================================================================================

EXCHANGE OVERVIEW
================================================================================

Name: Kraken
Website: https://www.kraken.com
API Documentation: https://docs.kraken.com/rest/
Founded: 2011
Headquarters: San Francisco, California, USA
Trading Volume: $1-2 billion daily (2024)
Global Rank: #4-6 by trading volume

HISTORY AND BACKGROUND:
-----------------------
Founded in 2011 by Jesse Powell, Kraken is one of the oldest and most
established cryptocurrency exchanges. The platform launched publicly in 2013
and has built a reputation for security and regulatory compliance. Kraken
has never been hacked and maintains strong reserves.

Key Milestones:
- 2011: Founded
- 2013: Public launch
- 2014: First exchange to have trading price and volume displayed on Bloomberg Terminal
- 2016: Partnered with German Fidor Bank
- 2018: Acquired Crypto Facilities (futures platform)
- 2020: First crypto company to receive banking charter in US (Kraken Bank)
- 2021: Launched Kraken Pro mobile app
- 2024: Continued global expansion

REGULATORY STATUS:
------------------
- Registered as Money Services Business with FinCEN
- State-licensed money transmitter in US
- FCA registered in UK
- Licensed in Canada, Japan, Germany
- Full banking charter in Wyoming (Kraken Financial)

MARKET POSITION:
----------------
- Top 5 exchange by volume
- 200+ cryptocurrencies
- 500+ trading pairs
- Strong institutional presence
- Excellent security track record

================================================================================
                            TRADING PAIRS AND MARKETS
================================================================================

SPOT TRADING:
-------------
Major Pairs:
- BTC/USD, ETH/USD, XRP/USD, ADA/USD
- BTC/EUR, ETH/EUR, BTC/GBP, ETH/GBP
- BTC/USDT, ETH/USDT, BTC/USDC
- 500+ trading pairs

Base Currencies:
- USD, EUR, GBP, CAD, CHF, JPY, AUD
- USDT, USDC, DAI (stablecoins)
- BTC, ETH (crypto pairs)

FUTURES TRADING:
----------------
- Up to 50x leverage
- Perpetual contracts
- Fixed maturity contracts
- Multi-collateral margin
- Advanced order types

MARGIN TRADING:
---------------
- Up to 5x leverage on spot
- 50+ margin pairs
- Flexible collateral options

STAKING:
--------
- On-chain and off-chain staking
- 15+ stakeable assets
- Weekly reward distributions

================================================================================
                              API ARCHITECTURE
================================================================================

API TYPES AVAILABLE:
--------------------

1. REST API
   Base URL: https://api.kraken.com
   - Public market data (no auth)
   - Private account/trading (requires auth)
   - Rate limited per tier

2. WebSocket API
   Public: wss://ws.kraken.com
   Private: wss://ws-auth.kraken.com
   - Real-time market data
   - Account notifications
   - Order management

3. FIX API (Institutional)
   - FIX 4.4 protocol
   - Requires verification and approval
   - Low latency connectivity

API VERSIONS:
-------------
- Current: API version 0 (v0)
- Stable and well-maintained
- Backwards compatible

RATE LIMITS BY TIER:
--------------------
Starter: 15 counter decay/3 sec
Intermediate: 20 counter decay/3 sec
Pro: 20 counter decay/2 sec

================================================================================
                       API KEY AND SECRET KEY MANAGEMENT
================================================================================

CREATING API KEYS:
------------------
1. Log in to Kraken account
2. Navigate to Settings > API
3. Click "Generate New Key"
4. Configure permissions:
   - Query Funds
   - Query Open Orders & Trades
   - Query Closed Orders & Trades
   - Create & Modify Orders
   - Cancel/Close Orders
   - Withdraw Funds (NOT recommended)
   - Export Data
5. Set key description and expiration (optional)
6. Complete 2FA verification
7. Save API Key and Private Key

API KEY FORMAT:
---------------
- API Key: Base64 encoded string (56 characters)
- Private Key: Base64 encoded string (88 characters)

SECURITY RECOMMENDATIONS:
-------------------------
1. Never enable withdrawal permissions for trading bots
2. Use separate keys for different purposes
3. Set expiration dates for keys
4. Monitor key usage through dashboard
5. Rotate keys every 90 days
6. Store keys in encrypted configuration
7. Use nonce properly to prevent replay attacks

API KEY LIMITS:
---------------
- No hard limit on number of keys
- Each key has independent rate limits
- Keys can be disabled/deleted instantly

NONCE MANAGEMENT:
-----------------
Kraken requires increasing nonce values for security.
Common approach: Unix timestamp in microseconds

#include <chrono>

uint64_t get_nonce() {
    auto now = std::chrono::system_clock::now();
    auto duration = now.time_since_epoch();
    return std::chrono::duration_cast<std::chrono::microseconds>(duration).count();
}

================================================================================
                          AUTHENTICATION METHODS
================================================================================

SIGNATURE GENERATION:
---------------------
Kraken uses HMAC-SHA512 for authentication.

Process:
1. Create POST data: nonce=xxx&param1=value1&param2=value2
2. Create message: URI path + SHA256(nonce + POST data)
3. Generate signature: HMAC-SHA512(message, base64_decode(private_key))
4. Encode signature: base64_encode(signature)

Required Headers:
- API-Key: Your API key
- API-Sign: Base64 encoded signature

C++ AUTHENTICATION IMPLEMENTATION:
-----------------------------------

#include <iostream>
#include <string>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <openssl/hmac.h>
#include <openssl/sha.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <curl/curl.h>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

class KrakenAuth {
private:
    std::string api_key;
    std::string private_key;

    std::string base64_encode(const unsigned char* buffer, size_t length) {
        BIO *bio, *b64;
        BUF_MEM *buffer_ptr;

        b64 = BIO_new(BIO_f_base64());
        bio = BIO_new(BIO_s_mem());
        bio = BIO_push(b64, bio);
        BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
        BIO_write(bio, buffer, length);
        BIO_flush(bio);
        BIO_get_mem_ptr(bio, &buffer_ptr);

        std::string result(buffer_ptr->data, buffer_ptr->length);
        BIO_free_all(bio);
        return result;
    }

    std::string base64_decode(const std::string& encoded) {
        BIO *bio, *b64;
        size_t decode_len = encoded.length();
        unsigned char* buffer = new unsigned char[decode_len];

        bio = BIO_new_mem_buf(encoded.c_str(), -1);
        b64 = BIO_new(BIO_f_base64());
        bio = BIO_push(b64, bio);
        BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);

        int length = BIO_read(bio, buffer, decode_len);
        BIO_free_all(bio);

        std::string result((char*)buffer, length);
        delete[] buffer;
        return result;
    }

    std::string sha256(const std::string& data) {
        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256((unsigned char*)data.c_str(), data.length(), hash);
        return std::string((char*)hash, SHA256_DIGEST_LENGTH);
    }

    std::string hmac_sha512(const std::string& data, const std::string& key) {
        unsigned char* digest;
        unsigned int digest_len;

        digest = HMAC(EVP_sha512(),
                      key.c_str(), key.length(),
                      (unsigned char*)data.c_str(), data.length(),
                      NULL, &digest_len);

        return std::string((char*)digest, digest_len);
    }

public:
    KrakenAuth(const std::string& key, const std::string& secret)
        : api_key(key), private_key(secret) {}

    uint64_t get_nonce() {
        auto now = std::chrono::system_clock::now();
        auto duration = now.time_since_epoch();
        return std::chrono::duration_cast<std::chrono::microseconds>(duration).count();
    }

    struct AuthHeaders {
        std::string api_key;
        std::string api_sign;
    };

    AuthHeaders generate_headers(const std::string& path,
                                 const std::string& postdata) {
        AuthHeaders headers;
        headers.api_key = api_key;

        // Create message for signing
        std::string nonce_postdata_hash = sha256(postdata);
        std::string message = path + nonce_postdata_hash;

        // Decode private key and sign
        std::string decoded_secret = base64_decode(private_key);
        std::string signature = hmac_sha512(message, decoded_secret);

        // Base64 encode signature
        headers.api_sign = base64_encode(
            (unsigned char*)signature.c_str(),
            signature.length()
        );

        return headers;
    }
};

================================================================================
                          RATE LIMITS AND RESTRICTIONS
================================================================================

RATE LIMIT SYSTEM:
------------------
Kraken uses a "counter" system for rate limiting.

- Each API call costs a certain number of points
- Counter decays over time (tier-dependent)
- When counter exceeds maximum, request is rejected

COUNTER DECAY RATES:
--------------------
Starter: 15 counter reduction per 3 seconds (max 15)
Intermediate: 20 counter reduction per 3 seconds (max 20)
Pro: 20 counter reduction per 2 seconds (max 20)

API CALL COSTS:
---------------
Public Endpoints:
- Ticker, OHLC, Order book, Trades: 1 point

Private Endpoints:
- Balance, Trade Balance, Open Orders: 1 point
- Closed Orders, Query Orders: 1 point (2 if includes trades)
- Trades History, Query Trades: 2 points
- Add Order: 0 points (maker), 0 points (taker)
- Cancel Order: 0 points
- Ledgers: 2 points

WEBSOCKET LIMITS:
-----------------
- Max 50 subscriptions per connection
- Max 25 private channels per connection
- Heartbeat required every 30 seconds

HANDLING RATE LIMITS:
---------------------
Error returned: {"error":["EAPI:Rate limit exceeded"]}

Best Practices:
1. Track your counter usage
2. Implement exponential backoff
3. Use WebSocket for real-time data
4. Batch operations when possible
5. Upgrade to higher tier for more capacity

================================================================================
                          MARKET DATA STRUCTURE
================================================================================

SERVER TIME:
------------
GET /0/public/Time

{
  "error": [],
  "result": {
    "unixtime": 1701234567,
    "rfc1123": "Mon, 28 Nov 2024 12:00:00 +0000"
  }
}

ASSET PAIRS:
------------
GET /0/public/AssetPairs

{
  "error": [],
  "result": {
    "XXBTZUSD": {
      "altname": "BTCUSD",
      "wsname": "BTC/USD",
      "aclass_base": "currency",
      "base": "XXBT",
      "aclass_quote": "currency",
      "quote": "ZUSD",
      "pair_decimals": 1,
      "lot_decimals": 8,
      "lot_multiplier": 1,
      "leverage_buy": [2, 3, 4, 5],
      "leverage_sell": [2, 3, 4, 5],
      "fees": [[0, 0.26], [50000, 0.24], [100000, 0.22]],
      "fees_maker": [[0, 0.16], [50000, 0.14], [100000, 0.12]],
      "fee_volume_currency": "ZUSD",
      "margin_call": 80,
      "margin_stop": 40,
      "ordermin": "0.0001"
    }
  }
}

TICKER INFORMATION:
-------------------
GET /0/public/Ticker?pair=BTCUSD

{
  "error": [],
  "result": {
    "XXBTZUSD": {
      "a": ["50000.00000", "1", "1.000"],  // ask [price, whole lot volume, lot volume]
      "b": ["49999.00000", "2", "2.000"],  // bid
      "c": ["50000.00000", "0.05000000"],  // last trade [price, lot volume]
      "v": ["1234.56789012", "2345.67890123"],  // volume [today, last 24 hours]
      "p": ["49500.00000", "49600.00000"],  // VWAP [today, last 24 hours]
      "t": [1000, 2000],  // number of trades [today, last 24 hours]
      "l": ["49000.00000", "48900.00000"],  // low [today, last 24 hours]
      "h": ["50500.00000", "50600.00000"],  // high [today, last 24 hours]
      "o": "49500.00000"  // today's opening price
    }
  }
}

ORDER BOOK:
-----------
GET /0/public/Depth?pair=BTCUSD&count=10

{
  "error": [],
  "result": {
    "XXBTZUSD": {
      "asks": [
        ["50000.000", "1.500", 1701234567],  // [price, volume, timestamp]
        ["50001.000", "2.300", 1701234568]
      ],
      "bids": [
        ["49999.000", "1.200", 1701234567],
        ["49998.000", "3.100", 1701234568]
      ]
    }
  }
}

RECENT TRADES:
--------------
GET /0/public/Trades?pair=BTCUSD

{
  "error": [],
  "result": {
    "XXBTZUSD": [
      ["50000.00000", "0.50000000", 1701234567.1234, "b", "m", ""],
      ["50001.00000", "0.25000000", 1701234568.5678, "s", "l", ""]
    ],
    "last": "1701234568567890123"
  }
}
Format: [price, volume, time, buy/sell, market/limit, miscellaneous]

OHLC DATA:
----------
GET /0/public/OHLC?pair=BTCUSD&interval=60

{
  "error": [],
  "result": {
    "XXBTZUSD": [
      [1701234000, "49500.0", "50100.0", "49900.0", "50000.0", "50050.0",
       "123.45", 100]
    ],
    "last": 1701234000
  }
}
Format: [time, open, high, low, close, vwap, volume, count]
Intervals: 1, 5, 15, 30, 60, 240, 1440, 10080, 21600 (minutes)

================================================================================
                          ORDER TYPES SUPPORTED
================================================================================

MARKET ORDER:
-------------
Executes immediately at best available price.

{
  "ordertype": "market",
  "type": "buy",
  "volume": "0.01",
  "pair": "BTCUSD"
}

LIMIT ORDER:
------------
Executes at specified price or better.

{
  "ordertype": "limit",
  "type": "buy",
  "volume": "0.01",
  "price": "50000.00",
  "pair": "BTCUSD"
}

STOP-LOSS ORDER:
----------------
Triggers market order when price reached.

{
  "ordertype": "stop-loss",
  "type": "sell",
  "volume": "0.01",
  "price": "49000.00",  // trigger price
  "pair": "BTCUSD"
}

STOP-LOSS-LIMIT ORDER:
----------------------
Triggers limit order when price reached.

{
  "ordertype": "stop-loss-limit",
  "type": "sell",
  "volume": "0.01",
  "price": "49000.00",   // trigger price
  "price2": "48900.00",  // limit price
  "pair": "BTCUSD"
}

TAKE-PROFIT ORDER:
------------------
{
  "ordertype": "take-profit",
  "type": "sell",
  "volume": "0.01",
  "price": "51000.00",
  "pair": "BTCUSD"
}

TAKE-PROFIT-LIMIT ORDER:
------------------------
{
  "ordertype": "take-profit-limit",
  "type": "sell",
  "volume": "0.01",
  "price": "51000.00",   // trigger price
  "price2": "51100.00",  // limit price
  "pair": "BTCUSD"
}

TRAILING STOP ORDER:
--------------------
{
  "ordertype": "trailing-stop",
  "type": "sell",
  "volume": "0.01",
  "price": "1000.00",  // trailing amount
  "pair": "BTCUSD"
}

ORDER FLAGS:
------------
- post: Post-only order (maker only)
- fcib: Prefer fee in base currency
- fciq: Prefer fee in quote currency
- nompp: No market price protection
- viqc: Order volume expressed in quote currency

TIME IN FORCE:
--------------
- GTC (Good-Till-Cancelled): Default
- IOC (Immediate-Or-Cancel)
- GTD (Good-Till-Date): Requires expiry time

CONDITIONAL ORDERS:
-------------------
Support for:
- If-touched orders
- One-cancels-other (OCO)
- Conditional close orders

================================================================================
                              FEE STRUCTURE
================================================================================

SPOT TRADING FEES (2024):
--------------------------

Volume-Based Tiers (30-day USD volume):
Tier 0: $0 - $50K
  Maker: 0.16% / Taker: 0.26%

Tier 1: $50K - $100K
  Maker: 0.14% / Taker: 0.24%

Tier 2: $100K - $250K
  Maker: 0.12% / Taker: 0.22%

Tier 3: $250K - $500K
  Maker: 0.10% / Taker: 0.20%

Tier 4: $500K - $1M
  Maker: 0.08% / Taker: 0.18%

Tier 5: $1M - $2.5M
  Maker: 0.06% / Taker: 0.16%

Tier 6: $2.5M - $5M
  Maker: 0.04% / Taker: 0.14%

Tier 7: $5M - $10M
  Maker: 0.02% / Taker: 0.12%

Tier 8: $10M+
  Maker: 0.00% / Taker: 0.10%

STABLECOIN PAIRS:
-----------------
Lower fees for stablecoin pairs (USDC, USDT, DAI)
Maker: 0.00% - 0.10%
Taker: 0.10% - 0.20%

FUTURES TRADING FEES:
---------------------
Maker: 0.02%
Taker: 0.05%
Volume discounts available

DEPOSIT FEES:
-------------
- Cryptocurrency: Free
- Fiat (wire): $5 - $10 depending on currency
- Fiat (online banking): Free (select regions)

WITHDRAWAL FEES:
----------------
Cryptocurrency (examples):
- BTC: 0.00005 BTC
- ETH: 0.0005 ETH
- XRP: 0.02 XRP

Fiat:
- Wire transfer: $5 - $25 depending on currency

================================================================================
                          WEBSOCKET CHANNELS
================================================================================

CONNECTION ENDPOINTS:
---------------------
Public: wss://ws.kraken.com
Private: wss://ws-auth.kraken.com

PUBLIC CHANNELS:
----------------

1. Ticker:
   {"name": "ticker"}
   - Real-time price updates
   - Bid/ask, VWAP, volume, etc.

2. OHLC:
   {"name": "ohlc", "interval": 1}
   - Candlestick updates
   - Intervals: 1, 5, 15, 30, 60, 240, 1440

3. Trade:
   {"name": "trade"}
   - Real-time trades
   - Price, volume, side, time

4. Spread:
   {"name": "spread"}
   - Best bid/ask updates

5. Book:
   {"name": "book", "depth": 10}
   - Order book snapshots and updates
   - Depths: 10, 25, 100, 500, 1000

PRIVATE CHANNELS:
-----------------

1. openOrders:
   - Real-time order updates

2. ownTrades:
   - Trade execution notifications

SUBSCRIPTION FORMAT:
--------------------
{
  "event": "subscribe",
  "pair": ["BTC/USD", "ETH/USD"],
  "subscription": {
    "name": "ticker"
  }
}

MESSAGE FORMATS:
----------------

Ticker Update:
[
  channelID,
  {
    "a": ["50000.00000", 1, "1.000"],
    "b": ["49999.00000", 2, "2.000"],
    "c": ["50000.00000", "0.05000000"],
    "v": ["1234.56789012", "2345.67890123"],
    "p": ["49500.00000", "49600.00000"],
    "t": [1000, 2000],
    "l": ["49000.00000", "48900.00000"],
    "h": ["50500.00000", "50600.00000"],
    "o": ["49500.00000", "49500.00000"]
  },
  "ticker",
  "XBT/USD"
]

Trade Update:
[
  channelID,
  [
    ["50000.00000", "0.50000000", "1701234567.123456", "b", "m", ""]
  ],
  "trade",
  "XBT/USD"
]

================================================================================
                      C++ CODE EXAMPLES - REST API
================================================================================

COMPLETE KRAKEN CLIENT IMPLEMENTATION:
--------------------------------------

#include <curl/curl.h>
#include <nlohmann/json.hpp>
#include <openssl/hmac.h>
#include <openssl/sha.h>
#include <iostream>
#include <chrono>

using json = nlohmann::json;

class KrakenClient {
private:
    std::string api_key;
    std::string private_key;
    std::string base_url = "https://api.kraken.com";

    static size_t WriteCallback(void* contents, size_t size,
                               size_t nmemb, std::string* userp) {
        userp->append((char*)contents, size * nmemb);
        return size * nmemb;
    }

    uint64_t get_nonce() {
        auto now = std::chrono::system_clock::now();
        auto duration = now.time_since_epoch();
        return std::chrono::duration_cast<std::chrono::microseconds>(duration).count();
    }

    std::string generate_signature(const std::string& path,
                                   const std::string& postdata) {
        // Implementation similar to KrakenAuth class above
        // ... (signature generation code)
        return ""; // placeholder
    }

    std::string public_request(const std::string& endpoint,
                               const std::string& params = "") {
        CURL* curl = curl_easy_init();
        std::string response;

        if(curl) {
            std::string url = base_url + endpoint;
            if(!params.empty()) {
                url += "?" + params;
            }

            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

            CURLcode res = curl_easy_perform(curl);
            if(res != CURLE_OK) {
                std::cerr << "Request failed: " << curl_easy_strerror(res) << std::endl;
            }
            curl_easy_cleanup(curl);
        }
        return response;
    }

    std::string private_request(const std::string& endpoint,
                                const json& params) {
        CURL* curl = curl_easy_init();
        std::string response;

        if(curl) {
            uint64_t nonce = get_nonce();
            json post_params = params;
            post_params["nonce"] = nonce;

            std::string postdata = "nonce=" + std::to_string(nonce);
            for(auto& el : params.items()) {
                postdata += "&" + el.key() + "=" + el.value().dump();
            }

            std::string signature = generate_signature(endpoint, postdata);
            std::string url = base_url + endpoint;

            struct curl_slist* headers = NULL;
            std::string api_key_header = "API-Key: " + api_key;
            std::string api_sign_header = "API-Sign: " + signature;

            headers = curl_slist_append(headers, api_key_header.c_str());
            headers = curl_slist_append(headers, api_sign_header.c_str());
            headers = curl_slist_append(headers, "Content-Type: application/x-www-form-urlencoded");

            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

            CURLcode res = curl_easy_perform(curl);
            if(res != CURLE_OK) {
                std::cerr << "Request failed: " << curl_easy_strerror(res) << std::endl;
            }

            curl_slist_free_all(headers);
            curl_easy_cleanup(curl);
        }
        return response;
    }

public:
    KrakenClient(const std::string& key, const std::string& secret)
        : api_key(key), private_key(secret) {}

    // Public API methods
    json get_server_time() {
        std::string response = public_request("/0/public/Time");
        return json::parse(response);
    }

    json get_asset_pairs(const std::string& pair = "") {
        std::string params = pair.empty() ? "" : "pair=" + pair;
        std::string response = public_request("/0/public/AssetPairs", params);
        return json::parse(response);
    }

    json get_ticker(const std::string& pair) {
        std::string response = public_request("/0/public/Ticker", "pair=" + pair);
        return json::parse(response);
    }

    json get_order_book(const std::string& pair, int count = 100) {
        std::string params = "pair=" + pair + "&count=" + std::to_string(count);
        std::string response = public_request("/0/public/Depth", params);
        return json::parse(response);
    }

    json get_recent_trades(const std::string& pair) {
        std::string response = public_request("/0/public/Trades", "pair=" + pair);
        return json::parse(response);
    }

    // Private API methods
    json get_balance() {
        std::string response = private_request("/0/private/Balance", {});
        return json::parse(response);
    }

    json add_order(const std::string& pair,
                  const std::string& type,
                  const std::string& ordertype,
                  const std::string& volume,
                  const std::string& price = "",
                  const json& optional_params = {}) {
        json params = {
            {"pair", pair},
            {"type", type},
            {"ordertype", ordertype},
            {"volume", volume}
        };

        if(!price.empty()) {
            params["price"] = price;
        }

        for(auto& el : optional_params.items()) {
            params[el.key()] = el.value();
        }

        std::string response = private_request("/0/private/AddOrder", params);
        return json::parse(response);
    }

    json cancel_order(const std::string& txid) {
        json params = {{"txid", txid}};
        std::string response = private_request("/0/private/CancelOrder", params);
        return json::parse(response);
    }

    json get_open_orders() {
        std::string response = private_request("/0/private/OpenOrders", {});
        return json::parse(response);
    }
};

// Usage example:
int main() {
    KrakenClient client("your_api_key", "your_private_key");

    // Get ticker
    json ticker = client.get_ticker("XBTUSD");
    std::cout << "Ticker: " << ticker.dump(2) << std::endl;

    // Place limit order
    json order = client.add_order("XBTUSD", "buy", "limit", "0.001", "45000");
    std::cout << "Order: " << order.dump(2) << std::endl;

    return 0;
}

================================================================================
                            BEST PRACTICES
================================================================================

1. NONCE MANAGEMENT:
--------------------
- Use microsecond timestamps
- Ensure strictly increasing values
- Handle clock synchronization
- Consider using sequence numbers

2. ERROR HANDLING:
------------------
- Check "error" field in responses
- Implement retry logic for transient errors
- Handle rate limit errors (EAPI:Rate limit exceeded)
- Log all errors with context

3. PERFORMANCE:
---------------
- Use WebSocket for market data
- Maintain local order book
- Batch queries when possible
- Monitor counter usage
- Implement connection pooling

4. SECURITY:
------------
- Never enable withdrawal permission for bots
- Use IP whitelisting if available
- Rotate API keys regularly
- Monitor unauthorized access attempts
- Implement 2FA for account

================================================================================
                        GEOGRAPHIC RESTRICTIONS
================================================================================

SUPPORTED REGIONS:
------------------
- United States (most states, check specific restrictions)
- European Union
- United Kingdom
- Canada
- Australia
- Japan
- Many other countries

RESTRICTED REGIONS:
-------------------
- New York (BitLicense requirements)
- Washington State (additional restrictions)
- Countries under international sanctions

VPN USAGE:
----------
- Not explicitly prohibited
- May trigger additional verification
- Use with caution

================================================================================
                          KYC REQUIREMENTS
================================================================================

STARTER VERIFICATION:
---------------------
- Email and phone
- Basic information
- Deposit limit: $1,000
- No trading restrictions

INTERMEDIATE VERIFICATION:
--------------------------
- Government-issued ID
- Proof of residence
- Deposit limit: $5,000/day
- Full trading access

PRO VERIFICATION:
-----------------
- Enhanced ID verification
- Source of wealth documentation
- Unlimited deposits/withdrawals
- Institutional features

================================================================================
                          SUPPORT RESOURCES
================================================================================

DOCUMENTATION:
--------------
- API Docs: https://docs.kraken.com/rest/
- WebSocket Docs: https://docs.kraken.com/websockets/
- Support Center: https://support.kraken.com

OFFICIAL SUPPORT:
-----------------
- Ticket System: Available through website
- Live Chat: For verified users
- Phone Support: For Pro/institutional clients

COMMUNITY:
----------
- Reddit: r/Kraken
- Twitter: @krakenfx
- GitHub: https://github.com/kraken

TESTNET:
--------
- Not publicly available
- Use small amounts for testing

================================================================================
                              END OF DOCUMENT
================================================================================
