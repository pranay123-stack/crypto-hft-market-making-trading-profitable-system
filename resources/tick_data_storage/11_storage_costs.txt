================================================================================
                    STORAGE COST ANALYSIS AND OPTIMIZATION
                    TCO for HFT Tick Data Storage
================================================================================

Table of Contents:
1. Storage Cost Components
2. Cost Analysis by Storage Tier
3. Cost Modeling and Forecasting
4. Cost Optimization Strategies
5. Compression Cost-Benefit Analysis
6. Cloud vs On-Premise TCO
7. Cost Monitoring and Alerting
8. Cost Optimization Recommendations

================================================================================
SECTION 1: STORAGE COST COMPONENTS
================================================================================

1.1 Total Cost of Ownership (TCO) Breakdown
-------------------------------------------

TCO Components:
┌─────────────────────────────┬──────────────┬────────────────────────────────┐
│ Cost Category               │ % of TCO     │ Components                     │
├─────────────────────────────┼──────────────┼────────────────────────────────┤
│ Hardware (CapEx)            │ 35-45%       │ Servers, storage, networking   │
│ Software Licenses           │ 10-15%       │ OS, DB licenses, monitoring    │
│ Facilities & Power          │ 15-20%       │ Datacenter, cooling, power     │
│ Personnel                   │ 20-25%       │ DevOps, SRE, DB admins         │
│ Network & Bandwidth         │ 5-10%        │ Data ingestion, replication    │
│ Maintenance & Support       │ 5-10%        │ Hardware refresh, support      │
└─────────────────────────────┴──────────────┴────────────────────────────────┘

1.2 Cost Calculation Framework
------------------------------

```cpp
// storage_cost_model.hpp - Storage Cost Modeling
#pragma once

#include <map>
#include <string>
#include <cmath>

namespace hft {
namespace cost {

struct HardwareCost {
    // Initial purchase
    double nvme_ssd_per_tb = 150.0;      // $150/TB for NVMe
    double sata_ssd_per_tb = 80.0;       // $80/TB for SATA SSD
    double hdd_per_tb = 20.0;            // $20/TB for HDD

    // Server costs
    double server_base_cost = 5000.0;    // Base server
    double cpu_cost_per_core = 50.0;     // Per CPU core
    double ram_cost_per_gb = 5.0;        // Per GB RAM

    // Network
    double network_switch_10g = 2000.0;  // 10GbE switch
    double network_switch_100g = 15000.0; // 100GbE switch

    // Depreciation period (years)
    double nvme_lifetime_years = 3.0;
    double ssd_lifetime_years = 5.0;
    double hdd_lifetime_years = 5.0;
    double server_lifetime_years = 5.0;
};

struct OperationalCost {
    // Monthly recurring costs
    double power_per_kwh = 0.10;              // $0.10/kWh
    double cooling_multiplier = 1.5;          // 1.5x power for cooling
    double datacenter_per_rack_unit = 100.0;  // $100/RU/month

    // Personnel (annual)
    double devops_engineer_annual = 150000.0;
    double sre_annual = 160000.0;
    double dba_annual = 140000.0;

    // Network bandwidth
    double bandwidth_per_gb = 0.05;  // $0.05/GB transfer
};

struct CloudCost {
    // AWS pricing examples (us-east-1)
    double ebs_gp3_per_gb_month = 0.08;       // GP3 SSD
    double ebs_io2_per_gb_month = 0.125;      // IO2 (high IOPS)
    double ebs_iops_per_month = 0.065;        // Per provisioned IOPS

    double s3_standard_per_gb = 0.023;        // S3 Standard
    double s3_ia_per_gb = 0.0125;             // S3 Infrequent Access
    double s3_glacier_per_gb = 0.004;         // S3 Glacier
    double s3_deep_archive_per_gb = 0.00099;  // S3 Glacier Deep Archive

    // RDS pricing
    double rds_timescaledb_instance = 1.50;   // r6g.2xlarge hourly

    // Data transfer
    double data_transfer_out_per_gb = 0.09;   // First 10TB
    double data_transfer_in_per_gb = 0.00;    // Free
};

class StorageCostCalculator {
public:
    StorageCostCalculator(
        const HardwareCost& hw_cost,
        const OperationalCost& op_cost,
        const CloudCost& cloud_cost
    ) : hw_cost_(hw_cost), op_cost_(op_cost), cloud_cost_(cloud_cost) {}

    // Calculate on-premise storage cost
    struct OnPremiseCost {
        double hardware_capex;
        double monthly_opex;
        double annual_tco;
        double cost_per_tb_month;

        void print() const {
            printf("\n========== ON-PREMISE STORAGE COST ==========\n");
            printf("Initial CapEx:        $%'12.2f\n", hardware_capex);
            printf("Monthly OpEx:         $%'12.2f\n", monthly_opex);
            printf("Annual TCO:           $%'12.2f\n", annual_tco);
            printf("Cost per TB/month:    $%'12.2f\n", cost_per_tb_month);
            printf("=============================================\n\n");
        }
    };

    OnPremiseCost calculateOnPremise(
        double hot_tb,
        double warm_tb,
        double cold_tb,
        size_t num_servers,
        size_t cpu_cores_per_server,
        size_t ram_gb_per_server
    ) {
        OnPremiseCost cost{};

        // Hardware CapEx
        double storage_cost =
            hot_tb * hw_cost_.nvme_ssd_per_tb +
            warm_tb * hw_cost_.sata_ssd_per_tb +
            cold_tb * hw_cost_.hdd_per_tb;

        double server_cost = num_servers * (
            hw_cost_.server_base_cost +
            cpu_cores_per_server * hw_cost_.cpu_cost_per_core +
            ram_gb_per_server * hw_cost_.ram_cost_per_gb
        );

        double network_cost = hw_cost_.network_switch_100g * 2;  // Redundant

        cost.hardware_capex = storage_cost + server_cost + network_cost;

        // Monthly OpEx

        // Power consumption estimate
        double power_kw =
            num_servers * 0.5 +  // 500W per server
            (hot_tb * 0.01) +    // 10W per TB NVMe
            (warm_tb * 0.005) +  // 5W per TB SSD
            (cold_tb * 0.008);   // 8W per TB HDD

        double monthly_power = power_kw * 24 * 30 *
            op_cost_.power_per_kwh * op_cost_.cooling_multiplier;

        // Datacenter (assume 4U per server)
        double monthly_datacenter = num_servers * 4 *
            op_cost_.datacenter_per_rack_unit;

        // Personnel (amortized monthly)
        double monthly_personnel =
            (op_cost_.devops_engineer_annual * 0.5 +  // 50% allocation
             op_cost_.sre_annual * 0.3 +              // 30% allocation
             op_cost_.dba_annual * 0.2) / 12;         // 20% allocation

        cost.monthly_opex = monthly_power + monthly_datacenter + monthly_personnel;

        // Annual TCO (CapEx amortized over lifetime)
        double annual_capex_amortized = cost.hardware_capex /
            hw_cost_.server_lifetime_years;

        cost.annual_tco = annual_capex_amortized + (cost.monthly_opex * 12);

        // Cost per TB per month
        double total_tb = hot_tb + warm_tb + cold_tb;
        if (total_tb > 0) {
            cost.cost_per_tb_month = (cost.annual_tco / 12) / total_tb;
        }

        return cost;
    }

    // Calculate cloud storage cost
    struct CloudStorageCost {
        double monthly_storage;
        double monthly_iops;
        double monthly_transfer;
        double monthly_total;
        double annual_tco;
        double cost_per_tb_month;

        void print() const {
            printf("\n========== CLOUD STORAGE COST ==========\n");
            printf("Monthly Storage:      $%'12.2f\n", monthly_storage);
            printf("Monthly IOPS:         $%'12.2f\n", monthly_iops);
            printf("Monthly Transfer:     $%'12.2f\n", monthly_transfer);
            printf("Monthly Total:        $%'12.2f\n", monthly_total);
            printf("Annual TCO:           $%'12.2f\n", annual_tco);
            printf("Cost per TB/month:    $%'12.2f\n", cost_per_tb_month);
            printf("========================================\n\n");
        }
    };

    CloudStorageCost calculateCloud(
        double hot_tb,
        double warm_tb,
        double cold_tb,
        double archive_tb,
        size_t provisioned_iops,
        double monthly_transfer_tb
    ) {
        CloudStorageCost cost{};

        // Storage costs
        cost.monthly_storage =
            hot_tb * 1024 * cloud_cost_.ebs_io2_per_gb_month +
            warm_tb * 1024 * cloud_cost_.ebs_gp3_per_gb_month +
            cold_tb * 1024 * cloud_cost_.s3_ia_per_gb +
            archive_tb * 1024 * cloud_cost_.s3_glacier_per_gb;

        // IOPS costs (for hot storage)
        cost.monthly_iops = provisioned_iops * cloud_cost_.ebs_iops_per_month;

        // Transfer costs
        cost.monthly_transfer = monthly_transfer_tb * 1024 *
            cloud_cost_.data_transfer_out_per_gb;

        cost.monthly_total = cost.monthly_storage + cost.monthly_iops +
            cost.monthly_transfer;

        cost.annual_tco = cost.monthly_total * 12;

        // Cost per TB per month
        double total_tb = hot_tb + warm_tb + cold_tb + archive_tb;
        if (total_tb > 0) {
            cost.cost_per_tb_month = cost.monthly_total / total_tb;
        }

        return cost;
    }

private:
    HardwareCost hw_cost_;
    OperationalCost op_cost_;
    CloudCost cloud_cost_;
};

} // namespace cost
} // namespace hft
```

================================================================================
SECTION 2: COST ANALYSIS BY STORAGE TIER
================================================================================

2.1 Per-Tier Cost Breakdown
---------------------------

Cost Comparison (per TB per month):
┌─────────────────────┬──────────────┬──────────────┬──────────────┬─────────┐
│ Storage Tier        │ On-Premise   │ AWS Cloud    │ GCP          │ Azure   │
├─────────────────────┼──────────────┼──────────────┼──────────────┼─────────┤
│ HOT (NVMe/EBS io2)  │ $35-50       │ $80-120      │ $75-110      │ $70-105 │
│ WARM (SSD/EBS gp3)  │ $15-25       │ $45-70       │ $40-65       │ $38-62  │
│ COLD (HDD/S3 IA)    │ $8-12        │ $15-25       │ $12-20       │ $10-18  │
│ ARCHIVE (S3 Glacier)│ N/A          │ $4-8         │ $3-7         │ $2-6    │
│ DEEP (Deep Archive) │ N/A          │ $1-2         │ $1-2         │ $1-2    │
└─────────────────────┴──────────────┴──────────────┴──────────────┴─────────┘

Note: On-premise costs include amortized CapEx, power, cooling, and personnel.

2.2 Example Cost Calculation
----------------------------

```cpp
// Example: 100TB tick data storage system
int main() {
    using namespace hft::cost;

    HardwareCost hw_cost;
    OperationalCost op_cost;
    CloudCost cloud_cost;

    StorageCostCalculator calculator(hw_cost, op_cost, cloud_cost);

    // Scenario: HFT firm storing 100TB tick data
    // - 5TB hot (last 7 days)
    // - 20TB warm (last 90 days)
    // - 75TB cold (1 year history)

    std::cout << "========================================\n";
    std::cout << "HFT TICK DATA STORAGE COST COMPARISON\n";
    std::cout << "Total Data: 100TB (5TB hot, 20TB warm, 75TB cold)\n";
    std::cout << "========================================\n\n";

    // On-premise calculation
    auto onprem = calculator.calculateOnPremise(
        5.0,   // 5TB hot (NVMe)
        20.0,  // 20TB warm (SSD)
        75.0,  // 75TB cold (HDD)
        4,     // 4 servers
        32,    // 32 cores per server
        256    // 256GB RAM per server
    );
    onprem.print();

    // Cloud calculation
    auto cloud = calculator.calculateCloud(
        5.0,   // 5TB hot (EBS io2)
        20.0,  // 20TB warm (EBS gp3)
        75.0,  // 75TB cold (S3 IA)
        0.0,   // 0TB archive (for now)
        100000, // 100k IOPS for hot tier
        10.0   // 10TB monthly transfer
    );
    cloud.print();

    // Break-even analysis
    double onprem_monthly = onprem.annual_tco / 12;
    double cloud_monthly = cloud.monthly_total;

    std::cout << "========================================\n";
    std::cout << "BREAK-EVEN ANALYSIS\n";
    std::cout << "========================================\n";
    printf("On-premise monthly:  $%'12.2f\n", onprem_monthly);
    printf("Cloud monthly:       $%'12.2f\n", cloud_monthly);
    printf("Monthly difference:  $%'12.2f ", std::abs(onprem_monthly - cloud_monthly));

    if (onprem_monthly < cloud_monthly) {
        printf("(on-premise cheaper)\n");
        printf("Annual savings:      $%'12.2f\n",
            (cloud_monthly - onprem_monthly) * 12);
    } else {
        printf("(cloud cheaper)\n");
        printf("Break-even months:   %.1f\n",
            onprem.hardware_capex / (onprem_monthly - cloud_monthly));
    }
    std::cout << "========================================\n\n";

    return 0;
}

/* Expected Output:
========================================
HFT TICK DATA STORAGE COST COMPARISON
Total Data: 100TB (5TB hot, 20TB warm, 75TB cold)
========================================

========== ON-PREMISE STORAGE COST ==========
Initial CapEx:        $   57,640.00
Monthly OpEx:         $   14,825.00
Annual TCO:           $  189,428.00
Cost per TB/month:    $      157.86
=============================================

========== CLOUD STORAGE COST ==========
Monthly Storage:      $    9,822.00
Monthly IOPS:         $    6,500.00
Monthly Transfer:     $      921.60
Monthly Total:        $   17,243.60
Annual TCO:           $  206,923.20
Cost per TB/month:    $      172.44
========================================

========================================
BREAK-EVEN ANALYSIS
========================================
On-premise monthly:  $   15,785.67
Cloud monthly:       $   17,243.60
Monthly difference:  $    1,457.93 (on-premise cheaper)
Annual savings:      $   17,495.16
========================================
*/
```

================================================================================
SECTION 3: COST MODELING AND FORECASTING
================================================================================

3.1 Data Growth Projections
---------------------------

```cpp
// cost_forecast.hpp - Cost Forecasting Model
#pragma once

#include <vector>
#include <cmath>

namespace hft {
namespace cost {

struct GrowthModel {
    double initial_tb;
    double monthly_growth_rate;  // e.g., 0.05 = 5% per month
    size_t forecast_months;

    // Calculate storage size at month N
    double sizeAtMonth(size_t month) const {
        return initial_tb * std::pow(1.0 + monthly_growth_rate, month);
    }

    // Total storage over forecast period
    double totalStorage() const {
        double total = 0.0;
        for (size_t m = 0; m < forecast_months; ++m) {
            total += sizeAtMonth(m);
        }
        return total;
    }
};

class CostForecaster {
public:
    struct ForecastResult {
        std::vector<double> monthly_storage_tb;
        std::vector<double> monthly_cost;
        std::vector<double> cumulative_cost;

        double total_cost;
        double avg_monthly_cost;
        double final_storage_tb;

        void print() const {
            printf("\n========== COST FORECAST ==========\n");
            printf("Forecast period:      %zu months\n", monthly_cost.size());
            printf("Final storage:        %.2f TB\n", final_storage_tb);
            printf("Total cost:           $%'12.2f\n", total_cost);
            printf("Avg monthly cost:     $%'12.2f\n", avg_monthly_cost);
            printf("\nMonthly Breakdown (first 12 months):\n");
            printf("Month  Storage(TB)    Cost($)    Cumulative($)\n");
            printf("----  ------------  -----------  --------------\n");

            size_t display_months = std::min(size_t(12), monthly_cost.size());
            for (size_t i = 0; i < display_months; ++i) {
                printf("%4zu  %12.2f  %'11.2f  %'14.2f\n",
                    i + 1,
                    monthly_storage_tb[i],
                    monthly_cost[i],
                    cumulative_cost[i]);
            }
            printf("===================================\n\n");
        }
    };

    ForecastResult forecastOnPremise(
        const GrowthModel& hot_growth,
        const GrowthModel& warm_growth,
        const GrowthModel& cold_growth,
        const StorageCostCalculator& calculator
    ) {
        ForecastResult result;

        size_t months = std::max({
            hot_growth.forecast_months,
            warm_growth.forecast_months,
            cold_growth.forecast_months
        });

        result.monthly_storage_tb.reserve(months);
        result.monthly_cost.reserve(months);
        result.cumulative_cost.reserve(months);

        double cumulative = 0.0;

        for (size_t m = 0; m < months; ++m) {
            double hot_tb = hot_growth.sizeAtMonth(m);
            double warm_tb = warm_growth.sizeAtMonth(m);
            double cold_tb = cold_growth.sizeAtMonth(m);
            double total_tb = hot_tb + warm_tb + cold_tb;

            // Recalculate servers needed (scale up)
            size_t servers = static_cast<size_t>(std::ceil(total_tb / 25.0));  // 25TB per server
            servers = std::max(servers, size_t(4));  // Minimum 4 servers

            auto cost = calculator.calculateOnPremise(
                hot_tb, warm_tb, cold_tb,
                servers, 32, 256
            );

            double monthly = cost.annual_tco / 12;
            cumulative += monthly;

            result.monthly_storage_tb.push_back(total_tb);
            result.monthly_cost.push_back(monthly);
            result.cumulative_cost.push_back(cumulative);
        }

        result.total_cost = cumulative;
        result.avg_monthly_cost = cumulative / months;
        result.final_storage_tb = result.monthly_storage_tb.back();

        return result;
    }

    ForecastResult forecastCloud(
        const GrowthModel& hot_growth,
        const GrowthModel& warm_growth,
        const GrowthModel& cold_growth,
        const GrowthModel& archive_growth,
        const StorageCostCalculator& calculator,
        size_t base_iops,
        double transfer_tb_per_month
    ) {
        ForecastResult result;

        size_t months = std::max({
            hot_growth.forecast_months,
            warm_growth.forecast_months,
            cold_growth.forecast_months,
            archive_growth.forecast_months
        });

        result.monthly_storage_tb.reserve(months);
        result.monthly_cost.reserve(months);
        result.cumulative_cost.reserve(months);

        double cumulative = 0.0;

        for (size_t m = 0; m < months; ++m) {
            double hot_tb = hot_growth.sizeAtMonth(m);
            double warm_tb = warm_growth.sizeAtMonth(m);
            double cold_tb = cold_growth.sizeAtMonth(m);
            double archive_tb = archive_growth.sizeAtMonth(m);
            double total_tb = hot_tb + warm_tb + cold_tb + archive_tb;

            // Scale IOPS with hot storage
            size_t scaled_iops = static_cast<size_t>(base_iops * (hot_tb / hot_growth.initial_tb));

            auto cost = calculator.calculateCloud(
                hot_tb, warm_tb, cold_tb, archive_tb,
                scaled_iops, transfer_tb_per_month
            );

            cumulative += cost.monthly_total;

            result.monthly_storage_tb.push_back(total_tb);
            result.monthly_cost.push_back(cost.monthly_total);
            result.cumulative_cost.push_back(cumulative);
        }

        result.total_cost = cumulative;
        result.avg_monthly_cost = cumulative / months;
        result.final_storage_tb = result.monthly_storage_tb.back();

        return result;
    }

    // Compare on-premise vs cloud over time
    struct ComparisonResult {
        ForecastResult onpremise;
        ForecastResult cloud;

        size_t breakeven_month;  // 0 if never breaks even
        double total_savings;     // Positive if on-prem cheaper

        void print() const {
            printf("\n========== ON-PREMISE VS CLOUD COMPARISON ==========\n\n");

            onpremise.print();
            cloud.print();

            printf("\n========== COMPARISON SUMMARY ==========\n");
            printf("Total cost difference: $%'12.2f ", std::abs(total_savings));
            if (total_savings > 0) {
                printf("(on-premise cheaper)\n");
            } else {
                printf("(cloud cheaper)\n");
            }

            if (breakeven_month > 0 && breakeven_month < 120) {
                printf("Break-even month:      %zu\n", breakeven_month);
            } else {
                printf("Break-even:            Never in forecast period\n");
            }
            printf("========================================\n\n");
        }
    };

    ComparisonResult compare(
        const ForecastResult& onprem,
        const ForecastResult& cloud,
        double onprem_initial_capex
    ) {
        ComparisonResult result;
        result.onpremise = onprem;
        result.cloud = cloud;
        result.total_savings = cloud.total_cost - onprem.total_cost;

        // Find break-even point (when cumulative on-prem + CapEx < cloud)
        result.breakeven_month = 0;
        for (size_t m = 0; m < onprem.cumulative_cost.size(); ++m) {
            double onprem_total = onprem_initial_capex + onprem.cumulative_cost[m];
            double cloud_total = cloud.cumulative_cost[m];

            if (onprem_total < cloud_total && result.breakeven_month == 0) {
                result.breakeven_month = m + 1;
                break;
            }
        }

        return result;
    }
};

} // namespace cost
} // namespace hft
```

3.2 Example Forecast
--------------------

```cpp
// Example: 3-year cost forecast with 5% monthly growth
void runCostForecast() {
    using namespace hft::cost;

    HardwareCost hw_cost;
    OperationalCost op_cost;
    CloudCost cloud_cost;
    StorageCostCalculator calculator(hw_cost, op_cost, cloud_cost);

    // Growth models (starting with 100TB, 5% monthly growth)
    GrowthModel hot_growth{5.0, 0.05, 36};      // 5TB initial
    GrowthModel warm_growth{20.0, 0.05, 36};    // 20TB initial
    GrowthModel cold_growth{75.0, 0.05, 36};    // 75TB initial
    GrowthModel archive_growth{0.0, 0.10, 36};  // 0TB initial, 10% growth

    CostForecaster forecaster;

    // On-premise forecast
    auto onprem_forecast = forecaster.forecastOnPremise(
        hot_growth, warm_growth, cold_growth, calculator
    );

    // Cloud forecast
    auto cloud_forecast = forecaster.forecastCloud(
        hot_growth, warm_growth, cold_growth, archive_growth,
        calculator, 100000, 10.0
    );

    // Compare
    double initial_capex = 57640.0;  // From earlier calculation
    auto comparison = forecaster.compare(onprem_forecast, cloud_forecast, initial_capex);
    comparison.print();
}
```

================================================================================
SECTION 4: COST OPTIMIZATION STRATEGIES
================================================================================

4.1 Optimization Techniques
---------------------------

Storage Cost Optimization Strategies:
┌────────────────────────────────┬─────────────────┬────────────────────────┐
│ Strategy                       │ Savings         │ Implementation         │
├────────────────────────────────┼─────────────────┼────────────────────────┤
│ Compression (LZ4)              │ 40-60%          │ Medium complexity      │
│ Compression (ZSTD high)        │ 60-80%          │ High complexity        │
│ Delta encoding                 │ 20-40%          │ Low complexity         │
│ Columnar storage               │ 30-50%          │ Medium complexity      │
│ Deduplication                  │ 10-30%          │ High complexity        │
│ Tiered storage policies        │ 50-70%          │ Medium complexity      │
│ Retention policy enforcement   │ 20-40%          │ Low complexity         │
│ Reserved instances (cloud)     │ 30-50%          │ Low complexity         │
│ Spot instances for batch       │ 60-80%          │ Medium complexity      │
└────────────────────────────────┴─────────────────┴────────────────────────┘

4.2 Compression ROI Calculator
------------------------------

```cpp
// compression_roi.hpp - Compression Cost-Benefit Analysis
#pragma once

namespace hft {
namespace cost {

struct CompressionMetrics {
    std::string algorithm;
    double compression_ratio;        // e.g., 0.3 = 30% of original size
    double compression_speed_mbs;    // Compression throughput
    double decompression_speed_mbs;  // Decompression throughput
    double cpu_cost_per_core_hour;   // CPU cost
};

class CompressionROICalculator {
public:
    struct ROIResult {
        double storage_savings_per_month;
        double cpu_cost_per_month;
        double net_savings_per_month;
        double annual_savings;
        double roi_percentage;

        void print() const {
            printf("\n========== COMPRESSION ROI ==========\n");
            printf("Storage savings/mo:  $%'12.2f\n", storage_savings_per_month);
            printf("CPU cost/mo:         $%'12.2f\n", cpu_cost_per_month);
            printf("Net savings/mo:      $%'12.2f\n", net_savings_per_month);
            printf("Annual savings:      $%'12.2f\n", annual_savings);
            printf("ROI:                 %12.1f%%\n", roi_percentage);
            printf("=====================================\n\n");
        }
    };

    static ROIResult calculateROI(
        double data_size_tb,
        double storage_cost_per_tb_month,
        const CompressionMetrics& compression,
        double monthly_ingestion_tb
    ) {
        ROIResult result{};

        // Storage savings
        double reduced_size_tb = data_size_tb * compression.compression_ratio;
        double storage_saved_tb = data_size_tb - reduced_size_tb;
        result.storage_savings_per_month = storage_saved_tb * storage_cost_per_tb_month;

        // CPU cost for compression
        // Assume we compress new data as it arrives
        double compression_hours = (monthly_ingestion_tb * 1024 * 1024) /
            compression.compression_speed_mbs / 3600.0;

        // Assume we need to decompress 10% of stored data per month for queries
        double query_data_tb = data_size_tb * 0.10;
        double decompression_hours = (query_data_tb * 1024 * 1024) /
            compression.decompression_speed_mbs / 3600.0;

        result.cpu_cost_per_month = (compression_hours + decompression_hours) *
            compression.cpu_cost_per_core_hour;

        // Net savings
        result.net_savings_per_month = result.storage_savings_per_month -
            result.cpu_cost_per_month;

        result.annual_savings = result.net_savings_per_month * 12;

        // ROI (savings vs baseline)
        if (result.cpu_cost_per_month > 0) {
            result.roi_percentage = (result.net_savings_per_month /
                result.cpu_cost_per_month) * 100.0;
        }

        return result;
    }

    // Compare multiple compression algorithms
    static void compareAlgorithms(
        double data_size_tb,
        double storage_cost_per_tb_month,
        double monthly_ingestion_tb
    ) {
        std::vector<CompressionMetrics> algorithms = {
            {"None (baseline)", 1.0, 0, 0, 0},
            {"LZ4", 0.40, 500, 2000, 0.05},
            {"ZSTD (level 3)", 0.30, 200, 800, 0.05},
            {"ZSTD (level 15)", 0.20, 50, 600, 0.05},
            {"Delta + LZ4", 0.25, 400, 1500, 0.05},
            {"Columnar + ZSTD", 0.15, 100, 500, 0.05}
        };

        printf("\n========== COMPRESSION ALGORITHM COMPARISON ==========\n");
        printf("Data size: %.2f TB, Storage cost: $%.2f/TB/month\n\n",
            data_size_tb, storage_cost_per_tb_month);

        printf("%-20s %8s %12s %12s %12s\n",
            "Algorithm", "Ratio", "Storage $/mo", "CPU $/mo", "Net Save $/mo");
        printf("------------------------------------------------------------------\n");

        for (const auto& algo : algorithms) {
            auto roi = calculateROI(data_size_tb, storage_cost_per_tb_month,
                                   algo, monthly_ingestion_tb);

            printf("%-20s %7.0f%% %'12.2f %'12.2f %'12.2f\n",
                algo.algorithm.c_str(),
                algo.compression_ratio * 100,
                roi.storage_savings_per_month,
                roi.cpu_cost_per_month,
                roi.net_savings_per_month);
        }
        printf("======================================================\n\n");
    }
};

} // namespace cost
} // namespace hft
```

================================================================================
SECTION 5: COMPRESSION COST-BENEFIT ANALYSIS
================================================================================

5.1 Compression Impact on TCO
-----------------------------

Example: 100TB dataset compression analysis

```plaintext
Baseline (No Compression):
- Storage: 100TB
- Cost: $15,000/month
- Total annual: $180,000

LZ4 Compression (40% size, 60% savings):
- Storage: 40TB
- Storage cost: $6,000/month
- CPU cost: $500/month (compression/decompression)
- Total annual: $78,000
- Savings: $102,000/year (57%)

ZSTD Level 15 (20% size, 80% savings):
- Storage: 20TB
- Storage cost: $3,000/month
- CPU cost: $1,200/month (higher CPU usage)
- Total annual: $50,400
- Savings: $129,600/year (72%)

Recommendation: ZSTD level 15 for cold/archive tiers
               LZ4 for warm tier (faster queries)
               No compression for hot tier (latency critical)
```

5.2 Tiering Impact on Costs
---------------------------

```cpp
// Example: Tiering strategy cost comparison
void compareTieringStrategies() {
    using namespace hft::cost;

    double total_data_tb = 100.0;
    double onprem_cost_per_tb = 25.0;  // Average

    printf("\n========== TIERING STRATEGY COMPARISON ==========\n\n");

    // Strategy 1: All hot (no tiering)
    double all_hot_cost = total_data_tb * 50.0;  // $50/TB for NVMe
    printf("Strategy 1 - All Hot (NVMe):\n");
    printf("  Cost: $%'12.2f/month\n\n", all_hot_cost);

    // Strategy 2: Simple tiering (hot + cold)
    double s2_hot = 10.0;   // 10TB hot
    double s2_cold = 90.0;  // 90TB cold
    double s2_cost = s2_hot * 50.0 + s2_cold * 10.0;
    printf("Strategy 2 - Simple Tiering (10%% hot, 90%% cold):\n");
    printf("  Cost: $%'12.2f/month\n", s2_cost);
    printf("  Savings vs All Hot: $%'12.2f (%.1f%%)\n\n",
        all_hot_cost - s2_cost,
        ((all_hot_cost - s2_cost) / all_hot_cost) * 100);

    // Strategy 3: Three-tier (hot + warm + cold)
    double s3_hot = 5.0;    // 5TB hot
    double s3_warm = 20.0;  // 20TB warm
    double s3_cold = 75.0;  // 75TB cold
    double s3_cost = s3_hot * 50.0 + s3_warm * 20.0 + s3_cold * 10.0;
    printf("Strategy 3 - Three-Tier (5%% hot, 20%% warm, 75%% cold):\n");
    printf("  Cost: $%'12.2f/month\n", s3_cost);
    printf("  Savings vs All Hot: $%'12.2f (%.1f%%)\n",
        all_hot_cost - s3_cost,
        ((all_hot_cost - s3_cost) / all_hot_cost) * 100);
    printf("  Savings vs Simple:  $%'12.2f (%.1f%%)\n\n",
        s2_cost - s3_cost,
        ((s2_cost - s3_cost) / s2_cost) * 100);

    // Strategy 4: Four-tier with cloud archive
    double s4_hot = 5.0;      // 5TB hot
    double s4_warm = 15.0;    // 15TB warm
    double s4_cold = 30.0;    // 30TB cold
    double s4_archive = 50.0; // 50TB archive (S3 Glacier)
    double s4_cost = s4_hot * 50.0 + s4_warm * 20.0 + s4_cold * 10.0 +
                     s4_archive * 4.0;
    printf("Strategy 4 - Four-Tier with Cloud Archive:\n");
    printf("  Cost: $%'12.2f/month\n", s4_cost);
    printf("  Savings vs All Hot: $%'12.2f (%.1f%%)\n",
        all_hot_cost - s4_cost,
        ((all_hot_cost - s4_cost) / all_hot_cost) * 100);
    printf("  Savings vs Three:   $%'12.2f (%.1f%%)\n",
        s3_cost - s4_cost,
        ((s3_cost - s4_cost) / s3_cost) * 100);

    printf("\n=================================================\n\n");
}
```

================================================================================
SECTION 6: CLOUD VS ON-PREMISE TCO
================================================================================

6.1 Decision Framework
----------------------

When to Choose On-Premise:
✓ Predictable, high-volume data storage (>50TB)
✓ Data retention > 3 years
✓ Latency requirements < 100µs
✓ Existing datacenter infrastructure
✓ Regulatory/compliance requires on-premise
✓ Skilled in-house DevOps team
✓ High data access frequency

When to Choose Cloud:
✓ Unpredictable or seasonal workloads
✓ Rapid scaling requirements
✓ Limited CapEx budget
✓ Short-term projects (< 2 years)
✓ Geographic distribution needed
✓ Disaster recovery priority
✓ Low data access frequency

Hybrid Approach:
✓ Hot tier on-premise for latency
✓ Cold/archive in cloud for cost
✓ Burst capacity to cloud
✓ DR/backup in secondary cloud region

6.2 Total Cost of Ownership Comparison
--------------------------------------

```cpp
// tco_comparison.hpp - Comprehensive TCO Analysis
#pragma once

namespace hft {
namespace cost {

class TCOComparison {
public:
    struct TCOBreakdown {
        // Capital costs
        double hardware_cost;
        double software_licenses;
        double network_equipment;
        double initial_setup;

        // Operational costs (annual)
        double power_cooling;
        double datacenter_space;
        double personnel;
        double maintenance;
        double bandwidth;

        // Cloud costs (annual)
        double cloud_storage;
        double cloud_compute;
        double cloud_transfer;
        double cloud_support;

        double totalOnPremise(size_t years) const {
            return hardware_cost + software_licenses + network_equipment +
                   initial_setup +
                   (power_cooling + datacenter_space + personnel +
                    maintenance + bandwidth) * years;
        }

        double totalCloud(size_t years) const {
            return (cloud_storage + cloud_compute + cloud_transfer +
                    cloud_support) * years;
        }

        void printComparison(size_t years) const {
            printf("\n========== %zu-YEAR TCO COMPARISON ==========\n\n", years);

            printf("ON-PREMISE:\n");
            printf("  Initial CapEx:       $%'12.2f\n",
                hardware_cost + software_licenses + network_equipment + initial_setup);
            printf("  Annual OpEx:         $%'12.2f\n",
                power_cooling + datacenter_space + personnel + maintenance + bandwidth);
            printf("  %zu-Year Total:       $%'12.2f\n\n", years, totalOnPremise(years));

            printf("CLOUD:\n");
            printf("  Initial cost:        $%'12.2f\n", 0.0);
            printf("  Annual cost:         $%'12.2f\n",
                cloud_storage + cloud_compute + cloud_transfer + cloud_support);
            printf("  %zu-Year Total:       $%'12.2f\n\n", years, totalCloud(years));

            double diff = totalOnPremise(years) - totalCloud(years);
            printf("DIFFERENCE: $%'12.2f ", std::abs(diff));
            if (diff < 0) {
                printf("(on-premise cheaper by %.1f%%)\n",
                    std::abs(diff) / totalCloud(years) * 100);
            } else {
                printf("(cloud cheaper by %.1f%%)\n",
                    diff / totalOnPremise(years) * 100);
            }
            printf("===========================================\n\n");
        }
    };

    // Calculate break-even point
    static size_t calculateBreakEvenMonths(const TCOBreakdown& tco) {
        double onprem_capex = tco.hardware_cost + tco.software_licenses +
                             tco.network_equipment + tco.initial_setup;
        double onprem_monthly_opex = (tco.power_cooling + tco.datacenter_space +
                                     tco.personnel + tco.maintenance + tco.bandwidth) / 12.0;
        double cloud_monthly = (tco.cloud_storage + tco.cloud_compute +
                               tco.cloud_transfer + tco.cloud_support) / 12.0;

        if (cloud_monthly <= onprem_monthly_opex) {
            return 0;  // Cloud always cheaper
        }

        double months = onprem_capex / (cloud_monthly - onprem_monthly_opex);
        return static_cast<size_t>(std::ceil(months));
    }
};

} // namespace cost
} // namespace hft
```

================================================================================
SECTION 7: COST MONITORING AND ALERTING
================================================================================

7.1 Cost Monitoring System
--------------------------

```cpp
// cost_monitor.hpp - Real-Time Cost Monitoring
#pragma once

#include <atomic>
#include <chrono>
#include <map>

namespace hft {
namespace monitoring {

struct CostMetrics {
    std::atomic<uint64_t> bytes_stored{0};
    std::atomic<uint64_t> bytes_ingested_today{0};
    std::atomic<uint64_t> bytes_queried_today{0};
    std::atomic<uint64_t> iops_consumed{0};
    std::atomic<uint64_t> network_transfer_gb{0};

    std::map<std::string, uint64_t> cost_by_tier;
    std::map<std::string, uint64_t> cost_by_symbol;
};

class CostMonitor {
public:
    CostMonitor(double daily_budget, double monthly_budget)
        : daily_budget_(daily_budget),
          monthly_budget_(monthly_budget) {
        start_time_ = std::chrono::system_clock::now();
    }

    void recordIngestion(uint64_t bytes, const std::string& tier) {
        metrics_.bytes_ingested_today.fetch_add(bytes);
        updateCost(tier, calculateIngestionCost(bytes, tier));
        checkBudgetAlerts();
    }

    void recordQuery(uint64_t bytes, const std::string& tier) {
        metrics_.bytes_queried_today.fetch_add(bytes);
        updateCost(tier, calculateQueryCost(bytes, tier));
        checkBudgetAlerts();
    }

    void recordTransfer(uint64_t bytes_gb) {
        metrics_.network_transfer_gb.fetch_add(bytes_gb);
        double cost = bytes_gb * 0.09;  // $0.09/GB
        updateCost("transfer", cost);
        checkBudgetAlerts();
    }

    struct CostReport {
        double total_daily_cost;
        double total_monthly_cost;
        double projected_monthly_cost;
        double budget_utilization_pct;
        std::map<std::string, double> cost_by_tier;

        void print() const {
            printf("\n========== COST REPORT ==========\n");
            printf("Daily cost:          $%'12.2f\n", total_daily_cost);
            printf("Monthly cost (MTD):  $%'12.2f\n", total_monthly_cost);
            printf("Projected monthly:   $%'12.2f\n", projected_monthly_cost);
            printf("Budget utilization:  %12.1f%%\n", budget_utilization_pct);
            printf("\nCost by tier:\n");
            for (const auto& [tier, cost] : cost_by_tier) {
                printf("  %-15s $%'12.2f\n", tier.c_str(), cost);
            }
            printf("=================================\n\n");
        }
    };

    CostReport generateReport() const {
        CostReport report;

        report.total_daily_cost = daily_cost_.load();
        report.total_monthly_cost = monthly_cost_.load();

        // Project monthly cost based on current daily rate
        auto now = std::chrono::system_clock::now();
        auto elapsed_days = std::chrono::duration_cast<std::chrono::hours>(
            now - start_time_).count() / 24.0;

        if (elapsed_days > 0) {
            double daily_avg = report.total_monthly_cost / elapsed_days;
            report.projected_monthly_cost = daily_avg * 30;
        }

        report.budget_utilization_pct =
            (report.total_monthly_cost / monthly_budget_) * 100.0;

        std::lock_guard lock(cost_mutex_);
        for (const auto& [tier, cost] : metrics_.cost_by_tier) {
            report.cost_by_tier[tier] = cost / 100.0;  // Convert cents to dollars
        }

        return report;
    }

    // Set cost alerts
    void setDailyBudgetAlert(double threshold_pct,
                            std::function<void(double)> callback) {
        daily_alert_threshold_ = threshold_pct;
        daily_alert_callback_ = callback;
    }

    void setMonthlyBudgetAlert(double threshold_pct,
                              std::function<void(double)> callback) {
        monthly_alert_threshold_ = threshold_pct;
        monthly_alert_callback_ = callback;
    }

private:
    double calculateIngestionCost(uint64_t bytes, const std::string& tier) {
        // Cost model per tier
        if (tier == "hot") {
            return (bytes / 1024.0 / 1024.0 / 1024.0) * 0.01;  // $0.01/GB
        } else if (tier == "warm") {
            return (bytes / 1024.0 / 1024.0 / 1024.0) * 0.005;
        }
        return 0.0;
    }

    double calculateQueryCost(uint64_t bytes, const std::string& tier) {
        // Cost for data retrieval
        return (bytes / 1024.0 / 1024.0 / 1024.0) * 0.001;  // $0.001/GB
    }

    void updateCost(const std::string& tier, double cost_dollars) {
        uint64_t cost_cents = static_cast<uint64_t>(cost_dollars * 100);

        std::lock_guard lock(cost_mutex_);
        metrics_.cost_by_tier[tier] += cost_cents;

        daily_cost_.fetch_add(cost_cents);
        monthly_cost_.fetch_add(cost_cents);
    }

    void checkBudgetAlerts() {
        double daily = daily_cost_.load() / 100.0;
        double monthly = monthly_cost_.load() / 100.0;

        if (daily_alert_callback_ &&
            (daily / daily_budget_) >= (daily_alert_threshold_ / 100.0)) {
            daily_alert_callback_(daily);
        }

        if (monthly_alert_callback_ &&
            (monthly / monthly_budget_) >= (monthly_alert_threshold_ / 100.0)) {
            monthly_alert_callback_(monthly);
        }
    }

    double daily_budget_;
    double monthly_budget_;
    std::chrono::system_clock::time_point start_time_;

    CostMetrics metrics_;
    std::atomic<uint64_t> daily_cost_{0};    // In cents
    std::atomic<uint64_t> monthly_cost_{0};  // In cents

    mutable std::mutex cost_mutex_;

    double daily_alert_threshold_ = 90.0;   // 90%
    double monthly_alert_threshold_ = 80.0; // 80%
    std::function<void(double)> daily_alert_callback_;
    std::function<void(double)> monthly_alert_callback_;
};

} // namespace monitoring
} // namespace hft
```

================================================================================
SECTION 8: COST OPTIMIZATION RECOMMENDATIONS
================================================================================

8.1 Best Practices Summary
--------------------------

IMMEDIATE ACTIONS (Quick Wins):
1. Enable compression on warm/cold tiers (50-70% savings)
2. Implement data retention policies (20-40% savings)
3. Use tiered storage architecture (60-80% savings)
4. Reserved instances for predictable workloads (30-50% cloud savings)
5. Delete unnecessary replicas/backups (10-30% savings)

SHORT-TERM (1-3 months):
1. Implement automated tiering policies
2. Optimize partition strategies
3. Set up cost monitoring and alerting
4. Review and optimize query patterns
5. Implement lifecycle management

LONG-TERM (3-12 months):
1. Evaluate on-premise vs cloud economics
2. Implement hybrid storage architecture
3. Advanced compression (columnar, delta encoding)
4. Data deduplication
5. Capacity planning and forecasting

8.2 Cost Optimization Checklist
-------------------------------

Storage Efficiency:
□ Compression enabled on all non-hot tiers
□ Appropriate compression algorithm selected
□ Delta encoding for time-series data
□ Columnar format for analytics
□ Deduplication for redundant data

Tiering Strategy:
□ Hot tier sized appropriately (only recent data)
□ Automated migration policies configured
□ Retention policies enforced
□ Archive tier for compliance data
□ Regular tier capacity reviews

Query Optimization:
□ Indexes optimized for query patterns
□ Partition pruning effective
□ Query result caching enabled
□ Connection pooling configured
□ Batch queries where possible

Cost Monitoring:
□ Daily cost tracking enabled
□ Budget alerts configured
□ Cost attribution by tier/symbol
□ Monthly cost reviews
□ Trend analysis and forecasting

Cloud Optimization (if applicable):
□ Reserved instances purchased
□ Spot instances for batch workloads
□ Lifecycle policies for S3
□ Data transfer optimized
□ Right-sized instance types

================================================================================
APPENDIX: COST CALCULATION EXAMPLES
================================================================================

Example 1: Small HFT Firm (10TB total)
--------------------------------------
Hot:    1TB NVMe    @ $50/TB  = $50/month
Warm:   3TB SSD     @ $20/TB  = $60/month
Cold:   6TB HDD     @ $10/TB  = $60/month
                    TOTAL     = $170/month ($2,040/year)

With compression (2:1 average):
                    TOTAL     = $85/month ($1,020/year)
                    SAVINGS   = $1,020/year (50%)

Example 2: Medium HFT Firm (100TB total)
-----------------------------------------
Hot:    5TB NVMe    @ $50/TB  = $250/month
Warm:   20TB SSD    @ $20/TB  = $400/month
Cold:   75TB HDD    @ $10/TB  = $750/month
                    TOTAL     = $1,400/month ($16,800/year)

With compression + tiering + cloud archive:
Hot:    5TB NVMe              = $250/month
Warm:   10TB SSD (compressed) = $200/month
Cold:   15TB HDD (compressed) = $150/month
Archive: 35TB S3 Glacier      = $140/month
                    TOTAL     = $740/month ($8,880/year)
                    SAVINGS   = $7,920/year (47%)

Example 3: Large HFT Firm (1PB total)
--------------------------------------
On-Premise:
- Initial CapEx: $500,000
- Annual OpEx: $300,000
- 5-year TCO: $2,000,000

Cloud (AWS):
- No CapEx
- Annual cost: $450,000
- 5-year TCO: $2,250,000

Hybrid (Hot on-prem, Cold in cloud):
- Initial CapEx: $200,000
- Annual OpEx: $150,000
- Annual cloud: $100,000
- 5-year TCO: $1,450,000
- SAVINGS: $550,000 vs on-premise (28%)

================================================================================
                         END OF STORAGE COSTS ANALYSIS
================================================================================
