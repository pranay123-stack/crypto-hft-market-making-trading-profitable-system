================================================================================
COMPILERS FOR HFT SYSTEMS
================================================================================

OVERVIEW
--------
Compiler choice and optimization flags are critical for HFT performance. Modern
compilers like GCC 11+, Clang 14+, and Intel ICC can generate highly optimized
code when configured correctly. This guide covers compiler selection, flags,
optimizations, and performance tuning for ultra-low-latency trading systems.

================================================================================
SECTION 1: COMPILER SELECTION
================================================================================

1.1 GCC (GNU COMPILER COLLECTION)
----------------------------------

GCC 11+ provides excellent optimization and C++20 support.

Installation:

```bash
# Ubuntu 22.04 LTS
sudo apt-get update
sudo apt-get install gcc-11 g++-11

# Set as default
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 100
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 100

# Verify installation
gcc --version    # Should show 11.x.x or higher
g++ --version    # Should show 11.x.x or higher

# Install GCC 12 (newer features)
sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt-get update
sudo apt-get install gcc-12 g++-12

# Install GCC 13 (latest)
sudo apt-get install gcc-13 g++-13
```

Check available features:

```bash
# Check supported C++ standards
g++ -v --help 2>&1 | grep std

# Check supported optimizations
g++ -march=native -Q --help=target

# Check available CPU extensions
g++ -march=native -dM -E - < /dev/null | grep -E "SSE|AVX"
```

1.2 CLANG/LLVM
--------------

Clang 14+ offers superior diagnostics and fast compilation.

Installation:

```bash
# Ubuntu 22.04 LTS
sudo apt-get install clang-14 llvm-14

# Install Clang 15
wget https://apt.llvm.org/llvm.sh
chmod +x llvm.sh
sudo ./llvm.sh 15

# Install Clang 16 (latest)
sudo ./llvm.sh 16

# Set as default
sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-14 100
sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-14 100

# Verify installation
clang --version
clang++ --version
```

Clang tools:

```bash
# Install additional Clang tools
sudo apt-get install \
    clang-format-14 \
    clang-tidy-14 \
    clangd-14 \
    lldb-14 \
    lld-14

# LLVM tools
sudo apt-get install \
    llvm-14-tools \
    llvm-14-dev \
    llvm-14-runtime
```

1.3 INTEL C++ COMPILER (ICC/ICX)
---------------------------------

Intel compilers provide best performance on Intel CPUs.

Installation:

```bash
# Install Intel oneAPI Base Toolkit
wget https://registrationcenter-download.intel.com/akdlm/irc_nas/19078/l_BaseKit_p_2023.0.0.25537.sh
sudo sh ./l_BaseKit_p_2023.0.0.25537.sh

# Install Intel HPC Toolkit
wget https://registrationcenter-download.intel.com/akdlm/irc_nas/19085/l_HPCKit_p_2023.0.0.25441.sh
sudo sh ./l_HPCKit_p_2023.0.0.25441.sh

# Source Intel environment
source /opt/intel/oneapi/setvars.sh

# Verify installation
icx --version
icpx --version  # C++ compiler
```

Classic ICC (deprecated but still useful):

```bash
# Using classic icc
icc --version

# Compile with ICC
icc -O3 -xHost -ipo -no-prec-div main.cpp -o trading_engine
icpc -O3 -xHost -ipo -no-prec-div main.cpp -o trading_engine
```

1.4 COMPILER COMPARISON
-----------------------

Performance comparison:

```bash
#!/bin/bash
# compile_benchmark.sh

SOURCE="benchmark.cpp"
ITERATIONS=1000000

# GCC
g++-11 -O3 -march=native -std=c++20 $SOURCE -o bench_gcc
time ./bench_gcc $ITERATIONS

# Clang
clang++-14 -O3 -march=native -std=c++20 $SOURCE -o bench_clang
time ./bench_clang $ITERATIONS

# Intel
icpx -O3 -xHost -std=c++20 $SOURCE -o bench_intel
time ./bench_intel $ITERATIONS

# Results comparison
echo "=== Performance Comparison ==="
perf stat -e cycles,instructions,cache-misses,branches,branch-misses ./bench_gcc $ITERATIONS
perf stat -e cycles,instructions,cache-misses,branches,branch-misses ./bench_clang $ITERATIONS
perf stat -e cycles,instructions,cache-misses,branches,branch-misses ./bench_intel $ITERATIONS
```

================================================================================
SECTION 2: OPTIMIZATION FLAGS
================================================================================

2.1 BASIC OPTIMIZATION LEVELS
------------------------------

```bash
# -O0: No optimization (debugging)
g++ -O0 -g main.cpp -o trading_engine_debug

# -O1: Basic optimizations
g++ -O1 main.cpp -o trading_engine_o1

# -O2: Recommended optimizations
g++ -O2 main.cpp -o trading_engine_o2

# -O3: Aggressive optimizations
g++ -O3 main.cpp -o trading_engine_o3

# -Ofast: Fastest, may break standards compliance
g++ -Ofast main.cpp -o trading_engine_ofast

# -Os: Optimize for size
g++ -Os main.cpp -o trading_engine_small

# -Og: Optimize for debugging
g++ -Og -g main.cpp -o trading_engine_debug_opt
```

Optimization level effects:

```
-O0: No optimization
     - Fast compilation
     - Large binaries
     - Slow execution
     - Good for debugging

-O1: Basic optimization
     - Reasonable compilation time
     - Moderate code size
     - Better performance than -O0

-O2: Standard optimization (default for production)
     - Longer compilation
     - Good balance between size and speed
     - No performance-vs-correctness tradeoffs

-O3: Aggressive optimization (recommended for HFT)
     - Longest compilation time
     - Larger code size due to inlining
     - Maximum performance
     - Includes: -finline-functions, -funswitch-loops, -fpredictive-commoning,
                 -fgcse-after-reload, -ftree-vectorize, -fvect-cost-model,
                 -ftree-partial-pre, -fipa-cp-clone

-Ofast: Beyond -O3
     - Disregards strict standards compliance
     - Enables -ffast-math
     - Use with caution in financial systems
```

2.2 ARCHITECTURE-SPECIFIC FLAGS (-march, -mtune)
-------------------------------------------------

Target specific CPU architectures for maximum performance:

```bash
# Generic x86-64
g++ -march=x86-64 -mtune=generic main.cpp

# Native (auto-detect current CPU)
g++ -march=native -mtune=native main.cpp

# Intel Specific

# Haswell (4th Gen, 2013-2015)
g++ -march=haswell -mtune=haswell main.cpp

# Broadwell (5th Gen, 2014-2016)
g++ -march=broadwell -mtune=broadwell main.cpp

# Skylake (6th Gen, 2015-2017)
g++ -march=skylake -mtune=skylake main.cpp

# Cascade Lake (2nd Gen Xeon Scalable, 2019)
g++ -march=cascadelake -mtune=cascadelake main.cpp

# Ice Lake (3rd Gen Xeon Scalable, 2021)
g++ -march=icelake-server -mtune=icelake-server main.cpp

# Sapphire Rapids (4th Gen Xeon Scalable, 2023)
g++ -march=sapphirerapids -mtune=sapphirerapids main.cpp

# AMD Specific

# Zen (1st Gen, 2017)
g++ -march=znver1 -mtune=znver1 main.cpp

# Zen 2 (2nd Gen, 2019)
g++ -march=znver2 -mtune=znver2 main.cpp

# Zen 3 (3rd Gen, 2020)
g++ -march=znver3 -mtune=znver3 main.cpp

# Zen 4 (4th Gen, 2022)
g++ -march=znver4 -mtune=znver4 main.cpp
```

Detecting current CPU:

```bash
# View CPU information
lscpu | grep -E "Model name|Flags"

# Check supported instruction sets
cat /proc/cpuinfo | grep flags | head -n1

# GCC native features
echo | gcc -march=native -E -dM - | grep -E "SSE|AVX|FMA"

# Detailed CPU info
sudo dmidecode -t processor
```

2.3 SIMD AND VECTORIZATION FLAGS
---------------------------------

Explicit SIMD instruction set enabling:

```bash
# SSE (Streaming SIMD Extensions)
g++ -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 main.cpp

# AVX (Advanced Vector Extensions)
g++ -mavx main.cpp           # AVX (256-bit)
g++ -mavx2 main.cpp          # AVX2 + FMA3
g++ -mavx512f main.cpp       # AVX-512 Foundation
g++ -mavx512cd main.cpp      # AVX-512 Conflict Detection
g++ -mavx512bw main.cpp      # AVX-512 Byte and Word
g++ -mavx512dq main.cpp      # AVX-512 Doubleword and Quadword
g++ -mavx512vl main.cpp      # AVX-512 Vector Length Extensions

# All AVX-512 features
g++ -mavx512f -mavx512cd -mavx512bw -mavx512dq -mavx512vl main.cpp

# Enable auto-vectorization
g++ -O3 -ftree-vectorize -fopt-info-vec-optimized main.cpp

# Vectorization reports
g++ -O3 -ftree-vectorize -fopt-info-vec-all main.cpp 2>&1 | grep vectorized
```

Checking if vectorization is enabled:

```cpp
// test_vectorization.cpp
#include <iostream>
#include <vector>
#include <chrono>

void scalar_add(const float* a, const float* b, float* c, size_t n) {
    for (size_t i = 0; i < n; ++i) {
        c[i] = a[i] + b[i];
    }
}

int main() {
    const size_t N = 1000000;
    std::vector<float> a(N, 1.0f);
    std::vector<float> b(N, 2.0f);
    std::vector<float> c(N);

    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < 1000; ++i) {
        scalar_add(a.data(), b.data(), c.data(), N);
    }
    auto end = std::chrono::high_resolution_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Time: " << duration.count() << " us\n";

    return 0;
}
```

Compile and compare:

```bash
# Without vectorization
g++ -O2 test_vectorization.cpp -o vec_no_opt
time ./vec_no_opt

# With vectorization
g++ -O3 -march=native -ftree-vectorize test_vectorization.cpp -o vec_opt
time ./vec_opt

# Check generated assembly
objdump -d vec_opt | grep -E "vaddps|addps|vmovups"
```

2.4 LINK-TIME OPTIMIZATION (LTO)
---------------------------------

Enable whole-program optimization:

```bash
# GCC LTO
g++ -O3 -flto -fuse-linker-plugin main.cpp module1.cpp module2.cpp -o trading_engine

# Parallel LTO (faster compilation)
g++ -O3 -flto=$(nproc) -fuse-linker-plugin main.cpp module1.cpp module2.cpp -o trading_engine

# Clang LTO (ThinLTO)
clang++ -O3 -flto=thin main.cpp module1.cpp module2.cpp -o trading_engine

# Intel LTO (IPO - Interprocedural Optimization)
icpx -O3 -ipo main.cpp module1.cpp module2.cpp -o trading_engine
```

LTO with separate compilation:

```bash
# Compile object files with LTO
g++ -O3 -flto -c main.cpp -o main.o
g++ -O3 -flto -c module1.cpp -o module1.o
g++ -O3 -flto -c module2.cpp -o module2.o

# Link with LTO
g++ -O3 -flto -fuse-linker-plugin main.o module1.o module2.o -o trading_engine
```

LTO with CMake:

```cmake
# Enable LTO globally
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)

# Or per-target
add_executable(trading_engine main.cpp)
set_target_properties(trading_engine PROPERTIES
    INTERPROCEDURAL_OPTIMIZATION TRUE
)

# Or per-configuration
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE TRUE)
```

2.5 PROFILE-GUIDED OPTIMIZATION (PGO)
--------------------------------------

Two-phase compilation for maximum performance:

Phase 1: Generate profile data

```bash
# GCC PGO - Instrumentation
g++ -O3 -march=native -fprofile-generate main.cpp -o trading_engine_gen

# Run with representative workload
./trading_engine_gen --config production.json --duration 3600

# Profile data generated in *.gcda files
ls *.gcda
```

Phase 2: Use profile data

```bash
# GCC PGO - Optimization
g++ -O3 -march=native -fprofile-use main.cpp -o trading_engine_opt

# Clean up profile data
rm -f *.gcda
```

Clang PGO:

```bash
# Phase 1: Generate profile
clang++ -O3 -march=native -fprofile-instr-generate main.cpp -o trading_engine_gen
./trading_engine_gen --config production.json --duration 3600

# Convert profile data
llvm-profdata merge -output=default.profdata default.profraw

# Phase 2: Use profile
clang++ -O3 -march=native -fprofile-instr-use=default.profdata main.cpp -o trading_engine_opt
```

Intel PGO:

```bash
# Phase 1: Generate profile
icpx -O3 -xHost -prof-gen main.cpp -o trading_engine_gen
./trading_engine_gen --config production.json --duration 3600

# Phase 2: Use profile
icpx -O3 -xHost -prof-use main.cpp -o trading_engine_opt
```

PGO with CMake:

```cmake
# PGO generation
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-generate")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fprofile-generate")

# Build, run workload, then rebuild with:
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-use")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fprofile-use")
```

================================================================================
SECTION 3: HFT-SPECIFIC OPTIMIZATION FLAGS
================================================================================

3.1 COMPLETE HFT OPTIMIZATION FLAGS
------------------------------------

GCC production flags:

```bash
g++ -O3 \
    -march=native \
    -mtune=native \
    -flto \
    -fuse-linker-plugin \
    -ffast-math \
    -funroll-loops \
    -fprefetch-loop-arrays \
    -ftree-vectorize \
    -finline-functions \
    -finline-limit=1000 \
    -fno-exceptions \
    -fno-rtti \
    -fno-omit-frame-pointer \
    -pthread \
    -DNDEBUG \
    main.cpp -o trading_engine
```

Clang production flags:

```bash
clang++ -O3 \
    -march=native \
    -mtune=native \
    -flto=thin \
    -ffast-math \
    -funroll-loops \
    -fvectorize \
    -fslp-vectorize \
    -fstrict-aliasing \
    -fno-exceptions \
    -fno-rtti \
    -fno-omit-frame-pointer \
    -pthread \
    -DNDEBUG \
    main.cpp -o trading_engine
```

Intel production flags:

```bash
icpx -O3 \
    -xHost \
    -ipo \
    -no-prec-div \
    -fp-model fast=2 \
    -fno-alias \
    -funroll-loops \
    -finline-functions \
    -qopt-prefetch \
    -fno-exceptions \
    -fno-rtti \
    -pthread \
    -DNDEBUG \
    main.cpp -o trading_engine
```

3.2 MATH OPTIMIZATION FLAGS
----------------------------

Fast math (use with caution in financial calculations):

```bash
# GCC fast math
g++ -O3 -ffast-math main.cpp

# Individual fast-math components
g++ -O3 \
    -fno-math-errno \           # Don't set errno for math functions
    -ffinite-math-only \        # Assume no NaN or Inf
    -fno-signed-zeros \         # Treat -0.0 as 0.0
    -fno-trapping-math \        # No FP exceptions
    -fassociative-math \        # Allow reassociation
    -freciprocal-math \         # Use reciprocal instead of division
    main.cpp
```

Safe math optimizations for financial systems:

```bash
# Safer optimizations (no -ffast-math)
g++ -O3 \
    -march=native \
    -fno-math-errno \           # Safe: errno not used
    -fno-trapping-math \        # Safe: we don't use FP exceptions
    main.cpp
```

3.3 INLINE AND FUNCTION OPTIMIZATION
-------------------------------------

```bash
# Aggressive inlining
g++ -O3 \
    -finline-functions \
    -finline-limit=1000 \       # Increase inline threshold
    -finline-small-functions \
    -fpartial-inlining \
    main.cpp

# Always inline attribute in code
__attribute__((always_inline)) inline void critical_path() {
    // ...
}

# No inline for large functions
__attribute__((noinline)) void large_function() {
    // ...
}
```

3.4 LOOP OPTIMIZATION FLAGS
----------------------------

```bash
# Loop optimizations
g++ -O3 \
    -funroll-loops \            # Unroll loops
    -funroll-all-loops \        # Aggressively unroll
    -fprefetch-loop-arrays \    # Prefetch data in loops
    -ftree-loop-vectorize \     # Vectorize loops
    -floop-unroll-and-jam \     # Unroll and jam loops
    main.cpp
```

3.5 BRANCH OPTIMIZATION
-----------------------

```bash
# Branch prediction
g++ -O3 \
    -fbranch-probabilities \    # Use profile for branches
    -freorder-blocks-and-partition \
    main.cpp

# In code: likely/unlikely hints
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)

if (likely(price > 0)) {
    // Hot path
} else {
    // Cold path
}
```

================================================================================
SECTION 4: DEBUGGING AND PROFILING FLAGS
================================================================================

4.1 DEBUG FLAGS
---------------

```bash
# Full debug info
g++ -g -O0 main.cpp -o trading_engine_debug

# Debug info with optimization
g++ -g -O2 main.cpp -o trading_engine_release_debug

# Extended debug info
g++ -g3 -O0 main.cpp -o trading_engine_debug_ext

# DWARF format selection
g++ -g -gdwarf-5 main.cpp  # Latest DWARF format

# Split debug info
g++ -g -gsplit-dwarf main.cpp
objcopy --only-keep-debug trading_engine trading_engine.debug
objcopy --strip-debug trading_engine
objcopy --add-gnu-debuglink=trading_engine.debug trading_engine
```

4.2 SANITIZER FLAGS
-------------------

AddressSanitizer (memory errors):

```bash
# ASan with Clang (recommended)
clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer main.cpp

# ASan runtime options
export ASAN_OPTIONS=detect_leaks=1:check_initialization_order=1:strict_init_order=1
./trading_engine
```

ThreadSanitizer (data races):

```bash
# TSan
clang++ -O1 -g -fsanitize=thread main.cpp

# TSan runtime options
export TSAN_OPTIONS=second_deadlock_stack=1:history_size=7
./trading_engine
```

UndefinedBehaviorSanitizer:

```bash
# UBSan
clang++ -O1 -g -fsanitize=undefined main.cpp

# Specific checks
clang++ -O1 -g \
    -fsanitize=undefined \
    -fsanitize=integer \
    -fsanitize=nullability \
    main.cpp
```

MemorySanitizer (uninitialized memory):

```bash
# MSan (Clang only)
clang++ -O1 -g -fsanitize=memory -fno-omit-frame-pointer main.cpp
```

Multiple sanitizers:

```bash
# ASan + UBSan
clang++ -O1 -g -fsanitize=address,undefined main.cpp

# Sanitizer blacklist
clang++ -fsanitize=address -fsanitize-blacklist=sanitizer_blacklist.txt main.cpp
```

4.3 PROFILING FLAGS
-------------------

gprof profiling:

```bash
# Compile with profiling
g++ -O2 -pg main.cpp -o trading_engine

# Run and generate profile
./trading_engine
gprof trading_engine gmon.out > profile.txt
```

perf profiling:

```bash
# Compile with frame pointers for accurate stack traces
g++ -O3 -march=native -fno-omit-frame-pointer main.cpp -o trading_engine

# Record profile
perf record -g ./trading_engine

# View profile
perf report

# Detailed stats
perf stat -e cycles,instructions,cache-misses,branch-misses ./trading_engine
```

4.4 CODE COVERAGE
-----------------

```bash
# GCC coverage
g++ -O0 -g --coverage main.cpp -o trading_engine

# Run tests
./trading_engine

# Generate coverage report
gcov main.cpp
lcov --capture --directory . --output-file coverage.info
genhtml coverage.info --output-directory coverage_html

# Clang coverage
clang++ -fprofile-instr-generate -fcoverage-mapping main.cpp -o trading_engine
./trading_engine
llvm-profdata merge -sparse default.profraw -o default.profdata
llvm-cov show ./trading_engine -instr-profile=default.profdata
```

================================================================================
SECTION 5: WARNING FLAGS
================================================================================

5.1 COMPREHENSIVE WARNING FLAGS
--------------------------------

```bash
# Essential warnings
g++ -Wall -Wextra -Wpedantic main.cpp

# Comprehensive warnings for HFT
g++ \
    -Wall \
    -Wextra \
    -Wpedantic \
    -Werror \                      # Treat warnings as errors
    -Wcast-align \                 # Unaligned pointer casts
    -Wcast-qual \                  # Cast removes qualifiers
    -Wconversion \                 # Implicit conversions
    -Wdouble-promotion \           # Float to double promotion
    -Wfloat-equal \                # Floating point comparison
    -Wformat=2 \                   # Printf format issues
    -Wnon-virtual-dtor \           # Missing virtual destructor
    -Wnull-dereference \           # Null pointer dereference
    -Wold-style-cast \             # C-style casts
    -Woverloaded-virtual \         # Overloaded virtual functions
    -Wshadow \                     # Variable shadowing
    -Wsign-conversion \            # Sign conversions
    -Wunused \                     # Unused variables/functions
    -Wunused-parameter \           # Unused parameters
    -Wno-unused-parameter \        # Disable if too noisy
    main.cpp
```

Clang-specific warnings:

```bash
clang++ \
    -Weverything \                 # Enable all warnings
    -Wno-c++98-compat \           # Disable C++98 compatibility
    -Wno-c++98-compat-pedantic \
    -Wno-padded \                  # Disable padding warnings
    -Wno-weak-vtables \
    main.cpp
```

5.2 STATIC ANALYSIS
-------------------

```bash
# Clang-tidy
clang-tidy main.cpp -- -std=c++20

# With specific checks
clang-tidy \
    -checks='*,-readability-magic-numbers,-cppcoreguidelines-avoid-magic-numbers' \
    main.cpp -- -std=c++20

# Clang static analyzer
clang++ --analyze -Xanalyzer -analyzer-output=text main.cpp

# GCC static analyzer (GCC 10+)
g++ -fanalyzer main.cpp
```

================================================================================
SECTION 6: LINKER FLAGS
================================================================================

6.1 LINKER OPTIMIZATION
-----------------------

```bash
# Link-time optimization
g++ -O3 -flto -fuse-linker-plugin main.cpp -o trading_engine

# Dead code elimination
g++ -Wl,--gc-sections -ffunction-sections -fdata-sections main.cpp

# Optimize linker performance
g++ -Wl,-O1 -Wl,--as-needed -Wl,--sort-common main.cpp

# Strip symbols (production)
g++ -O3 main.cpp -o trading_engine
strip --strip-all trading_engine

# Or during linking
g++ -O3 -Wl,-s main.cpp -o trading_engine
```

6.2 RPATH AND LIBRARY PATHS
----------------------------

```bash
# Set RPATH
g++ main.cpp -Wl,-rpath,/opt/hft/lib -L/opt/hft/lib -lhft_core

# Set RUNPATH
g++ main.cpp -Wl,--enable-new-dtags,-rpath,/opt/hft/lib

# Check RPATH
readelf -d trading_engine | grep RPATH
objdump -x trading_engine | grep RPATH
```

6.3 USING LLD (LLVM LINKER)
----------------------------

```bash
# Use lld (faster linker)
clang++ -fuse-ld=lld main.cpp -o trading_engine

# GCC with lld
g++ -fuse-ld=lld main.cpp -o trading_engine

# Install lld
sudo apt-get install lld
```

6.4 USING GOLD LINKER
---------------------

```bash
# Use gold linker
g++ -fuse-ld=gold main.cpp -o trading_engine

# Gold linker options
g++ -fuse-ld=gold -Wl,--threads -Wl,--thread-count=8 main.cpp
```

================================================================================
SECTION 7: COMPILER-SPECIFIC FEATURES
================================================================================

7.1 GCC SPECIFIC
----------------

```bash
# Function multiversioning (auto-dispatch based on CPU)
g++ -O3 main.cpp

# In code:
__attribute__((target("default")))
void compute() {
    // Generic implementation
}

__attribute__((target("avx2")))
void compute() {
    // AVX2 implementation
}

__attribute__((target("avx512f")))
void compute() {
    // AVX-512 implementation
}
```

7.2 CLANG SPECIFIC
------------------

```bash
# Time trace (see what takes time during compilation)
clang++ -ftime-trace main.cpp

# View trace
google-chrome main.json

# Optimization remarks
clang++ -O3 -Rpass=inline -Rpass-analysis=loop-vectorize main.cpp
```

7.3 INTEL SPECIFIC
------------------

```bash
# Optimization reports
icpx -O3 -qopt-report=5 -qopt-report-phase=vec main.cpp

# View report
cat main.optrpt

# Intel-specific intrinsics
icpx -O3 -xHost -qopt-zmm-usage=high main.cpp
```

================================================================================
SECTION 8: BUILD SCRIPTS
================================================================================

8.1 PRODUCTION BUILD SCRIPT
----------------------------

build_production.sh:

```bash
#!/bin/bash
set -euo pipefail

# Configuration
CXX=${CXX:-g++-11}
BUILD_TYPE=${BUILD_TYPE:-Release}
TARGET=${TARGET:-trading_engine}

# Compiler flags
CXXFLAGS=(
    -std=c++20
    -O3
    -march=native
    -mtune=native
    -flto
    -fuse-linker-plugin
    -ffast-math
    -funroll-loops
    -fprefetch-loop-arrays
    -ftree-vectorize
    -finline-functions
    -fno-exceptions
    -fno-rtti
    -fno-omit-frame-pointer
    -pthread
    -Wall
    -Wextra
    -Werror
    -DNDEBUG
)

# Linker flags
LDFLAGS=(
    -flto
    -fuse-linker-plugin
    -Wl,-O1
    -Wl,--as-needed
    -Wl,--gc-sections
    -pthread
)

# Include paths
INCLUDES=(
    -I./include
    -I/usr/local/include
)

# Library paths
LIBS=(
    -L/usr/local/lib
    -lboost_system
    -lboost_thread
    -lpthread
    -lspdlog
)

# Build
echo "Building ${TARGET} with ${CXX}..."
$CXX "${CXXFLAGS[@]}" "${INCLUDES[@]}" \
     src/*.cpp \
     "${LDFLAGS[@]}" "${LIBS[@]}" \
     -o "${TARGET}"

echo "Build complete: ${TARGET}"

# Strip symbols
strip --strip-all "${TARGET}"

# Print binary info
echo "Binary size: $(du -h ${TARGET} | cut -f1)"
file "${TARGET}"
```

8.2 MULTI-COMPILER BUILD SCRIPT
--------------------------------

build_all_compilers.sh:

```bash
#!/bin/bash
set -euo pipefail

SOURCE="src/*.cpp"
COMMON_FLAGS="-std=c++20 -O3 -march=native -pthread"

# GCC
echo "=== Building with GCC ==="
g++-11 $COMMON_FLAGS -flto $SOURCE -o trading_engine_gcc
ls -lh trading_engine_gcc

# Clang
echo "=== Building with Clang ==="
clang++-14 $COMMON_FLAGS -flto=thin $SOURCE -o trading_engine_clang
ls -lh trading_engine_clang

# Intel
if command -v icpx &> /dev/null; then
    echo "=== Building with Intel ==="
    source /opt/intel/oneapi/setvars.sh
    icpx $COMMON_FLAGS -ipo $SOURCE -o trading_engine_intel
    ls -lh trading_engine_intel
fi

echo "=== Performance Comparison ==="
time ./trading_engine_gcc --benchmark
time ./trading_engine_clang --benchmark
if [ -f trading_engine_intel ]; then
    time ./trading_engine_intel --benchmark
fi
```

================================================================================
SECTION 9: TROUBLESHOOTING
================================================================================

9.1 COMMON COMPILATION ERRORS
------------------------------

Error: undefined reference to symbol

```bash
# Solution: Add missing library
g++ main.cpp -lpthread -lboost_system

# Check required libraries
ldd trading_engine
```

Error: conflicting compiler flags

```bash
# Check active flags
g++ -Q --help=optimizers
g++ -Q --help=target

# Clear and rebuild
make clean
make
```

Error: LTO failures

```bash
# Use GCC AR and RANLIB for LTO
export AR=gcc-ar-11
export RANLIB=gcc-ranlib-11
make clean
make
```

9.2 PERFORMANCE DEBUGGING
--------------------------

Check if optimizations are applied:

```bash
# View assembly
g++ -O3 -S main.cpp
cat main.s

# Check if vectorized
objdump -d trading_engine | grep -E "vmovups|vaddps"

# Optimization reports
g++ -O3 -fopt-info-vec-optimized main.cpp
```

================================================================================
BEST PRACTICES FOR HFT COMPILATION
================================================================================

1. Use GCC 11+ or Clang 14+ for modern C++20 support
2. Always compile with -O3 -march=native for production
3. Enable LTO (-flto) for maximum performance
4. Use -fno-omit-frame-pointer for profiling
5. Disable exceptions and RTTI if not needed
6. Enable all warnings (-Wall -Wextra -Werror)
7. Use sanitizers during development
8. Profile with perf before and after optimization
9. Consider PGO for critical hot paths
10. Keep build scripts in version control

================================================================================
COMPILER FLAGS QUICK REFERENCE
================================================================================

Production (Maximum Performance):
    g++ -O3 -march=native -flto -fuse-linker-plugin -ffast-math

Debug (Development):
    g++ -O0 -g -Wall -Wextra -fsanitize=address

Release with Debug Info:
    g++ -O2 -g -fno-omit-frame-pointer

Profiling:
    g++ -O2 -pg -fno-omit-frame-pointer

Coverage:
    g++ -O0 -g --coverage

================================================================================
Last Updated: 2025-11-25
Version: 1.0.0
