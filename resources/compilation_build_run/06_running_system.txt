================================================================================
RUNNING HFT TRADING SYSTEMS
================================================================================

OVERVIEW
--------
Running an HFT system involves more than just executing the binary. Proper
configuration management, command-line argument parsing, environment setup,
process management, and monitoring are critical for reliable operation.
This guide covers all aspects of running HFT systems in development, staging,
and production environments.

================================================================================
SECTION 1: COMMAND-LINE ARGUMENTS
================================================================================

1.1 BASIC ARGUMENT PARSING
---------------------------

Simple argument parsing:

```cpp
// main.cpp
#include <iostream>
#include <string>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <config_file>\n";
        return 1;
    }

    std::string config_file = argv[1];
    std::cout << "Using config: " << config_file << "\n";

    return 0;
}
```

Run:

```bash
./trading_engine config/production.json
```

1.2 BOOST PROGRAM_OPTIONS
--------------------------

Professional argument parsing:

```cpp
// main.cpp
#include <boost/program_options.hpp>
#include <iostream>
#include <string>

namespace po = boost::program_options;

int main(int argc, char* argv[]) {
    try {
        po::options_description desc("HFT Trading Engine");
        desc.add_options()
            ("help,h", "Display help message")
            ("config,c", po::value<std::string>()->required(), "Configuration file")
            ("symbols,s", po::value<std::vector<std::string>>()->multitoken(),
             "Trading symbols (e.g., AAPL TSLA)")
            ("exchange,e", po::value<std::string>()->default_value("NYSE"),
             "Exchange name")
            ("port,p", po::value<int>()->default_value(8080), "Server port")
            ("verbose,v", po::bool_switch()->default_value(false), "Verbose logging")
            ("dry-run", po::bool_switch(), "Dry run mode (no actual trading)")
            ("threads,t", po::value<int>()->default_value(4), "Worker threads");

        po::variables_map vm;
        po::store(po::parse_command_line(argc, argv, desc), vm);

        if (vm.count("help")) {
            std::cout << desc << "\n";
            return 0;
        }

        po::notify(vm);  // Throws if required options missing

        // Access options
        std::string config = vm["config"].as<std::string>();
        std::string exchange = vm["exchange"].as<std::string>();
        int port = vm["port"].as<int>();
        bool verbose = vm["verbose"].as<bool>();
        bool dry_run = vm["dry-run"].as<bool>();
        int threads = vm["threads"].as<int>();

        if (vm.count("symbols")) {
            auto symbols = vm["symbols"].as<std::vector<std::string>>();
            std::cout << "Trading symbols: ";
            for (const auto& sym : symbols) {
                std::cout << sym << " ";
            }
            std::cout << "\n";
        }

        std::cout << "Config: " << config << "\n";
        std::cout << "Exchange: " << exchange << "\n";
        std::cout << "Port: " << port << "\n";
        std::cout << "Verbose: " << (verbose ? "yes" : "no") << "\n";
        std::cout << "Dry run: " << (dry_run ? "yes" : "no") << "\n";
        std::cout << "Threads: " << threads << "\n";

    } catch (const po::error& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }

    return 0;
}
```

Build and run:

```bash
# Compile
g++ -std=c++20 -O3 main.cpp -lboost_program_options -o trading_engine

# Usage examples
./trading_engine --help

./trading_engine --config config/prod.json

./trading_engine -c config/prod.json -s AAPL TSLA MSFT -e NASDAQ -p 9000 --verbose

./trading_engine --config config/test.json --dry-run --threads 8
```

1.3 CLI11 LIBRARY
-----------------

Modern alternative to Boost.ProgramOptions:

```cpp
// main.cpp
#include <CLI/CLI.hpp>
#include <iostream>
#include <string>
#include <vector>

int main(int argc, char** argv) {
    CLI::App app{"HFT Trading Engine"};

    std::string config_file;
    std::vector<std::string> symbols;
    std::string exchange = "NYSE";
    int port = 8080;
    bool verbose = false;
    bool dry_run = false;
    int threads = 4;

    app.add_option("-c,--config", config_file, "Configuration file")
        ->required()
        ->check(CLI::ExistingFile);

    app.add_option("-s,--symbols", symbols, "Trading symbols");

    app.add_option("-e,--exchange", exchange, "Exchange name")
        ->check(CLI::IsMember({"NYSE", "NASDAQ", "CBOE"}));

    app.add_option("-p,--port", port, "Server port")
        ->check(CLI::Range(1024, 65535));

    app.add_flag("-v,--verbose", verbose, "Verbose logging");

    app.add_flag("--dry-run", dry_run, "Dry run mode");

    app.add_option("-t,--threads", threads, "Worker threads")
        ->check(CLI::Range(1, 64));

    CLI11_PARSE(app, argc, argv);

    std::cout << "Config: " << config_file << "\n";
    std::cout << "Exchange: " << exchange << "\n";
    std::cout << "Port: " << port << "\n";
    std::cout << "Threads: " << threads << "\n";

    return 0;
}
```

1.4 COMPLETE ARGUMENT HANDLING
-------------------------------

Production-ready argument handling:

```cpp
// TradingEngineConfig.h
#pragma once
#include <CLI/CLI.hpp>
#include <string>
#include <vector>

struct TradingEngineConfig {
    std::string config_file;
    std::string log_level = "info";
    std::string log_file;
    std::vector<std::string> symbols;
    std::string exchange;
    std::string strategy = "market_making";
    int port = 8080;
    int threads = 4;
    bool verbose = false;
    bool dry_run = false;
    bool enable_risk_checks = true;
    double max_position_size = 1000.0;
    std::string api_key;
    std::string api_secret;

    static TradingEngineConfig parse_args(int argc, char** argv);
    void validate() const;
};

// TradingEngineConfig.cpp
#include "TradingEngineConfig.h"
#include <stdexcept>

TradingEngineConfig TradingEngineConfig::parse_args(int argc, char** argv) {
    TradingEngineConfig config;

    CLI::App app{"HFT Trading Engine v1.0.0"};

    app.add_option("-c,--config", config.config_file, "Configuration file")
        ->required()
        ->check(CLI::ExistingFile);

    app.add_option("--log-level", config.log_level, "Log level")
        ->check(CLI::IsMember({"trace", "debug", "info", "warn", "error"}));

    app.add_option("--log-file", config.log_file, "Log file path");

    app.add_option("-s,--symbols", config.symbols, "Trading symbols");

    app.add_option("-e,--exchange", config.exchange, "Exchange")
        ->check(CLI::IsMember({"NYSE", "NASDAQ", "CBOE", "CME"}));

    app.add_option("--strategy", config.strategy, "Trading strategy")
        ->check(CLI::IsMember({"market_making", "momentum", "arbitrage"}));

    app.add_option("-p,--port", config.port, "Server port")
        ->check(CLI::Range(1024, 65535));

    app.add_option("-t,--threads", config.threads, "Worker threads")
        ->check(CLI::Range(1, 64));

    app.add_flag("-v,--verbose", config.verbose, "Verbose output");

    app.add_flag("--dry-run", config.dry_run, "Dry run (no trading)");

    app.add_flag("--no-risk-checks", [&](size_t) {
        config.enable_risk_checks = false;
    }, "Disable risk checks");

    app.add_option("--max-position", config.max_position_size,
                   "Maximum position size");

    app.add_option("--api-key", config.api_key, "API key")
        ->envname("HFT_API_KEY");

    app.add_option("--api-secret", config.api_secret, "API secret")
        ->envname("HFT_API_SECRET");

    CLI11_PARSE(app, argc, argv);

    config.validate();

    return config;
}

void TradingEngineConfig::validate() const {
    if (api_key.empty() || api_secret.empty()) {
        throw std::runtime_error("API credentials required");
    }

    if (max_position_size <= 0) {
        throw std::runtime_error("Invalid position size");
    }

    if (!dry_run && !enable_risk_checks) {
        throw std::runtime_error("Cannot disable risk checks in live mode");
    }
}
```

Usage in main:

```cpp
// main.cpp
#include "TradingEngineConfig.h"
#include <iostream>

int main(int argc, char** argv) {
    try {
        auto config = TradingEngineConfig::parse_args(argc, argv);

        std::cout << "Starting trading engine...\n";
        std::cout << "Mode: " << (config.dry_run ? "DRY RUN" : "LIVE") << "\n";

        // Initialize engine with config
        // ...

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }

    return 0;
}
```

Run examples:

```bash
# Basic usage
./trading_engine --config config/prod.json

# Full configuration
./trading_engine \
    --config config/prod.json \
    --symbols AAPL TSLA MSFT \
    --exchange NASDAQ \
    --strategy momentum \
    --port 9000 \
    --threads 8 \
    --log-level debug \
    --log-file /var/log/hft/trading.log \
    --api-key $HFT_API_KEY \
    --api-secret $HFT_API_SECRET

# Dry run for testing
./trading_engine --config config/test.json --dry-run --verbose
```

================================================================================
SECTION 2: CONFIGURATION FILES
================================================================================

2.1 JSON CONFIGURATION
----------------------

config/production.json:

```json
{
  "general": {
    "engine_id": "hft-prod-01",
    "environment": "production",
    "log_level": "info",
    "log_file": "/var/log/hft/trading.log"
  },
  "exchange": {
    "name": "NASDAQ",
    "api_endpoint": "wss://api.exchange.com/v1/ws",
    "api_key": "${HFT_API_KEY}",
    "api_secret": "${HFT_API_SECRET}",
    "timeout_ms": 5000,
    "retry_attempts": 3
  },
  "trading": {
    "symbols": ["AAPL", "TSLA", "MSFT", "AMZN"],
    "strategy": "market_making",
    "max_position_size": 1000,
    "max_order_value": 100000,
    "enable_risk_checks": true,
    "dry_run": false
  },
  "network": {
    "server_port": 8080,
    "worker_threads": 8,
    "io_threads": 4,
    "tcp_nodelay": true,
    "tcp_quickack": true
  },
  "performance": {
    "cpu_affinity": [0, 1, 2, 3, 4, 5, 6, 7],
    "thread_priority": 99,
    "use_hugepages": true,
    "lock_memory": true
  },
  "monitoring": {
    "metrics_port": 9090,
    "health_check_interval_ms": 1000,
    "enable_profiling": false
  }
}
```

Parsing JSON with simdjson:

```cpp
// ConfigParser.h
#pragma once
#include <simdjson.h>
#include <string>
#include <vector>

struct Config {
    std::string engine_id;
    std::string environment;
    std::string log_level;
    std::string log_file;

    std::string exchange_name;
    std::string api_endpoint;
    std::string api_key;
    std::string api_secret;

    std::vector<std::string> symbols;
    std::string strategy;
    int max_position_size;
    bool enable_risk_checks;
    bool dry_run;

    int server_port;
    int worker_threads;

    static Config from_file(const std::string& filename);
};

// ConfigParser.cpp
#include "ConfigParser.h"
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <cstdlib>

std::string expand_env_vars(const std::string& str) {
    if (str.size() > 3 && str.substr(0, 2) == "${" && str.back() == '}') {
        std::string var_name = str.substr(2, str.size() - 3);
        const char* value = std::getenv(var_name.c_str());
        if (value) {
            return value;
        }
    }
    return str;
}

Config Config::from_file(const std::string& filename) {
    // Read file
    std::ifstream file(filename);
    if (!file) {
        throw std::runtime_error("Cannot open config file: " + filename);
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string json_str = buffer.str();

    // Parse JSON
    simdjson::dom::parser parser;
    simdjson::dom::element doc = parser.parse(json_str);

    Config config;

    // General settings
    config.engine_id = std::string(doc["general"]["engine_id"]);
    config.environment = std::string(doc["general"]["environment"]);
    config.log_level = std::string(doc["general"]["log_level"]);
    config.log_file = std::string(doc["general"]["log_file"]);

    // Exchange settings
    config.exchange_name = std::string(doc["exchange"]["name"]);
    config.api_endpoint = std::string(doc["exchange"]["api_endpoint"]);
    config.api_key = expand_env_vars(std::string(doc["exchange"]["api_key"]));
    config.api_secret = expand_env_vars(std::string(doc["exchange"]["api_secret"]));

    // Trading settings
    for (auto symbol : doc["trading"]["symbols"]) {
        config.symbols.push_back(std::string(symbol));
    }
    config.strategy = std::string(doc["trading"]["strategy"]);
    config.max_position_size = int64_t(doc["trading"]["max_position_size"]);
    config.enable_risk_checks = bool(doc["trading"]["enable_risk_checks"]);
    config.dry_run = bool(doc["trading"]["dry_run"]);

    // Network settings
    config.server_port = int64_t(doc["network"]["server_port"]);
    config.worker_threads = int64_t(doc["network"]["worker_threads"]);

    return config;
}
```

2.2 YAML CONFIGURATION
----------------------

Alternative: YAML format (more human-friendly):

config/production.yaml:

```yaml
general:
  engine_id: hft-prod-01
  environment: production
  log_level: info
  log_file: /var/log/hft/trading.log

exchange:
  name: NASDAQ
  api_endpoint: wss://api.exchange.com/v1/ws
  api_key: ${HFT_API_KEY}
  api_secret: ${HFT_API_SECRET}
  timeout_ms: 5000

trading:
  symbols:
    - AAPL
    - TSLA
    - MSFT
  strategy: market_making
  max_position_size: 1000
  enable_risk_checks: true
  dry_run: false

network:
  server_port: 8080
  worker_threads: 8
  io_threads: 4
```

2.3 CONFIGURATION OVERLAY
--------------------------

Multiple configuration files with override:

```bash
# Base configuration
./trading_engine \
    --config config/base.json \
    --config-override config/prod-override.json

# Or via environment
export HFT_CONFIG_BASE=config/base.json
export HFT_CONFIG_OVERRIDE=config/prod-override.json
./trading_engine
```

2.4 CONFIGURATION VALIDATION
-----------------------------

```cpp
// ConfigValidator.h
#pragma once
#include "Config.h"

class ConfigValidator {
public:
    static void validate(const Config& config);

private:
    static void validate_general(const Config& config);
    static void validate_exchange(const Config& config);
    static void validate_trading(const Config& config);
    static void validate_network(const Config& config);
};

// ConfigValidator.cpp
#include "ConfigValidator.h"
#include <stdexcept>

void ConfigValidator::validate(const Config& config) {
    validate_general(config);
    validate_exchange(config);
    validate_trading(config);
    validate_network(config);
}

void ConfigValidator::validate_general(const Config& config) {
    if (config.engine_id.empty()) {
        throw std::runtime_error("engine_id cannot be empty");
    }

    if (config.log_level != "trace" && config.log_level != "debug" &&
        config.log_level != "info" && config.log_level != "warn" &&
        config.log_level != "error") {
        throw std::runtime_error("Invalid log_level: " + config.log_level);
    }
}

void ConfigValidator::validate_exchange(const Config& config) {
    if (config.api_key.empty() || config.api_secret.empty()) {
        throw std::runtime_error("API credentials missing");
    }

    if (config.api_endpoint.empty()) {
        throw std::runtime_error("API endpoint missing");
    }
}

void ConfigValidator::validate_trading(const Config& config) {
    if (config.symbols.empty()) {
        throw std::runtime_error("No trading symbols specified");
    }

    if (config.max_position_size <= 0) {
        throw std::runtime_error("Invalid max_position_size");
    }

    if (!config.dry_run && !config.enable_risk_checks) {
        throw std::runtime_error("Risk checks cannot be disabled in live mode");
    }
}

void ConfigValidator::validate_network(const Config& config) {
    if (config.server_port < 1024 || config.server_port > 65535) {
        throw std::runtime_error("Invalid server_port");
    }

    if (config.worker_threads < 1 || config.worker_threads > 64) {
        throw std::runtime_error("Invalid worker_threads");
    }
}
```

================================================================================
SECTION 3: ENVIRONMENT VARIABLES
================================================================================

3.1 USING ENVIRONMENT VARIABLES
--------------------------------

```cpp
// Reading environment variables
#include <cstdlib>
#include <string>

std::string get_env(const std::string& name, const std::string& default_value = "") {
    const char* value = std::getenv(name.c_str());
    return value ? std::string(value) : default_value;
}

int get_env_int(const std::string& name, int default_value = 0) {
    const char* value = std::getenv(name.c_str());
    return value ? std::stoi(value) : default_value;
}

bool get_env_bool(const std::string& name, bool default_value = false) {
    const char* value = std::getenv(name.c_str());
    if (!value) return default_value;
    std::string str_value(value);
    return str_value == "1" || str_value == "true" || str_value == "TRUE";
}

// Usage
int main() {
    std::string api_key = get_env("HFT_API_KEY");
    std::string api_secret = get_env("HFT_API_SECRET");
    std::string log_level = get_env("HFT_LOG_LEVEL", "info");
    int port = get_env_int("HFT_PORT", 8080);
    bool dry_run = get_env_bool("HFT_DRY_RUN", false);

    // ...
}
```

3.2 ENVIRONMENT FILE (.env)
----------------------------

.env file for local development:

```bash
# .env
HFT_ENV=development
HFT_LOG_LEVEL=debug
HFT_LOG_FILE=/tmp/hft/trading.log
HFT_API_KEY=your_api_key_here
HFT_API_SECRET=your_api_secret_here
HFT_EXCHANGE=NASDAQ
HFT_PORT=8080
HFT_THREADS=4
HFT_DRY_RUN=true
```

Load .env file:

```bash
# Source environment
source .env
./trading_engine

# Or use env command
env $(cat .env | xargs) ./trading_engine

# Or dotenv tool
dotenv ./trading_engine
```

3.3 SYSTEMD ENVIRONMENT
-----------------------

/etc/systemd/system/hft-trading.service:

```ini
[Unit]
Description=HFT Trading Engine
After=network.target

[Service]
Type=simple
User=hft
Group=hft
WorkingDirectory=/opt/hft
Environment="HFT_ENV=production"
Environment="HFT_LOG_LEVEL=info"
Environment="HFT_LOG_FILE=/var/log/hft/trading.log"
EnvironmentFile=/etc/hft/environment
ExecStart=/opt/hft/bin/trading_engine --config /etc/hft/production.json
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

/etc/hft/environment:

```bash
HFT_API_KEY=prod_api_key
HFT_API_SECRET=prod_api_secret
HFT_EXCHANGE=NASDAQ
```

3.4 PRIORITY ORDER
------------------

Configuration priority (highest to lowest):

1. Command-line arguments
2. Environment variables
3. Configuration file
4. Default values

```cpp
// Configuration with priority
struct Config {
    std::string log_level;

    void load(const std::string& config_file, int argc, char** argv) {
        // 1. Default
        log_level = "info";

        // 2. Config file
        auto file_config = parse_config_file(config_file);
        if (!file_config.log_level.empty()) {
            log_level = file_config.log_level;
        }

        // 3. Environment
        const char* env_log_level = std::getenv("HFT_LOG_LEVEL");
        if (env_log_level) {
            log_level = env_log_level;
        }

        // 4. Command line (highest priority)
        // Parse CLI args and override
    }
};
```

================================================================================
SECTION 4: PROCESS MANAGEMENT
================================================================================

4.1 DAEMONIZATION
-----------------

Run as background daemon:

```bash
# Simple background execution
./trading_engine --config config/prod.json &

# Nohup for persistence
nohup ./trading_engine --config config/prod.json > /var/log/hft/output.log 2>&1 &

# Disown to detach from shell
./trading_engine --config config/prod.json &
disown

# Screen session
screen -S hft-trading
./trading_engine --config config/prod.json
# Ctrl+A, D to detach

# Tmux session
tmux new -s hft-trading
./trading_engine --config config/prod.json
# Ctrl+B, D to detach
```

4.2 SYSTEMD SERVICE
-------------------

Complete systemd service:

/etc/systemd/system/hft-trading.service:

```ini
[Unit]
Description=HFT Trading Engine
Documentation=https://docs.hft.com
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=hft
Group=hft
WorkingDirectory=/opt/hft

# Environment
Environment="HFT_ENV=production"
EnvironmentFile=-/etc/hft/environment

# Resource limits
LimitNOFILE=65536
LimitMEMLOCK=infinity
LimitCORE=infinity

# CPU affinity
CPUAffinity=0-7

# Nice priority
Nice=-20

# Execution
ExecStartPre=/opt/hft/scripts/pre-start.sh
ExecStart=/opt/hft/bin/trading_engine --config /etc/hft/production.json
ExecReload=/bin/kill -HUP $MAINPID
ExecStop=/opt/hft/scripts/graceful-shutdown.sh

# Restart policy
Restart=always
RestartSec=10
StartLimitBurst=5
StartLimitIntervalSec=60

# Security
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/log/hft /var/lib/hft

# Logging
StandardOutput=journal
StandardError=journal
SyslogIdentifier=hft-trading

[Install]
WantedBy=multi-user.target
```

Manage service:

```bash
# Reload systemd
sudo systemctl daemon-reload

# Enable at boot
sudo systemctl enable hft-trading

# Start service
sudo systemctl start hft-trading

# Status
sudo systemctl status hft-trading

# Logs
sudo journalctl -u hft-trading -f

# Stop
sudo systemctl stop hft-trading

# Restart
sudo systemctl restart hft-trading
```

4.3 SUPERVISOR
--------------

Alternative: Supervisor for process management:

/etc/supervisor/conf.d/hft-trading.conf:

```ini
[program:hft-trading]
command=/opt/hft/bin/trading_engine --config /etc/hft/production.json
directory=/opt/hft
user=hft
group=hft
autostart=true
autorestart=true
startretries=3
redirect_stderr=true
stdout_logfile=/var/log/hft/trading.log
stdout_logfile_maxbytes=50MB
stdout_logfile_backups=10
environment=HFT_ENV="production",HFT_LOG_LEVEL="info"
```

Manage:

```bash
# Update config
sudo supervisorctl reread
sudo supervisorctl update

# Start
sudo supervisorctl start hft-trading

# Status
sudo supervisorctl status hft-trading

# Stop
sudo supervisorctl stop hft-trading

# Restart
sudo supervisorctl restart hft-trading

# Tail logs
sudo supervisorctl tail -f hft-trading
```

================================================================================
SECTION 5: STARTUP SCRIPTS
================================================================================

5.1 PRE-START SCRIPT
--------------------

scripts/pre-start.sh:

```bash
#!/bin/bash
set -euo pipefail

echo "=== Pre-start checks ==="

# Check binary exists
if [ ! -f /opt/hft/bin/trading_engine ]; then
    echo "Error: Binary not found"
    exit 1
fi

# Check configuration
if [ ! -f /etc/hft/production.json ]; then
    echo "Error: Config file not found"
    exit 1
fi

# Check API credentials
if [ -z "${HFT_API_KEY:-}" ] || [ -z "${HFT_API_SECRET:-}" ]; then
    echo "Error: API credentials not set"
    exit 1
fi

# Check network connectivity
if ! ping -c 1 8.8.8.8 > /dev/null 2>&1; then
    echo "Warning: No network connectivity"
fi

# Create log directory
mkdir -p /var/log/hft
chown hft:hft /var/log/hft

# Set CPU governor to performance
for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
    echo performance > $cpu
done

# Disable CPU frequency scaling
echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo || true

# Set TCP parameters
sysctl -w net.core.rmem_max=134217728
sysctl -w net.core.wmem_max=134217728
sysctl -w net.ipv4.tcp_rmem="4096 87380 134217728"
sysctl -w net.ipv4.tcp_wmem="4096 65536 134217728"

echo "âœ“ Pre-start checks passed"
```

5.2 GRACEFUL SHUTDOWN
---------------------

scripts/graceful-shutdown.sh:

```bash
#!/bin/bash
set -euo pipefail

PID_FILE=/var/run/hft-trading.pid

if [ ! -f "$PID_FILE" ]; then
    echo "No PID file found"
    exit 0
fi

PID=$(cat "$PID_FILE")

echo "Sending SIGTERM to PID $PID"
kill -TERM "$PID"

# Wait for graceful shutdown (max 30 seconds)
for i in {1..30}; do
    if ! kill -0 "$PID" 2>/dev/null; then
        echo "Process terminated gracefully"
        rm -f "$PID_FILE"
        exit 0
    fi
    sleep 1
done

echo "Force killing process"
kill -KILL "$PID"
rm -f "$PID_FILE"
```

In application code:

```cpp
// main.cpp
#include <signal.h>
#include <atomic>

std::atomic<bool> g_running{true};

void signal_handler(int signal) {
    if (signal == SIGTERM || signal == SIGINT) {
        std::cout << "Received shutdown signal, stopping...\n";
        g_running = false;
    }
}

int main(int argc, char** argv) {
    // Install signal handlers
    signal(SIGTERM, signal_handler);
    signal(SIGINT, signal_handler);

    // Main loop
    while (g_running) {
        // Process events
    }

    // Graceful shutdown
    std::cout << "Shutting down gracefully...\n";
    // Close connections, flush buffers, etc.

    return 0;
}
```

================================================================================
SECTION 6: MONITORING AND HEALTH CHECKS
================================================================================

6.1 HEALTH CHECK ENDPOINT
--------------------------

```cpp
// HealthCheck.h
#pragma once
#include <string>
#include <chrono>

class HealthCheck {
public:
    struct Status {
        bool is_healthy;
        std::string message;
        std::chrono::system_clock::time_point last_update;
        int64_t uptime_seconds;
    };

    static Status check();
};

// Simple HTTP health endpoint
void start_health_server(int port) {
    // Listen on port (e.g., 8888)
    // Respond to GET /health with JSON status
}
```

6.2 READINESS vs LIVENESS
--------------------------

Kubernetes-style probes:

```bash
# Liveness: Is the process running?
curl http://localhost:8888/health/live

# Readiness: Is the process ready to serve traffic?
curl http://localhost:8888/health/ready
```

6.3 METRICS ENDPOINT
--------------------

Prometheus-compatible metrics:

```bash
# Metrics endpoint
curl http://localhost:9090/metrics

# Example output:
# hft_orders_processed_total 12345
# hft_latency_microseconds{quantile="0.99"} 125
# hft_position_size{symbol="AAPL"} 500
```

================================================================================
BEST PRACTICES
================================================================================

1. Use structured argument parsing (Boost.ProgramOptions or CLI11)
2. Support both CLI args and config files
3. Allow environment variable overrides
4. Validate configuration thoroughly before starting
5. Implement graceful shutdown on SIGTERM
6. Use systemd for production process management
7. Provide health check endpoints
8. Log startup configuration for debugging
9. Set appropriate resource limits
10. Document all configuration options

================================================================================
Last Updated: 2025-11-25
Version: 1.0.0
