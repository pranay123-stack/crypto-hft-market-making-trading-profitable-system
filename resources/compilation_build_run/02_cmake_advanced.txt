================================================================================
CMAKE ADVANCED TECHNIQUES FOR HFT SYSTEMS
================================================================================

OVERVIEW
--------
Advanced CMake techniques are essential for HFT systems that need cross-
compilation, custom toolchains, complex dependency management, and reproducible
builds across development, staging, and production environments.

This guide covers cross-compilation, toolchain files, ExternalProject,
custom build configurations, and advanced CMake features for production-grade
HFT systems.

================================================================================
SECTION 1: CROSS-COMPILATION
================================================================================

1.1 CROSS-COMPILATION BASICS
-----------------------------

Cross-compilation allows building binaries for different target architectures
from a single development machine.

Setting target architecture:

```cmake
# Set target system
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR x86_64)

# Specify compilers
set(CMAKE_C_COMPILER /usr/bin/x86_64-linux-gnu-gcc)
set(CMAKE_CXX_COMPILER /usr/bin/x86_64-linux-gnu-g++)

# Specify sysroot
set(CMAKE_SYSROOT /opt/cross/sysroot)
set(CMAKE_FIND_ROOT_PATH /opt/cross/sysroot)

# Search modes
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
```

1.2 AMD64 TO AMD64 OPTIMIZATION BUILDS
---------------------------------------

Building for different AMD64 microarchitectures:

Toolchain file: cmake/toolchains/amd64-zen3.cmake

```cmake
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR x86_64)

# Use native compilers
set(CMAKE_C_COMPILER gcc-11)
set(CMAKE_CXX_COMPILER g++-11)

# Zen 3 specific optimizations (AMD EPYC Milan)
set(CMAKE_C_FLAGS_INIT "-march=znver3 -mtune=znver3")
set(CMAKE_CXX_FLAGS_INIT "-march=znver3 -mtune=znver3")

# Additional optimizations
add_compile_options(
    -O3
    -flto
    -ffast-math
    -funroll-loops
    -fprefetch-loop-arrays
    -fno-omit-frame-pointer
)

# Link-time optimizations
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)
```

Toolchain file: cmake/toolchains/amd64-icelake.cmake

```cmake
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR x86_64)

# Intel compilers for maximum performance
set(CMAKE_C_COMPILER icc)
set(CMAKE_CXX_COMPILER icpc)

# Ice Lake specific optimizations (Intel Xeon 3rd Gen)
set(CMAKE_C_FLAGS_INIT "-march=icelake-server -mtune=icelake-server")
set(CMAKE_CXX_FLAGS_INIT "-march=icelake-server -mtune=icelake-server")

# Intel-specific optimizations
add_compile_options(
    -O3
    -ipo                        # Interprocedural optimization
    -xICELAKE-SERVER           # Target Ice Lake
    -no-prec-div               # Fast division
    -fp-model fast=2           # Aggressive FP optimizations
    -fno-alias                 # No pointer aliasing
)
```

Usage:

```bash
# Build for AMD Zen 3
cmake -DCMAKE_TOOLCHAIN_FILE=cmake/toolchains/amd64-zen3.cmake \
      -B build-zen3

# Build for Intel Ice Lake
cmake -DCMAKE_TOOLCHAIN_FILE=cmake/toolchains/amd64-icelake.cmake \
      -B build-icelake
```

1.3 ARM64 CROSS-COMPILATION
----------------------------

For ARM-based colocation servers:

Toolchain file: cmake/toolchains/aarch64-linux.cmake

```cmake
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR aarch64)

# Cross-compilation tools
set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
set(CMAKE_AR aarch64-linux-gnu-ar)
set(CMAKE_RANLIB aarch64-linux-gnu-ranlib)
set(CMAKE_STRIP aarch64-linux-gnu-strip)

# Sysroot for ARM64 libraries
set(CMAKE_SYSROOT /usr/aarch64-linux-gnu)
set(CMAKE_FIND_ROOT_PATH /usr/aarch64-linux-gnu)

# ARM64 Neoverse N1 optimizations
set(CMAKE_CXX_FLAGS_INIT "-march=armv8.2-a+crypto+crc -mtune=neoverse-n1")

# Additional flags
add_compile_options(
    -O3
    -flto
    -fno-omit-frame-pointer
)

# Search modes
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
```

Install cross-compilation tools:

```bash
# Install ARM64 toolchain
sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

# Install ARM64 system libraries
sudo apt-get install crossbuild-essential-arm64

# Build with toolchain
cmake -DCMAKE_TOOLCHAIN_FILE=cmake/toolchains/aarch64-linux.cmake \
      -B build-arm64
cmake --build build-arm64
```

================================================================================
SECTION 2: TOOLCHAIN FILES
================================================================================

2.1 PRODUCTION TOOLCHAIN STRUCTURE
-----------------------------------

Complete production toolchain file:

cmake/toolchains/production.cmake:

```cmake
# Production HFT Trading System Toolchain
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_VERSION 1)
set(CMAKE_SYSTEM_PROCESSOR x86_64)

# Compiler selection
set(CMAKE_C_COMPILER gcc-11)
set(CMAKE_CXX_COMPILER g++-11)

# C++ standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Build type defaults
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release)
endif()

# Compiler flags - Base
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} \
    -Wall \
    -Wextra \
    -Wpedantic \
    -Werror \
    -Wno-unused-parameter \
    -fno-exceptions \
    -fno-rtti \
    -pthread"
)

# Release flags - Maximum performance
set(CMAKE_CXX_FLAGS_RELEASE "\
    -O3 \
    -march=native \
    -mtune=native \
    -flto \
    -ffast-math \
    -funroll-loops \
    -fprefetch-loop-arrays \
    -fno-omit-frame-pointer \
    -DNDEBUG"
)

# Debug flags
set(CMAKE_CXX_FLAGS_DEBUG "\
    -g \
    -O0 \
    -fno-inline \
    -DDEBUG"
)

# RelWithDebInfo flags
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "\
    -O2 \
    -g \
    -march=native \
    -DNDEBUG"
)

# Linker flags
set(CMAKE_EXE_LINKER_FLAGS "\
    -Wl,--as-needed \
    -Wl,-O1 \
    -Wl,--sort-common \
    -Wl,--gc-sections"
)

set(CMAKE_EXE_LINKER_FLAGS_RELEASE "\
    -Wl,-s \
    -flto"
)

# Install prefix
set(CMAKE_INSTALL_PREFIX "/opt/hft" CACHE PATH "Install prefix")

# RPATH settings for portable binaries
set(CMAKE_SKIP_BUILD_RPATH FALSE)
set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")
set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)

# Link-time optimization
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE TRUE)

# Output directories
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

# Find dependencies
list(APPEND CMAKE_PREFIX_PATH
    /usr/local
    /opt/local
    ${CMAKE_INSTALL_PREFIX}
)

# Performance monitoring build
option(ENABLE_PERF_MONITORING "Enable performance monitoring hooks" ON)
if(ENABLE_PERF_MONITORING)
    add_compile_definitions(PERF_MONITORING_ENABLED)
endif()

# Hardware capabilities
include(CheckCXXCompilerFlag)

check_cxx_compiler_flag("-mavx2" COMPILER_SUPPORTS_AVX2)
if(COMPILER_SUPPORTS_AVX2)
    add_compile_options(-mavx2)
endif()

check_cxx_compiler_flag("-mavx512f" COMPILER_SUPPORTS_AVX512)
if(COMPILER_SUPPORTS_AVX512)
    add_compile_options(-mavx512f)
endif()
```

Usage:

```bash
cmake -DCMAKE_TOOLCHAIN_FILE=cmake/toolchains/production.cmake -B build-prod
cmake --build build-prod --config Release -j$(nproc)
```

2.2 SANITIZER TOOLCHAINS
-------------------------

AddressSanitizer toolchain:

cmake/toolchains/asan.cmake:

```cmake
set(CMAKE_C_COMPILER clang-14)
set(CMAKE_CXX_COMPILER clang++-14)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_BUILD_TYPE Debug)

# AddressSanitizer flags
set(SANITIZER_FLAGS "\
    -fsanitize=address \
    -fsanitize-address-use-after-scope \
    -fno-omit-frame-pointer \
    -fno-optimize-sibling-calls \
    -g"
)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${SANITIZER_FLAGS}")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${SANITIZER_FLAGS}")

# ASAN runtime options
set(ENV{ASAN_OPTIONS} "detect_leaks=1:check_initialization_order=1:strict_init_order=1")
```

ThreadSanitizer toolchain:

cmake/toolchains/tsan.cmake:

```cmake
set(CMAKE_C_COMPILER clang-14)
set(CMAKE_CXX_COMPILER clang++-14)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_BUILD_TYPE Debug)

# ThreadSanitizer flags
set(SANITIZER_FLAGS "\
    -fsanitize=thread \
    -fno-omit-frame-pointer \
    -g"
)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${SANITIZER_FLAGS}")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${SANITIZER_FLAGS}")

# TSAN runtime options
set(ENV{TSAN_OPTIONS} "second_deadlock_stack=1:history_size=7")
```

UndefinedBehaviorSanitizer toolchain:

cmake/toolchains/ubsan.cmake:

```cmake
set(CMAKE_C_COMPILER clang-14)
set(CMAKE_CXX_COMPILER clang++-14)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_BUILD_TYPE Debug)

# UBSan flags
set(SANITIZER_FLAGS "\
    -fsanitize=undefined \
    -fsanitize=integer \
    -fsanitize=nullability \
    -fno-omit-frame-pointer \
    -g"
)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${SANITIZER_FLAGS}")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${SANITIZER_FLAGS}")
```

2.3 COMPILER-SPECIFIC TOOLCHAINS
---------------------------------

Clang toolchain with advanced optimizations:

cmake/toolchains/clang-performance.cmake:

```cmake
set(CMAKE_C_COMPILER clang-14)
set(CMAKE_CXX_COMPILER clang++-14)
set(CMAKE_AR llvm-ar-14)
set(CMAKE_RANLIB llvm-ranlib-14)

set(CMAKE_CXX_STANDARD 20)

# Clang-specific performance flags
set(CMAKE_CXX_FLAGS_RELEASE "\
    -O3 \
    -march=native \
    -mtune=native \
    -flto=thin \
    -ffast-math \
    -funroll-loops \
    -fvectorize \
    -fslp-vectorize \
    -fstrict-aliasing \
    -fno-omit-frame-pointer \
    -DNDEBUG"
)

# Profile-guided optimization support
option(ENABLE_PGO "Enable Profile-Guided Optimization" OFF)
if(ENABLE_PGO)
    if(PGO_GENERATE)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-generate")
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fprofile-generate")
    elseif(PGO_USE)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-use=${PGO_DATA_PATH}")
    endif()
endif()

# Link-time optimization
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)
```

GCC toolchain with LTO:

cmake/toolchains/gcc-lto.cmake:

```cmake
set(CMAKE_C_COMPILER gcc-11)
set(CMAKE_CXX_COMPILER g++-11)
set(CMAKE_AR gcc-ar-11)
set(CMAKE_RANLIB gcc-ranlib-11)

set(CMAKE_CXX_STANDARD 20)

# GCC LTO flags
set(CMAKE_CXX_FLAGS_RELEASE "\
    -O3 \
    -march=native \
    -mtune=native \
    -flto \
    -fuse-linker-plugin \
    -ffast-math \
    -funroll-loops \
    -fprefetch-loop-arrays \
    -ftree-vectorize \
    -fno-omit-frame-pointer \
    -DNDEBUG"
)

set(CMAKE_EXE_LINKER_FLAGS_RELEASE "\
    -flto \
    -fuse-linker-plugin \
    -Wl,-O1 \
    -Wl,--as-needed"
)

# LTO parallelism
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -flto=$(nproc)")

set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)
```

================================================================================
SECTION 3: EXTERNALPROJECT
================================================================================

3.1 EXTERNALPROJECT BASICS
---------------------------

ExternalProject allows building external dependencies as part of the build:

```cmake
include(ExternalProject)

ExternalProject_Add(spdlog_external
    GIT_REPOSITORY https://github.com/gabime/spdlog.git
    GIT_TAG v1.11.0
    CMAKE_ARGS
        -DCMAKE_INSTALL_PREFIX=${CMAKE_BINARY_DIR}/external
        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
        -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}
        -DCMAKE_CXX_FLAGS=${CMAKE_CXX_FLAGS}
    BUILD_COMMAND ${CMAKE_COMMAND} --build <BINARY_DIR> --config ${CMAKE_BUILD_TYPE}
    INSTALL_COMMAND ${CMAKE_COMMAND} --install <BINARY_DIR>
    LOG_DOWNLOAD ON
    LOG_CONFIGURE ON
    LOG_BUILD ON
    LOG_INSTALL ON
)

# Use the external project
add_executable(trading_engine main.cpp)
add_dependencies(trading_engine spdlog_external)

target_include_directories(trading_engine
    PRIVATE ${CMAKE_BINARY_DIR}/external/include
)

target_link_libraries(trading_engine
    PRIVATE ${CMAKE_BINARY_DIR}/external/lib/libspdlog.a
)
```

3.2 BUILDING MULTIPLE EXTERNAL DEPENDENCIES
--------------------------------------------

Complex dependency setup:

```cmake
include(ExternalProject)

# Set common external project variables
set(EXTERNAL_INSTALL_DIR ${CMAKE_BINARY_DIR}/external)
set(EXTERNAL_CMAKE_ARGS
    -DCMAKE_INSTALL_PREFIX=${EXTERNAL_INSTALL_DIR}
    -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
    -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}
    -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}
    -DCMAKE_CXX_STANDARD=20
)

# simdjson
ExternalProject_Add(simdjson_external
    GIT_REPOSITORY https://github.com/simdjson/simdjson.git
    GIT_TAG v3.2.0
    CMAKE_ARGS
        ${EXTERNAL_CMAKE_ARGS}
        -DSIMDJSON_BUILD_STATIC=ON
        -DSIMDJSON_ENABLE_THREADS=ON
    INSTALL_DIR ${EXTERNAL_INSTALL_DIR}
)

# librdkafka
ExternalProject_Add(librdkafka_external
    GIT_REPOSITORY https://github.com/edenhill/librdkafka.git
    GIT_TAG v1.9.2
    CMAKE_ARGS
        ${EXTERNAL_CMAKE_ARGS}
        -DRDKAFKA_BUILD_STATIC=ON
        -DRDKAFKA_BUILD_TESTS=OFF
        -DRDKAFKA_BUILD_EXAMPLES=OFF
    INSTALL_DIR ${EXTERNAL_INSTALL_DIR}
)

# ZeroMQ
ExternalProject_Add(zeromq_external
    GIT_REPOSITORY https://github.com/zeromq/libzmq.git
    GIT_TAG v4.3.4
    CMAKE_ARGS
        ${EXTERNAL_CMAKE_ARGS}
        -DBUILD_STATIC=ON
        -DBUILD_SHARED=OFF
        -DBUILD_TESTS=OFF
    INSTALL_DIR ${EXTERNAL_INSTALL_DIR}
)

# cppzmq (depends on ZeroMQ)
ExternalProject_Add(cppzmq_external
    DEPENDS zeromq_external
    GIT_REPOSITORY https://github.com/zeromq/cppzmq.git
    GIT_TAG v4.9.0
    CMAKE_ARGS
        ${EXTERNAL_CMAKE_ARGS}
        -DZeroMQ_DIR=${EXTERNAL_INSTALL_DIR}/lib/cmake/ZeroMQ
        -DCPPZMQ_BUILD_TESTS=OFF
    INSTALL_DIR ${EXTERNAL_INSTALL_DIR}
)

# Create imported targets
add_library(simdjson STATIC IMPORTED)
set_target_properties(simdjson PROPERTIES
    IMPORTED_LOCATION ${EXTERNAL_INSTALL_DIR}/lib/libsimdjson.a
    INTERFACE_INCLUDE_DIRECTORIES ${EXTERNAL_INSTALL_DIR}/include
)
add_dependencies(simdjson simdjson_external)

add_library(rdkafka STATIC IMPORTED)
set_target_properties(rdkafka PROPERTIES
    IMPORTED_LOCATION ${EXTERNAL_INSTALL_DIR}/lib/librdkafka.a
    INTERFACE_INCLUDE_DIRECTORIES ${EXTERNAL_INSTALL_DIR}/include
)
add_dependencies(rdkafka librdkafka_external)

add_library(zmq STATIC IMPORTED)
set_target_properties(zmq PROPERTIES
    IMPORTED_LOCATION ${EXTERNAL_INSTALL_DIR}/lib/libzmq.a
    INTERFACE_INCLUDE_DIRECTORIES ${EXTERNAL_INSTALL_DIR}/include
)
add_dependencies(zmq zeromq_external cppzmq_external)

# Link against imported targets
add_executable(trading_engine main.cpp)
target_link_libraries(trading_engine
    PRIVATE
        simdjson
        rdkafka
        zmq
)
```

3.3 EXTERNALPROJECT WITH CUSTOM BUILD STEPS
--------------------------------------------

Building autotools-based projects:

```cmake
ExternalProject_Add(libfixengine
    URL https://example.com/libfixengine-1.0.tar.gz
    CONFIGURE_COMMAND <SOURCE_DIR>/configure
        --prefix=${EXTERNAL_INSTALL_DIR}
        --enable-static
        --disable-shared
        CXX=${CMAKE_CXX_COMPILER}
        CXXFLAGS=-O3 -march=native
    BUILD_COMMAND make -j$(nproc)
    INSTALL_COMMAND make install
    LOG_DOWNLOAD ON
    LOG_CONFIGURE ON
    LOG_BUILD ON
)
```

Custom Makefile-based projects:

```cmake
ExternalProject_Add(quickfix
    GIT_REPOSITORY https://github.com/quickfix/quickfix.git
    GIT_TAG master
    CONFIGURE_COMMAND ""
    BUILD_COMMAND
        make -C <SOURCE_DIR>
            CXX=${CMAKE_CXX_COMPILER}
            CXXFLAGS=-O3
            -j$(nproc)
    INSTALL_COMMAND
        make -C <SOURCE_DIR> install PREFIX=${EXTERNAL_INSTALL_DIR}
    BUILD_IN_SOURCE 1
)
```

3.4 SUPERBUILD PATTERN
-----------------------

Separating external dependencies from main project:

CMakeLists.txt (superbuild):

```cmake
cmake_minimum_required(VERSION 3.20)
project(HFTSystemSuperbuild)

include(ExternalProject)

set(EXTERNAL_INSTALL_DIR ${CMAKE_BINARY_DIR}/install)

# Build all external dependencies
ExternalProject_Add(dependencies
    SOURCE_DIR ${CMAKE_SOURCE_DIR}/cmake/external
    CMAKE_ARGS
        -DCMAKE_INSTALL_PREFIX=${EXTERNAL_INSTALL_DIR}
        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
    INSTALL_COMMAND ""
)

# Build main project
ExternalProject_Add(hft_system
    DEPENDS dependencies
    SOURCE_DIR ${CMAKE_SOURCE_DIR}/hft_system
    CMAKE_ARGS
        -DCMAKE_PREFIX_PATH=${EXTERNAL_INSTALL_DIR}
        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
        -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}
)
```

cmake/external/CMakeLists.txt:

```cmake
cmake_minimum_required(VERSION 3.20)
project(HFTDependencies)

include(ExternalProject)

# Build spdlog
ExternalProject_Add(spdlog
    GIT_REPOSITORY https://github.com/gabime/spdlog.git
    GIT_TAG v1.11.0
    CMAKE_ARGS
        -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}
        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
)

# Build simdjson
ExternalProject_Add(simdjson
    GIT_REPOSITORY https://github.com/simdjson/simdjson.git
    GIT_TAG v3.2.0
    CMAKE_ARGS
        -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}
        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
)
```

Usage:

```bash
mkdir superbuild && cd superbuild
cmake ..
cmake --build . -j$(nproc)
```

================================================================================
SECTION 4: CUSTOM BUILD CONFIGURATIONS
================================================================================

4.1 MULTIPLE BUILD TYPES
-------------------------

Defining custom build types:

```cmake
# Add Profiling build type
set(CMAKE_CXX_FLAGS_PROFILING
    "-O2 -g -pg -fno-omit-frame-pointer"
    CACHE STRING "Flags for profiling builds"
)

set(CMAKE_EXE_LINKER_FLAGS_PROFILING
    "-pg"
    CACHE STRING "Linker flags for profiling builds"
)

# Add Coverage build type
set(CMAKE_CXX_FLAGS_COVERAGE
    "-O0 -g --coverage -fprofile-arcs -ftest-coverage"
    CACHE STRING "Flags for coverage builds"
)

set(CMAKE_EXE_LINKER_FLAGS_COVERAGE
    "--coverage"
    CACHE STRING "Linker flags for coverage builds"
)

# Mark as advanced
mark_as_advanced(
    CMAKE_CXX_FLAGS_PROFILING
    CMAKE_EXE_LINKER_FLAGS_PROFILING
    CMAKE_CXX_FLAGS_COVERAGE
    CMAKE_EXE_LINKER_FLAGS_COVERAGE
)

# Update configuration types
set(CMAKE_CONFIGURATION_TYPES
    "Debug;Release;RelWithDebInfo;MinSizeRel;Profiling;Coverage"
    CACHE STRING "Available build types" FORCE
)
```

Usage:

```bash
# Profiling build
cmake -DCMAKE_BUILD_TYPE=Profiling ..
cmake --build .

# Coverage build
cmake -DCMAKE_BUILD_TYPE=Coverage ..
cmake --build .
ctest
gcovr -r . --html --html-details -o coverage.html
```

4.2 CONFIGURATION-SPECIFIC SETTINGS
------------------------------------

Per-configuration compile definitions:

```cmake
add_executable(trading_engine main.cpp)

target_compile_definitions(trading_engine
    PRIVATE
        $<$<CONFIG:Debug>:DEBUG_MODE>
        $<$<CONFIG:Debug>:ENABLE_ASSERTIONS>
        $<$<CONFIG:Debug>:VERBOSE_LOGGING>
        $<$<CONFIG:Release>:NDEBUG>
        $<$<CONFIG:Release>:DISABLE_LOGGING>
        $<$<CONFIG:Profiling>:PROFILING_MODE>
        $<$<CONFIG:Profiling>:ENABLE_PERF_COUNTERS>
)

target_compile_options(trading_engine
    PRIVATE
        $<$<CONFIG:Debug>:-O0;-g;-fsanitize=address>
        $<$<CONFIG:Release>:-O3;-march=native;-flto>
        $<$<CONFIG:Profiling>:-O2;-g;-pg>
)

target_link_options(trading_engine
    PRIVATE
        $<$<CONFIG:Debug>:-fsanitize=address>
        $<$<CONFIG:Release>:-flto>
        $<$<CONFIG:Profiling>:-pg>
)
```

4.3 BUILD OPTIONS AND FEATURES
-------------------------------

Conditional features:

```cmake
# Build options
option(ENABLE_LOGGING "Enable logging system" ON)
option(ENABLE_METRICS "Enable performance metrics" ON)
option(ENABLE_BACKTESTING "Build backtesting tools" OFF)
option(ENABLE_LIVE_TRADING "Enable live trading mode" ON)
option(USE_JEMALLOC "Use jemalloc allocator" ON)
option(USE_MIMALLOC "Use mimalloc allocator" OFF)

# Feature-based configuration
if(ENABLE_LOGGING)
    add_compile_definitions(LOGGING_ENABLED)
    find_package(spdlog REQUIRED)
endif()

if(ENABLE_METRICS)
    add_compile_definitions(METRICS_ENABLED)
    list(APPEND REQUIRED_LIBS prometheus-cpp)
endif()

if(USE_JEMALLOC)
    find_package(PkgConfig REQUIRED)
    pkg_check_modules(JEMALLOC REQUIRED jemalloc)
    add_compile_definitions(USE_JEMALLOC)
    list(APPEND REQUIRED_LIBS ${JEMALLOC_LIBRARIES})
elseif(USE_MIMALLOC)
    find_package(mimalloc REQUIRED)
    add_compile_definitions(USE_MIMALLOC)
    list(APPEND REQUIRED_LIBS mimalloc)
endif()

# Conditional compilation
if(ENABLE_BACKTESTING)
    add_subdirectory(backtesting)
endif()

if(ENABLE_LIVE_TRADING)
    add_subdirectory(live_trading)
endif()
```

================================================================================
SECTION 5: ADVANCED DEPENDENCY MANAGEMENT
================================================================================

5.1 FETCHCONTENT WITH VERSION CONTROL
--------------------------------------

Sophisticated FetchContent usage:

```cmake
include(FetchContent)

# Control whether to update dependencies
set(FETCHCONTENT_UPDATES_DISCONNECTED ON CACHE BOOL
    "Disable automatic updates for FetchContent dependencies"
)

# Quiet mode
set(FETCHCONTENT_QUIET OFF)

# Declare dependencies with options
FetchContent_Declare(
    spdlog
    GIT_REPOSITORY https://github.com/gabime/spdlog.git
    GIT_TAG v1.11.0
    GIT_SHALLOW TRUE
    GIT_PROGRESS TRUE
    FIND_PACKAGE_ARGS NAMES spdlog
)

FetchContent_Declare(
    simdjson
    GIT_REPOSITORY https://github.com/simdjson/simdjson.git
    GIT_TAG v3.2.0
    GIT_SHALLOW TRUE
    FIND_PACKAGE_ARGS NAMES simdjson
)

# Try find_package first, fall back to FetchContent
FetchContent_MakeAvailable(spdlog simdjson)

# Configure fetched content
if(spdlog_POPULATED)
    set(SPDLOG_BUILD_EXAMPLE OFF CACHE BOOL "" FORCE)
    set(SPDLOG_BUILD_TESTS OFF CACHE BOOL "" FORCE)
endif()

if(simdjson_POPULATED)
    set(SIMDJSON_BUILD_STATIC ON CACHE BOOL "" FORCE)
    set(SIMDJSON_JUST_LIBRARY ON CACHE BOOL "" FORCE)
endif()
```

5.2 DEPENDENCY VERSIONING
--------------------------

Tracking dependency versions:

cmake/DependencyVersions.cmake:

```cmake
# Pin dependency versions
set(SPDLOG_VERSION "v1.11.0")
set(SIMDJSON_VERSION "v3.2.0")
set(GOOGLETEST_VERSION "release-1.12.1")
set(BENCHMARK_VERSION "v1.7.1")
set(BOOST_VERSION "1.81.0")
set(FMT_VERSION "9.1.0")

# Export versions for logging
message(STATUS "Dependency Versions:")
message(STATUS "  spdlog: ${SPDLOG_VERSION}")
message(STATUS "  simdjson: ${SIMDJSON_VERSION}")
message(STATUS "  googletest: ${GOOGLETEST_VERSION}")
message(STATUS "  benchmark: ${BENCHMARK_VERSION}")
message(STATUS "  boost: ${BOOST_VERSION}")
message(STATUS "  fmt: ${FMT_VERSION}")

# Generate version info file
configure_file(
    ${CMAKE_SOURCE_DIR}/cmake/version_info.h.in
    ${CMAKE_BINARY_DIR}/generated/version_info.h
)
```

cmake/version_info.h.in:

```cpp
#pragma once

namespace hft {
namespace build_info {

constexpr const char* spdlog_version = "@SPDLOG_VERSION@";
constexpr const char* simdjson_version = "@SIMDJSON_VERSION@";
constexpr const char* build_type = "@CMAKE_BUILD_TYPE@";
constexpr const char* compiler = "@CMAKE_CXX_COMPILER_ID@ @CMAKE_CXX_COMPILER_VERSION@";
constexpr const char* build_date = __DATE__ " " __TIME__;

}  // namespace build_info
}  // namespace hft
```

5.3 DEPENDENCY OVERRIDE SYSTEM
-------------------------------

Allow overriding dependency sources:

```cmake
# Allow users to specify custom dependency paths
set(SPDLOG_ROOT "" CACHE PATH "Custom spdlog installation path")
set(SIMDJSON_ROOT "" CACHE PATH "Custom simdjson installation path")

# Try custom paths first
if(SPDLOG_ROOT)
    list(PREPEND CMAKE_PREFIX_PATH ${SPDLOG_ROOT})
endif()

if(SIMDJSON_ROOT)
    list(PREPEND CMAKE_PREFIX_PATH ${SIMDJSON_ROOT})
endif()

# Try system installation
find_package(spdlog QUIET)
find_package(simdjson QUIET)

# Fall back to FetchContent if not found
if(NOT spdlog_FOUND)
    message(STATUS "spdlog not found, using FetchContent")
    FetchContent_Declare(spdlog
        GIT_REPOSITORY https://github.com/gabime/spdlog.git
        GIT_TAG v1.11.0
    )
    FetchContent_MakeAvailable(spdlog)
endif()

if(NOT simdjson_FOUND)
    message(STATUS "simdjson not found, using FetchContent")
    FetchContent_Declare(simdjson
        GIT_REPOSITORY https://github.com/simdjson/simdjson.git
        GIT_TAG v3.2.0
    )
    FetchContent_MakeAvailable(simdjson)
endif()
```

Usage:

```bash
# Use system packages
cmake ..

# Use custom spdlog
cmake -DSPDLOG_ROOT=/opt/custom/spdlog ..

# Use custom simdjson
cmake -DSIMDJSON_ROOT=/opt/custom/simdjson ..
```

================================================================================
SECTION 6: ADVANCED TECHNIQUES
================================================================================

6.1 PRECOMPILED HEADERS
------------------------

Speed up compilation:

```cmake
# Enable precompiled headers (requires CMake 3.16+)
target_precompile_headers(trading_engine
    PRIVATE
        <iostream>
        <string>
        <vector>
        <memory>
        <algorithm>
        <chrono>
        <thread>
        <mutex>
        <condition_variable>
        <atomic>
        <optional>
        <variant>
        <boost/asio.hpp>
        <spdlog/spdlog.h>
)

# Reuse precompiled headers across targets
target_precompile_headers(market_data_handler
    REUSE_FROM trading_engine
)
```

6.2 UNITY BUILDS
-----------------

Reduce compilation time:

```cmake
# Enable unity builds globally
set(CMAKE_UNITY_BUILD ON)
set(CMAKE_UNITY_BUILD_BATCH_SIZE 16)

# Or per-target
add_executable(trading_engine ${SOURCES})
set_target_properties(trading_engine PROPERTIES
    UNITY_BUILD ON
    UNITY_BUILD_BATCH_SIZE 16
)

# Exclude specific files from unity build
set_source_files_properties(
    main.cpp
    PROPERTIES SKIP_UNITY_BUILD_INCLUSION ON
)
```

6.3 CCACHE INTEGRATION
-----------------------

Cache compilation results:

```cmake
find_program(CCACHE_PROGRAM ccache)
if(CCACHE_PROGRAM)
    message(STATUS "Found ccache: ${CCACHE_PROGRAM}")
    set(CMAKE_CXX_COMPILER_LAUNCHER "${CCACHE_PROGRAM}")
    set(CMAKE_C_COMPILER_LAUNCHER "${CCACHE_PROGRAM}")

    # Configure ccache
    set(ENV{CCACHE_SLOPPINESS} "pch_defines,time_macros")
    set(ENV{CCACHE_MAXSIZE} "5G")
else()
    message(STATUS "ccache not found")
endif()
```

6.4 NINJA GENERATOR
-------------------

Use Ninja for faster builds:

```bash
# Install Ninja
sudo apt-get install ninja-build

# Use Ninja generator
cmake -G Ninja -B build

# Build with Ninja
cmake --build build
```

CMakeLists.txt configuration for Ninja:

```cmake
# Prefer Ninja if available
find_program(NINJA_EXECUTABLE ninja)
if(NINJA_EXECUTABLE)
    set(CMAKE_GENERATOR "Ninja" CACHE INTERNAL "")
    message(STATUS "Using Ninja generator")
endif()

# Ninja-specific optimizations
if(CMAKE_GENERATOR STREQUAL "Ninja")
    # Use response files for long command lines
    set(CMAKE_NINJA_FORCE_RESPONSE_FILE ON)

    # Parallel linking
    set_property(GLOBAL PROPERTY JOB_POOLS link_pool=4)
    set(CMAKE_JOB_POOL_LINK link_pool)
endif()
```

================================================================================
SECTION 7: TROUBLESHOOTING ADVANCED BUILDS
================================================================================

7.1 DEBUGGING TOOLCHAIN FILES
------------------------------

```cmake
# Add to toolchain file for debugging
message(STATUS "=== Toolchain Information ===")
message(STATUS "System: ${CMAKE_SYSTEM_NAME}")
message(STATUS "Processor: ${CMAKE_SYSTEM_PROCESSOR}")
message(STATUS "C Compiler: ${CMAKE_C_COMPILER}")
message(STATUS "CXX Compiler: ${CMAKE_CXX_COMPILER}")
message(STATUS "Sysroot: ${CMAKE_SYSROOT}")
message(STATUS "Find root path: ${CMAKE_FIND_ROOT_PATH}")
message(STATUS "============================")

# Test compiler
try_compile(COMPILER_WORKS
    ${CMAKE_BINARY_DIR}/test
    ${CMAKE_SOURCE_DIR}/cmake/test_compiler.cpp
    OUTPUT_VARIABLE COMPILE_OUTPUT
)

if(NOT COMPILER_WORKS)
    message(FATAL_ERROR "Compiler test failed:\n${COMPILE_OUTPUT}")
endif()
```

7.2 EXTERNALPROJECT DEBUGGING
------------------------------

```bash
# Enable verbose logging
cmake -DCMAKE_VERBOSE_MAKEFILE=ON ..

# Check external project status
cmake --build . --target help

# Rebuild specific external project
cmake --build . --target spdlog_external-rebuild

# Clean and rebuild
cmake --build . --target spdlog_external-clean
cmake --build . --target spdlog_external
```

7.3 CROSS-COMPILATION ISSUES
-----------------------------

Common problems and solutions:

```cmake
# Issue: Can't find libraries in sysroot
# Solution: Verify CMAKE_FIND_ROOT_PATH
message(STATUS "Find root path: ${CMAKE_FIND_ROOT_PATH}")
message(STATUS "Prefix path: ${CMAKE_PREFIX_PATH}")

# Issue: Wrong architecture binaries
# Solution: Verify compiler output
execute_process(
    COMMAND ${CMAKE_CXX_COMPILER} -dumpmachine
    OUTPUT_VARIABLE COMPILER_TARGET
    OUTPUT_STRIP_TRAILING_WHITESPACE
)
message(STATUS "Compiler target: ${COMPILER_TARGET}")

# Issue: Missing cross-compiled dependencies
# Solution: Build dependencies separately
include(ExternalProject)
# ... build dependencies for target architecture
```

================================================================================
SECTION 8: PRODUCTION BUILD SCRIPTS
================================================================================

8.1 AUTOMATED BUILD SCRIPT
---------------------------

scripts/build_all_configs.sh:

```bash
#!/bin/bash
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
BUILD_ROOT="${PROJECT_ROOT}/builds"

echo "Building all configurations..."

# Debug build
echo "=== Debug Build ==="
cmake -S "${PROJECT_ROOT}" \
      -B "${BUILD_ROOT}/debug" \
      -DCMAKE_BUILD_TYPE=Debug \
      -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
cmake --build "${BUILD_ROOT}/debug" -j$(nproc)

# Release build
echo "=== Release Build ==="
cmake -S "${PROJECT_ROOT}" \
      -B "${BUILD_ROOT}/release" \
      -DCMAKE_BUILD_TYPE=Release
cmake --build "${BUILD_ROOT}/release" -j$(nproc)

# ASan build
echo "=== AddressSanitizer Build ==="
cmake -S "${PROJECT_ROOT}" \
      -B "${BUILD_ROOT}/asan" \
      -DCMAKE_TOOLCHAIN_FILE="${PROJECT_ROOT}/cmake/toolchains/asan.cmake"
cmake --build "${BUILD_ROOT}/asan" -j$(nproc)

# Production build
echo "=== Production Build ==="
cmake -S "${PROJECT_ROOT}" \
      -B "${BUILD_ROOT}/production" \
      -DCMAKE_TOOLCHAIN_FILE="${PROJECT_ROOT}/cmake/toolchains/production.cmake" \
      -DCMAKE_INSTALL_PREFIX="/opt/hft"
cmake --build "${BUILD_ROOT}/production" -j$(nproc)

echo "All builds completed successfully"
```

8.2 CROSS-COMPILATION BUILD SCRIPT
-----------------------------------

scripts/cross_build.sh:

```bash
#!/bin/bash
set -euo pipefail

usage() {
    echo "Usage: $0 [zen3|icelake|arm64]"
    exit 1
}

if [ $# -ne 1 ]; then
    usage
fi

ARCH="$1"
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
BUILD_DIR="${PROJECT_ROOT}/build-${ARCH}"

case "${ARCH}" in
    zen3)
        TOOLCHAIN="amd64-zen3.cmake"
        ;;
    icelake)
        TOOLCHAIN="amd64-icelake.cmake"
        ;;
    arm64)
        TOOLCHAIN="aarch64-linux.cmake"
        ;;
    *)
        echo "Unknown architecture: ${ARCH}"
        usage
        ;;
esac

echo "Building for ${ARCH} using ${TOOLCHAIN}"

cmake -S "${PROJECT_ROOT}" \
      -B "${BUILD_DIR}" \
      -DCMAKE_TOOLCHAIN_FILE="${PROJECT_ROOT}/cmake/toolchains/${TOOLCHAIN}" \
      -DCMAKE_BUILD_TYPE=Release

cmake --build "${BUILD_DIR}" -j$(nproc)

echo "Build completed: ${BUILD_DIR}/bin/trading_engine"
```

================================================================================
BEST PRACTICES
================================================================================

1. Always use toolchain files for cross-compilation
2. Pin dependency versions for reproducible builds
3. Use ExternalProject for complex third-party libraries
4. Enable LTO for production builds
5. Use ccache to speed up recompilation
6. Prefer Ninja generator for faster builds
7. Implement superbuild pattern for large projects
8. Test builds with sanitizers regularly
9. Document all custom toolchain files
10. Automate builds with scripts

================================================================================
Last Updated: 2025-11-25
Version: 1.0.0
