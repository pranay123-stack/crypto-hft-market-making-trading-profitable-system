================================================================================
BUILD TYPES FOR HFT SYSTEMS
================================================================================

OVERVIEW
--------
Different build configurations serve different purposes in HFT development.
Debug builds enable development and troubleshooting, Release builds maximize
performance for production, and specialized builds support profiling, testing,
and analysis. This guide covers all build types and their appropriate usage.

================================================================================
SECTION 1: STANDARD BUILD TYPES
================================================================================

1.1 DEBUG BUILD
---------------

Purpose: Development, debugging, testing
Performance: Slow (no optimizations)
Binary size: Large (includes debug symbols)
Use cases: Active development, debugging crashes, memory issues

CMake configuration:

```cmake
# Debug build settings
set(CMAKE_BUILD_TYPE Debug)

set(CMAKE_CXX_FLAGS_DEBUG
    "-g -O0 -DDEBUG -D_DEBUG"
    CACHE STRING "Debug flags" FORCE
)

# Enhanced debug information
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g3 -ggdb")

# No optimization, better debugging
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -fno-inline -fno-omit-frame-pointer")

# Runtime checks
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC")
```

Command line:

```bash
# Configure debug build
cmake -DCMAKE_BUILD_TYPE=Debug -B build-debug

# Build
cmake --build build-debug

# Run with debugger
gdb ./build-debug/bin/trading_engine

# Or lldb
lldb ./build-debug/bin/trading_engine
```

Debug-specific code:

```cpp
#ifdef DEBUG
    #include <cassert>
    #define LOG_DEBUG(msg) std::cout << "[DEBUG] " << msg << std::endl
    #define ASSERT(condition) assert(condition)
#else
    #define LOG_DEBUG(msg)
    #define ASSERT(condition)
#endif

void process_order(const Order& order) {
    ASSERT(order.price > 0);
    ASSERT(order.quantity > 0);
    LOG_DEBUG("Processing order: " << order.id);

    // Implementation
}
```

1.2 RELEASE BUILD
-----------------

Purpose: Production deployment
Performance: Maximum (aggressive optimizations)
Binary size: Medium (symbols stripped)
Use cases: Production trading, live markets

CMake configuration:

```cmake
set(CMAKE_BUILD_TYPE Release)

set(CMAKE_CXX_FLAGS_RELEASE
    "-O3 -DNDEBUG"
    CACHE STRING "Release flags" FORCE
)

# Architecture-specific optimizations
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -march=native -mtune=native")

# Link-time optimization
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -flto")

# Additional performance flags
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -ffast-math -funroll-loops")

# Strip symbols in linker
set(CMAKE_EXE_LINKER_FLAGS_RELEASE "-Wl,-s")

# Enable interprocedural optimization
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE TRUE)
```

Command line:

```bash
# Configure release build
cmake -DCMAKE_BUILD_TYPE=Release -B build-release

# Build with maximum parallelism
cmake --build build-release -j$(nproc)

# Strip additional symbols
strip --strip-all build-release/bin/trading_engine

# Verify optimizations
objdump -d build-release/bin/trading_engine | head -100
```

Production optimizations:

```cpp
// Compile-time optimizations
#ifdef NDEBUG
    #define FORCE_INLINE __attribute__((always_inline)) inline
    #define NO_INLINE __attribute__((noinline))
    #define LIKELY(x) __builtin_expect(!!(x), 1)
    #define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
    #define FORCE_INLINE inline
    #define NO_INLINE
    #define LIKELY(x) (x)
    #define UNLIKELY(x) (x)
#endif

// Hot path optimization
FORCE_INLINE void process_tick(const MarketData& tick) {
    if (LIKELY(tick.is_valid())) {
        update_order_book(tick);
    } else {
        UNLIKELY_PATH handle_invalid_tick(tick);
    }
}
```

1.3 RELWITHDEBINFO BUILD
------------------------

Purpose: Production debugging, post-mortem analysis
Performance: High (optimized but with debug symbols)
Binary size: Large (optimized code + symbols)
Use cases: Investigating production issues, profiling

CMake configuration:

```cmake
set(CMAKE_BUILD_TYPE RelWithDebInfo)

set(CMAKE_CXX_FLAGS_RELWITHDEBINFO
    "-O2 -g -DNDEBUG"
    CACHE STRING "RelWithDebInfo flags" FORCE
)

# Keep frame pointers for profiling
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -fno-omit-frame-pointer")

# Moderate optimization for better debugging
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -march=native")

# Optional: Split debug info
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -gsplit-dwarf")
```

Command line:

```bash
# Build RelWithDebInfo
cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -B build-relwithdebinfo
cmake --build build-relwithdebinfo -j$(nproc)

# Split debug symbols for deployment
objcopy --only-keep-debug build-relwithdebinfo/bin/trading_engine trading_engine.debug
objcopy --strip-debug build-relwithdebinfo/bin/trading_engine
objcopy --add-gnu-debuglink=trading_engine.debug build-relwithdebinfo/bin/trading_engine

# Deploy binary without symbols
cp build-relwithdebinfo/bin/trading_engine /opt/hft/bin/

# Keep symbols for debugging
cp trading_engine.debug /opt/hft/debug/
```

Usage in production debugging:

```bash
# Run with debug symbols
gdb --symbol=/opt/hft/debug/trading_engine.debug /opt/hft/bin/trading_engine

# Attach to running process
sudo gdb -p $(pgrep trading_engine) --symbol=/opt/hft/debug/trading_engine.debug

# Analyze core dump
gdb --symbol=/opt/hft/debug/trading_engine.debug /opt/hft/bin/trading_engine core.12345
```

1.4 MINSIZEREL BUILD
--------------------

Purpose: Size-constrained deployments
Performance: Moderate (optimized for size)
Binary size: Smallest
Use cases: Embedded systems, firmware, limited storage

CMake configuration:

```cmake
set(CMAKE_BUILD_TYPE MinSizeRel)

set(CMAKE_CXX_FLAGS_MINSIZEREL
    "-Os -DNDEBUG"
    CACHE STRING "MinSizeRel flags" FORCE
)

# Additional size optimizations
set(CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL} -ffunction-sections -fdata-sections")
set(CMAKE_EXE_LINKER_FLAGS_MINSIZEREL "-Wl,--gc-sections")

# Strip everything
set(CMAKE_EXE_LINKER_FLAGS_MINSIZEREL "${CMAKE_EXE_LINKER_FLAGS_MINSIZEREL} -Wl,-s")
```

Command line:

```bash
# Build for minimum size
cmake -DCMAKE_BUILD_TYPE=MinSizeRel -B build-minsizerel
cmake --build build-minsizerel -j$(nproc)

# Further size reduction with UPX
upx --best --lzma build-minsizerel/bin/trading_engine

# Compare sizes
ls -lh build-*/bin/trading_engine
```

================================================================================
SECTION 2: SPECIALIZED BUILD TYPES
================================================================================

2.1 PROFILING BUILD
-------------------

Purpose: Performance analysis, hotspot identification
Tools: gprof, perf, valgrind

CMake configuration:

```cmake
# Create custom Profiling build type
set(CMAKE_CXX_FLAGS_PROFILING
    "-O2 -g -pg -fno-omit-frame-pointer"
    CACHE STRING "Profiling flags" FORCE
)

set(CMAKE_EXE_LINKER_FLAGS_PROFILING
    "-pg"
    CACHE STRING "Profiling linker flags" FORCE
)

# Add to configuration types
set(CMAKE_CONFIGURATION_TYPES "Debug;Release;RelWithDebInfo;MinSizeRel;Profiling")
```

gprof profiling:

```bash
# Build with profiling
cmake -DCMAKE_BUILD_TYPE=Profiling -B build-profiling
cmake --build build-profiling

# Run to generate profile data
./build-profiling/bin/trading_engine --duration 60

# Analyze profile
gprof build-profiling/bin/trading_engine gmon.out > profile.txt

# View top functions
gprof build-profiling/bin/trading_engine gmon.out | head -50
```

perf profiling (preferred for HFT):

```cmake
# Profiling build for perf
set(CMAKE_CXX_FLAGS_PROFILING
    "-O3 -g -fno-omit-frame-pointer -march=native"
    CACHE STRING "Profiling flags" FORCE
)
```

```bash
# Build
cmake -DCMAKE_BUILD_TYPE=Profiling -B build-profiling
cmake --build build-profiling

# Record profile
perf record -g --call-graph dwarf -F 999 ./build-profiling/bin/trading_engine

# View results
perf report -g

# Detailed statistics
perf stat -e cycles,instructions,cache-references,cache-misses,branches,branch-misses \
    ./build-profiling/bin/trading_engine

# Generate flamegraph
perf script | stackcollapse-perf.pl | flamegraph.pl > flamegraph.svg
```

2.2 SANITIZER BUILDS
--------------------

AddressSanitizer (ASan) build:

```cmake
set(CMAKE_CXX_FLAGS_ASAN
    "-O1 -g -fsanitize=address -fno-omit-frame-pointer"
    CACHE STRING "ASan flags" FORCE
)

set(CMAKE_EXE_LINKER_FLAGS_ASAN
    "-fsanitize=address"
    CACHE STRING "ASan linker flags" FORCE
)
```

```bash
# Build with ASan
cmake -DCMAKE_BUILD_TYPE=Asan -B build-asan
cmake --build build-asan

# Run with ASan options
ASAN_OPTIONS=detect_leaks=1:check_initialization_order=1:strict_init_order=1 \
    ./build-asan/bin/trading_engine
```

ThreadSanitizer (TSan) build:

```cmake
set(CMAKE_CXX_FLAGS_TSAN
    "-O1 -g -fsanitize=thread -fno-omit-frame-pointer"
    CACHE STRING "TSan flags" FORCE
)

set(CMAKE_EXE_LINKER_FLAGS_TSAN
    "-fsanitize=thread"
    CACHE STRING "TSan linker flags" FORCE
)
```

```bash
# Build with TSan
cmake -DCMAKE_BUILD_TYPE=Tsan -B build-tsan
cmake --build build-tsan

# Run with TSan
TSAN_OPTIONS=second_deadlock_stack=1:history_size=7 \
    ./build-tsan/bin/trading_engine
```

UndefinedBehaviorSanitizer (UBSan) build:

```cmake
set(CMAKE_CXX_FLAGS_UBSAN
    "-O1 -g -fsanitize=undefined -fno-omit-frame-pointer"
    CACHE STRING "UBSan flags" FORCE
)

set(CMAKE_EXE_LINKER_FLAGS_UBSAN
    "-fsanitize=undefined"
    CACHE STRING "UBSan linker flags" FORCE
)
```

2.3 COVERAGE BUILD
------------------

Purpose: Code coverage analysis, test effectiveness

```cmake
set(CMAKE_CXX_FLAGS_COVERAGE
    "-O0 -g --coverage -fprofile-arcs -ftest-coverage"
    CACHE STRING "Coverage flags" FORCE
)

set(CMAKE_EXE_LINKER_FLAGS_COVERAGE
    "--coverage"
    CACHE STRING "Coverage linker flags" FORCE
)
```

```bash
# Build with coverage
cmake -DCMAKE_BUILD_TYPE=Coverage -B build-coverage
cmake --build build-coverage

# Run tests
cd build-coverage
ctest

# Generate coverage report
gcov src/*.cpp
lcov --capture --directory . --output-file coverage.info
genhtml coverage.info --output-directory coverage_html

# View coverage
firefox coverage_html/index.html

# Clean coverage data
find . -name "*.gcda" -delete
```

2.4 BENCHMARK BUILD
-------------------

Purpose: Performance benchmarking, optimization validation

```cmake
set(CMAKE_CXX_FLAGS_BENCHMARK
    "-O3 -march=native -mtune=native -fno-omit-frame-pointer -DBENCHMARK_MODE"
    CACHE STRING "Benchmark flags" FORCE
)

# Disable some optimizations for consistent timing
set(CMAKE_CXX_FLAGS_BENCHMARK "${CMAKE_CXX_FLAGS_BENCHMARK} -fno-inline-small-functions")
```

```bash
# Build benchmark configuration
cmake -DCMAKE_BUILD_TYPE=Benchmark -B build-benchmark
cmake --build build-benchmark

# Run benchmarks
./build-benchmark/bin/trading_engine --benchmark

# With Google Benchmark
./build-benchmark/bin/hft_benchmarks --benchmark_format=json > results.json
```

================================================================================
SECTION 3: MULTI-CONFIGURATION BUILDS
================================================================================

3.1 NINJA MULTI-CONFIG
----------------------

Build all configurations in one directory:

```bash
# Configure with Ninja Multi-Config
cmake -G "Ninja Multi-Config" -B build-multi

# Build specific configurations
cmake --build build-multi --config Debug
cmake --build build-multi --config Release
cmake --build build-multi --config RelWithDebInfo

# All configurations
cmake --build build-multi --config Debug
cmake --build build-multi --config Release

# Binaries in separate directories
ls build-multi/Debug/bin/
ls build-multi/Release/bin/
```

3.2 PARALLEL CONFIGURATION BUILDS
----------------------------------

Build script for all configurations:

```bash
#!/bin/bash
# build_all_configs.sh

set -euo pipefail

PROJECT_ROOT="$(pwd)"
BUILD_ROOT="${PROJECT_ROOT}/builds"

CONFIGS=("Debug" "Release" "RelWithDebInfo" "Profiling" "Asan")

for config in "${CONFIGS[@]}"; do
    echo "=== Building $config ==="

    BUILD_DIR="${BUILD_ROOT}/${config,,}"

    cmake -DCMAKE_BUILD_TYPE="$config" \
          -B "$BUILD_DIR" \
          -S "$PROJECT_ROOT"

    cmake --build "$BUILD_DIR" -j$(nproc)

    echo "✓ $config build complete"
done

echo ""
echo "=== Build Summary ==="
for config in "${CONFIGS[@]}"; do
    BUILD_DIR="${BUILD_ROOT}/${config,,}"
    if [ -f "$BUILD_DIR/bin/trading_engine" ]; then
        SIZE=$(du -h "$BUILD_DIR/bin/trading_engine" | cut -f1)
        echo "$config: $SIZE"
    fi
done
```

================================================================================
SECTION 4: CONDITIONAL COMPILATION
================================================================================

4.1 BUILD-TYPE SPECIFIC CODE
-----------------------------

```cpp
// config.h
#pragma once

// Debug mode
#ifdef DEBUG
    #define ENABLE_LOGGING 1
    #define ENABLE_ASSERTIONS 1
    #define ENABLE_VALIDATION 1
    #define LOG_LEVEL TRACE
#else
    #define ENABLE_LOGGING 0
    #define ENABLE_ASSERTIONS 0
    #define ENABLE_VALIDATION 0
    #define LOG_LEVEL ERROR
#endif

// Release mode
#ifdef NDEBUG
    #define ENABLE_OPTIMIZATIONS 1
    #define INLINE_THRESHOLD 1000
    #define PREFETCH_ENABLED 1
#else
    #define ENABLE_OPTIMIZATIONS 0
    #define INLINE_THRESHOLD 100
    #define PREFETCH_ENABLED 0
#endif

// Profiling mode
#ifdef PROFILING_MODE
    #define ENABLE_PERF_COUNTERS 1
    #define ENABLE_TIMING_STATS 1
#else
    #define ENABLE_PERF_COUNTERS 0
    #define ENABLE_TIMING_STATS 0
#endif

// Benchmark mode
#ifdef BENCHMARK_MODE
    #define ITERATIONS 1000000
    #define WARMUP_ITERATIONS 1000
#else
    #define ITERATIONS 100
    #define WARMUP_ITERATIONS 10
#endif
```

Usage:

```cpp
#include "config.h"

void process_order(const Order& order) {
    #if ENABLE_VALIDATION
    if (!order.is_valid()) {
        throw std::invalid_argument("Invalid order");
    }
    #endif

    #if ENABLE_LOGGING
    LOG_DEBUG("Processing order: " << order.id);
    #endif

    // Process order

    #if ENABLE_PERF_COUNTERS
    perf_counter.increment("orders_processed");
    #endif
}
```

4.2 FEATURE FLAGS
-----------------

CMake feature configuration:

```cmake
# Feature options
option(ENABLE_LIVE_TRADING "Enable live trading mode" ON)
option(ENABLE_BACKTESTING "Enable backtesting mode" ON)
option(ENABLE_MARKET_DATA "Enable market data recording" ON)
option(ENABLE_RISK_CHECKS "Enable risk management checks" ON)
option(USE_HARDWARE_TIMESTAMPS "Use hardware timestamping" OFF)

# Configure features based on build type
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    set(ENABLE_VALIDATION ON)
    set(ENABLE_ASSERTIONS ON)
elseif(CMAKE_BUILD_TYPE STREQUAL "Release")
    set(ENABLE_VALIDATION OFF)
    set(ENABLE_ASSERTIONS OFF)
endif()

# Generate config header
configure_file(
    ${CMAKE_SOURCE_DIR}/include/build_config.h.in
    ${CMAKE_BINARY_DIR}/generated/build_config.h
)
```

build_config.h.in:

```cpp
#pragma once

// Build type
#define BUILD_TYPE "@CMAKE_BUILD_TYPE@"

// Features
#cmakedefine ENABLE_LIVE_TRADING
#cmakedefine ENABLE_BACKTESTING
#cmakedefine ENABLE_MARKET_DATA
#cmakedefine ENABLE_RISK_CHECKS
#cmakedefine USE_HARDWARE_TIMESTAMPS

// Validation
#cmakedefine ENABLE_VALIDATION
#cmakedefine ENABLE_ASSERTIONS

// Version info
#define VERSION_MAJOR @PROJECT_VERSION_MAJOR@
#define VERSION_MINOR @PROJECT_VERSION_MINOR@
#define VERSION_PATCH @PROJECT_VERSION_PATCH@
```

================================================================================
SECTION 5: BUILD PERFORMANCE OPTIMIZATION
================================================================================

5.1 CCACHE INTEGRATION
----------------------

```cmake
# Enable ccache
find_program(CCACHE_PROGRAM ccache)
if(CCACHE_PROGRAM)
    message(STATUS "Found ccache: ${CCACHE_PROGRAM}")
    set(CMAKE_CXX_COMPILER_LAUNCHER "${CCACHE_PROGRAM}")
    set(CMAKE_C_COMPILER_LAUNCHER "${CCACHE_PROGRAM}")
endif()
```

```bash
# Install ccache
sudo apt-get install ccache

# Configure ccache
ccache --max-size=10G
ccache --set-config=compression=true
ccache --set-config=compression_level=6

# Statistics
ccache -s

# Clear cache
ccache -C
```

5.2 PRECOMPILED HEADERS
-----------------------

```cmake
# Enable precompiled headers
target_precompile_headers(trading_engine PRIVATE
    <iostream>
    <string>
    <vector>
    <memory>
    <algorithm>
    <thread>
    <mutex>
    <atomic>
    <chrono>
    <boost/asio.hpp>
)

# Reuse across targets
target_precompile_headers(market_data_handler REUSE_FROM trading_engine)
```

5.3 UNITY BUILDS
----------------

```cmake
# Enable unity builds
set(CMAKE_UNITY_BUILD ON)
set(CMAKE_UNITY_BUILD_BATCH_SIZE 16)

# Or per-target
set_target_properties(trading_engine PROPERTIES
    UNITY_BUILD ON
    UNITY_BUILD_BATCH_SIZE 16
)
```

5.4 PARALLEL BUILDS
-------------------

```bash
# Ninja (recommended)
cmake -G Ninja -B build
cmake --build build

# Make with parallelism
cmake -B build
cmake --build build -j$(nproc)

# Limit parallel jobs (for low memory)
cmake --build build -j4
```

================================================================================
SECTION 6: BUILD VERIFICATION
================================================================================

6.1 POST-BUILD CHECKS
----------------------

```bash
#!/bin/bash
# verify_build.sh

BINARY="$1"

echo "=== Build Verification ==="

# Check binary exists
if [ ! -f "$BINARY" ]; then
    echo "❌ Binary not found: $BINARY"
    exit 1
fi

# Check binary type
echo "Binary type:"
file "$BINARY"

# Check dependencies
echo ""
echo "Dependencies:"
ldd "$BINARY"

# Check symbols
echo ""
echo "Symbol table size:"
readelf -s "$BINARY" | wc -l

# Check optimization level (heuristic)
echo ""
echo "Optimization check:"
if objdump -d "$BINARY" | grep -q "vmovups\|vaddps"; then
    echo "✓ SIMD instructions found (vectorized)"
else
    echo "⚠ No SIMD instructions detected"
fi

# Check size
echo ""
echo "Binary size:"
du -h "$BINARY"

# Check RPATH
echo ""
echo "RPATH:"
readelf -d "$BINARY" | grep -E "RPATH|RUNPATH"

echo ""
echo "✓ Build verification complete"
```

6.2 PERFORMANCE SMOKE TEST
---------------------------

```bash
#!/bin/bash
# smoke_test.sh

BUILD_TYPE="$1"
BINARY="./builds/${BUILD_TYPE,,}/bin/trading_engine"

echo "=== Smoke Test: $BUILD_TYPE ==="

# Quick functional test
timeout 10 "$BINARY" --test || echo "Functional test completed"

# Performance test
echo ""
echo "Performance test:"
time "$BINARY" --benchmark --iterations=100000

# Memory usage
echo ""
echo "Memory usage:"
/usr/bin/time -v "$BINARY" --benchmark --iterations=10000 2>&1 | grep -E "Maximum resident"

echo ""
echo "✓ Smoke test complete"
```

================================================================================
SECTION 7: BUILD COMPARISON
================================================================================

7.1 COMPARING BUILD CONFIGURATIONS
-----------------------------------

```bash
#!/bin/bash
# compare_builds.sh

echo "=== Build Comparison ==="
echo ""

printf "%-20s %-15s %-15s %-20s\n" "Configuration" "Size" "Compile Time" "Runtime (1M ops)"

for config in Debug Release RelWithDebInfo Profiling; do
    BUILD_DIR="builds/${config,,}"
    BINARY="$BUILD_DIR/bin/trading_engine"

    if [ -f "$BINARY" ]; then
        SIZE=$(du -h "$BINARY" | cut -f1)

        # Measure compile time (rebuild)
        COMPILE_START=$(date +%s)
        cmake --build "$BUILD_DIR" --clean-first > /dev/null 2>&1
        COMPILE_END=$(date +%s)
        COMPILE_TIME=$((COMPILE_END - COMPILE_START))

        # Measure runtime
        RUNTIME=$( { time "$BINARY" --benchmark --iterations=1000000; } 2>&1 | grep real | awk '{print $2}' )

        printf "%-20s %-15s %-15ss %-20s\n" "$config" "$SIZE" "$COMPILE_TIME" "$RUNTIME"
    fi
done
```

7.2 PERFORMANCE COMPARISON
---------------------------

```bash
#!/bin/bash
# perf_compare.sh

echo "=== Performance Comparison ==="

for config in Release RelWithDebInfo Profiling; do
    BINARY="builds/${config,,}/bin/trading_engine"

    if [ -f "$BINARY" ]; then
        echo ""
        echo "=== $config ==="
        perf stat -e cycles,instructions,cache-misses,branch-misses \
            "$BINARY" --benchmark --iterations=100000 2>&1 | \
            grep -E "cycles|instructions|cache-misses|branch-misses|seconds"
    fi
done
```

================================================================================
SECTION 8: PRODUCTION BUILD CHECKLIST
================================================================================

Pre-deployment checklist:

```
[ ] Built with Release or RelWithDebInfo configuration
[ ] Compiler optimizations enabled (-O3 -march=native)
[ ] LTO enabled for maximum performance
[ ] Symbols stripped or split for production binary
[ ] All tests passing in release configuration
[ ] Sanitizer builds clean (no ASan/TSan/UBSan errors)
[ ] Performance benchmarks meet targets
[ ] Memory leaks checked with Valgrind
[ ] Binary dependencies verified (ldd)
[ ] RPATH correctly set for deployment location
[ ] Configuration files validated
[ ] Logging level appropriate for production
[ ] Debug symbols archived for post-mortem analysis
[ ] Version information embedded in binary
[ ] Build is reproducible (same hash from same source)
[ ] Binary size acceptable for deployment
```

================================================================================
BEST PRACTICES
================================================================================

1. Use Debug builds for development, Release for production
2. Keep RelWithDebInfo builds for production debugging
3. Run sanitizer builds regularly in CI/CD
4. Profile with Profiling builds, not Debug builds
5. Use ccache to speed up incremental builds
6. Enable LTO for production builds
7. Split debug symbols for production deployment
8. Verify optimizations with objdump
9. Benchmark before and after build changes
10. Keep build times under 5 minutes with parallelism

================================================================================
Last Updated: 2025-11-25
Version: 1.0.0
