================================================================================
                    HFT DEBUGGING - QUICK START GUIDE
================================================================================

EMERGENCY? JUMP TO THE RIGHT FILE IMMEDIATELY!
===============================================

Your Problem                         | Go To File
-------------------------------------|----------------------------------------
System crashed                       | 09_postmortem_debugging.txt
High latency spikes                  | 04_latency_debugging.txt
Memory leak                          | 02_memory_debugging.txt
Race condition / Crash under load    | 01_thread_debugging.txt
Packet loss                          | 03_network_debugging.txt
Poor performance                     | 05_performance_debugging.txt
Lock contention                      | 06_concurrency_debugging.txt
System interference                  | 07_system_debugging.txt
Production issue (live system)       | 08_live_debugging.txt
Need complete workflow               | 10_comprehensive_debugging_workflows.txt

================================================================================
FASTEST PATH TO DEBUGGING SUCCESS
================================================================================

Step 1: IDENTIFY THE SYMPTOM
   [ ] Crash / Segfault
   [ ] Latency spike
   [ ] Memory issue
   [ ] Network issue
   [ ] Performance degradation
   [ ] Thread issue

Step 2: OPEN THE RELEVANT FILE
   Read the "Step-by-Step Debugging Workflows" section

Step 3: RUN THE COMMANDS
   Copy-paste the debugging commands from the file

Step 4: ANALYZE THE OUTPUT
   Follow the interpretation guide in the file

Step 5: APPLY THE FIX
   Use the provided solutions and code examples

================================================================================
MOST COMMON HFT DEBUGGING SCENARIOS
================================================================================

SCENARIO 1: "My P99 latency suddenly jumped!"
----------------------------------------------
File: 04_latency_debugging.txt
Quick fix:
  1. Check CPU frequency: grep MHz /proc/cpuinfo
  2. If low: echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
  3. Profile: perf record -g -p $(pidof trading_engine) -- sleep 5

SCENARIO 2: "I'm losing multicast packets!"
--------------------------------------------
File: 03_network_debugging.txt
Quick fix:
  1. Check drops: netstat -su | grep -A 5 Udp
  2. Increase buffer: sudo sysctl -w net.core.rmem_max=134217728
  3. Verify: ethtool -S eth0 | grep drop

SCENARIO 3: "Process crashed, need core dump analysis"
-------------------------------------------------------
File: 09_postmortem_debugging.txt
Quick analysis:
  1. Load core: gdb ./trading_engine core.12345
  2. Get backtrace: (gdb) thread apply all bt
  3. Analyze: Look for SIGSEGV, use-after-free, etc.

SCENARIO 4: "Memory usage keeps growing"
-----------------------------------------
File: 02_memory_debugging.txt
Quick fix:
  1. Enable leak detection: ASAN_OPTIONS=detect_leaks=1 ./trading_engine
  2. Or Valgrind: valgrind --leak-check=full ./trading_engine
  3. Fix leaks from the stack traces

SCENARIO 5: "Getting random crashes under load"
------------------------------------------------
File: 01_thread_debugging.txt
Quick fix:
  1. Compile with TSan: g++ -g -fsanitize=thread program.cpp
  2. Run and wait for race detection
  3. Fix the data races reported

================================================================================
ONE-LINE DEBUGGING COMMANDS
================================================================================

# Quick Performance Check
perf stat -e cycles,instructions,cache-misses ./trading_engine

# Quick Memory Check
ASAN_OPTIONS=detect_leaks=1 ./trading_engine

# Quick Thread Check
valgrind --tool=helgrind ./trading_engine

# Quick Network Check
sudo tcpdump -i eth0 -c 100 port 12345

# Quick System Check
strace -c ./trading_engine

# Quick Latency Check
perf record -g -F 9999 ./trading_engine

# Quick Profile
perf record -g ./trading_engine && perf report --stdio

# Quick Core Analysis
gdb -batch -ex "bt" -ex "quit" ./trading_engine core.12345

================================================================================
ESSENTIAL SYSTEM TUNING (Copy-Paste This)
================================================================================

#!/bin/bash
# Save as: tune_hft_system.sh

# CPU Performance
echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
sudo cpupower idle-set -D 0
echo 1 | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo

# Network
sudo sysctl -w net.core.rmem_max=134217728
sudo sysctl -w net.core.wmem_max=134217728
sudo sysctl -w net.core.netdev_max_backlog=10000

# NIC
sudo ethtool -G eth0 rx 4096 tx 4096
sudo ethtool -C eth0 rx-usecs 0 tx-usecs 0

# IRQ Affinity (pin to CPU 0, trading on CPU 2+)
for IRQ in $(grep eth0 /proc/interrupts | awk -F: '{print $1}'); do
    echo 1 | sudo tee /proc/irq/$IRQ/smp_affinity_list
done

# Memory
ulimit -c unlimited
echo "/tmp/cores/core.%e.%p.%t" | sudo tee /proc/sys/kernel/core_pattern

echo "System tuned for HFT!"

================================================================================
ESSENTIAL C++ CODE TEMPLATE
================================================================================

```cpp
#include <sys/mman.h>
#include <sched.h>

class HFTOptimizer {
public:
    static void optimize() {
        // Lock memory
        mlockall(MCL_CURRENT | MCL_FUTURE);

        // Set realtime priority
        struct sched_param param = {.sched_priority = 99};
        sched_setscheduler(0, SCHED_FIFO, &param);

        // Pin to CPU 2
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        CPU_SET(2, &cpuset);
        pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);

        // Prefault stack
        char dummy[8*1024*1024];
        memset(dummy, 0, sizeof(dummy));
    }
};

int main() {
    HFTOptimizer::optimize();
    // Your trading code here
}
```

================================================================================
TOOLS AT A GLANCE
================================================================================

Memory:     AddressSanitizer (-fsanitize=address)
Threads:    ThreadSanitizer (-fsanitize=thread)
Profile:    perf record -g
Latency:    Use RDTSC (__rdtsc())
Network:    tcpdump, ethtool
System:     strace, perf sched
Live:       eBPF/bpftrace
Crash:      GDB + core dump

================================================================================
FILE SIZES AND WHAT'S IN THEM
================================================================================

00_README_INDEX.txt                     17K  Complete overview and index
01_thread_debugging.txt                 28K  Race conditions, deadlocks
02_memory_debugging.txt                 34K  Leaks, corruption, allocators
03_network_debugging.txt                38K  Packet loss, network issues
04_latency_debugging.txt                40K  Tail latency, jitter
05_performance_debugging.txt            33K  CPU, cache, optimization
06_concurrency_debugging.txt            20K  Lock-free, false sharing
07_system_debugging.txt                 20K  Kernel, IRQ, NUMA
08_live_debugging.txt                    7K  Production debugging
09_postmortem_debugging.txt              9K  Crash analysis
10_comprehensive_debugging_workflows    11K  Complete workflows

TOTAL: Nearly 10,000 lines of debugging knowledge!

================================================================================
REMEMBER
================================================================================

1. Always test in dev/staging first
2. Measure before and after changes
3. One change at a time
4. Document everything
5. Have a rollback plan

For complete information, start with: 00_README_INDEX.txt

================================================================================
GOOD LUCK!
================================================================================
