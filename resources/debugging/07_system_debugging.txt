================================================================================
                    HFT SYSTEM DEBUGGING GUIDE
================================================================================

TABLE OF CONTENTS
-----------------
1. Theory and Common System Issues in HFT
2. System Debugging Tools
3. Kernel Issues Detection
4. Interrupt and IRQ Debugging
5. Context Switch Analysis
6. Step-by-Step Debugging Workflows
7. Real HFT C++ Code Examples
8. Debugging Commands and Interpretation
9. Solutions and Fixes
10. Best Practices for HFT System Configuration

================================================================================
1. THEORY AND COMMON SYSTEM ISSUES IN HFT
================================================================================

SYSTEM-LEVEL BOTTLENECKS
-------------------------

A) KERNEL SCHEDULER
   - Context switches
   - CPU migrations
   - Priority inversions
   - Scheduler latency

B) INTERRUPTS
   - Hardware interrupts
   - IRQ affinity misconfigurations
   - Interrupt storms
   - Coalescing issues

C) SYSTEM CALLS
   - Expensive syscall overhead
   - Frequent syscalls in hot path
   - Blocking syscalls

D) CPU POWER MANAGEMENT
   - C-states (idle states)
   - P-states (frequency scaling)
   - Turbo boost variations

E) NUMA EFFECTS
   - Remote memory access
   - Cross-node allocations
   - Unbalanced NUMA placement

================================================================================
2. SYSTEM DEBUGGING TOOLS
================================================================================

FTRACE - KERNEL FUNCTION TRACER
--------------------------------

Enable function tracing:
```bash
cd /sys/kernel/debug/tracing
echo function > current_tracer
echo 1 > tracing_on
cat trace | head -50
```

Trace specific function:
```bash
echo schedule > set_ftrace_filter
cat trace
```

STRACE - SYSTEM CALL TRACER
----------------------------

```bash
# Trace all syscalls
strace -c ./trading_engine

# Trace specific syscalls
strace -e trace=read,write,send,recv ./trading_engine

# Attach to running process
strace -p $(pidof trading_engine) -e trace=all

# With timestamps
strace -tt -e trace=all ./trading_engine
```

PERF SCHED - SCHEDULER ANALYSIS
--------------------------------

```bash
# Record scheduler events
perf sched record ./trading_engine

# Show latencies
perf sched latency

# Show timeline
perf sched map

# Show statistics
perf sched timehist
```

IRQBALANCE
----------

```bash
# Check IRQ distribution
cat /proc/interrupts

# Disable irqbalance (for manual IRQ pinning)
sudo systemctl stop irqbalance
sudo systemctl disable irqbalance
```

NUMACTL - NUMA CONTROL
-----------------------

```bash
# Show NUMA topology
numactl --hardware

# Show process NUMA stats
numastat -p $(pidof trading_engine)

# Run on specific NUMA node
numactl --cpunodebind=0 --membind=0 ./trading_engine
```

================================================================================
3. KERNEL ISSUES DETECTION
================================================================================

CONTEXT SWITCH DETECTION
-------------------------

```bash
# Monitor context switches
perf stat -e context-switches,cs ./trading_engine

# Detailed context switch tracing
perf record -e sched:sched_switch -g ./trading_engine
perf script
```

High context switches indicate:
- Blocking I/O
- Lock contention
- Excessive thread creation
- Preemption issues

MEASURING SCHEDULER LATENCY
----------------------------

```bash
# cyclictest for real-time latency
sudo cyclictest -p 99 -t 1 -n -i 1000 -l 100000

# Output shows min/avg/max latency
```

DETECTING PAGE FAULTS
----------------------

```bash
# Count page faults
perf stat -e page-faults,minor-faults,major-faults ./trading_engine

# Major faults = disk I/O (very bad for HFT!)
```

Prevent page faults:
```cpp
#include <sys/mman.h>

void lock_memory() {
    // Lock all current and future memory
    if (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) {
        perror("mlockall failed");
    }
}

void prefault_stack() {
    // Touch all stack pages to fault them in
    const size_t stack_size = 8 * 1024 * 1024;  // 8MB
    char dummy[stack_size];
    memset(dummy, 0, sizeof(dummy));
}
```

CPU FREQUENCY MONITORING
-------------------------

```bash
# Monitor CPU frequency
watch -n 1 'grep MHz /proc/cpuinfo'

# Or with perf
perf stat -e 'power:cpu_frequency' -a -I 1000
```

Set performance governor:
```bash
echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
```

================================================================================
4. INTERRUPT AND IRQ DEBUGGING
================================================================================

VIEWING INTERRUPTS
------------------

```bash
# Show interrupt counts
cat /proc/interrupts

# Watch in real-time
watch -n 1 'cat /proc/interrupts | head -20'

# Per-CPU softirq stats
cat /proc/softirqs
```

IRQ AFFINITY CONFIGURATION
---------------------------

```bash
# Find network device IRQ
grep eth0 /proc/interrupts
# Output: 25: ... eth0-rx-0

# Show current affinity (bitmask)
cat /proc/irq/25/smp_affinity

# Set affinity to CPU 2
echo 4 | sudo tee /proc/irq/25/smp_affinity  # Binary 0100 = CPU 2

# Or use CPU list
echo 2 | sudo tee /proc/irq/25/smp_affinity_list
```

DETECTING INTERRUPT STORMS
---------------------------

```bash
# Script to detect interrupt storms
#!/bin/bash
prev=$(cat /proc/interrupts | grep eth0 | awk '{print $2}')
sleep 1
curr=$(cat /proc/interrupts | grep eth0 | awk '{print $2}')
rate=$((curr - prev))
echo "Interrupt rate: $rate/sec"

if [ $rate -gt 100000 ]; then
    echo "WARNING: Interrupt storm detected!"
fi
```

INTERRUPT COALESCING
---------------------

```bash
# Check coalescing settings
ethtool -c eth0

# Disable (for minimum latency)
sudo ethtool -C eth0 rx-usecs 0 rx-frames 1 tx-usecs 0 tx-frames 1

# Enable (for throughput)
sudo ethtool -C eth0 rx-usecs 50 rx-frames 32
```

================================================================================
5. CONTEXT SWITCH ANALYSIS
================================================================================

MEASURING CONTEXT SWITCHES
---------------------------

```bash
# Per-process context switches
grep ctxt /proc/$(pidof trading_engine)/status

# voluntary_ctxt_switches: Process yields CPU
# nonvoluntary_ctxt_switches: Process preempted
```

REDUCING CONTEXT SWITCHES
--------------------------

1. Use SCHED_FIFO:
```cpp
#include <sched.h>

void set_realtime_priority() {
    struct sched_param param;
    param.sched_priority = 99;  // Highest priority

    if (sched_setscheduler(0, SCHED_FIFO, &param) != 0) {
        perror("sched_setscheduler");
    }
}
```

2. CPU Isolation:
```bash
# Edit /etc/default/grub
GRUB_CMDLINE_LINUX="isolcpus=2,3,4,5 nohz_full=2,3,4,5 rcu_nocbs=2,3,4,5"

# Update and reboot
sudo update-grub
sudo reboot

# Run trading engine on isolated CPUs
taskset -c 2 ./trading_engine
```

3. Disable Timer Ticks:
```bash
# Add to kernel command line
nohz_full=2-7  # No timer ticks on these CPUs
```

MONITORING WITH PERF
---------------------

```bash
# Record context switches
perf record -e sched:sched_switch -g -a -- sleep 10

# Analyze
perf script | head -100

# Statistical view
perf sched latency
```

================================================================================
6. STEP-BY-STEP DEBUGGING WORKFLOWS
================================================================================

WORKFLOW 1: HIGH CONTEXT SWITCH INVESTIGATION
----------------------------------------------

Step 1: Measure Context Switches
```bash
perf stat -e context-switches ./trading_engine
```

Step 2: Identify Cause
```bash
strace -c ./trading_engine
# Look for blocking syscalls: futex, poll, select, read
```

Step 3: Profile Scheduler Events
```bash
perf record -e sched:sched_switch -g ./trading_engine
perf script | less
```

Step 4: Fix Based on Findings
- Blocking I/O → Use non-blocking or io_uring
- Lock contention → Use lock-free structures
- Too many threads → Reduce thread count
- Preemption → Use SCHED_FIFO, isolate CPUs

WORKFLOW 2: LATENCY SPIKE FROM SYSTEM
--------------------------------------

Step 1: Capture System Events During Spike
```bash
# Enable tracing
echo 1 > /sys/kernel/debug/tracing/events/sched/enable
echo 1 > /sys/kernel/debug/tracing/events/irq/enable

# Capture spike
# (Application detects spike and signals tracer)

# View trace
cat /sys/kernel/debug/tracing/trace > spike_trace.txt
```

Step 2: Analyze Trace
Look for:
- Unexpected context switches
- Interrupt handling
- Other processes interfering

Step 3: Correlate with Application Logs
Match timestamps to identify root cause

Step 4: Apply Fix
- IRQ affinity if interrupt on wrong CPU
- CPU isolation if other processes interfering
- Priority adjustment if preemption issue

================================================================================
7. REAL HFT C++ CODE EXAMPLES
================================================================================

EXAMPLE 1: SYSTEM CONFIGURATION AT STARTUP
-------------------------------------------

```cpp
#include <sys/mman.h>
#include <sched.h>
#include <numa.h>

class SystemOptimizer {
public:
    static bool optimize_for_hft() {
        bool success = true;

        // Lock memory
        if (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) {
            std::cerr << "Failed to lock memory\n";
            success = false;
        }

        // Prefault stack
        prefault_stack();

        // Set realtime priority
        if (!set_realtime_priority(99)) {
            std::cerr << "Failed to set realtime priority\n";
            success = false;
        }

        // Pin to CPU
        if (!pin_to_cpu(2)) {
            std::cerr << "Failed to pin to CPU\n";
            success = false;
        }

        // Set NUMA policy
        if (!set_numa_policy(0)) {
            std::cerr << "Failed to set NUMA policy\n";
            success = false;
        }

        return success;
    }

private:
    static void prefault_stack() {
        const size_t stack_size = 8 * 1024 * 1024;
        char dummy[stack_size];
        memset(dummy, 0, sizeof(dummy));
    }

    static bool set_realtime_priority(int priority) {
        struct sched_param param;
        param.sched_priority = priority;
        return sched_setscheduler(0, SCHED_FIFO, &param) == 0;
    }

    static bool pin_to_cpu(int cpu) {
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        CPU_SET(cpu, &cpuset);
        return pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset) == 0;
    }

    static bool set_numa_policy(int node) {
        if (numa_available() < 0) {
            return false;
        }

        struct bitmask* mask = numa_allocate_nodemask();
        numa_bitmask_setbit(mask, node);
        numa_set_membind(mask);
        numa_free_nodemask(mask);

        return true;
    }
};

int main() {
    if (!SystemOptimizer::optimize_for_hft()) {
        std::cerr << "Warning: Some optimizations failed\n";
    }

    // Start trading engine...
}
```

EXAMPLE 2: SYSTEM MONITORING
-----------------------------

```cpp
#include <fstream>
#include <sstream>

class SystemMonitor {
    uint64_t prev_voluntary_switches = 0;
    uint64_t prev_involuntary_switches = 0;

public:
    struct Stats {
        uint64_t voluntary_ctx_switches;
        uint64_t involuntary_ctx_switches;
        uint64_t minor_page_faults;
        uint64_t major_page_faults;
        unsigned int cpu_mhz;
    };

    Stats get_stats() {
        Stats stats = {};

        // Read /proc/self/status
        std::ifstream status("/proc/self/status");
        std::string line;
        while (std::getline(status, line)) {
            if (line.find("voluntary_ctxt_switches") == 0) {
                std::istringstream iss(line);
                std::string key;
                iss >> key >> stats.voluntary_ctx_switches;
            } else if (line.find("nonvoluntary_ctxt_switches") == 0) {
                std::istringstream iss(line);
                std::string key;
                iss >> key >> stats.involuntary_ctx_switches;
            }
        }

        // Read /proc/self/stat for page faults
        std::ifstream stat("/proc/self/stat");
        std::string dummy;
        for (int i = 0; i < 9; ++i) stat >> dummy;
        stat >> stats.minor_page_faults >> dummy >> stats.major_page_faults;

        // Read CPU frequency
        std::ifstream freq("/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq");
        unsigned int khz;
        freq >> khz;
        stats.cpu_mhz = khz / 1000;

        return stats;
    }

    void check_and_alert(const Stats& stats) {
        // Check for new involuntary context switches
        if (stats.involuntary_ctx_switches > prev_involuntary_switches) {
            uint64_t new_switches = stats.involuntary_ctx_switches - prev_involuntary_switches;
            if (new_switches > 0) {
                std::cerr << "ALERT: " << new_switches << " involuntary context switches!\n";
            }
        }

        // Check for major page faults (very bad!)
        if (stats.major_page_faults > 0) {
            std::cerr << "CRITICAL: Major page fault detected!\n";
        }

        // Check CPU frequency
        if (stats.cpu_mhz < 3000) {  // Assuming 3GHz expected
            std::cerr << "WARNING: CPU frequency dropped to " << stats.cpu_mhz << " MHz\n";
        }

        prev_voluntary_switches = stats.voluntary_ctx_switches;
        prev_involuntary_switches = stats.involuntary_ctx_switches;
    }
};
```

EXAMPLE 3: AVOIDING SYSTEM CALLS
---------------------------------

```cpp
// Avoid gettimeofday() syscall overhead
class FastClock {
    static inline double tsc_to_ns = 0.0;

public:
    static void calibrate() {
        struct timespec start, end;
        clock_gettime(CLOCK_MONOTONIC, &start);
        uint64_t tsc_start = __rdtsc();

        usleep(100000);  // 100ms

        uint64_t tsc_end = __rdtsc();
        clock_gettime(CLOCK_MONOTONIC, &end);

        uint64_t ns = (end.tv_sec - start.tv_sec) * 1000000000ULL +
                      (end.tv_nsec - start.tv_nsec);
        uint64_t tsc_delta = tsc_end - tsc_start;

        tsc_to_ns = (double)ns / tsc_delta;
    }

    static uint64_t now_ns() {
        return __rdtsc() * tsc_to_ns;
    }
};

// Usage: No syscall overhead!
uint64_t timestamp = FastClock::now_ns();
```

================================================================================
8. DEBUGGING COMMANDS AND INTERPRETATION
================================================================================

SYSTEM CALL ANALYSIS
---------------------

```bash
# Count syscalls by type
strace -c ./program

# Output:
# % time     seconds  usecs/call     calls    errors syscall
# ------ ----------- ----------- --------- --------- ----------------
#  45.23    0.012345          12      1000           read
#  32.10    0.008765           8      1000           write
#  12.34    0.003456          34       100           futex
```

SCHEDULER LATENCY
-----------------

```bash
perf sched latency

# Output:
# Task                  | Runtime ms  | Switches | Average delay ms | Maximum delay ms |
# trading_engine:1234   |   1000.123  |     100  |     0.123        |     5.456        |
```

IRQ STATISTICS
--------------

```bash
cat /proc/interrupts | grep eth0

# Output:
#            CPU0       CPU1       CPU2       CPU3
#  25:    1000000          0          0          0   IR-PCI-MSI-edge      eth0-rx-0
#  26:          0    2000000          0          0   IR-PCI-MSI-edge      eth0-tx-0
```

NUMA STATISTICS
---------------

```bash
numastat -p $(pidof trading_engine)

# Output:
# Per-node process memory usage (in MBs) for PID 1234
#                           Node 0          Node 1           Total
#                  --------------- --------------- ---------------
# Huge                        0.00            0.00            0.00
# Heap                      100.00            5.00          105.00  # Good: mostly local
# Stack                      10.00            0.50           10.50
# Private                   200.00           10.00          210.00
```

================================================================================
9. SOLUTIONS AND FIXES
================================================================================

SOLUTION 1: FIX HIGH CONTEXT SWITCHES
--------------------------------------

Problem: Excessive context switches degrading performance

Before:
```cpp
// Blocking I/O causes context switches
int n = read(sockfd, buffer, size);  // Blocks, context switch!
```

After:
```cpp
// Non-blocking I/O with epoll
int epfd = epoll_create1(0);
struct epoll_event ev = {.events = EPOLLIN, .data.fd = sockfd};
epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &ev);

// Set non-blocking
fcntl(sockfd, F_SETFL, O_NONBLOCK);

// Poll without blocking
struct epoll_event events[10];
int nfds = epoll_wait(epfd, events, 10, 0);  // 0 timeout = non-blocking
```

SOLUTION 2: FIX CPU FREQUENCY SCALING
--------------------------------------

```bash
# Disable frequency scaling permanently
echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor

# Disable turbo boost
echo 1 | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo

# Make persistent (add to /etc/rc.local)
```

SOLUTION 3: FIX NUMA REMOTE ACCESS
-----------------------------------

Problem: Process accessing memory on remote NUMA node

Detection:
```bash
numastat -p $(pidof trading_engine)
# Shows high "Node 1" usage when running on Node 0
```

Fix:
```bash
# Pin to Node 0 CPU and memory
numactl --cpunodebind=0 --membind=0 ./trading_engine
```

In code:
```cpp
#include <numa.h>

void optimize_numa() {
    if (numa_available() < 0) return;

    // Bind to node 0
    struct bitmask* mask = numa_allocate_nodemask();
    numa_bitmask_setbit(mask, 0);
    numa_bind(mask);
    numa_free_nodemask(mask);
}
```

SOLUTION 4: FIX INTERRUPT AFFINITY
-----------------------------------

```bash
# Find network IRQ
IRQ=$(grep eth0 /proc/interrupts | awk -F: '{print $1}' | head -1)

# Pin to CPU 0 (separate from trading CPU)
echo 1 | sudo tee /proc/irq/$IRQ/smp_affinity_list

# Disable irqbalance to prevent changes
sudo systemctl stop irqbalance
sudo systemctl disable irqbalance
```

================================================================================
10. BEST PRACTICES FOR HFT SYSTEM CONFIGURATION
================================================================================

1. CPU ISOLATION
```bash
# Kernel command line (GRUB)
isolcpus=2,3,4,5 nohz_full=2,3,4,5 rcu_nocbs=2,3,4,5
```

2. DISABLE POWER MANAGEMENT
```bash
echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
sudo cpupower idle-set -D 0
echo 1 | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo
```

3. LOCK MEMORY
```cpp
mlockall(MCL_CURRENT | MCL_FUTURE);
```

4. SET REALTIME PRIORITY
```cpp
struct sched_param param = {.sched_priority = 99};
sched_setscheduler(0, SCHED_FIFO, &param);
```

5. PIN TO CPU
```cpp
cpu_set_t cpuset;
CPU_ZERO(&cpuset);
CPU_SET(2, &cpuset);
pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);
```

6. OPTIMIZE NUMA
```bash
numactl --cpunodebind=0 --membind=0 ./trading_engine
```

7. PIN IRQS
```bash
echo 0 | sudo tee /proc/irq/*/smp_affinity_list  # Pin to CPU 0
```

8. DISABLE UNNECESSARY SERVICES
```bash
sudo systemctl disable bluetooth
sudo systemctl disable cups
```

9. HUGEPAGES
```bash
echo 1024 | sudo tee /proc/sys/vm/nr_hugepages
```

10. MONITOR CONTINUOUSLY
```cpp
// Periodic system checks
if (involuntary_ctx_switches > threshold) {
    alert("System interference detected");
}
```

================================================================================
END OF SYSTEM DEBUGGING GUIDE
================================================================================
