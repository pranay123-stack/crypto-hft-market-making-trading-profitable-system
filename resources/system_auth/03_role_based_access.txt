================================================================================
ROLE-BASED ACCESS CONTROL (RBAC)
High-Frequency Trading System - Authorization Framework
================================================================================

VERSION: 2.0
LAST UPDATED: 2025-11-26
CLASSIFICATION: CONFIDENTIAL

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. RBAC Model and Architecture
3. Role Hierarchy Design
4. Permission Management
5. C++ RBAC Implementation
6. Policy Definition Language
7. Dynamic Role Assignment
8. Audit and Compliance
9. Performance Optimization
10. Best Practices

================================================================================
1. OVERVIEW
================================================================================

Role-Based Access Control (RBAC) is the authorization mechanism that controls
what authenticated users can do within the HFT trading system. RBAC assigns
permissions to roles, and roles to users, simplifying access management.

KEY CONCEPTS:

User: A person or service account (e.g., trader, algorithm, admin)
Role: A collection of permissions (e.g., Trader, RiskManager, SystemAdmin)
Permission: An action on a resource (e.g., CREATE:ORDER, READ:POSITIONS)
Resource: An object in the system (e.g., trading orders, market data, configs)

RBAC ADVANTAGES FOR HFT SYSTEMS:

1. Scalability: Manage permissions for 1000s of users efficiently
2. Compliance: Enforce regulatory separation of duties
3. Audit Trail: Track who has access to what
4. Least Privilege: Grant minimum necessary permissions
5. Operational Efficiency: Quickly onboard/offboard users

REGULATORY REQUIREMENTS:

FINRA Rule 3110: Supervision of trading activities
- Traders cannot approve their own large orders
- Separate roles for order entry and risk approval

SOX Compliance: Separation of duties
- Developers cannot have production access
- Audit logs must be read-only for most users

MiFID II: Transaction reporting and accountability
- Clear assignment of responsibilities
- Audit trail of access decisions

================================================================================
2. RBAC MODEL AND ARCHITECTURE
================================================================================

2.1 RBAC COMPONENTS
-------------------

┌─────────────────────────────────────────────────────────────────┐
│                           USER                                   │
│  - user_id: UUID                                                │
│  - username: string                                             │
│  - email: string                                                │
│  - status: ACTIVE | SUSPENDED | DISABLED                        │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             │ has many
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      USER_ROLE (Association)                     │
│  - user_id: UUID                                                │
│  - role_id: UUID                                                │
│  - assigned_by: UUID (admin who granted role)                   │
│  - assigned_at: timestamp                                       │
│  - expires_at: timestamp (optional)                             │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             │ belongs to
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                           ROLE                                   │
│  - role_id: UUID                                                │
│  - role_name: string (e.g., "Trader", "RiskManager")           │
│  - description: string                                          │
│  - parent_role_id: UUID (for role hierarchy)                    │
│  - created_at: timestamp                                        │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             │ has many
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                   ROLE_PERMISSION (Association)                  │
│  - role_id: UUID                                                │
│  - permission_id: UUID                                          │
│  - granted_at: timestamp                                        │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             │ grants
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                         PERMISSION                               │
│  - permission_id: UUID                                          │
│  - resource: string (e.g., "ORDER", "POSITION", "CONFIG")      │
│  - action: string (e.g., "CREATE", "READ", "UPDATE", "DELETE") │
│  - scope: string (e.g., "OWN", "TEAM", "ALL")                  │
│  - description: string                                          │
└─────────────────────────────────────────────────────────────────┘

2.2 PERMISSION NAMING CONVENTION
---------------------------------

Format: <ACTION>:<RESOURCE>:<SCOPE>

Examples:
- READ:ORDER:OWN          - Read own orders
- READ:ORDER:TEAM         - Read team's orders
- READ:ORDER:ALL          - Read all orders
- CREATE:ORDER:MARKET     - Create market orders
- CREATE:ORDER:LIMIT      - Create limit orders
- DELETE:ORDER:OWN        - Cancel own orders
- UPDATE:RISK_LIMIT:TEAM  - Modify team risk limits
- EXECUTE:ALGORITHM:ALL   - Run trading algorithms
- READ:MARKET_DATA:L1     - Access Level 1 market data
- READ:MARKET_DATA:L2     - Access Level 2 market data
- ADMIN:SYSTEM:ALL        - Full system administration

================================================================================
3. ROLE HIERARCHY DESIGN
================================================================================

3.1 STANDARD ROLE HIERARCHY
----------------------------

SuperAdmin (inherits all permissions)
│
├── SystemAdmin
│   ├── TradingAdmin
│   │   ├── SeniorTrader
│   │   │   └── Trader
│   │   └── TradingAnalyst
│   │
│   ├── RiskAdmin
│   │   ├── RiskManager
│   │   └── RiskAnalyst
│   │
│   └── OperationsAdmin
│       ├── OperationsManager
│       └── OperationsAnalyst
│
├── SecurityAdmin
│   ├── SecurityAnalyst
│   └── AuditViewer
│
└── DeveloperAdmin
    ├── SeniorDeveloper
    └── Developer (ReadOnly production)

3.2 ROLE DEFINITIONS AND PERMISSIONS
-------------------------------------

ROLE: SuperAdmin
DESCRIPTION: Ultimate system access (CEO, CTO only)
PERMISSIONS:
  - ADMIN:SYSTEM:ALL
  - ADMIN:USER:ALL
  - ADMIN:ROLE:ALL
  - READ:AUDIT:ALL
  - All other permissions inherited
COUNT: Typically 2-3 users
SPECIAL REQUIREMENTS: Hardware token MFA, IP whitelist

ROLE: TradingAdmin
DESCRIPTION: Manages trading operations and traders
PERMISSIONS:
  - CREATE:ORDER:ALL
  - READ:ORDER:ALL
  - UPDATE:ORDER:ALL
  - DELETE:ORDER:ALL
  - READ:POSITION:ALL
  - UPDATE:RISK_LIMIT:ALL
  - EXECUTE:ALGORITHM:ALL
  - ADMIN:TRADER:TEAM
SPECIAL REQUIREMENTS: Dual approval for large orders

ROLE: Trader
DESCRIPTION: Executes trades within assigned limits
PERMISSIONS:
  - CREATE:ORDER:OWN (up to $1M notional)
  - READ:ORDER:OWN
  - DELETE:ORDER:OWN
  - READ:POSITION:OWN
  - READ:MARKET_DATA:L1
  - READ:MARKET_DATA:L2
CONSTRAINTS:
  - Daily volume limit: $50M
  - Position limit per symbol: $5M
  - Requires pre-trade risk approval for orders > $1M

ROLE: SeniorTrader
DESCRIPTION: Experienced trader with higher limits
INHERITS: Trader
ADDITIONAL PERMISSIONS:
  - CREATE:ORDER:OWN (up to $10M notional)
  - READ:ORDER:TEAM
  - APPROVE:ORDER:TEAM (for junior traders)
CONSTRAINTS:
  - Daily volume limit: $500M
  - Position limit per symbol: $50M

ROLE: RiskManager
DESCRIPTION: Monitors and controls trading risk
PERMISSIONS:
  - READ:ORDER:ALL
  - READ:POSITION:ALL
  - READ:RISK_METRICS:ALL
  - UPDATE:RISK_LIMIT:ALL
  - EXECUTE:RISK_CHECK:ALL
  - DELETE:ORDER:ALL (kill switch authority)
  - READ:MARKET_DATA:L1
  - READ:MARKET_DATA:L2
SPECIAL: Can override trader limits in emergencies

ROLE: RiskAnalyst
DESCRIPTION: Analyzes risk metrics (read-only)
INHERITS: (none)
PERMISSIONS:
  - READ:ORDER:ALL
  - READ:POSITION:ALL
  - READ:RISK_METRICS:ALL
  - READ:MARKET_DATA:L1

ROLE: Developer
DESCRIPTION: Develops trading algorithms and infrastructure
PERMISSIONS:
  - READ:CODE:ALL
  - UPDATE:CODE:DEV
  - EXECUTE:BACKTEST:ALL
  - READ:LOG:DEV
  - READ:METRIC:DEV
CONSTRAINTS:
  - NO production access
  - NO production data access
  - Can only access anonymized historical data

ROLE: SeniorDeveloper
DESCRIPTION: Senior developer with limited production access
INHERITS: Developer
ADDITIONAL PERMISSIONS:
  - READ:LOG:PROD (read-only)
  - READ:METRIC:PROD (read-only)
  - EXECUTE:DEPLOYMENT:STAGING
CONSTRAINTS:
  - Read-only production access
  - Cannot modify production systems
  - Requires approval for production deployments

ROLE: AuditViewer
DESCRIPTION: Views audit logs for compliance
PERMISSIONS:
  - READ:AUDIT:ALL
  - READ:COMPLIANCE_REPORT:ALL
CONSTRAINTS:
  - Read-only access
  - Cannot modify or delete audit logs
  - Cannot export without approval

================================================================================
4. PERMISSION MANAGEMENT
================================================================================

4.1 PERMISSION DEFINITION
--------------------------

```cpp
#include <string>
#include <vector>
#include <map>
#include <set>

class Permission {
public:
    enum class Action {
        CREATE,
        READ,
        UPDATE,
        DELETE,
        EXECUTE,
        APPROVE,
        ADMIN
    };

    enum class Scope {
        OWN,      // Only user's own resources
        TEAM,     // User's team resources
        ALL       // All resources (requires high privilege)
    };

    struct Definition {
        std::string permission_id;
        Action action;
        std::string resource;
        Scope scope;
        std::string description;
        std::map<std::string, std::string> constraints;  // Additional constraints
    };

    Permission(const Definition& def) : def_(def) {}

    std::string toString() const {
        return actionToString(def_.action) + ":" +
               def_.resource + ":" +
               scopeToString(def_.scope);
    }

    bool matches(Action action, const std::string& resource, Scope scope) const {
        return def_.action == action &&
               def_.resource == resource &&
               (def_.scope == scope || def_.scope == Scope::ALL);
    }

    static std::string actionToString(Action action) {
        switch (action) {
            case Action::CREATE: return "CREATE";
            case Action::READ: return "READ";
            case Action::UPDATE: return "UPDATE";
            case Action::DELETE: return "DELETE";
            case Action::EXECUTE: return "EXECUTE";
            case Action::APPROVE: return "APPROVE";
            case Action::ADMIN: return "ADMIN";
            default: return "UNKNOWN";
        }
    }

    static std::string scopeToString(Scope scope) {
        switch (scope) {
            case Scope::OWN: return "OWN";
            case Scope::TEAM: return "TEAM";
            case Scope::ALL: return "ALL";
            default: return "UNKNOWN";
        }
    }

    static Action stringToAction(const std::string& str) {
        if (str == "CREATE") return Action::CREATE;
        if (str == "READ") return Action::READ;
        if (str == "UPDATE") return Action::UPDATE;
        if (str == "DELETE") return Action::DELETE;
        if (str == "EXECUTE") return Action::EXECUTE;
        if (str == "APPROVE") return Action::APPROVE;
        if (str == "ADMIN") return Action::ADMIN;
        throw std::invalid_argument("Invalid action: " + str);
    }

    static Scope stringToScope(const std::string& str) {
        if (str == "OWN") return Scope::OWN;
        if (str == "TEAM") return Scope::TEAM;
        if (str == "ALL") return Scope::ALL;
        throw std::invalid_argument("Invalid scope: " + str);
    }

    const Definition& getDefinition() const { return def_; }

private:
    Definition def_;
};
```

4.2 ROLE IMPLEMENTATION
------------------------

```cpp
#include <memory>
#include <algorithm>

class Role {
public:
    struct Definition {
        std::string role_id;
        std::string role_name;
        std::string description;
        std::string parent_role_id;  // For role hierarchy
        std::vector<Permission::Definition> permissions;
        std::map<std::string, std::string> attributes;
        bool is_system_role;  // Cannot be deleted if true
    };

    Role(const Definition& def) : def_(def) {
        for (const auto& perm_def : def_.permissions) {
            permissions_.push_back(std::make_shared<Permission>(perm_def));
        }
    }

    const std::string& getId() const { return def_.role_id; }
    const std::string& getName() const { return def_.role_name; }
    const std::string& getParentId() const { return def_.parent_role_id; }

    bool hasPermission(Permission::Action action,
                      const std::string& resource,
                      Permission::Scope scope) const {
        for (const auto& perm : permissions_) {
            if (perm->matches(action, resource, scope)) {
                return true;
            }
        }
        return false;
    }

    bool hasPermission(const std::string& permission_str) const {
        for (const auto& perm : permissions_) {
            if (perm->toString() == permission_str) {
                return true;
            }
        }
        return false;
    }

    std::vector<std::string> getAllPermissions() const {
        std::vector<std::string> perms;
        for (const auto& perm : permissions_) {
            perms.push_back(perm->toString());
        }
        return perms;
    }

    void addPermission(const Permission::Definition& perm_def) {
        permissions_.push_back(std::make_shared<Permission>(perm_def));
    }

    void removePermission(const std::string& permission_str) {
        permissions_.erase(
            std::remove_if(permissions_.begin(), permissions_.end(),
                [&](const auto& perm) { return perm->toString() == permission_str; }),
            permissions_.end()
        );
    }

private:
    Definition def_;
    std::vector<std::shared_ptr<Permission>> permissions_;
};
```

4.3 RBAC ENGINE IMPLEMENTATION
-------------------------------

```cpp
#include <unordered_map>
#include <mutex>
#include <memory>

class RBACEngine {
public:
    struct AccessRequest {
        std::string user_id;
        Permission::Action action;
        std::string resource;
        std::string resource_id;  // Specific resource instance
        Permission::Scope scope;
        std::map<std::string, std::string> context;  // Additional context
    };

    struct AccessDecision {
        bool allowed;
        std::string reason;
        std::vector<std::string> applicable_roles;
        std::vector<std::string> applicable_permissions;
        std::time_t decision_time;
    };

    RBACEngine() {
        initializeStandardRoles();
    }

    // Check if user has permission
    AccessDecision checkAccess(const AccessRequest& request) {
        std::lock_guard<std::mutex> lock(mutex_);

        AccessDecision decision;
        decision.decision_time = std::time(nullptr);
        decision.allowed = false;

        // Get user's roles
        auto user_roles = getUserRoles(request.user_id);
        if (user_roles.empty()) {
            decision.reason = "User has no assigned roles";
            logAccessDecision(request, decision);
            return decision;
        }

        // Check each role for the required permission
        for (const auto& role : user_roles) {
            if (role->hasPermission(request.action, request.resource, request.scope)) {
                decision.allowed = true;
                decision.applicable_roles.push_back(role->getName());

                // Build permission string
                std::string perm_str = Permission::actionToString(request.action) + ":" +
                                      request.resource + ":" +
                                      Permission::scopeToString(request.scope);
                decision.applicable_permissions.push_back(perm_str);
            }
        }

        // If allowed, check additional constraints
        if (decision.allowed) {
            if (!checkConstraints(request, user_roles)) {
                decision.allowed = false;
                decision.reason = "Permission constraints not satisfied";
            } else {
                decision.reason = "Access granted";
            }
        } else {
            decision.reason = "No role grants the required permission";
        }

        // Check if resource ownership matches scope
        if (decision.allowed && request.scope == Permission::Scope::OWN) {
            if (!verifyResourceOwnership(request.user_id, request.resource, request.resource_id)) {
                decision.allowed = false;
                decision.reason = "User does not own the requested resource";
            }
        }

        logAccessDecision(request, decision);
        return decision;
    }

    // Assign role to user
    bool assignRole(const std::string& user_id, const std::string& role_name,
                   const std::string& assigned_by,
                   std::time_t expires_at = 0) {
        std::lock_guard<std::mutex> lock(mutex_);

        // Check if assigner has permission to assign roles
        AccessRequest admin_check;
        admin_check.user_id = assigned_by;
        admin_check.action = Permission::Action::ADMIN;
        admin_check.resource = "ROLE";
        admin_check.scope = Permission::Scope::ALL;

        auto decision = checkAccess(admin_check);
        if (!decision.allowed) {
            logError("User " + assigned_by + " does not have permission to assign roles");
            return false;
        }

        // Find role
        auto role_it = roles_.find(role_name);
        if (role_it == roles_.end()) {
            logError("Role not found: " + role_name);
            return false;
        }

        // Assign role to user
        user_roles_[user_id].push_back(role_it->second);

        // Store in database
        storeUserRoleInDB(user_id, role_it->second->getId(), assigned_by, expires_at);

        logInfo("Assigned role " + role_name + " to user " + user_id);
        auditLog("ROLE_ASSIGNED", user_id, role_name, assigned_by);

        return true;
    }

    // Revoke role from user
    bool revokeRole(const std::string& user_id, const std::string& role_name,
                   const std::string& revoked_by) {
        std::lock_guard<std::mutex> lock(mutex_);

        auto& user_roles = user_roles_[user_id];
        auto it = std::find_if(user_roles.begin(), user_roles.end(),
            [&](const auto& role) { return role->getName() == role_name; });

        if (it == user_roles.end()) {
            logWarning("User " + user_id + " does not have role " + role_name);
            return false;
        }

        user_roles.erase(it);

        // Remove from database
        removeUserRoleFromDB(user_id, role_name);

        logInfo("Revoked role " + role_name + " from user " + user_id);
        auditLog("ROLE_REVOKED", user_id, role_name, revoked_by);

        return true;
    }

    // Get all roles for user
    std::vector<std::string> getUserRoleNames(const std::string& user_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        std::vector<std::string> role_names;
        auto roles = getUserRoles(user_id);
        for (const auto& role : roles) {
            role_names.push_back(role->getName());
        }
        return role_names;
    }

    // Get all permissions for user (flattened from all roles)
    std::vector<std::string> getUserPermissions(const std::string& user_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        std::set<std::string> permissions_set;
        auto roles = getUserRoles(user_id);
        for (const auto& role : roles) {
            auto role_perms = role->getAllPermissions();
            permissions_set.insert(role_perms.begin(), role_perms.end());
        }

        return std::vector<std::string>(permissions_set.begin(), permissions_set.end());
    }

    // Create new role
    bool createRole(const Role::Definition& role_def, const std::string& created_by) {
        std::lock_guard<std::mutex> lock(mutex_);

        if (roles_.find(role_def.role_name) != roles_.end()) {
            logError("Role already exists: " + role_def.role_name);
            return false;
        }

        auto role = std::make_shared<Role>(role_def);
        roles_[role_def.role_name] = role;

        // Store in database
        storeRoleInDB(role_def);

        auditLog("ROLE_CREATED", role_def.role_name, "", created_by);
        return true;
    }

    // Delete role (only if not system role and not assigned to any user)
    bool deleteRole(const std::string& role_name, const std::string& deleted_by) {
        std::lock_guard<std::mutex> lock(mutex_);

        auto role_it = roles_.find(role_name);
        if (role_it == roles_.end()) {
            logError("Role not found: " + role_name);
            return false;
        }

        auto role = role_it->second;

        // Check if system role
        if (role->getDefinition().is_system_role) {
            logError("Cannot delete system role: " + role_name);
            return false;
        }

        // Check if assigned to any user
        for (const auto& [user_id, user_roles] : user_roles_) {
            for (const auto& ur : user_roles) {
                if (ur->getName() == role_name) {
                    logError("Cannot delete role " + role_name + " - still assigned to users");
                    return false;
                }
            }
        }

        roles_.erase(role_it);

        // Remove from database
        deleteRoleFromDB(role_name);

        auditLog("ROLE_DELETED", role_name, "", deleted_by);
        return true;
    }

private:
    std::unordered_map<std::string, std::shared_ptr<Role>> roles_;
    std::unordered_map<std::string, std::vector<std::shared_ptr<Role>>> user_roles_;
    std::mutex mutex_;

    void initializeStandardRoles() {
        // Define SuperAdmin role
        Role::Definition superadmin;
        superadmin.role_name = "SuperAdmin";
        superadmin.description = "Full system access";
        superadmin.is_system_role = true;

        Permission::Definition admin_all;
        admin_all.action = Permission::Action::ADMIN;
        admin_all.resource = "*";  // All resources
        admin_all.scope = Permission::Scope::ALL;
        superadmin.permissions.push_back(admin_all);

        roles_["SuperAdmin"] = std::make_shared<Role>(superadmin);

        // Define Trader role
        Role::Definition trader;
        trader.role_name = "Trader";
        trader.description = "Standard trader role";
        trader.is_system_role = true;

        Permission::Definition create_order_own;
        create_order_own.action = Permission::Action::CREATE;
        create_order_own.resource = "ORDER";
        create_order_own.scope = Permission::Scope::OWN;
        create_order_own.constraints["max_notional"] = "1000000";  // $1M
        trader.permissions.push_back(create_order_own);

        Permission::Definition read_order_own;
        read_order_own.action = Permission::Action::READ;
        read_order_own.resource = "ORDER";
        read_order_own.scope = Permission::Scope::OWN;
        trader.permissions.push_back(read_order_own);

        Permission::Definition delete_order_own;
        delete_order_own.action = Permission::Action::DELETE;
        delete_order_own.resource = "ORDER";
        delete_order_own.scope = Permission::Scope::OWN;
        trader.permissions.push_back(delete_order_own);

        Permission::Definition read_market_l1;
        read_market_l1.action = Permission::Action::READ;
        read_market_l1.resource = "MARKET_DATA_L1";
        read_market_l1.scope = Permission::Scope::ALL;
        trader.permissions.push_back(read_market_l1);

        roles_["Trader"] = std::make_shared<Role>(trader);

        // Load other roles from database
        loadRolesFromDB();
    }

    std::vector<std::shared_ptr<Role>> getUserRoles(const std::string& user_id) {
        auto it = user_roles_.find(user_id);
        if (it != user_roles_.end()) {
            return it->second;
        }

        // Load from database if not in cache
        return loadUserRolesFromDB(user_id);
    }

    bool checkConstraints(const AccessRequest& request,
                         const std::vector<std::shared_ptr<Role>>& roles) {
        // Check constraint like max order size, daily volume limits, etc.
        // This is a simplified example
        for (const auto& role : roles) {
            for (const auto& perm : role->getDefinition().permissions) {
                if (perm.action == request.action &&
                    perm.resource == request.resource) {

                    // Check max_notional constraint
                    auto it = perm.constraints.find("max_notional");
                    if (it != perm.constraints.end()) {
                        double max_notional = std::stod(it->second);
                        auto notional_it = request.context.find("notional");
                        if (notional_it != request.context.end()) {
                            double req_notional = std::stod(notional_it->second);
                            if (req_notional > max_notional) {
                                return false;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    bool verifyResourceOwnership(const std::string& user_id,
                                const std::string& resource,
                                const std::string& resource_id) {
        // Query database to verify user owns the resource
        // For example, check if order was created by this user
        return true;  // Simplified
    }

    void loadRolesFromDB() {
        // Load roles from PostgreSQL
    }

    std::vector<std::shared_ptr<Role>> loadUserRolesFromDB(const std::string& user_id) {
        // Load user's roles from database
        return {};
    }

    void storeRoleInDB(const Role::Definition& role_def) {
        // Store role in database
    }

    void storeUserRoleInDB(const std::string& user_id, const std::string& role_id,
                          const std::string& assigned_by, std::time_t expires_at) {
        // Store user-role assignment in database
    }

    void removeUserRoleFromDB(const std::string& user_id, const std::string& role_name) {
        // Remove user-role assignment from database
    }

    void deleteRoleFromDB(const std::string& role_name) {
        // Delete role from database
    }

    void logAccessDecision(const AccessRequest& request, const AccessDecision& decision) {
        // Log to audit system
    }

    void logError(const std::string& msg) {}
    void logWarning(const std::string& msg) {}
    void logInfo(const std::string& msg) {}
    void auditLog(const std::string& event, const std::string& target,
                 const std::string& detail, const std::string& actor) {}
};
```

================================================================================
5. POLICY DEFINITION LANGUAGE
================================================================================

5.1 JSON POLICY FORMAT
-----------------------

```json
{
  "role": {
    "name": "Trader",
    "description": "Standard trader role with basic trading permissions",
    "parent_role": null,
    "is_system_role": true,
    "permissions": [
      {
        "action": "CREATE",
        "resource": "ORDER",
        "scope": "OWN",
        "constraints": {
          "max_notional_per_order": "1000000",
          "max_daily_volume": "50000000",
          "allowed_order_types": ["MARKET", "LIMIT"],
          "allowed_symbols": ["*"],
          "trading_hours_only": true
        }
      },
      {
        "action": "READ",
        "resource": "ORDER",
        "scope": "OWN"
      },
      {
        "action": "UPDATE",
        "resource": "ORDER",
        "scope": "OWN",
        "constraints": {
          "allowed_fields": ["quantity", "price"]
        }
      },
      {
        "action": "DELETE",
        "resource": "ORDER",
        "scope": "OWN"
      },
      {
        "action": "READ",
        "resource": "POSITION",
        "scope": "OWN"
      },
      {
        "action": "READ",
        "resource": "MARKET_DATA_L1",
        "scope": "ALL"
      },
      {
        "action": "READ",
        "resource": "MARKET_DATA_L2",
        "scope": "ALL"
      }
    ],
    "attributes": {
      "max_position_size": "5000000",
      "max_leverage": "2.0",
      "requires_pre_trade_approval_above": "1000000"
    }
  }
}
```

5.2 POLICY LOADER
-----------------

```python
#!/usr/bin/env python3
"""
RBAC Policy Loader
Loads role definitions from JSON files and stores in database
"""

import json
import psycopg2
from typing import Dict, List
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class RBACPolicyLoader:
    """Loads RBAC policies from JSON files into database"""

    def __init__(self, db_config: Dict[str, str]):
        self.conn = psycopg2.connect(
            host=db_config['host'],
            port=db_config['port'],
            database=db_config['database'],
            user=db_config['user'],
            password=db_config['password']
        )

    def load_policy_file(self, file_path: str) -> bool:
        """Load a policy file and store in database"""
        try:
            with open(file_path, 'r') as f:
                policy = json.load(f)

            if 'role' in policy:
                return self.load_role(policy['role'])
            else:
                logger.error(f"Invalid policy format in {file_path}")
                return False

        except Exception as e:
            logger.error(f"Failed to load policy file {file_path}: {e}")
            return False

    def load_role(self, role_def: Dict) -> bool:
        """Load a role definition into database"""
        cursor = self.conn.cursor()

        try:
            # Insert role
            cursor.execute("""
                INSERT INTO roles (name, description, parent_role, is_system_role, attributes)
                VALUES (%s, %s, %s, %s, %s)
                ON CONFLICT (name) DO UPDATE
                SET description = EXCLUDED.description,
                    parent_role = EXCLUDED.parent_role,
                    attributes = EXCLUDED.attributes
                RETURNING id
            """, (
                role_def['name'],
                role_def['description'],
                role_def.get('parent_role'),
                role_def.get('is_system_role', False),
                json.dumps(role_def.get('attributes', {}))
            ))

            role_id = cursor.fetchone()[0]

            # Delete existing permissions for this role
            cursor.execute("DELETE FROM role_permissions WHERE role_id = %s", (role_id,))

            # Insert permissions
            for perm in role_def.get('permissions', []):
                cursor.execute("""
                    INSERT INTO permissions (action, resource, scope, constraints)
                    VALUES (%s, %s, %s, %s)
                    ON CONFLICT (action, resource, scope) DO UPDATE
                    SET constraints = EXCLUDED.constraints
                    RETURNING id
                """, (
                    perm['action'],
                    perm['resource'],
                    perm['scope'],
                    json.dumps(perm.get('constraints', {}))
                ))

                perm_id = cursor.fetchone()[0]

                # Link permission to role
                cursor.execute("""
                    INSERT INTO role_permissions (role_id, permission_id)
                    VALUES (%s, %s)
                    ON CONFLICT DO NOTHING
                """, (role_id, perm_id))

            self.conn.commit()
            logger.info(f"Successfully loaded role: {role_def['name']}")
            return True

        except Exception as e:
            self.conn.rollback()
            logger.error(f"Failed to load role {role_def.get('name')}: {e}")
            return False

        finally:
            cursor.close()

    def load_directory(self, dir_path: str):
        """Load all policy files from a directory"""
        import os

        for filename in os.listdir(dir_path):
            if filename.endswith('.json'):
                file_path = os.path.join(dir_path, filename)
                logger.info(f"Loading policy file: {file_path}")
                self.load_policy_file(file_path)

    def export_role(self, role_name: str, output_file: str):
        """Export a role definition to JSON file"""
        cursor = self.conn.cursor()

        try:
            # Get role
            cursor.execute("""
                SELECT id, name, description, parent_role, is_system_role, attributes
                FROM roles
                WHERE name = %s
            """, (role_name,))

            role_row = cursor.fetchone()
            if not role_row:
                logger.error(f"Role not found: {role_name}")
                return False

            role_id, name, description, parent_role, is_system_role, attributes = role_row

            # Get permissions
            cursor.execute("""
                SELECT p.action, p.resource, p.scope, p.constraints
                FROM permissions p
                JOIN role_permissions rp ON p.id = rp.permission_id
                WHERE rp.role_id = %s
            """, (role_id,))

            permissions = []
            for action, resource, scope, constraints in cursor.fetchall():
                perm = {
                    'action': action,
                    'resource': resource,
                    'scope': scope
                }
                if constraints:
                    perm['constraints'] = json.loads(constraints)
                permissions.append(perm)

            # Build policy object
            policy = {
                'role': {
                    'name': name,
                    'description': description,
                    'parent_role': parent_role,
                    'is_system_role': is_system_role,
                    'permissions': permissions,
                    'attributes': json.loads(attributes) if attributes else {}
                }
            }

            # Write to file
            with open(output_file, 'w') as f:
                json.dump(policy, f, indent=2)

            logger.info(f"Exported role {role_name} to {output_file}")
            return True

        except Exception as e:
            logger.error(f"Failed to export role {role_name}: {e}")
            return False

        finally:
            cursor.close()

def main():
    """Main function"""
    db_config = {
        'host': 'localhost',
        'port': 5432,
        'database': 'hft_trading',
        'user': 'admin',
        'password': 'secure_password'
    }

    loader = RBACPolicyLoader(db_config)

    # Load all policies from directory
    loader.load_directory('/etc/hft/rbac/policies/')

    # Export a role for review
    loader.export_role('Trader', '/tmp/trader_role.json')

if __name__ == '__main__':
    main()
```

================================================================================
6. DYNAMIC ROLE ASSIGNMENT
================================================================================

6.1 CONDITIONAL ROLE ASSIGNMENT
--------------------------------

Assign roles based on conditions (e.g., time-based, attribute-based):

```cpp
#include <chrono>

class DynamicRoleManager {
public:
    struct ConditionalRole {
        std::string role_name;
        std::function<bool(const std::string& user_id,
                          const std::map<std::string, std::string>& context)> condition;
        std::time_t start_time;  // 0 = no restriction
        std::time_t end_time;    // 0 = no restriction
    };

    void addConditionalRole(const ConditionalRole& conditional_role) {
        conditional_roles_.push_back(conditional_role);
    }

    std::vector<std::string> evaluateConditionalRoles(
        const std::string& user_id,
        const std::map<std::string, std::string>& context) {

        std::vector<std::string> granted_roles;
        std::time_t now = std::time(nullptr);

        for (const auto& cr : conditional_roles_) {
            // Check time restrictions
            if (cr.start_time != 0 && now < cr.start_time) continue;
            if (cr.end_time != 0 && now >= cr.end_time) continue;

            // Evaluate condition
            if (cr.condition(user_id, context)) {
                granted_roles.push_back(cr.role_name);
            }
        }

        return granted_roles;
    }

private:
    std::vector<ConditionalRole> conditional_roles_;
};

// Example usage
void setupConditionalRoles(DynamicRoleManager& manager) {
    // Trading hours role
    DynamicRoleManager::ConditionalRole trading_hours_role;
    trading_hours_role.role_name = "ActiveTrader";
    trading_hours_role.condition = [](const std::string& user_id,
                                     const std::map<std::string, std::string>& context) {
        // Check if during trading hours (9:30 AM - 4:00 PM ET)
        auto now = std::chrono::system_clock::now();
        std::time_t tt = std::chrono::system_clock::to_time_t(now);
        std::tm* tm = std::localtime(&tt);

        int hour = tm->tm_hour;
        return (hour >= 9 && hour < 16);
    };
    manager.addConditionalRole(trading_hours_role);

    // High-value customer role
    DynamicRoleManager::ConditionalRole hvс_role;
    hvc_role.role_name = "PremiumTrader";
    hvc_role.condition = [](const std::string& user_id,
                           const std::map<std::string, std::string>& context) {
        // Check if account balance > $1M
        auto it = context.find("account_balance");
        if (it != context.end()) {
            double balance = std::stod(it->second);
            return balance > 1000000.0;
        }
        return false;
    };
    manager.addConditionalRole(hvc_role);
}
```

================================================================================
7. AUDIT AND COMPLIANCE
================================================================================

7.1 ACCESS DECISION LOGGING
----------------------------

```cpp
class RBACLogger {
public:
    struct AccessLogEntry {
        std::string log_id;
        std::time_t timestamp;
        std::string user_id;
        std::string username;
        std::string action;
        std::string resource;
        std::string resource_id;
        bool allowed;
        std::string reason;
        std::vector<std::string> roles_checked;
        std::string ip_address;
        std::string user_agent;
    };

    void logAccessDecision(const AccessLogEntry& entry) {
        // Write to database
        storeLogInDB(entry);

        // Also write to SIEM (Security Information and Event Management)
        sendToSIEM(entry);

        // If access denied, check if alert needed
        if (!entry.allowed) {
            checkForAnomalies(entry);
        }
    }

    // Generate compliance report
    void generateComplianceReport(const std::string& user_id,
                                 std::time_t start_time,
                                 std::time_t end_time,
                                 const std::string& output_file) {
        // Query all access decisions for user in time range
        auto logs = queryAccessLogs(user_id, start_time, end_time);

        // Generate report in CSV format
        std::ofstream out(output_file);
        out << "Timestamp,User,Action,Resource,Allowed,Reason\n";

        for (const auto& log : logs) {
            out << log.timestamp << ","
                << log.username << ","
                << log.action << ","
                << log.resource << ","
                << (log.allowed ? "YES" : "NO") << ","
                << log.reason << "\n";
        }

        out.close();
    }

private:
    void storeLogInDB(const AccessLogEntry& entry) {
        // Store in PostgreSQL or similar
    }

    void sendToSIEM(const AccessLogEntry& entry) {
        // Send to Splunk, ELK, etc.
    }

    void checkForAnomalies(const AccessLogEntry& entry) {
        // Check for suspicious patterns
        // Multiple failed access attempts
        // Access from unusual location
        // Access outside normal hours
    }

    std::vector<AccessLogEntry> queryAccessLogs(const std::string& user_id,
                                                std::time_t start_time,
                                                std::time_t end_time) {
        // Query from database
        return {};
    }
};
```

================================================================================
8. PERFORMANCE OPTIMIZATION
================================================================================

8.1 CACHING STRATEGY
--------------------

```cpp
#include <lru/lru.hpp>

class RBACCacheManager {
public:
    RBACCacheManager(size_t cache_size = 10000)
        : access_decision_cache_(cache_size),
          user_roles_cache_(cache_size),
          permission_cache_(cache_size) {}

    // Cache access decision
    void cacheAccessDecision(const std::string& key,
                            const RBACEngine::AccessDecision& decision) {
        access_decision_cache_.insert(key, decision);
    }

    // Get cached decision
    std::optional<RBACEngine::AccessDecision> getCachedDecision(const std::string& key) {
        return access_decision_cache_.get(key);
    }

    // Generate cache key
    std::string generateCacheKey(const std::string& user_id,
                                const std::string& action,
                                const std::string& resource,
                                const std::string& scope) {
        return user_id + ":" + action + ":" + resource + ":" + scope;
    }

    // Invalidate cache for user (when roles change)
    void invalidateUserCache(const std::string& user_id) {
        // Remove all cached decisions for this user
        // Implementation depends on cache library
    }

private:
    LRUCache<std::string, RBACEngine::AccessDecision> access_decision_cache_;
    LRUCache<std::string, std::vector<std::string>> user_roles_cache_;
    LRUCache<std::string, std::vector<std::string>> permission_cache_;
};
```

================================================================================
9. BEST PRACTICES
================================================================================

1. PRINCIPLE OF LEAST PRIVILEGE
   - Grant minimum permissions required for job function
   - Review permissions quarterly
   - Revoke unused permissions

2. SEPARATION OF DUTIES
   - No single person has end-to-end control
   - Traders cannot approve their own large orders
   - Developers cannot access production without approval

3. ROLE EXPLOSION PREVENTION
   - Keep number of roles manageable (< 50)
   - Use role hierarchy to avoid duplication
   - Combine with ABAC for fine-grained control

4. REGULAR AUDITS
   - Review role assignments monthly
   - Audit high-privilege roles weekly
   - Generate compliance reports for regulators

5. PERFORMANCE CONSIDERATIONS
   - Cache access decisions (5-minute TTL)
   - Pre-compute role inheritance
   - Use database indexes on user_id, role_id

6. TESTING
   - Unit test each permission check
   - Integration test role assignments
   - Penetration test for privilege escalation

================================================================================
END OF DOCUMENT
================================================================================
