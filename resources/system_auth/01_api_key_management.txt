================================================================================
API KEY MANAGEMENT FOR EXCHANGE CONNECTIVITY
High-Frequency Trading System - Secure API Key Lifecycle
================================================================================

VERSION: 2.0
LAST UPDATED: 2025-11-26
CLASSIFICATION: HIGHLY CONFIDENTIAL

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. Exchange API Key Requirements
3. Secure Storage Architecture
4. Key Generation and Registration
5. Key Rotation Strategy
6. C++ Implementation
7. Python Automation Scripts
8. Monitoring and Alerting
9. Emergency Key Revocation
10. Compliance and Audit

================================================================================
1. OVERVIEW
================================================================================

API keys are the primary authentication mechanism for connecting to
cryptocurrency and traditional exchanges. In HFT systems, API keys must be:

SECURITY REQUIREMENTS:
- Stored encrypted at rest (AES-256-GCM)
- Never logged in plaintext
- Rotated regularly (30-90 days depending on exchange)
- Access controlled with strict RBAC
- Monitored for unauthorized usage
- Backed up with disaster recovery plan

PERFORMANCE REQUIREMENTS:
- Sub-microsecond retrieval from memory cache
- Zero-copy access to avoid memory allocations
- Lock-free concurrent access where possible
- Minimal latency impact on order execution

OPERATIONAL REQUIREMENTS:
- Automated rotation without service interruption
- Emergency revocation capability
- Multi-region redundancy
- Version control and rollback support

KEY RISK FACTORS:
1. Exposure Risk: Keys leaked through logs, error messages, or code
2. Theft Risk: Unauthorized access to key storage
3. Compromise Risk: Man-in-the-middle or replay attacks
4. Operational Risk: Service disruption during rotation
5. Compliance Risk: Inadequate audit trail or access controls

================================================================================
2. EXCHANGE API KEY REQUIREMENTS
================================================================================

2.1 MAJOR EXCHANGE SPECIFICATIONS
----------------------------------

EXCHANGE: CME Group (Futures)
API Type: FIX API with API Key + Secret
Key Format: 32-character alphanumeric
Secret Format: 64-character hex string
Signature: HMAC-SHA256
IP Whitelisting: Required
Rotation Policy: 30 days mandatory
Permissions: Granular (view, trade, withdraw)
Rate Limits: 100 requests/second per key

EXCHANGE: Binance (Crypto)
API Type: REST + WebSocket
Key Format: 64-character string
Secret Format: 64-character string
Signature: HMAC-SHA256
IP Whitelisting: Optional but recommended
Rotation Policy: 90 days recommended
Permissions: Read-only, Trade, Withdraw
Rate Limits: Weight-based system (1200/minute)

EXCHANGE: NYSE (Equities)
API Type: OAuth 2.0 Client Credentials
Key Format: Client ID (UUID)
Secret Format: Client Secret (256-bit)
Token: JWT (1-hour expiration)
IP Whitelisting: Required
Rotation Policy: 90 days
Permissions: Market data, Order entry
Rate Limits: 10 requests/second

EXCHANGE: Kraken (Crypto)
API Type: REST
Key Format: Base64-encoded (56 chars)
Secret Format: Base64-encoded (88 chars)
Signature: HMAC-SHA512
Nonce: Required (timestamp-based)
IP Whitelisting: Optional
Rotation Policy: 60 days recommended
Rate Limits: 15-20 per minute (tier-based)

2.2 KEY PERMISSION SCOPES
--------------------------

Always follow principle of least privilege:

SCOPE                 REQUIRED FOR                  RISK LEVEL
----------------------------------------------------------------------
Read Market Data     Price feeds, order books       LOW
Read Account         Balance, positions             MEDIUM
Create Orders        Place new orders               HIGH
Cancel Orders        Cancel pending orders          MEDIUM-HIGH
Withdraw Funds       Transfer funds out             CRITICAL
Margin Trading       Leveraged positions            HIGH
Futures Trading      Derivatives trading            HIGH
Admin Functions      User management                CRITICAL

BEST PRACTICE: Create separate API keys for different functions:
- MarketData-ReadOnly: For analytics and risk monitoring
- Trading-NoWithdraw: For order execution
- Reconciliation-ReadOnly: For accounting and settlement
- Emergency-CancelOnly: For risk management shutdowns

================================================================================
3. SECURE STORAGE ARCHITECTURE
================================================================================

3.1 MULTI-LAYER ENCRYPTION ARCHITECTURE
----------------------------------------

┌─────────────────────────────────────────────────────────────────┐
│                    APPLICATION LAYER                             │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │         API Key Manager (C++ Service)                     │  │
│  │  - In-memory encrypted cache (mlock'd memory)            │  │
│  │  - AES-256-GCM encryption                                 │  │
│  │  - Key derivation from HSM master key                    │  │
│  └───────────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────────┘
                            │ TLS 1.3
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                  SECRETS MANAGEMENT LAYER                        │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │         HashiCorp Vault / AWS Secrets Manager            │  │
│  │  - Transit encryption engine                              │  │
│  │  - Dynamic secrets generation                             │  │
│  │  - Automatic rotation scheduling                          │  │
│  │  - Access policy enforcement                              │  │
│  └───────────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────────┘
                            │ Encrypted connection
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│               KEY MANAGEMENT SERVICE (KMS)                       │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │   Hardware Security Module (HSM) / AWS KMS               │  │
│  │  - Master encryption keys                                 │  │
│  │  - FIPS 140-2 Level 3 certified                          │  │
│  │  - Tamper-resistant hardware                              │  │
│  │  - Audit logging                                          │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘

3.2 ENCRYPTION IMPLEMENTATION
------------------------------

```cpp
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/err.h>
#include <string>
#include <vector>
#include <memory>
#include <sys/mman.h>

class SecureAPIKeyStorage {
public:
    struct EncryptedKey {
        std::vector<unsigned char> ciphertext;
        std::vector<unsigned char> iv;          // Initialization vector
        std::vector<unsigned char> tag;         // Authentication tag for GCM
        std::vector<unsigned char> aad;         // Additional authenticated data
        std::string key_id;
        std::string exchange;
        std::time_t created_at;
        std::time_t expires_at;
    };

    SecureAPIKeyStorage() {
        // Initialize OpenSSL
        OpenSSL_add_all_algorithms();
        ERR_load_crypto_strings();

        // Allocate secure memory (prevent swapping to disk)
        allocateSecureMemory();
    }

    ~SecureAPIKeyStorage() {
        // Securely wipe memory before destruction
        secureWipeMemory();
    }

    // Encrypt API key using AES-256-GCM
    bool encryptAPIKey(const std::string& plaintext_key,
                      const std::string& key_id,
                      const std::string& exchange,
                      EncryptedKey& encrypted_out) {

        // Generate random IV (12 bytes for GCM)
        encrypted_out.iv.resize(12);
        if (RAND_bytes(encrypted_out.iv.data(), 12) != 1) {
            logError("Failed to generate random IV");
            return false;
        }

        // Additional authenticated data (metadata that must not be tampered with)
        std::string aad_str = key_id + ":" + exchange;
        encrypted_out.aad.assign(aad_str.begin(), aad_str.end());

        // Create cipher context
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx) {
            logError("Failed to create cipher context");
            return false;
        }

        // Initialize encryption with AES-256-GCM
        if (EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr,
                              master_key_.data(), encrypted_out.iv.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            logError("Failed to initialize encryption");
            return false;
        }

        // Provide AAD
        int len;
        if (EVP_EncryptUpdate(ctx, nullptr, &len,
                             encrypted_out.aad.data(),
                             encrypted_out.aad.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            logError("Failed to set AAD");
            return false;
        }

        // Encrypt plaintext
        encrypted_out.ciphertext.resize(plaintext_key.size() + EVP_CIPHER_block_size(EVP_aes_256_gcm()));
        if (EVP_EncryptUpdate(ctx, encrypted_out.ciphertext.data(), &len,
                             reinterpret_cast<const unsigned char*>(plaintext_key.data()),
                             plaintext_key.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            logError("Failed to encrypt data");
            return false;
        }
        int ciphertext_len = len;

        // Finalize encryption
        if (EVP_EncryptFinal_ex(ctx, encrypted_out.ciphertext.data() + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            logError("Failed to finalize encryption");
            return false;
        }
        ciphertext_len += len;
        encrypted_out.ciphertext.resize(ciphertext_len);

        // Get authentication tag
        encrypted_out.tag.resize(16);  // 128-bit tag
        if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16,
                               encrypted_out.tag.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            logError("Failed to get authentication tag");
            return false;
        }

        EVP_CIPHER_CTX_free(ctx);

        // Set metadata
        encrypted_out.key_id = key_id;
        encrypted_out.exchange = exchange;
        encrypted_out.created_at = std::time(nullptr);
        encrypted_out.expires_at = encrypted_out.created_at + (30 * 24 * 3600); // 30 days

        logInfo("Successfully encrypted API key: " + key_id);
        return true;
    }

    // Decrypt API key
    bool decryptAPIKey(const EncryptedKey& encrypted_key,
                      std::string& plaintext_out) {

        // Check if key has expired
        if (std::time(nullptr) > encrypted_key.expires_at) {
            logWarning("API key has expired: " + encrypted_key.key_id);
            return false;
        }

        // Create cipher context
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx) {
            logError("Failed to create cipher context");
            return false;
        }

        // Initialize decryption
        if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr,
                              master_key_.data(), encrypted_key.iv.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            logError("Failed to initialize decryption");
            return false;
        }

        // Provide AAD
        int len;
        if (EVP_DecryptUpdate(ctx, nullptr, &len,
                             encrypted_key.aad.data(),
                             encrypted_key.aad.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            logError("Failed to set AAD for decryption");
            return false;
        }

        // Decrypt ciphertext
        std::vector<unsigned char> plaintext_buf(encrypted_key.ciphertext.size());
        if (EVP_DecryptUpdate(ctx, plaintext_buf.data(), &len,
                             encrypted_key.ciphertext.data(),
                             encrypted_key.ciphertext.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            logError("Failed to decrypt data");
            return false;
        }
        int plaintext_len = len;

        // Set expected tag
        if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16,
                                const_cast<unsigned char*>(encrypted_key.tag.data()))) {
            EVP_CIPHER_CTX_free(ctx);
            logError("Failed to set authentication tag");
            return false;
        }

        // Finalize decryption (verifies authentication tag)
        int ret = EVP_DecryptFinal_ex(ctx, plaintext_buf.data() + len, &len);
        EVP_CIPHER_CTX_free(ctx);

        if (ret <= 0) {
            logError("Decryption failed: Authentication tag mismatch");
            return false;
        }

        plaintext_len += len;
        plaintext_out.assign(plaintext_buf.begin(), plaintext_buf.begin() + plaintext_len);

        logInfo("Successfully decrypted API key: " + encrypted_key.key_id);
        return true;
    }

private:
    std::vector<unsigned char> master_key_;  // 256-bit master key
    void* secure_memory_ = nullptr;
    size_t secure_memory_size_ = 4096;

    void allocateSecureMemory() {
        // Allocate memory that won't be swapped to disk
        secure_memory_ = mmap(nullptr, secure_memory_size_,
                             PROT_READ | PROT_WRITE,
                             MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

        if (secure_memory_ == MAP_FAILED) {
            logError("Failed to allocate secure memory");
            return;
        }

        // Lock memory to prevent swapping
        if (mlock(secure_memory_, secure_memory_size_) != 0) {
            logWarning("Failed to lock memory (requires elevated privileges)");
        }

        // Initialize master key from HSM/KMS
        loadMasterKeyFromHSM();
    }

    void secureWipeMemory() {
        if (secure_memory_ != nullptr && secure_memory_ != MAP_FAILED) {
            // Securely wipe memory
            OPENSSL_cleanse(secure_memory_, secure_memory_size_);
            munlock(secure_memory_, secure_memory_size_);
            munmap(secure_memory_, secure_memory_size_);
        }

        // Wipe master key
        OPENSSL_cleanse(master_key_.data(), master_key_.size());
    }

    void loadMasterKeyFromHSM() {
        // In production, retrieve from HSM or KMS
        // For this example, generate a random key (DO NOT USE IN PRODUCTION)
        master_key_.resize(32);  // 256 bits
        RAND_bytes(master_key_.data(), 32);

        logWarning("Using randomly generated master key (DEVELOPMENT ONLY)");
    }

    void logError(const std::string& msg) {
        // Log to secure audit system
    }

    void logWarning(const std::string& msg) {
        // Log to audit system
    }

    void logInfo(const std::string& msg) {
        // Log to audit system
    }
};
```

================================================================================
4. KEY GENERATION AND REGISTRATION
================================================================================

4.1 AUTOMATED KEY GENERATION
-----------------------------

```cpp
#include <random>
#include <algorithm>
#include <sstream>
#include <iomanip>

class APIKeyGenerator {
public:
    struct APIKeyPair {
        std::string key_id;
        std::string api_key;
        std::string api_secret;
        std::string exchange;
        std::vector<std::string> permissions;
        std::time_t created_at;
        std::time_t expires_at;
    };

    // Generate cryptographically secure API key pair
    APIKeyPair generateKeyPair(const std::string& exchange,
                               const std::vector<std::string>& permissions,
                               int validity_days = 90) {
        APIKeyPair key_pair;

        // Generate unique key ID
        key_pair.key_id = generateUUID();
        key_pair.exchange = exchange;
        key_pair.permissions = permissions;
        key_pair.created_at = std::time(nullptr);
        key_pair.expires_at = key_pair.created_at + (validity_days * 24 * 3600);

        // Generate API key (64 characters)
        key_pair.api_key = generateSecureRandomString(64);

        // Generate API secret (64 characters, higher entropy)
        key_pair.api_secret = generateSecureRandomString(64);

        // Log key generation event (DO NOT log the actual keys)
        auditLog("API_KEY_GENERATED", key_pair.key_id, exchange);

        return key_pair;
    }

private:
    std::string generateSecureRandomString(size_t length) {
        const char charset[] =
            "0123456789"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz";

        std::vector<unsigned char> random_bytes(length);
        if (RAND_bytes(random_bytes.data(), length) != 1) {
            throw std::runtime_error("Failed to generate random bytes");
        }

        std::string result;
        result.reserve(length);
        for (size_t i = 0; i < length; ++i) {
            result += charset[random_bytes[i] % (sizeof(charset) - 1)];
        }

        return result;
    }

    std::string generateUUID() {
        std::random_device rd;
        std::mt19937_64 gen(rd());
        std::uniform_int_distribution<uint64_t> dis;

        uint64_t high = dis(gen);
        uint64_t low = dis(gen);

        std::stringstream ss;
        ss << std::hex << std::setfill('0')
           << std::setw(16) << high
           << std::setw(16) << low;

        return ss.str();
    }

    void auditLog(const std::string& event, const std::string& key_id,
                 const std::string& exchange) {
        // Log to security audit system
    }
};
```

4.2 EXCHANGE REGISTRATION WORKFLOW
-----------------------------------

```python
#!/usr/bin/env python3
"""
Exchange API Key Registration Script
Automates the process of registering API keys with exchanges
"""

import requests
import hmac
import hashlib
import time
import json
from typing import Dict, List, Optional

class ExchangeKeyRegistrar:
    """Handles API key registration with various exchanges"""

    def __init__(self, config_file: str):
        with open(config_file, 'r') as f:
            self.config = json.load(f)

    def register_binance_key(self, api_key: str, api_secret: str,
                            permissions: List[str],
                            ip_whitelist: Optional[List[str]] = None) -> Dict:
        """
        Register API key with Binance exchange

        Args:
            api_key: API key to register
            api_secret: API secret for authentication
            permissions: List of permissions (e.g., ['SPOT', 'MARGIN'])
            ip_whitelist: List of IP addresses to whitelist

        Returns:
            Registration response dictionary
        """
        endpoint = "https://api.binance.com/sapi/v1/account/apiRestrictions"

        # Create signature
        timestamp = int(time.time() * 1000)
        params = {
            'timestamp': timestamp,
            'permissions': ','.join(permissions)
        }

        if ip_whitelist:
            params['ipRestrict'] = True
            params['ipList'] = ','.join(ip_whitelist)

        query_string = '&'.join([f"{k}={v}" for k, v in params.items()])
        signature = hmac.new(
            api_secret.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

        params['signature'] = signature

        headers = {
            'X-MBX-APIKEY': api_key
        }

        response = requests.post(endpoint, params=params, headers=headers)

        if response.status_code == 200:
            print(f"✓ Successfully registered API key with Binance")
            return response.json()
        else:
            print(f"✗ Failed to register API key: {response.text}")
            return {'error': response.text}

    def register_coinbase_key(self, api_key: str, api_secret: str,
                             passphrase: str,
                             permissions: List[str]) -> Dict:
        """Register API key with Coinbase Pro"""
        endpoint = "https://api.pro.coinbase.com/profiles"

        timestamp = str(time.time())
        message = timestamp + 'GET' + '/profiles'

        signature = hmac.new(
            api_secret.encode('utf-8'),
            message.encode('utf-8'),
            hashlib.sha256
        ).digest().hex()

        headers = {
            'CB-ACCESS-KEY': api_key,
            'CB-ACCESS-SIGN': signature,
            'CB-ACCESS-TIMESTAMP': timestamp,
            'CB-ACCESS-PASSPHRASE': passphrase,
            'Content-Type': 'application/json'
        }

        response = requests.get(endpoint, headers=headers)

        if response.status_code == 200:
            print(f"✓ Successfully validated API key with Coinbase Pro")
            return response.json()
        else:
            print(f"✗ Failed to validate API key: {response.text}")
            return {'error': response.text}

    def test_api_key(self, exchange: str, api_key: str, api_secret: str) -> bool:
        """
        Test API key by making a simple authenticated request

        Args:
            exchange: Exchange name (binance, coinbase, kraken, etc.)
            api_key: API key to test
            api_secret: API secret

        Returns:
            True if key is valid, False otherwise
        """
        if exchange == 'binance':
            return self._test_binance_key(api_key, api_secret)
        elif exchange == 'coinbase':
            return self._test_coinbase_key(api_key, api_secret)
        elif exchange == 'kraken':
            return self._test_kraken_key(api_key, api_secret)
        else:
            print(f"✗ Unsupported exchange: {exchange}")
            return False

    def _test_binance_key(self, api_key: str, api_secret: str) -> bool:
        """Test Binance API key"""
        endpoint = "https://api.binance.com/api/v3/account"

        timestamp = int(time.time() * 1000)
        query_string = f"timestamp={timestamp}"

        signature = hmac.new(
            api_secret.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

        headers = {'X-MBX-APIKEY': api_key}
        params = {'timestamp': timestamp, 'signature': signature}

        try:
            response = requests.get(endpoint, params=params, headers=headers, timeout=5)
            return response.status_code == 200
        except Exception as e:
            print(f"✗ API key test failed: {e}")
            return False

    def _test_coinbase_key(self, api_key: str, api_secret: str) -> bool:
        """Test Coinbase Pro API key"""
        # Implementation similar to register_coinbase_key
        pass

    def _test_kraken_key(self, api_key: str, api_secret: str) -> bool:
        """Test Kraken API key"""
        # Implementation for Kraken
        pass

def main():
    """Main registration workflow"""
    registrar = ExchangeKeyRegistrar('/etc/hft/exchange_config.json')

    # Example: Register Binance API key
    api_key = "YOUR_API_KEY_HERE"  # Retrieved from Vault
    api_secret = "YOUR_API_SECRET_HERE"  # Retrieved from Vault

    # Test the key first
    if registrar.test_api_key('binance', api_key, api_secret):
        print("✓ API key is valid")

        # Register with specific permissions
        result = registrar.register_binance_key(
            api_key,
            api_secret,
            permissions=['SPOT', 'MARGIN'],
            ip_whitelist=['203.0.113.10', '203.0.113.11']
        )

        print(f"Registration result: {json.dumps(result, indent=2)}")
    else:
        print("✗ API key validation failed")

if __name__ == '__main__':
    main()
```

================================================================================
5. KEY ROTATION STRATEGY
================================================================================

5.1 ROTATION POLICIES
----------------------

ROTATION FREQUENCY BY EXCHANGE:
- Binance: Every 30 days
- Coinbase Pro: Every 60 days
- Kraken: Every 60 days
- FTX: Every 45 days
- Traditional Exchanges (CME, NYSE): Every 90 days

ROTATION TRIGGERS:
1. Scheduled rotation (time-based)
2. Security incident detected
3. Employee access changes
4. Compromised credential detected
5. Regulatory audit requirement
6. System upgrade or migration

5.2 ZERO-DOWNTIME ROTATION IMPLEMENTATION
------------------------------------------

```cpp
#include <memory>
#include <atomic>
#include <mutex>
#include <chrono>

class APIKeyRotationManager {
public:
    struct KeyVersion {
        std::string key_id;
        std::string api_key;
        std::string api_secret;
        int version;
        std::time_t created_at;
        std::time_t valid_until;
        bool is_active;
    };

    // Dual-key pattern: maintain both old and new keys during rotation
    void rotateKey(const std::string& exchange, const std::string& key_id) {
        std::lock_guard<std::mutex> lock(rotation_mutex_);

        // Step 1: Generate new key
        auto new_key = generateNewKey(exchange, key_id);

        // Step 2: Register new key with exchange
        if (!registerKeyWithExchange(exchange, new_key)) {
            logError("Failed to register new key with exchange");
            return;
        }

        // Step 3: Store new key in Vault
        if (!storeKeyInVault(new_key)) {
            logError("Failed to store new key in Vault");
            // Attempt to revoke the key from exchange
            revokeKeyFromExchange(exchange, new_key.api_key);
            return;
        }

        // Step 4: Update in-memory cache with both keys
        auto old_key = getActiveKey(exchange, key_id);
        setDualKeyMode(exchange, key_id, old_key, new_key);

        // Step 5: Grace period - both keys are active for 1 hour
        std::this_thread::sleep_for(std::chrono::hours(1));

        // Step 6: Deactivate old key
        deactivateKey(exchange, old_key.key_id);

        // Step 7: Revoke old key from exchange (after grace period)
        revokeKeyFromExchange(exchange, old_key.api_key);

        // Step 8: Remove old key from Vault
        removeKeyFromVault(old_key.key_id);

        logInfo("Successfully rotated API key: " + key_id);
        auditLog("API_KEY_ROTATED", key_id, exchange);
    }

    // Get active key for exchange (handles rotation transparently)
    KeyVersion getActiveKey(const std::string& exchange,
                           const std::string& key_id) {
        std::lock_guard<std::mutex> lock(key_cache_mutex_);

        auto it = key_cache_.find(exchange + ":" + key_id);
        if (it != key_cache_.end()) {
            return it->second.primary_key;
        }

        // Cache miss - fetch from Vault
        return fetchKeyFromVault(exchange, key_id);
    }

private:
    struct DualKeyEntry {
        KeyVersion primary_key;
        KeyVersion secondary_key;
        bool in_rotation;
        std::time_t rotation_started;
    };

    std::mutex rotation_mutex_;
    std::mutex key_cache_mutex_;
    std::map<std::string, DualKeyEntry> key_cache_;

    KeyVersion generateNewKey(const std::string& exchange,
                             const std::string& key_id) {
        // Implementation
        KeyVersion key;
        // ... generate key
        return key;
    }

    bool registerKeyWithExchange(const std::string& exchange,
                                const KeyVersion& key) {
        // Exchange-specific registration logic
        return true;
    }

    bool storeKeyInVault(const KeyVersion& key) {
        // Store in HashiCorp Vault or AWS Secrets Manager
        return true;
    }

    void revokeKeyFromExchange(const std::string& exchange,
                              const std::string& api_key) {
        // Revoke key from exchange
    }

    void setDualKeyMode(const std::string& exchange,
                       const std::string& key_id,
                       const KeyVersion& old_key,
                       const KeyVersion& new_key) {
        std::lock_guard<std::mutex> lock(key_cache_mutex_);

        DualKeyEntry entry;
        entry.primary_key = new_key;
        entry.secondary_key = old_key;
        entry.in_rotation = true;
        entry.rotation_started = std::time(nullptr);

        key_cache_[exchange + ":" + key_id] = entry;
    }

    void deactivateKey(const std::string& exchange, const std::string& key_id) {
        // Mark key as inactive
    }

    void removeKeyFromVault(const std::string& key_id) {
        // Remove from Vault
    }

    KeyVersion fetchKeyFromVault(const std::string& exchange,
                                 const std::string& key_id) {
        // Fetch from Vault
        KeyVersion key;
        return key;
    }

    void logError(const std::string& msg) {}
    void logInfo(const std::string& msg) {}
    void auditLog(const std::string& event, const std::string& key_id,
                 const std::string& exchange) {}
};
```

5.3 AUTOMATED ROTATION SCHEDULER
---------------------------------

```python
#!/usr/bin/env python3
"""
Automated API Key Rotation Scheduler
Handles scheduled rotation of all exchange API keys
"""

import schedule
import time
import logging
from datetime import datetime, timedelta
from typing import List, Dict
import hvac  # HashiCorp Vault client
import boto3  # AWS SDK

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class APIKeyRotationScheduler:
    """Manages scheduled rotation of API keys"""

    def __init__(self, vault_addr: str, vault_token: str):
        self.vault_client = hvac.Client(url=vault_addr, token=vault_token)
        self.rotation_history = []

    def schedule_rotations(self):
        """Set up rotation schedules for all exchanges"""

        # Binance - every 30 days at 2 AM UTC
        schedule.every(30).days.at("02:00").do(
            self.rotate_exchange_keys, exchange='binance'
        )

        # Coinbase - every 60 days at 3 AM UTC
        schedule.every(60).days.at("03:00").do(
            self.rotate_exchange_keys, exchange='coinbase'
        )

        # Kraken - every 60 days at 4 AM UTC
        schedule.every(60).days.at("04:00").do(
            self.rotate_exchange_keys, exchange='kraken'
        )

        # CME - every 90 days at 5 AM UTC
        schedule.every(90).days.at("05:00").do(
            self.rotate_exchange_keys, exchange='cme'
        )

        logger.info("API key rotation schedules configured")

    def rotate_exchange_keys(self, exchange: str):
        """Rotate all API keys for a specific exchange"""
        logger.info(f"Starting rotation for {exchange} exchange")

        try:
            # Get all keys for this exchange
            keys = self.get_exchange_keys(exchange)

            for key_info in keys:
                self.rotate_single_key(exchange, key_info)

            # Send notification
            self.send_rotation_notification(exchange, success=True)

        except Exception as e:
            logger.error(f"Rotation failed for {exchange}: {e}")
            self.send_rotation_notification(exchange, success=False, error=str(e))

    def rotate_single_key(self, exchange: str, key_info: Dict):
        """Rotate a single API key"""
        key_id = key_info['key_id']
        logger.info(f"Rotating key {key_id} for {exchange}")

        # Step 1: Generate new key pair
        new_key, new_secret = self.generate_key_pair()

        # Step 2: Register with exchange
        registration_success = self.register_with_exchange(
            exchange, new_key, new_secret, key_info['permissions']
        )

        if not registration_success:
            raise Exception(f"Failed to register new key with {exchange}")

        # Step 3: Store new key in Vault
        self.store_in_vault(exchange, key_id, new_key, new_secret)

        # Step 4: Update application configuration
        self.update_application_config(exchange, key_id, new_key)

        # Step 5: Monitor for errors during grace period (1 hour)
        self.monitor_key_usage(exchange, key_id, duration_minutes=60)

        # Step 6: Revoke old key
        old_key = key_info['api_key']
        self.revoke_from_exchange(exchange, old_key)

        # Record rotation
        self.rotation_history.append({
            'exchange': exchange,
            'key_id': key_id,
            'rotated_at': datetime.utcnow().isoformat(),
            'status': 'success'
        })

        logger.info(f"Successfully rotated key {key_id}")

    def get_exchange_keys(self, exchange: str) -> List[Dict]:
        """Retrieve all API keys for an exchange from Vault"""
        secret_path = f'secret/exchanges/{exchange}/keys'

        try:
            response = self.vault_client.secrets.kv.v2.list_secrets(
                path=f'exchanges/{exchange}'
            )

            keys = []
            for key_name in response['data']['keys']:
                key_data = self.vault_client.secrets.kv.v2.read_secret_version(
                    path=f'exchanges/{exchange}/{key_name}'
                )
                keys.append(key_data['data']['data'])

            return keys

        except Exception as e:
            logger.error(f"Failed to retrieve keys from Vault: {e}")
            return []

    def generate_key_pair(self) -> tuple:
        """Generate a new API key pair"""
        import secrets
        import string

        alphabet = string.ascii_letters + string.digits
        new_key = ''.join(secrets.choice(alphabet) for _ in range(64))
        new_secret = ''.join(secrets.choice(alphabet) for _ in range(64))

        return new_key, new_secret

    def register_with_exchange(self, exchange: str, api_key: str,
                              api_secret: str, permissions: List[str]) -> bool:
        """Register new API key with exchange"""
        # Exchange-specific registration logic
        logger.info(f"Registering new key with {exchange}")
        return True

    def store_in_vault(self, exchange: str, key_id: str,
                      api_key: str, api_secret: str):
        """Store new key in Vault"""
        secret_path = f'exchanges/{exchange}/{key_id}'

        secret_data = {
            'api_key': api_key,
            'api_secret': api_secret,
            'created_at': datetime.utcnow().isoformat(),
            'expires_at': (datetime.utcnow() + timedelta(days=30)).isoformat()
        }

        self.vault_client.secrets.kv.v2.create_or_update_secret(
            path=secret_path,
            secret=secret_data
        )

        logger.info(f"Stored new key in Vault: {secret_path}")

    def update_application_config(self, exchange: str, key_id: str, api_key: str):
        """Update application configuration with new key"""
        # Trigger application config reload
        logger.info(f"Updating application config for {exchange}/{key_id}")

    def monitor_key_usage(self, exchange: str, key_id: str, duration_minutes: int):
        """Monitor new key for errors during grace period"""
        logger.info(f"Monitoring key {key_id} for {duration_minutes} minutes")

        end_time = datetime.utcnow() + timedelta(minutes=duration_minutes)
        error_count = 0

        while datetime.utcnow() < end_time:
            # Check error logs
            errors = self.check_key_errors(exchange, key_id)
            error_count += len(errors)

            if error_count > 10:
                logger.error(f"Too many errors for new key {key_id}, rolling back")
                self.rollback_rotation(exchange, key_id)
                raise Exception("Key rotation failed due to errors")

            time.sleep(60)  # Check every minute

    def check_key_errors(self, exchange: str, key_id: str) -> List[Dict]:
        """Check for errors related to the key"""
        # Query error logs
        return []

    def rollback_rotation(self, exchange: str, key_id: str):
        """Rollback to previous key if rotation fails"""
        logger.warning(f"Rolling back rotation for {key_id}")
        # Reactivate old key, revoke new key

    def revoke_from_exchange(self, exchange: str, api_key: str):
        """Revoke old API key from exchange"""
        logger.info(f"Revoking old key from {exchange}")

    def send_rotation_notification(self, exchange: str, success: bool, error: str = None):
        """Send notification about rotation status"""
        if success:
            logger.info(f"✓ Rotation completed successfully for {exchange}")
        else:
            logger.error(f"✗ Rotation failed for {exchange}: {error}")

    def run(self):
        """Run the scheduler"""
        logger.info("Starting API key rotation scheduler")
        self.schedule_rotations()

        while True:
            schedule.run_pending()
            time.sleep(60)

def main():
    vault_addr = 'http://vault.internal:8200'
    vault_token = 'YOUR_VAULT_TOKEN'  # Should be retrieved securely

    scheduler = APIKeyRotationScheduler(vault_addr, vault_token)
    scheduler.run()

if __name__ == '__main__':
    main()
```

================================================================================
6. MONITORING AND ALERTING
================================================================================

6.1 KEY USAGE MONITORING
-------------------------

```cpp
#include <prometheus/counter.h>
#include <prometheus/gauge.h>
#include <prometheus/histogram.h>

class APIKeyMonitor {
public:
    APIKeyMonitor() {
        // Initialize Prometheus metrics
        api_calls_total_ = prometheus::BuildCounter()
            .Name("api_key_calls_total")
            .Help("Total number of API calls per key")
            .Register(*registry_);

        api_errors_total_ = prometheus::BuildCounter()
            .Name("api_key_errors_total")
            .Help("Total number of API errors per key")
            .Register(*registry_);

        key_age_days_ = prometheus::BuildGauge()
            .Name("api_key_age_days")
            .Help("Age of API key in days")
            .Register(*registry_);

        api_latency_ = prometheus::BuildHistogram()
            .Name("api_call_latency_seconds")
            .Help("API call latency distribution")
            .Register(*registry_);
    }

    void recordAPICall(const std::string& exchange, const std::string& key_id,
                      bool success, double latency_seconds) {
        // Increment call counter
        api_calls_total_.Add({{"exchange", exchange}, {"key_id", key_id}}).Increment();

        // Record error if failed
        if (!success) {
            api_errors_total_.Add({{"exchange", exchange}, {"key_id", key_id}}).Increment();
            checkErrorThreshold(exchange, key_id);
        }

        // Record latency
        api_latency_.Add({{"exchange", exchange}}).Observe(latency_seconds);
    }

    void updateKeyAge(const std::string& exchange, const std::string& key_id,
                     int age_days) {
        key_age_days_.Add({{"exchange", exchange}, {"key_id", key_id}}).Set(age_days);

        // Alert if key is too old
        if (age_days > rotation_threshold_days_) {
            alertKeyRotationRequired(exchange, key_id, age_days);
        }
    }

private:
    std::shared_ptr<prometheus::Registry> registry_;
    prometheus::Family<prometheus::Counter>& api_calls_total_;
    prometheus::Family<prometheus::Counter>& api_errors_total_;
    prometheus::Family<prometheus::Gauge>& key_age_days_;
    prometheus::Family<prometheus::Histogram>& api_latency_;

    int rotation_threshold_days_ = 30;

    void checkErrorThreshold(const std::string& exchange, const std::string& key_id) {
        // Check if error rate exceeds threshold
        // If so, alert and potentially revoke key
    }

    void alertKeyRotationRequired(const std::string& exchange,
                                  const std::string& key_id, int age_days) {
        // Send alert via PagerDuty, Slack, etc.
    }
};
```

================================================================================
7. EMERGENCY KEY REVOCATION
================================================================================

7.1 IMMEDIATE REVOCATION PROCEDURE
-----------------------------------

```python
#!/usr/bin/env python3
"""
Emergency API Key Revocation Script
Use when a key compromise is detected
"""

import sys
import logging
from datetime import datetime

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def emergency_revoke_key(exchange: str, key_id: str, reason: str):
    """
    Immediately revoke an API key

    Args:
        exchange: Exchange name
        key_id: Key identifier
        reason: Revocation reason
    """
    logger.critical(f"EMERGENCY REVOCATION: {exchange}/{key_id}")
    logger.critical(f"Reason: {reason}")

    # Step 1: Disable key in application (immediate)
    disable_key_in_app(exchange, key_id)
    logger.info("✓ Key disabled in application")

    # Step 2: Revoke from exchange API
    revoke_from_exchange(exchange, key_id)
    logger.info("✓ Key revoked from exchange")

    # Step 3: Remove from Vault
    remove_from_vault(exchange, key_id)
    logger.info("✓ Key removed from Vault")

    # Step 4: Audit all recent activity
    audit_key_activity(exchange, key_id, hours=24)
    logger.info("✓ Audit initiated")

    # Step 5: Alert security team
    alert_security_team(exchange, key_id, reason)
    logger.info("✓ Security team alerted")

    # Step 6: Generate replacement key
    new_key_id = generate_replacement_key(exchange)
    logger.info(f"✓ Replacement key generated: {new_key_id}")

    logger.critical("EMERGENCY REVOCATION COMPLETE")

def disable_key_in_app(exchange: str, key_id: str):
    """Immediately disable key in application"""
    pass

def revoke_from_exchange(exchange: str, key_id: str):
    """Revoke key from exchange"""
    pass

def remove_from_vault(exchange: str, key_id: str):
    """Remove key from Vault"""
    pass

def audit_key_activity(exchange: str, key_id: str, hours: int):
    """Audit all activity for the key"""
    pass

def alert_security_team(exchange: str, key_id: str, reason: str):
    """Alert security team"""
    pass

def generate_replacement_key(exchange: str) -> str:
    """Generate replacement key"""
    return "new_key_id"

if __name__ == '__main__':
    if len(sys.argv) != 4:
        print("Usage: emergency_revoke.py <exchange> <key_id> <reason>")
        sys.exit(1)

    exchange = sys.argv[1]
    key_id = sys.argv[2]
    reason = sys.argv[3]

    confirm = input(f"Revoke {exchange}/{key_id}? (yes/no): ")
    if confirm.lower() == 'yes':
        emergency_revoke_key(exchange, key_id, reason)
    else:
        print("Revocation cancelled")
```

================================================================================
END OF DOCUMENT
================================================================================
