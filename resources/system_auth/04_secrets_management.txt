================================================================================
SECRETS MANAGEMENT
High-Frequency Trading System - Secure Secrets Storage and Access
================================================================================

VERSION: 2.0
LAST UPDATED: 2025-11-26
CLASSIFICATION: HIGHLY CONFIDENTIAL

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. Secrets Management Solutions
3. HashiCorp Vault Implementation
4. AWS Secrets Manager Integration
5. Secrets Lifecycle Management
6. C++ Vault Client Implementation
7. Python Automation Scripts
8. Dynamic Secrets Generation
9. Secrets Rotation Automation
10. Security Best Practices

================================================================================
1. OVERVIEW
================================================================================

Secrets are sensitive data that must be protected from unauthorized access:
- API keys and secrets for exchange connectivity
- Database passwords and connection strings
- TLS/SSL certificates and private keys
- Encryption keys for data at rest
- OAuth client secrets
- Service account credentials
- Hardware token PINs

CHALLENGES IN HFT SYSTEMS:

Performance Requirements:
- < 100μs latency for secrets retrieval (hot cache)
- < 10ms for cold cache / vault fetch
- High throughput (1M+ requests/sec)
- Zero downtime during rotation

Security Requirements:
- Encryption at rest (AES-256)
- Encryption in transit (TLS 1.3)
- Access control with audit logging
- Automatic rotation without service disruption
- Secure distribution to microservices
- Tamper detection and alerting

Operational Requirements:
- Centralized management of all secrets
- Version control and rollback capability
- Disaster recovery and backup
- Multi-region replication
- Compliance with SOC 2, PCI-DSS, GDPR

SECRETS MANAGEMENT ANTI-PATTERNS (NEVER DO THIS):

❌ Hardcoding secrets in source code
❌ Storing secrets in configuration files
❌ Committing secrets to version control (Git)
❌ Emailing or Slacking secrets
❌ Storing secrets in environment variables (on shared systems)
❌ Using weak encryption (DES, MD5, SHA1)
❌ Sharing secrets across environments (dev/staging/prod)
❌ Never rotating secrets

================================================================================
2. SECRETS MANAGEMENT SOLUTIONS
================================================================================

2.1 COMPARISON OF SOLUTIONS
----------------------------

SOLUTION              PROS                           CONS                    COST
------------------------------------------------------------------------------------
HashiCorp Vault      - Most feature-rich            - Complex setup         Open source
                     - Dynamic secrets              - Requires HA setup     (Enterprise: $$$$)
                     - Multi-cloud support          - Learning curve
                     - Active community

AWS Secrets Manager  - Managed service              - AWS lock-in           $$$
                     - Auto rotation                - Limited to AWS        ($0.40/secret/month)
                     - RDS integration              - Higher latency
                     - No maintenance

AWS Parameter Store  - Simple                       - Basic features        Free (Standard)
                     - Free tier                    - No auto rotation      $$ (Advanced)
                     - CloudFormation integration   - 10K limit

Azure Key Vault      - Azure native                 - Azure lock-in         $$$
                     - HSM support                  - Complex pricing
                     - Good for hybrid cloud

GCP Secret Manager   - GCP native                   - GCP lock-in           $$$
                     - Good IAM integration         - Newer product
                     - Automatic replication

RECOMMENDATION FOR HFT:
- Primary: HashiCorp Vault (flexibility, performance, multi-cloud)
- Backup: AWS Secrets Manager (managed service for AWS resources)
- HSM: Thales Luna HSM or AWS CloudHSM for master keys

2.2 ARCHITECTURE
----------------

┌─────────────────────────────────────────────────────────────────┐
│                   APPLICATION LAYER                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ Trading Eng  │  │ Risk Engine  │  │ Market Data  │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
└─────────┼──────────────────┼──────────────────┼─────────────────┘
          │                  │                  │
          │ Vault Client     │                  │
          ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────────────┐
│              SECRETS MANAGEMENT LAYER                            │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │         HashiCorp Vault Cluster (HA)                      │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │  │
│  │  │Vault Node 1 │  │Vault Node 2 │  │Vault Node 3 │      │  │
│  │  │  (Leader)   │  │ (Standby)   │  │ (Standby)   │      │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘      │  │
│  │                                                           │  │
│  │  Secret Engines:                                         │  │
│  │  - KV v2 (versioned secrets)                            │  │
│  │  - Database (dynamic DB credentials)                     │  │
│  │  - Transit (encryption as a service)                     │  │
│  │  - PKI (certificate generation)                          │  │
│  └───────────────────────────────────────────────────────────┘  │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    STORAGE BACKEND                               │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │         Consul Cluster (Encrypted Storage)                │  │
│  │  OR                                                       │  │
│  │         AWS DynamoDB (Multi-region replication)          │  │
│  └───────────────────────────────────────────────────────────┘  │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                 KEY MANAGEMENT SERVICE                           │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │         HSM / AWS KMS (Master Encryption Keys)           │  │
│  │  - FIPS 140-2 Level 3 certified                          │  │
│  │  - Automatic key rotation                                 │  │
│  │  - Audit logging                                          │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘

================================================================================
3. HASHICORP VAULT IMPLEMENTATION
================================================================================

3.1 VAULT INSTALLATION AND CONFIGURATION
-----------------------------------------

```bash
#!/bin/bash
# Install HashiCorp Vault

# Download Vault
wget https://releases.hashicorp.com/vault/1.15.0/vault_1.15.0_linux_amd64.zip
unzip vault_1.15.0_linux_amd64.zip
sudo mv vault /usr/local/bin/

# Create Vault user
sudo useradd --system --home /etc/vault.d --shell /bin/false vault

# Create directories
sudo mkdir -p /etc/vault.d
sudo mkdir -p /var/lib/vault/data

# Create Vault configuration
cat <<EOF | sudo tee /etc/vault.d/vault.hcl
# Storage backend (Consul for HA)
storage "consul" {
  address = "127.0.0.1:8500"
  path    = "vault/"
}

# Listener (API endpoint)
listener "tcp" {
  address     = "0.0.0.0:8200"
  tls_cert_file = "/etc/vault.d/tls/vault.crt"
  tls_key_file  = "/etc/vault.d/tls/vault.key"
  tls_min_version = "tls13"
}

# UI
ui = true

# Seal configuration (AWS KMS auto-unseal)
seal "awskms" {
  region     = "us-east-1"
  kms_key_id = "arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012"
}

# Telemetry
telemetry {
  prometheus_retention_time = "30s"
  disable_hostname = true
}

# API address
api_addr = "https://vault.example.com:8200"
cluster_addr = "https://vault-node1.internal:8201"
EOF

# Set permissions
sudo chown -R vault:vault /etc/vault.d /var/lib/vault

# Create systemd service
cat <<EOF | sudo tee /etc/systemd/system/vault.service
[Unit]
Description=HashiCorp Vault
Documentation=https://www.vaultproject.io/docs/
Requires=network-online.target
After=network-online.target
ConditionFileNotEmpty=/etc/vault.d/vault.hcl

[Service]
User=vault
Group=vault
ProtectSystem=full
ProtectHome=read-only
PrivateTmp=yes
PrivateDevices=yes
SecureBits=keep-caps
AmbientCapabilities=CAP_IPC_LOCK
Capabilities=CAP_IPC_LOCK+ep
CapabilityBoundingSet=CAP_SYSLOG CAP_IPC_LOCK
NoNewPrivileges=yes
ExecStart=/usr/local/bin/vault server -config=/etc/vault.d/vault.hcl
ExecReload=/bin/kill --signal HUP $MAINPID
KillMode=process
KillSignal=SIGINT
Restart=on-failure
RestartSec=5
TimeoutStopSec=30
LimitNOFILE=65536
LimitMEMLOCK=infinity

[Install]
WantedBy=multi-user.target
EOF

# Enable and start Vault
sudo systemctl enable vault
sudo systemctl start vault

# Initialize Vault (first time only)
vault operator init -key-shares=5 -key-threshold=3 > /tmp/vault_keys.txt

# Store unseal keys securely (distribute to key custodians)
echo "IMPORTANT: Store unseal keys in separate secure locations!"
echo "Keys written to /tmp/vault_keys.txt"
```

3.2 VAULT POLICY CONFIGURATION
-------------------------------

```hcl
# Trading service policy
path "secret/data/trading/*" {
  capabilities = ["read"]
}

path "secret/data/exchanges/*" {
  capabilities = ["read"]
}

path "database/creds/trading-db" {
  capabilities = ["read"]
}

path "transit/encrypt/trading" {
  capabilities = ["update"]
}

path "transit/decrypt/trading" {
  capabilities = ["update"]
}

# Risk management service policy
path "secret/data/risk/*" {
  capabilities = ["read"]
}

path "secret/data/trading/*" {
  capabilities = ["read"]
}

path "database/creds/risk-db" {
  capabilities = ["read"]
}

# Admin policy (for secret rotation and management)
path "secret/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

path "auth/*" {
  capabilities = ["create", "read", "update", "delete", "list", "sudo"]
}

path "sys/policies/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

path "database/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
```

Apply policies:

```bash
# Create policies
vault policy write trading-policy trading-policy.hcl
vault policy write risk-policy risk-policy.hcl
vault policy write admin-policy admin-policy.hcl

# Enable AppRole authentication
vault auth enable approle

# Create AppRole for trading service
vault write auth/approle/role/trading-service \
    token_ttl=1h \
    token_max_ttl=4h \
    policies="trading-policy"

# Get RoleID and SecretID
vault read auth/approle/role/trading-service/role-id
vault write -f auth/approle/role/trading-service/secret-id
```

================================================================================
4. C++ VAULT CLIENT IMPLEMENTATION
================================================================================

4.1 VAULT CLIENT CLASS
-----------------------

```cpp
#include <curl/curl.h>
#include <json/json.h>
#include <string>
#include <memory>
#include <mutex>
#include <chrono>

class VaultClient {
public:
    struct Config {
        std::string vault_addr;       // e.g., "https://vault.example.com:8200"
        std::string role_id;          // AppRole role ID
        std::string secret_id;        // AppRole secret ID
        std::string namespace;        // Vault namespace (Enterprise feature)
        int timeout_ms = 5000;        // Request timeout
        bool verify_ssl = true;       // Verify SSL certificates
        std::string ca_cert_path;     // Path to CA certificate
    };

    VaultClient(const Config& config) : config_(config) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        authenticate();
    }

    ~VaultClient() {
        curl_global_cleanup();
    }

    // Get secret from KV v2 engine
    std::string getSecret(const std::string& path, const std::string& key) {
        std::lock_guard<std::mutex> lock(mutex_);

        // Check if token needs renewal
        if (isTokenExpired()) {
            authenticate();
        }

        // Build request URL
        std::string url = config_.vault_addr + "/v1/secret/data/" + path;

        // Make GET request
        Json::Value response = makeRequest("GET", url, Json::Value());

        // Extract secret value
        if (response["data"]["data"].isMember(key)) {
            return response["data"]["data"][key].asString();
        }

        throw std::runtime_error("Secret key not found: " + key);
    }

    // Get multiple secrets at once
    std::map<std::string, std::string> getSecrets(const std::string& path) {
        std::lock_guard<std::mutex> lock(mutex_);

        if (isTokenExpired()) {
            authenticate();
        }

        std::string url = config_.vault_addr + "/v1/secret/data/" + path;
        Json::Value response = makeRequest("GET", url, Json::Value());

        std::map<std::string, std::string> secrets;
        Json::Value data = response["data"]["data"];

        for (const auto& key : data.getMemberNames()) {
            secrets[key] = data[key].asString();
        }

        return secrets;
    }

    // Write secret to KV v2 engine
    bool putSecret(const std::string& path, const std::string& key,
                  const std::string& value) {
        std::lock_guard<std::mutex> lock(mutex_);

        if (isTokenExpired()) {
            authenticate();
        }

        std::string url = config_.vault_addr + "/v1/secret/data/" + path;

        // Prepare request body
        Json::Value data;
        data["data"][key] = value;

        // Make POST request
        try {
            makeRequest("POST", url, data);
            return true;
        } catch (const std::exception& e) {
            logError("Failed to write secret: " + std::string(e.what()));
            return false;
        }
    }

    // Get dynamic database credentials
    struct DBCredentials {
        std::string username;
        std::string password;
        std::time_t lease_id;
        int lease_duration;
    };

    DBCredentials getDatabaseCredentials(const std::string& role_name) {
        std::lock_guard<std::mutex> lock(mutex_);

        if (isTokenExpired()) {
            authenticate();
        }

        std::string url = config_.vault_addr + "/v1/database/creds/" + role_name;
        Json::Value response = makeRequest("GET", url, Json::Value());

        DBCredentials creds;
        creds.username = response["data"]["username"].asString();
        creds.password = response["data"]["password"].asString();
        creds.lease_duration = response["lease_duration"].asInt();

        return creds;
    }

    // Encrypt data using Transit engine
    std::string encrypt(const std::string& key_name, const std::string& plaintext) {
        std::lock_guard<std::mutex> lock(mutex_);

        if (isTokenExpired()) {
            authenticate();
        }

        std::string url = config_.vault_addr + "/v1/transit/encrypt/" + key_name;

        // Base64 encode plaintext
        std::string base64_plaintext = base64Encode(plaintext);

        Json::Value data;
        data["plaintext"] = base64_plaintext;

        Json::Value response = makeRequest("POST", url, data);

        return response["data"]["ciphertext"].asString();
    }

    // Decrypt data using Transit engine
    std::string decrypt(const std::string& key_name, const std::string& ciphertext) {
        std::lock_guard<std::mutex> lock(mutex_);

        if (isTokenExpired()) {
            authenticate();
        }

        std::string url = config_.vault_addr + "/v1/transit/decrypt/" + key_name;

        Json::Value data;
        data["ciphertext"] = ciphertext;

        Json::Value response = makeRequest("POST", url, data);

        // Base64 decode plaintext
        std::string base64_plaintext = response["data"]["plaintext"].asString();
        return base64Decode(base64_plaintext);
    }

private:
    Config config_;
    std::string token_;
    std::time_t token_expiry_;
    std::mutex mutex_;

    // Authenticate with Vault using AppRole
    void authenticate() {
        std::string url = config_.vault_addr + "/v1/auth/approle/login";

        Json::Value login_data;
        login_data["role_id"] = config_.role_id;
        login_data["secret_id"] = config_.secret_id;

        Json::Value response = makeRequest("POST", url, login_data, false);

        token_ = response["auth"]["client_token"].asString();
        int ttl = response["auth"]["lease_duration"].asInt();
        token_expiry_ = std::time(nullptr) + ttl - 300;  // Renew 5 min before expiry

        logInfo("Successfully authenticated with Vault");
    }

    bool isTokenExpired() {
        return std::time(nullptr) >= token_expiry_;
    }

    // Make HTTP request to Vault
    Json::Value makeRequest(const std::string& method,
                           const std::string& url,
                           const Json::Value& data,
                           bool use_token = true) {
        CURL* curl = curl_easy_init();
        if (!curl) {
            throw std::runtime_error("Failed to initialize CURL");
        }

        // Set URL
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

        // Set method
        if (method == "POST") {
            curl_easy_setopt(curl, CURLOPT_POST, 1L);
        } else if (method == "PUT") {
            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT");
        } else if (method == "DELETE") {
            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
        }

        // Set headers
        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers, "Content-Type: application/json");

        if (use_token && !token_.empty()) {
            std::string auth_header = "X-Vault-Token: " + token_;
            headers = curl_slist_append(headers, auth_header.c_str());
        }

        if (!config_.namespace.empty()) {
            std::string ns_header = "X-Vault-Namespace: " + config_.namespace;
            headers = curl_slist_append(headers, ns_header.c_str());
        }

        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

        // Set request body
        std::string request_body;
        if (!data.empty()) {
            Json::FastWriter writer;
            request_body = writer.write(data);
            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, request_body.c_str());
        }

        // Set timeout
        curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, config_.timeout_ms);

        // SSL verification
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, config_.verify_ssl ? 1L : 0L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, config_.verify_ssl ? 2L : 0L);

        if (!config_.ca_cert_path.empty()) {
            curl_easy_setopt(curl, CURLOPT_CAINFO, config_.ca_cert_path.c_str());
        }

        // Response buffer
        std::string response_str;
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_str);

        // Perform request
        CURLcode res = curl_easy_perform(curl);

        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        if (res != CURLE_OK) {
            throw std::runtime_error("CURL error: " + std::string(curl_easy_strerror(res)));
        }

        if (http_code < 200 || http_code >= 300) {
            throw std::runtime_error("HTTP error " + std::to_string(http_code) + ": " + response_str);
        }

        // Parse JSON response
        Json::Value response;
        Json::Reader reader;
        if (!reader.parse(response_str, response)) {
            throw std::runtime_error("Failed to parse JSON response");
        }

        return response;
    }

    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
        ((std::string*)userp)->append((char*)contents, size * nmemb);
        return size * nmemb;
    }

    std::string base64Encode(const std::string& input) {
        // Base64 encoding implementation
        static const char* base64_chars =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz"
            "0123456789+/";

        std::string output;
        int val = 0;
        int valb = -6;

        for (unsigned char c : input) {
            val = (val << 8) + c;
            valb += 8;
            while (valb >= 0) {
                output.push_back(base64_chars[(val >> valb) & 0x3F]);
                valb -= 6;
            }
        }

        if (valb > -6) {
            output.push_back(base64_chars[((val << 8) >> (valb + 8)) & 0x3F]);
        }

        while (output.size() % 4) {
            output.push_back('=');
        }

        return output;
    }

    std::string base64Decode(const std::string& input) {
        // Base64 decoding implementation
        static const unsigned char base64_table[256] = {
            64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
            // ... (full table)
        };

        std::string output;
        int val = 0;
        int valb = -8;

        for (unsigned char c : input) {
            if (base64_table[c] == 64) break;
            val = (val << 6) + base64_table[c];
            valb += 6;
            if (valb >= 0) {
                output.push_back(char((val >> valb) & 0xFF));
                valb -= 8;
            }
        }

        return output;
    }

    void logError(const std::string& msg) {
        // Log to system
    }

    void logInfo(const std::string& msg) {
        // Log to system
    }
};
```

4.2 CACHING VAULT CLIENT
-------------------------

```cpp
#include <unordered_map>
#include <chrono>

class CachingVaultClient {
public:
    CachingVaultClient(const VaultClient::Config& config,
                      int cache_ttl_seconds = 300)
        : vault_client_(config), cache_ttl_(cache_ttl_seconds) {}

    std::string getSecret(const std::string& path, const std::string& key) {
        std::lock_guard<std::mutex> lock(cache_mutex_);

        std::string cache_key = path + ":" + key;

        // Check cache
        auto it = secret_cache_.find(cache_key);
        if (it != secret_cache_.end()) {
            auto& entry = it->second;
            auto age = std::chrono::steady_clock::now() - entry.cached_at;

            if (age < std::chrono::seconds(cache_ttl_)) {
                cache_hits_++;
                return entry.value;
            }
        }

        // Cache miss - fetch from Vault
        cache_misses_++;
        std::string value = vault_client_.getSecret(path, key);

        // Update cache
        CacheEntry entry;
        entry.value = value;
        entry.cached_at = std::chrono::steady_clock::now();
        secret_cache_[cache_key] = entry;

        return value;
    }

    void invalidateCache() {
        std::lock_guard<std::mutex> lock(cache_mutex_);
        secret_cache_.clear();
    }

    void getCacheStats(int& hits, int& misses) {
        hits = cache_hits_.load();
        misses = cache_misses_.load();
    }

private:
    struct CacheEntry {
        std::string value;
        std::chrono::steady_clock::time_point cached_at;
    };

    VaultClient vault_client_;
    std::unordered_map<std::string, CacheEntry> secret_cache_;
    std::mutex cache_mutex_;
    int cache_ttl_;
    std::atomic<int> cache_hits_{0};
    std::atomic<int> cache_misses_{0};
};
```

================================================================================
5. AWS SECRETS MANAGER INTEGRATION
================================================================================

5.1 AWS SECRETS MANAGER CLIENT
-------------------------------

```cpp
#include <aws/core/Aws.h>
#include <aws/secretsmanager/SecretsManagerClient.h>
#include <aws/secretsmanager/model/GetSecretValueRequest.h>
#include <aws/secretsmanager/model/CreateSecretRequest.h>
#include <aws/secretsmanager/model/UpdateSecretRequest.h>

class AWSSecretsManagerClient {
public:
    AWSSecretsManagerClient(const std::string& region = "us-east-1") {
        Aws::SDKOptions options;
        Aws::InitAPI(options);

        Aws::Client::ClientConfiguration config;
        config.region = region;

        client_ = std::make_unique<Aws::SecretsManager::SecretsManagerClient>(config);
    }

    ~AWSSecretsManagerClient() {
        Aws::SDKOptions options;
        Aws::ShutdownAPI(options);
    }

    std::string getSecret(const std::string& secret_name) {
        Aws::SecretsManager::Model::GetSecretValueRequest request;
        request.SetSecretId(secret_name);

        auto outcome = client_->GetSecretValue(request);

        if (outcome.IsSuccess()) {
            auto& result = outcome.GetResult();

            if (result.SecretStringHasBeenSet()) {
                return result.GetSecretString();
            } else {
                // Binary secret
                auto& buffer = result.GetSecretBinary();
                return std::string(reinterpret_cast<const char*>(buffer.GetUnderlyingData()),
                                 buffer.GetLength());
            }
        } else {
            throw std::runtime_error("Failed to get secret: " +
                                   outcome.GetError().GetMessage());
        }
    }

    bool createSecret(const std::string& secret_name, const std::string& secret_value) {
        Aws::SecretsManager::Model::CreateSecretRequest request;
        request.SetName(secret_name);
        request.SetSecretString(secret_value);

        auto outcome = client_->CreateSecret(request);

        if (outcome.IsSuccess()) {
            logInfo("Created secret: " + secret_name);
            return true;
        } else {
            logError("Failed to create secret: " + outcome.GetError().GetMessage());
            return false;
        }
    }

    bool updateSecret(const std::string& secret_name, const std::string& secret_value) {
        Aws::SecretsManager::Model::UpdateSecretRequest request;
        request.SetSecretId(secret_name);
        request.SetSecretString(secret_value);

        auto outcome = client_->UpdateSecret(request);

        if (outcome.IsSuccess()) {
            logInfo("Updated secret: " + secret_name);
            return true;
        } else {
            logError("Failed to update secret: " + outcome.GetError().GetMessage());
            return false;
        }
    }

private:
    std::unique_ptr<Aws::SecretsManager::SecretsManagerClient> client_;

    void logInfo(const std::string& msg) {}
    void logError(const std::string& msg) {}
};
```

================================================================================
6. SECRETS ROTATION AUTOMATION
================================================================================

6.1 AUTOMATED ROTATION SCRIPT
------------------------------

```python
#!/usr/bin/env python3
"""
Automated Secrets Rotation Script
Rotates secrets in Vault on a schedule
"""

import hvac
import schedule
import time
import logging
from datetime import datetime, timedelta
from typing import Dict, List
import secrets
import string

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SecretsRotationManager:
    """Manages automated rotation of secrets"""

    def __init__(self, vault_addr: str, vault_token: str):
        self.vault_client = hvac.Client(url=vault_addr, token=vault_token)

    def rotate_api_key(self, path: str, key_name: str):
        """Rotate an API key"""
        logger.info(f"Rotating API key: {path}/{key_name}")

        # Generate new API key
        new_key = self.generate_secure_key(64)
        new_secret = self.generate_secure_key(64)

        # Read existing secret to preserve other fields
        existing = self.vault_client.secrets.kv.v2.read_secret_version(path=path)
        data = existing['data']['data'].copy()

        # Update key and secret
        data[f'{key_name}_old'] = data.get(key_name, '')
        data[key_name] = new_key
        data[f'{key_name}_secret_old'] = data.get(f'{key_name}_secret', '')
        data[f'{key_name}_secret'] = new_secret
        data['rotated_at'] = datetime.utcnow().isoformat()

        # Write back to Vault
        self.vault_client.secrets.kv.v2.create_or_update_secret(
            path=path,
            secret=data
        )

        logger.info(f"Successfully rotated API key: {path}/{key_name}")

        # Notify applications of rotation
        self.notify_rotation(path, key_name)

    def rotate_database_password(self, connection_name: str):
        """Rotate database password"""
        logger.info(f"Rotating database password: {connection_name}")

        # Trigger rotation in Vault's database engine
        self.vault_client.secrets.database.rotate_root_credentials(
            name=connection_name
        )

        logger.info(f"Successfully rotated database password: {connection_name}")

    def generate_secure_key(self, length: int) -> str:
        """Generate cryptographically secure random key"""
        alphabet = string.ascii_letters + string.digits
        return ''.join(secrets.choice(alphabet) for _ in range(length))

    def notify_rotation(self, path: str, key_name: str):
        """Notify applications that secret was rotated"""
        # Send webhook notification
        # Publish to message queue (RabbitMQ, Kafka)
        # Update service discovery
        pass

    def schedule_rotations(self):
        """Set up rotation schedules"""

        # Exchange API keys - rotate every 30 days
        schedule.every(30).days.do(
            self.rotate_api_key, path='exchanges/binance', key_name='api_key'
        )
        schedule.every(30).days.do(
            self.rotate_api_key, path='exchanges/coinbase', key_name='api_key'
        )

        # Database passwords - rotate every 90 days
        schedule.every(90).days.do(
            self.rotate_database_password, connection_name='trading-db'
        )

        # TLS certificates - rotate every 60 days
        schedule.every(60).days.do(
            self.rotate_tls_certificate, domain='api.trading.example.com'
        )

        logger.info("Rotation schedules configured")

    def rotate_tls_certificate(self, domain: str):
        """Rotate TLS certificate using Vault PKI"""
        logger.info(f"Rotating TLS certificate for: {domain}")

        # Generate new certificate
        cert_response = self.vault_client.secrets.pki.generate_certificate(
            name='trading-role',
            common_name=domain,
            ttl='60d'
        )

        certificate = cert_response['data']['certificate']
        private_key = cert_response['data']['private_key']
        ca_chain = cert_response['data']['ca_chain']

        # Store in Vault
        self.vault_client.secrets.kv.v2.create_or_update_secret(
            path=f'tls/{domain}',
            secret={
                'certificate': certificate,
                'private_key': private_key,
                'ca_chain': '\n'.join(ca_chain),
                'rotated_at': datetime.utcnow().isoformat()
            }
        )

        logger.info(f"Successfully rotated TLS certificate: {domain}")

    def run(self):
        """Run the rotation scheduler"""
        logger.info("Starting secrets rotation manager")
        self.schedule_rotations()

        while True:
            schedule.run_pending()
            time.sleep(3600)  # Check every hour

def main():
    vault_addr = 'https://vault.example.com:8200'
    vault_token = 'YOUR_VAULT_TOKEN'

    manager = SecretsRotationManager(vault_addr, vault_token)
    manager.run()

if __name__ == '__main__':
    main()
```

================================================================================
7. SECURITY BEST PRACTICES
================================================================================

1. NEVER log secrets in plaintext
2. USE short-lived credentials (< 1 hour for dynamic secrets)
3. ROTATE secrets regularly (API keys: 30-90 days, passwords: 90 days)
4. IMPLEMENT least privilege access (narrow Vault policies)
5. ENABLE Vault audit logging
6. USE auto-unseal with KMS (avoid manual unsealing)
7. ENCRYPT Vault storage backend
8. MONITOR for unauthorized access attempts
9. TEST secret rotation procedures regularly
10. HAVE disaster recovery plan for Vault outage

================================================================================
END OF DOCUMENT
================================================================================
