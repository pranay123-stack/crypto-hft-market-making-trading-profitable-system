================================================================================
OAUTH 2.0 & JWT TOKEN INTEGRATION
High-Frequency Trading System - Modern Authentication Protocols
================================================================================

VERSION: 2.0
LAST UPDATED: 2025-11-26
CLASSIFICATION: CONFIDENTIAL

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. OAuth 2.0 Architecture
3. Authorization Code Flow
4. Client Credentials Flow
5. JWT Token Implementation
6. Token Validation and Refresh
7. C++ OAuth Client
8. Python OAuth Server
9. Security Best Practices
10. Integration Examples

================================================================================
1. OVERVIEW
================================================================================

OAuth 2.0 is an authorization framework that enables applications to obtain
limited access to user accounts on HTTP services. Combined with JWT (JSON Web
Tokens), it provides secure, stateless authentication for HFT systems.

KEY CONCEPTS:

Resource Owner: The user who owns the data (trader, analyst)
Client: The application requesting access (trading terminal, mobile app)
Authorization Server: Issues access tokens (our OAuth server)
Resource Server: Hosts protected resources (trading API, market data)
Access Token: Short-lived token granting access (15 min)
Refresh Token: Long-lived token to obtain new access tokens (7 days)

OAUTH 2.0 FLOWS:

1. Authorization Code Flow
   - For web applications with backend
   - Most secure flow
   - Requires user interaction

2. Client Credentials Flow
   - For machine-to-machine authentication
   - No user interaction
   - Service accounts

3. Resource Owner Password Credentials (DEPRECATED)
   - Direct password exchange
   - NOT RECOMMENDED (legacy only)

4. Implicit Flow (DEPRECATED)
   - For SPAs (Single Page Apps)
   - Replaced by Authorization Code + PKCE

WHY OAUTH 2.0 + JWT FOR HFT:

✓ Stateless authentication (no session storage)
✓ Scalable across microservices
✓ Fine-grained access control (scopes)
✓ Token expiration and refresh
✓ Support for mobile and web clients
✓ Industry standard with wide library support

================================================================================
2. OAUTH 2.0 ARCHITECTURE
================================================================================

2.1 SYSTEM COMPONENTS
----------------------

┌─────────────────────────────────────────────────────────────────┐
│                       CLIENT APPLICATION                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ Web Browser  │  │ Mobile App   │  │ Service      │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
└─────────┼──────────────────┼──────────────────┼─────────────────┘
          │                  │                  │
          │ 1. Auth Request  │                  │
          ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────────────┐
│              AUTHORIZATION SERVER                                │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  OAuth 2.0 Endpoints:                                     │  │
│  │  - /authorize (authorization code)                        │  │
│  │  - /token (token issuance)                                │  │
│  │  - /introspect (token validation)                         │  │
│  │  - /revoke (token revocation)                             │  │
│  │  - /.well-known/jwks.json (public keys)                   │  │
│  └───────────────────────────────────────────────────────────┘  │
└────────────────────────────┬────────────────────────────────────┘
                             │ 2. User Login & Consent
                             │ 3. Authorization Code
                             │ 4. Access + Refresh Tokens
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    RESOURCE SERVER                               │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  Protected Resources:                                     │  │
│  │  - Trading API                                            │  │
│  │  - Market Data API                                        │  │
│  │  - Risk Management API                                    │  │
│  │  - Analytics API                                          │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                  │
│  Validates JWT tokens using public key from Auth Server         │
└─────────────────────────────────────────────────────────────────┘

2.2 TOKEN STRUCTURE
-------------------

JWT ACCESS TOKEN:
```
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiJ1c2VyMTIzIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNzAwMDAwMDAwLCJleHAiOjE3MDAwMDA5MDAsInNjb3BlIjoidHJhZGluZzpyZWFkIHRyYWRpbmc6d3JpdGUifQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

Decoded Payload:
```json
{
  "sub": "user123",                    // Subject (user ID)
  "name": "John Doe",
  "email": "john.doe@trading.com",
  "iat": 1700000000,                   // Issued at (Unix timestamp)
  "exp": 1700000900,                   // Expiration (15 min)
  "scope": "trading:read trading:write market-data:read",
  "roles": ["Trader", "Analyst"],
  "iss": "https://auth.trading.com",   // Issuer
  "aud": "https://api.trading.com",    // Audience
  "jti": "abc123xyz"                   // JWT ID (unique)
}
```

REFRESH TOKEN (Opaque):
```
rt_abc123def456ghi789jkl012mno345pqr678stu901vwx234yz
```

- Stored in database with user association
- Long-lived (7 days)
- Can be revoked
- Used to obtain new access tokens

================================================================================
3. AUTHORIZATION CODE FLOW
================================================================================

3.1 FLOW DIAGRAM
----------------

1. User clicks "Login" on client application
2. Client redirects to /authorize endpoint with:
   - client_id
   - redirect_uri
   - response_type=code
   - scope (requested permissions)
   - state (CSRF protection)

3. User authenticates (username/password + MFA)
4. User consents to requested scopes
5. Authorization server redirects back to client with:
   - code (authorization code, single-use, 10-minute expiry)
   - state (must match original)

6. Client exchanges code for tokens at /token endpoint:
   - code
   - client_id
   - client_secret
   - grant_type=authorization_code
   - redirect_uri (must match)

7. Authorization server validates and returns:
   - access_token (JWT)
   - refresh_token (opaque)
   - expires_in (seconds)
   - token_type=Bearer
   - scope (granted scopes)

8. Client uses access_token to call APIs

3.2 IMPLEMENTATION
------------------

```cpp
#include <jwt-cpp/jwt.h>
#include <curl/curl.h>
#include <json/json.h>
#include <string>
#include <map>

class OAuthAuthorizationServer {
public:
    struct ClientConfig {
        std::string client_id;
        std::string client_secret;
        std::vector<std::string> redirect_uris;
        std::vector<std::string> allowed_scopes;
        std::string client_name;
    };

    OAuthAuthorizationServer(const std::string& issuer, const std::string& private_key)
        : issuer_(issuer), private_key_(private_key) {
        loadRegisteredClients();
    }

    // Step 1: Generate authorization URL
    std::string getAuthorizationURL(const std::string& client_id,
                                   const std::string& redirect_uri,
                                   const std::string& scope,
                                   const std::string& state) {
        std::stringstream ss;
        ss << issuer_ << "/authorize"
           << "?client_id=" << urlEncode(client_id)
           << "&redirect_uri=" << urlEncode(redirect_uri)
           << "&response_type=code"
           << "&scope=" << urlEncode(scope)
           << "&state=" << urlEncode(state);

        return ss.str();
    }

    // Step 2: Handle authorization request (after user login)
    struct AuthorizationResponse {
        std::string code;
        std::string state;
        std::string error;
    };

    AuthorizationResponse handleAuthorizationRequest(
        const std::string& client_id,
        const std::string& redirect_uri,
        const std::string& scope,
        const std::string& state,
        const std::string& user_id) {

        AuthorizationResponse response;
        response.state = state;

        // Validate client
        if (registered_clients_.find(client_id) == registered_clients_.end()) {
            response.error = "invalid_client";
            return response;
        }

        auto& client = registered_clients_[client_id];

        // Validate redirect URI
        if (std::find(client.redirect_uris.begin(), client.redirect_uris.end(),
                     redirect_uri) == client.redirect_uris.end()) {
            response.error = "invalid_redirect_uri";
            return response;
        }

        // Validate scope
        std::vector<std::string> requested_scopes = splitScopes(scope);
        for (const auto& s : requested_scopes) {
            if (std::find(client.allowed_scopes.begin(), client.allowed_scopes.end(), s)
                == client.allowed_scopes.end()) {
                response.error = "invalid_scope";
                return response;
            }
        }

        // Generate authorization code
        response.code = generateAuthorizationCode(client_id, user_id, redirect_uri, scope);

        // Store authorization code in database (10-minute expiry)
        storeAuthorizationCode(response.code, client_id, user_id, redirect_uri, scope);

        return response;
    }

    // Step 3: Exchange authorization code for tokens
    struct TokenResponse {
        std::string access_token;
        std::string refresh_token;
        std::string token_type;
        int expires_in;
        std::string scope;
        std::string error;
    };

    TokenResponse exchangeCodeForToken(
        const std::string& code,
        const std::string& client_id,
        const std::string& client_secret,
        const std::string& redirect_uri) {

        TokenResponse response;

        // Validate client credentials
        if (!validateClientCredentials(client_id, client_secret)) {
            response.error = "invalid_client";
            return response;
        }

        // Retrieve and validate authorization code
        AuthCodeData code_data;
        if (!retrieveAuthorizationCode(code, code_data)) {
            response.error = "invalid_grant";
            return response;
        }

        // Check if code expired
        if (isAuthCodeExpired(code_data)) {
            response.error = "invalid_grant";
            return response;
        }

        // Validate redirect URI matches
        if (code_data.redirect_uri != redirect_uri) {
            response.error = "invalid_grant";
            return response;
        }

        // Delete authorization code (single use)
        deleteAuthorizationCode(code);

        // Generate access token (JWT)
        response.access_token = generateAccessToken(
            code_data.user_id,
            code_data.client_id,
            code_data.scope
        );

        // Generate refresh token
        response.refresh_token = generateRefreshToken(
            code_data.user_id,
            code_data.client_id,
            code_data.scope
        );

        response.token_type = "Bearer";
        response.expires_in = 900;  // 15 minutes
        response.scope = code_data.scope;

        return response;
    }

    // Generate JWT access token
    std::string generateAccessToken(const std::string& user_id,
                                   const std::string& client_id,
                                   const std::string& scope) {
        auto now = std::chrono::system_clock::now();
        auto expiry = now + std::chrono::minutes(15);

        auto token = jwt::create()
            .set_issuer(issuer_)
            .set_subject(user_id)
            .set_audience(client_id)
            .set_type("JWT")
            .set_issued_at(now)
            .set_expires_at(expiry)
            .set_payload_claim("scope", jwt::claim(scope))
            .set_payload_claim("jti", jwt::claim(generateJTI()))
            .sign(jwt::algorithm::rs256("", private_key_, "", ""));

        return token;
    }

    // Validate JWT access token
    bool validateAccessToken(const std::string& token, std::string& user_id,
                           std::vector<std::string>& scopes) {
        try {
            auto verifier = jwt::verify()
                .allow_algorithm(jwt::algorithm::rs256(public_key_, "", "", ""))
                .with_issuer(issuer_);

            auto decoded = jwt::decode(token);
            verifier.verify(decoded);

            user_id = decoded.get_subject();
            std::string scope_str = decoded.get_payload_claim("scope").as_string();
            scopes = splitScopes(scope_str);

            return true;

        } catch (const std::exception& e) {
            logError("Token validation failed: " + std::string(e.what()));
            return false;
        }
    }

private:
    std::string issuer_;
    std::string private_key_;
    std::string public_key_;
    std::map<std::string, ClientConfig> registered_clients_;

    struct AuthCodeData {
        std::string code;
        std::string client_id;
        std::string user_id;
        std::string redirect_uri;
        std::string scope;
        std::time_t created_at;
    };

    void loadRegisteredClients() {
        // Load from database
        ClientConfig trading_web;
        trading_web.client_id = "trading_web_client";
        trading_web.client_secret = "secret123";  // Hashed in production
        trading_web.redirect_uris = {"https://trading.example.com/callback"};
        trading_web.allowed_scopes = {"trading:read", "trading:write", "market-data:read"};
        trading_web.client_name = "Trading Web Application";

        registered_clients_[trading_web.client_id] = trading_web;
    }

    std::string generateAuthorizationCode(const std::string& client_id,
                                         const std::string& user_id,
                                         const std::string& redirect_uri,
                                         const std::string& scope) {
        // Generate cryptographically secure random code
        unsigned char bytes[32];
        RAND_bytes(bytes, 32);

        std::stringstream ss;
        ss << "ac_";  // Authorization code prefix
        for (int i = 0; i < 32; ++i) {
            ss << std::hex << std::setw(2) << std::setfill('0') << (int)bytes[i];
        }

        return ss.str();
    }

    std::string generateRefreshToken(const std::string& user_id,
                                    const std::string& client_id,
                                    const std::string& scope) {
        unsigned char bytes[32];
        RAND_bytes(bytes, 32);

        std::stringstream ss;
        ss << "rt_";  // Refresh token prefix
        for (int i = 0; i < 32; ++i) {
            ss << std::hex << std::setw(2) << std::setfill('0') << (int)bytes[i];
        }

        std::string token = ss.str();

        // Store in database
        storeRefreshToken(token, user_id, client_id, scope);

        return token;
    }

    std::string generateJTI() {
        unsigned char bytes[16];
        RAND_bytes(bytes, 16);

        std::stringstream ss;
        for (int i = 0; i < 16; ++i) {
            ss << std::hex << std::setw(2) << std::setfill('0') << (int)bytes[i];
        }

        return ss.str();
    }

    std::vector<std::string> splitScopes(const std::string& scope) {
        std::vector<std::string> scopes;
        std::stringstream ss(scope);
        std::string item;

        while (std::getline(ss, item, ' ')) {
            if (!item.empty()) {
                scopes.push_back(item);
            }
        }

        return scopes;
    }

    bool validateClientCredentials(const std::string& client_id,
                                  const std::string& client_secret) {
        auto it = registered_clients_.find(client_id);
        if (it == registered_clients_.end()) {
            return false;
        }

        // In production, use secure comparison and hashed secrets
        return it->second.client_secret == client_secret;
    }

    void storeAuthorizationCode(const std::string& code,
                                const std::string& client_id,
                                const std::string& user_id,
                                const std::string& redirect_uri,
                                const std::string& scope) {
        // Store in Redis with 10-minute TTL
    }

    bool retrieveAuthorizationCode(const std::string& code, AuthCodeData& data) {
        // Retrieve from Redis
        return false;  // Simplified
    }

    bool isAuthCodeExpired(const AuthCodeData& data) {
        return (std::time(nullptr) - data.created_at) > 600;  // 10 minutes
    }

    void deleteAuthorizationCode(const std::string& code) {
        // Delete from Redis
    }

    void storeRefreshToken(const std::string& token,
                          const std::string& user_id,
                          const std::string& client_id,
                          const std::string& scope) {
        // Store in database with 7-day expiry
    }

    std::string urlEncode(const std::string& value) {
        std::ostringstream escaped;
        escaped.fill('0');
        escaped << std::hex;

        for (char c : value) {
            if (std::isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') {
                escaped << c;
            } else {
                escaped << '%' << std::setw(2) << int((unsigned char)c);
            }
        }

        return escaped.str();
    }

    void logError(const std::string& msg) {}
};
```

================================================================================
4. CLIENT CREDENTIALS FLOW (MACHINE-TO-MACHINE)
================================================================================

4.1 FLOW IMPLEMENTATION
------------------------

```cpp
class OAuthClientCredentials {
public:
    struct TokenResponse {
        std::string access_token;
        std::string token_type;
        int expires_in;
        std::string scope;
    };

    // Server-side: Handle client credentials request
    TokenResponse handleClientCredentialsRequest(
        const std::string& client_id,
        const std::string& client_secret,
        const std::string& scope) {

        TokenResponse response;

        // Validate client credentials
        if (!validateServiceAccount(client_id, client_secret)) {
            throw std::runtime_error("Invalid client credentials");
        }

        // Validate requested scope
        if (!validateScope(client_id, scope)) {
            throw std::runtime_error("Invalid scope");
        }

        // Generate access token (no refresh token for client credentials)
        response.access_token = generateServiceAccessToken(client_id, scope);
        response.token_type = "Bearer";
        response.expires_in = 3600;  // 1 hour for service accounts
        response.scope = scope;

        return response;
    }

    // Client-side: Request token
    std::string requestAccessToken(const std::string& token_endpoint,
                                  const std::string& client_id,
                                  const std::string& client_secret,
                                  const std::string& scope) {
        CURL* curl = curl_easy_init();
        if (!curl) {
            throw std::runtime_error("Failed to initialize CURL");
        }

        // Prepare POST data
        std::stringstream post_data;
        post_data << "grant_type=client_credentials"
                 << "&client_id=" << urlEncode(client_id)
                 << "&client_secret=" << urlEncode(client_secret)
                 << "&scope=" << urlEncode(scope);

        std::string post_str = post_data.str();

        // Set options
        curl_easy_setopt(curl, CURLOPT_URL, token_endpoint.c_str());
        curl_easy_setopt(curl, CURLOPT_POST, 1L);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_str.c_str());

        // Response buffer
        std::string response_str;
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_str);

        // Perform request
        CURLcode res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);

        if (res != CURLE_OK) {
            throw std::runtime_error("HTTP request failed");
        }

        // Parse JSON response
        Json::Value response;
        Json::Reader reader;
        if (!reader.parse(response_str, response)) {
            throw std::runtime_error("Failed to parse response");
        }

        return response["access_token"].asString();
    }

private:
    bool validateServiceAccount(const std::string& client_id,
                               const std::string& client_secret) {
        // Validate against database
        return true;
    }

    bool validateScope(const std::string& client_id, const std::string& scope) {
        // Check if client is allowed to request this scope
        return true;
    }

    std::string generateServiceAccessToken(const std::string& client_id,
                                          const std::string& scope) {
        // Generate JWT token for service
        return "";
    }

    std::string urlEncode(const std::string& value) {
        // URL encoding implementation
        return value;
    }

    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
        ((std::string*)userp)->append((char*)contents, size * nmemb);
        return size * nmemb;
    }
};
```

================================================================================
5. TOKEN REFRESH IMPLEMENTATION
================================================================================

```cpp
class TokenRefreshHandler {
public:
    struct RefreshResponse {
        std::string access_token;
        std::string refresh_token;  // Optional: new refresh token
        int expires_in;
        std::string scope;
    };

    RefreshResponse refreshAccessToken(const std::string& refresh_token,
                                       const std::string& client_id,
                                       const std::string& client_secret) {
        RefreshResponse response;

        // Validate client
        if (!validateClientCredentials(client_id, client_secret)) {
            throw std::runtime_error("Invalid client credentials");
        }

        // Validate refresh token
        RefreshTokenData token_data;
        if (!retrieveRefreshToken(refresh_token, token_data)) {
            throw std::runtime_error("Invalid refresh token");
        }

        // Check if refresh token expired
        if (isRefreshTokenExpired(token_data)) {
            deleteRefreshToken(refresh_token);
            throw std::runtime_error("Refresh token expired");
        }

        // Check if refresh token belongs to this client
        if (token_data.client_id != client_id) {
            throw std::runtime_error("Token mismatch");
        }

        // Generate new access token
        response.access_token = generateAccessToken(
            token_data.user_id,
            token_data.client_id,
            token_data.scope
        );

        response.expires_in = 900;  // 15 minutes
        response.scope = token_data.scope;

        // Optional: Rotate refresh token
        if (shouldRotateRefreshToken(token_data)) {
            std::string new_refresh_token = generateRefreshToken(
                token_data.user_id,
                token_data.client_id,
                token_data.scope
            );

            deleteRefreshToken(refresh_token);
            response.refresh_token = new_refresh_token;
        }

        return response;
    }

private:
    struct RefreshTokenData {
        std::string refresh_token;
        std::string user_id;
        std::string client_id;
        std::string scope;
        std::time_t created_at;
        std::time_t expires_at;
    };

    bool validateClientCredentials(const std::string& client_id,
                                  const std::string& client_secret) {
        return true;  // Simplified
    }

    bool retrieveRefreshToken(const std::string& token, RefreshTokenData& data) {
        // Query database
        return true;
    }

    bool isRefreshTokenExpired(const RefreshTokenData& data) {
        return std::time(nullptr) >= data.expires_at;
    }

    void deleteRefreshToken(const std::string& token) {
        // Delete from database
    }

    bool shouldRotateRefreshToken(const RefreshTokenData& data) {
        // Rotate if token is more than half expired
        std::time_t age = std::time(nullptr) - data.created_at;
        std::time_t lifetime = data.expires_at - data.created_at;
        return age > (lifetime / 2);
    }

    std::string generateAccessToken(const std::string& user_id,
                                   const std::string& client_id,
                                   const std::string& scope) {
        return "";  // JWT generation
    }

    std::string generateRefreshToken(const std::string& user_id,
                                    const std::string& client_id,
                                    const std::string& scope) {
        return "";  // Random token generation
    }
};
```

================================================================================
6. PYTHON OAUTH SERVER EXAMPLE
================================================================================

```python
#!/usr/bin/env python3
"""
OAuth 2.0 Authorization Server using FastAPI
"""

from fastapi import FastAPI, HTTPException, Depends, Form, Request
from fastapi.responses import RedirectResponse
from pydantic import BaseModel
from typing import Optional, List
import jwt
import datetime
import secrets
import hashlib

app = FastAPI()

# Configuration
ISSUER = "https://auth.trading.com"
PRIVATE_KEY = open('/etc/hft/oauth/private_key.pem').read()
PUBLIC_KEY = open('/etc/hft/oauth/public_key.pem').read()

# In-memory storage (use database in production)
authorization_codes = {}
refresh_tokens = {}

registered_clients = {
    "trading_web": {
        "client_secret": "secret123",  # Hashed in production
        "redirect_uris": ["https://trading.example.com/callback"],
        "allowed_scopes": ["trading:read", "trading:write", "market-data:read"]
    }
}

@app.get("/authorize")
async def authorize(
    client_id: str,
    redirect_uri: str,
    response_type: str,
    scope: str,
    state: str,
    user_id: str = "user123"  # From session after login
):
    """Authorization endpoint"""

    # Validate client
    if client_id not in registered_clients:
        raise HTTPException(status_code=400, detail="Invalid client")

    client = registered_clients[client_id]

    # Validate redirect URI
    if redirect_uri not in client["redirect_uris"]:
        raise HTTPException(status_code=400, detail="Invalid redirect URI")

    # Validate scope
    requested_scopes = scope.split()
    for s in requested_scopes:
        if s not in client["allowed_scopes"]:
            raise HTTPException(status_code=400, detail=f"Invalid scope: {s}")

    # Generate authorization code
    code = f"ac_{secrets.token_urlsafe(32)}"

    authorization_codes[code] = {
        "client_id": client_id,
        "user_id": user_id,
        "redirect_uri": redirect_uri,
        "scope": scope,
        "created_at": datetime.datetime.utcnow()
    }

    # Redirect back to client with code
    return RedirectResponse(
        url=f"{redirect_uri}?code={code}&state={state}"
    )

@app.post("/token")
async def token(
    grant_type: str = Form(...),
    code: Optional[str] = Form(None),
    redirect_uri: Optional[str] = Form(None),
    client_id: str = Form(...),
    client_secret: str = Form(...),
    refresh_token_str: Optional[str] = Form(None, alias="refresh_token")
):
    """Token endpoint"""

    # Validate client credentials
    if client_id not in registered_clients:
        raise HTTPException(status_code=401, detail="Invalid client")

    if registered_clients[client_id]["client_secret"] != client_secret:
        raise HTTPException(status_code=401, detail="Invalid client secret")

    if grant_type == "authorization_code":
        # Authorization code flow
        if code not in authorization_codes:
            raise HTTPException(status_code=400, detail="Invalid authorization code")

        code_data = authorization_codes[code]

        # Check expiry (10 minutes)
        age = (datetime.datetime.utcnow() - code_data["created_at"]).total_seconds()
        if age > 600:
            del authorization_codes[code]
            raise HTTPException(status_code=400, detail="Authorization code expired")

        # Validate redirect URI
        if code_data["redirect_uri"] != redirect_uri:
            raise HTTPException(status_code=400, detail="Redirect URI mismatch")

        # Delete code (single use)
        del authorization_codes[code]

        # Generate tokens
        access_token = generate_access_token(
            code_data["user_id"],
            client_id,
            code_data["scope"]
        )

        refresh_token_val = generate_refresh_token(
            code_data["user_id"],
            client_id,
            code_data["scope"]
        )

        return {
            "access_token": access_token,
            "refresh_token": refresh_token_val,
            "token_type": "Bearer",
            "expires_in": 900,
            "scope": code_data["scope"]
        }

    elif grant_type == "refresh_token":
        # Refresh token flow
        if refresh_token_str not in refresh_tokens:
            raise HTTPException(status_code=400, detail="Invalid refresh token")

        token_data = refresh_tokens[refresh_token_str]

        # Check expiry
        if datetime.datetime.utcnow() >= token_data["expires_at"]:
            del refresh_tokens[refresh_token_str]
            raise HTTPException(status_code=400, detail="Refresh token expired")

        # Generate new access token
        access_token = generate_access_token(
            token_data["user_id"],
            client_id,
            token_data["scope"]
        )

        return {
            "access_token": access_token,
            "token_type": "Bearer",
            "expires_in": 900,
            "scope": token_data["scope"]
        }

    elif grant_type == "client_credentials":
        # Client credentials flow (machine-to-machine)
        scope = "service:read service:write"

        access_token = generate_access_token(client_id, client_id, scope)

        return {
            "access_token": access_token,
            "token_type": "Bearer",
            "expires_in": 3600,
            "scope": scope
        }

    else:
        raise HTTPException(status_code=400, detail="Unsupported grant type")

def generate_access_token(user_id: str, client_id: str, scope: str) -> str:
    """Generate JWT access token"""
    now = datetime.datetime.utcnow()
    expiry = now + datetime.timedelta(minutes=15)

    payload = {
        "iss": ISSUER,
        "sub": user_id,
        "aud": client_id,
        "iat": int(now.timestamp()),
        "exp": int(expiry.timestamp()),
        "scope": scope,
        "jti": secrets.token_urlsafe(16)
    }

    token = jwt.encode(payload, PRIVATE_KEY, algorithm="RS256")
    return token

def generate_refresh_token(user_id: str, client_id: str, scope: str) -> str:
    """Generate opaque refresh token"""
    token = f"rt_{secrets.token_urlsafe(32)}"

    refresh_tokens[token] = {
        "user_id": user_id,
        "client_id": client_id,
        "scope": scope,
        "created_at": datetime.datetime.utcnow(),
        "expires_at": datetime.datetime.utcnow() + datetime.timedelta(days=7)
    }

    return token

@app.get("/.well-known/jwks.json")
async def jwks():
    """JSON Web Key Set endpoint (public keys for token verification)"""
    # Return public key in JWK format
    return {
        "keys": [
            {
                "kty": "RSA",
                "use": "sig",
                "kid": "key-1",
                "alg": "RS256",
                "n": "...",  # Public key modulus
                "e": "AQAB"  # Public key exponent
            }
        ]
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, ssl_keyfile="/etc/hft/tls/key.pem",
                ssl_certfile="/etc/hft/tls/cert.pem")
```

================================================================================
7. SECURITY BEST PRACTICES
================================================================================

1. ALWAYS use HTTPS for OAuth endpoints
2. VALIDATE redirect_uri strictly (exact match)
3. USE state parameter to prevent CSRF
4. SHORT-LIVED access tokens (15 min)
5. LONG-LIVED refresh tokens (7 days) stored securely
6. ROTATE refresh tokens on use
7. IMPLEMENT rate limiting on token endpoint
8. LOG all authentication events
9. REVOKE tokens on logout
10. USE PKCE for mobile/SPA applications

================================================================================
END OF DOCUMENT
================================================================================
