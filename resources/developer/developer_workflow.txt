================================================================================
                       DEVELOPER WORKFLOW GUIDE
================================================================================
Version: 3.2.1
Last Updated: 2025-11-25
Owner: Engineering Management
Maintainer: Bob Johnson

================================================================================
SECTION 1: OVERVIEW
================================================================================

This document defines the standard development workflows for the HFT trading
system. All developers must follow these procedures to ensure code quality,
system stability, and regulatory compliance.

CORE PRINCIPLES:
1. Safety First: Never compromise system reliability
2. Test Thoroughly: Comprehensive testing before production
3. Document Everything: Code, decisions, and changes
4. Review Carefully: Multiple eyes on every change
5. Monitor Continuously: Track impact of changes

================================================================================
SECTION 2: DEVELOPMENT ENVIRONMENT SETUP
================================================================================

WORKSTATION REQUIREMENTS:
------------------------------------------------------------
Hardware Specifications:
    CPU: Intel Core i9 or AMD Ryzen 9 (8+ cores)
    RAM: 32GB minimum, 64GB recommended
    Storage: 1TB NVMe SSD
    Network: Gigabit Ethernet (minimum)
    Display: Dual monitors recommended

Operating System:
    Primary: Ubuntu 22.04 LTS
    Alternative: RedHat Enterprise Linux 8.x
    Not Supported: Windows (use WSL2 if required)

Required Software:
    Version Control: git 2.40+
    Compiler: GCC 11+ or Clang 14+
    Build System: CMake 3.25+, Make, Ninja
    Python: 3.9, 3.10, 3.11 (virtualenv for each)
    Java: OpenJDK 11, 17
    Database: PostgreSQL 14+ client tools
    Container: Docker 24+, docker-compose 2+


INITIAL SETUP PROCEDURE:
------------------------------------------------------------
Step 1: Access Provisioning (Complete HR/Security Forms)
    [ ] VPN access credentials
    [ ] SSH key generation and registration
    [ ] GitHub Enterprise account creation
    [ ] GitLab account activation
    [ ] Bastion host access
    [ ] Development server access
    [ ] Database read-only access (initial)

Step 2: SSH Key Setup
    Generate SSH key pair:
        $ ssh-keygen -t ed25519 -C "your.email@hftsystem.local" -f ~/.ssh/id_ed25519_hft

    Add to SSH agent:
        $ eval "$(ssh-agent -s)"
        $ ssh-add ~/.ssh/id_ed25519_hft

    Copy public key to clipboard:
        $ cat ~/.ssh/id_ed25519_hft.pub

    Add to GitLab:
        - Navigate to: https://gitlab.hftsystem.local/profile/keys
        - Paste public key
        - Title: "Workstation - $(hostname)"

    Configure SSH config (~/.ssh/config):
        Host gitlab.hftsystem.local
            HostName gitlab.hftsystem.local
            User git
            IdentityFile ~/.ssh/id_ed25519_hft

        Host bastion.prod
            HostName bastion.prod.hftsystem.local
            User your_username
            IdentityFile ~/.ssh/id_ed25519_hft

        Host dev-shared-*
            User your_username
            IdentityFile ~/.ssh/id_ed25519_hft
            ProxyJump bastion.prod

Step 3: Clone Source Repository
    Create workspace directory:
        $ mkdir -p ~/workspace/hft
        $ cd ~/workspace/hft

    Clone main repository:
        $ git clone git@gitlab.hftsystem.local:hft/trading-system.git
        $ cd trading-system

    Configure git:
        $ git config user.name "Your Full Name"
        $ git config user.email "your.email@hftsystem.local"
        $ git config pull.rebase true
        $ git config core.autocrlf input

    Setup git hooks:
        $ ./scripts/setup_git_hooks.sh

Step 4: Install Development Dependencies
    Ubuntu/Debian:
        $ sudo apt-get update
        $ sudo apt-get install -y \
            build-essential cmake ninja-build \
            libboost-all-dev libssl-dev libpq-dev \
            python3-dev python3-pip python3-venv \
            openjdk-11-jdk maven \
            docker.io docker-compose \
            clang-format clang-tidy \
            valgrind gdb lldb \
            htop iotop nethogs

    Python virtual environment:
        $ python3 -m venv ~/workspace/hft/venv
        $ source ~/workspace/hft/venv/bin/activate
        $ pip install --upgrade pip setuptools wheel
        $ pip install -r requirements.txt
        $ pip install -r requirements-dev.txt

Step 5: Build System Locally
    Configure build:
        $ cd ~/workspace/hft/trading-system
        $ mkdir -p build/debug build/release

    Debug build:
        $ cd build/debug
        $ cmake -DCMAKE_BUILD_TYPE=Debug -G Ninja ../..
        $ ninja -j$(nproc)

    Release build:
        $ cd build/release
        $ cmake -DCMAKE_BUILD_TYPE=Release -G Ninja ../..
        $ ninja -j$(nproc)

    Run tests:
        $ cd build/debug
        $ ctest --output-on-failure

Step 6: Database Setup (Local Development)
    Start PostgreSQL in Docker:
        $ docker-compose -f docker/dev/docker-compose.yml up -d postgres

    Initialize database schema:
        $ ./scripts/db/init_dev_database.sh

    Load test data:
        $ ./scripts/db/load_test_data.sh

    Verify connection:
        $ psql -h localhost -p 5432 -U hft_dev -d trading_db
        Password: dev_password_123

Step 7: IDE Configuration
    VS Code (Recommended):
        Extensions to install:
        - C/C++ (Microsoft)
        - Python (Microsoft)
        - GitLens
        - CMake Tools
        - Docker
        - Remote - SSH

        Copy workspace settings:
        $ cp .vscode/settings.example.json .vscode/settings.json

    CLion (Alternative):
        - Open project from CMakeLists.txt
        - Configure toolchain (GCC/Clang)
        - Setup remote debugging to dev servers

Step 8: Verify Setup
    Run verification script:
        $ ./scripts/verify_dev_environment.sh

    Should output:
        [OK] Git configured correctly
        [OK] SSH keys setup
        [OK] Build tools available
        [OK] Python environment ready
        [OK] Database connection successful
        [OK] Docker running
        [OK] All unit tests pass


================================================================================
SECTION 3: DAILY DEVELOPMENT WORKFLOW
================================================================================

MORNING ROUTINE:
------------------------------------------------------------
Step 1: Start of Day (8:30 AM - 9:00 AM)
    [ ] Pull latest changes from develop branch
        $ cd ~/workspace/hft/trading-system
        $ git checkout develop
        $ git pull origin develop

    [ ] Check CI/CD status
        Navigate to: https://jenkins.hftsystem.local/
        Verify develop branch is green

    [ ] Review assigned tasks
        Check Jira: https://jira.hftsystem.local/
        Filter: assignee = currentUser() AND status = "To Do"

    [ ] Attend daily standup (8:30 AM)
        Update team on:
        - What you did yesterday
        - What you plan today
        - Any blockers

    [ ] Check team chat for urgent issues
        Slack #dev-team channel
        Slack #prod-alerts channel

Step 2: Plan Day's Work (9:00 AM - 9:30 AM)
    [ ] Review task requirements
    [ ] Break down into sub-tasks
    [ ] Estimate effort
    [ ] Identify dependencies
    [ ] Plan testing approach


FEATURE DEVELOPMENT WORKFLOW:
------------------------------------------------------------
Step 1: Create Feature Branch
    Branch naming convention:
        feature/JIRA-###-short-description

    Example:
        $ git checkout develop
        $ git pull origin develop
        $ git checkout -b feature/TRADE-1234-add-new-risk-check
        $ git push -u origin feature/TRADE-1234-add-new-risk-check

Step 2: Implement Feature
    Development cycle:
    1. Write failing test (TDD approach)
    2. Implement minimal code to pass test
    3. Refactor for quality
    4. Repeat

    Code organization:
        - One logical change per commit
        - Keep commits small and focused
        - Write descriptive commit messages

    Commit message format:
        [TRADE-1234] Add new position limit risk check

        Implements real-time position limit checking against
        configured thresholds. Rejects orders that would
        breach position limits.

        - Add PositionLimitChecker class
        - Integrate with RiskEngine
        - Add unit tests (95% coverage)
        - Update API documentation

        Related: TRADE-1230, TRADE-1235

Step 3: Local Testing
    Run unit tests:
        $ cd build/debug
        $ ctest --output-on-failure

    Run specific test:
        $ ./tests/risk_engine_tests --gtest_filter=PositionLimitChecker.*

    Check code coverage:
        $ ./scripts/generate_coverage_report.sh
        $ firefox coverage/index.html

    Run static analysis:
        $ ./scripts/run_static_analysis.sh
        $ less static-analysis-report.txt

    Run performance benchmarks (if applicable):
        $ ./build/release/benchmarks/risk_benchmarks

    Memory leak check:
        $ valgrind --leak-check=full ./build/debug/tests/risk_engine_tests

Step 4: Code Review Preparation
    Self-review checklist:
        [ ] All tests pass locally
        [ ] Code coverage > 80% for new code
        [ ] No compiler warnings (-Wall -Wextra)
        [ ] Static analysis clean
        [ ] No obvious performance issues
        [ ] Code follows style guide
        [ ] Comments explain why, not what
        [ ] API documentation updated
        [ ] No debugging code left in
        [ ] No commented-out code
        [ ] Error handling implemented
        [ ] Logging added at appropriate levels

    Format code:
        $ ./scripts/format_code.sh --staged

    Commit formatting changes:
        $ git commit -am "[TRADE-1234] Format code per style guide"

Step 5: Push and Create Pull Request
    Push branch:
        $ git push origin feature/TRADE-1234-add-new-risk-check

    Create pull request:
        Navigate to: https://gitlab.hftsystem.local/hft/trading-system
        Click "Create Pull Request"

        PR Title: [TRADE-1234] Add new position limit risk check

        PR Description Template:
        ```
        ## Summary
        Implements real-time position limit checking in the risk engine.
        Orders that would breach position limits are rejected before
        reaching the exchange.

        ## Changes
        - Added PositionLimitChecker class in risk/position_limits.cpp
        - Integrated with RiskEngine::checkOrder() flow
        - Added comprehensive unit tests (95% coverage)
        - Updated risk engine documentation

        ## Testing
        - All existing tests pass
        - Added 15 new unit tests
        - Tested manually in dev environment
        - Benchmarked: < 50μs latency impact

        ## Deployment Notes
        - Requires configuration update: position_limits.yaml
        - Backward compatible - feature flag controlled
        - No database migration required

        ## Checklist
        - [x] Tests added/updated
        - [x] Documentation updated
        - [x] No breaking changes
        - [x] Backward compatible
        - [x] Performance validated

        Related Tickets: TRADE-1230, TRADE-1235
        ```

        Assign Reviewers:
        - Minimum 2 reviewers required
        - At least 1 senior developer
        - Domain expert if available

        Labels:
        - Component: risk-engine
        - Priority: medium
        - Size: small/medium/large


CODE REVIEW PROCESS:
------------------------------------------------------------
As Reviewer:
    Review checklist:
        [ ] Code logic is correct
        [ ] Edge cases handled
        [ ] Error handling appropriate
        [ ] Performance acceptable
        [ ] Tests are comprehensive
        [ ] Code is readable
        [ ] Documentation is clear
        [ ] No security issues
        [ ] Follows architecture patterns
        [ ] No unnecessary complexity

    Review thoroughly:
        - Understand the change purpose
        - Check for unintended side effects
        - Suggest improvements
        - Ask questions if unclear
        - Test locally if complex

    Review etiquette:
        - Be respectful and constructive
        - Explain your reasoning
        - Suggest alternatives
        - Approve once satisfied
        - Don't rubber-stamp

As Author (Addressing Feedback):
    Respond to all comments:
        - Acknowledge feedback
        - Make requested changes
        - Explain if you disagree (respectfully)
        - Mark resolved when addressed

    Update PR:
        $ git add <files>
        $ git commit -m "[TRADE-1234] Address review feedback - improve error handling"
        $ git push origin feature/TRADE-1234-add-new-risk-check

    Request re-review:
        Comment in PR: "@reviewer ready for re-review"

Step 6: Merge to Develop
    After approvals and CI passing:
        Click "Merge" button in GitLab

    Merge strategy:
        - Use "Squash and Merge" for small features
        - Use "Merge Commit" for large features
        - Never use "Fast Forward" for features

    Delete branch after merge:
        $ git branch -d feature/TRADE-1234-add-new-risk-check
        $ git push origin --delete feature/TRADE-1234-add-new-risk-check

    Update local repository:
        $ git checkout develop
        $ git pull origin develop


BUG FIX WORKFLOW:
------------------------------------------------------------
Similar to feature workflow but:

Branch naming:
    bugfix/JIRA-###-short-description

Priority handling:
    - P0/P1 bugs: May require hotfix process
    - P2/P3 bugs: Follow normal workflow

Testing emphasis:
    - Write test that reproduces bug
    - Verify fix resolves the issue
    - Add regression test

Documentation:
    - Update troubleshooting guide if applicable
    - Document root cause in ticket


HOTFIX WORKFLOW (PRODUCTION ISSUES):
------------------------------------------------------------
Used for critical production issues requiring immediate fix.

Step 1: Create Hotfix Branch
    Branch from main (production branch):
        $ git checkout main
        $ git pull origin main
        $ git checkout -b hotfix/TRADE-9999-critical-order-routing-bug
        $ git push -u origin hotfix/TRADE-9999-critical-order-routing-bug

Step 2: Implement Fix (Minimal Changes Only)
    - Fix ONLY the critical issue
    - No refactoring or improvements
    - Minimal code changes
    - Keep changes isolated

Step 3: Fast-Track Testing
    - Run relevant tests only
    - Test in staging environment
    - Get expedited code review
    - Minimum 1 senior developer review

Step 4: Emergency Deployment
    - Follow deployment_checklist.txt
    - Deploy to production immediately
    - Monitor closely for 1 hour

Step 5: Merge Hotfix
    Merge to main:
        $ git checkout main
        $ git merge --no-ff hotfix/TRADE-9999-critical-order-routing-bug
        $ git tag -a v3.2.2 -m "Hotfix: Critical order routing bug"
        $ git push origin main --tags

    Back-merge to develop:
        $ git checkout develop
        $ git merge --no-ff hotfix/TRADE-9999-critical-order-routing-bug
        $ git push origin develop

Step 6: Post-Mortem
    - Document incident
    - Identify root cause
    - Plan preventive measures
    - Update monitoring/alerts


================================================================================
SECTION 4: TESTING STANDARDS
================================================================================

UNIT TESTING:
------------------------------------------------------------
Framework: Google Test (C++), pytest (Python), JUnit (Java)

Guidelines:
    - Test one thing per test
    - Use descriptive test names
    - Follow AAA pattern: Arrange, Act, Assert
    - Mock external dependencies
    - Keep tests fast (< 1ms per test)

Coverage Requirements:
    - New code: 80% minimum
    - Critical paths: 100% required
    - Risk engine: 100% required
    - Order routing: 100% required

Example (C++):
    TEST(PositionLimitChecker, RejectsOrderExceedingLimit) {
        // Arrange
        PositionLimitChecker checker;
        checker.setLimit("AAPL", 10000);
        checker.setCurrentPosition("AAPL", 9500);
        Order order("AAPL", Side::BUY, 1000);

        // Act
        RiskCheckResult result = checker.checkOrder(order);

        // Assert
        EXPECT_FALSE(result.approved);
        EXPECT_EQ(result.reason, "Position limit exceeded");
    }

Running Tests:
    All tests:
        $ ctest --output-on-failure

    Specific suite:
        $ ./tests/risk_engine_tests

    With coverage:
        $ ./scripts/run_tests_with_coverage.sh

    Parallel execution:
        $ ctest -j$(nproc)


INTEGRATION TESTING:
------------------------------------------------------------
Purpose: Test interaction between components

Environment: Dedicated integration test cluster
    - Servers: dev-integration-01
    - Isolated from development and production
    - Uses test market data
    - No real order submission

Test Scenarios:
    1. End-to-end order flow
    2. Market data to signal generation
    3. Risk checks across components
    4. Database operations
    5. Multiple strategies running simultaneously

Running Integration Tests:
    $ ./scripts/run_integration_tests.sh

    Runs on every PR
    Must pass before merge


PERFORMANCE TESTING:
------------------------------------------------------------
Purpose: Validate latency requirements

Benchmarking Framework: Google Benchmark

Requirements:
    - Order processing: < 100μs (p99)
    - Market data processing: < 50μs (p99)
    - Risk checks: < 200μs (p99)

Running Benchmarks:
    $ ./build/release/benchmarks/latency_benchmarks
    $ ./build/release/benchmarks/throughput_benchmarks

Compare with baseline:
    $ ./scripts/compare_benchmarks.sh --baseline develop --current HEAD

Performance regression:
    - > 10% degradation requires explanation
    - > 20% degradation blocks merge


REGRESSION TESTING:
------------------------------------------------------------
Purpose: Ensure no functionality broken

Full Test Suite:
    - All unit tests
    - All integration tests
    - Smoke tests
    - End-to-end tests

Execution:
    - Automatically on develop branch (nightly)
    - Before release (manually triggered)
    - After hotfix deployment

Running:
    $ ./scripts/run_regression_suite.sh


LOAD TESTING:
------------------------------------------------------------
Purpose: Validate system under high load

Test Scenarios:
    - 100k orders/second
    - 500k market data messages/second
    - 1000 simultaneous strategy instances

Tools:
    - Custom load generator
    - Locust (Python-based)
    - JMeter (Java-based)

Running:
    $ ./scripts/run_load_tests.sh --scenario high_frequency

Schedule:
    - Weekly on staging environment
    - Before major releases


================================================================================
SECTION 5: CODE QUALITY STANDARDS
================================================================================

CODING STYLE GUIDE:
------------------------------------------------------------
C++ Style:
    - Follow Google C++ Style Guide
    - Use clang-format for automatic formatting
    - Max line length: 100 characters
    - Indent: 2 spaces (no tabs)
    - Naming:
        - Classes: PascalCase
        - Functions: camelCase
        - Variables: snake_case
        - Constants: UPPER_SNAKE_CASE
        - Namespaces: lowercase

Python Style:
    - Follow PEP 8
    - Use black for formatting
    - Use type hints
    - Max line length: 88 characters (black default)
    - Docstrings: Google style

Java Style:
    - Follow Oracle Java conventions
    - Use Google Java Format
    - Max line length: 100 characters

Formatting Code:
    $ ./scripts/format_code.sh --all
    $ ./scripts/format_code.sh --staged


STATIC ANALYSIS:
------------------------------------------------------------
Tools:
    C++: clang-tidy, cppcheck
    Python: pylint, mypy, flake8
    Java: PMD, SpotBugs, Checkstyle

Running:
    $ ./scripts/run_static_analysis.sh

CI Integration:
    - Runs on every commit
    - Blocks merge if critical issues found

Suppression:
    - Only suppress false positives
    - Add comment explaining suppression
    - Get review approval for suppressions


DOCUMENTATION STANDARDS:
------------------------------------------------------------
Code Documentation:
    C++: Doxygen comments
        /**
         * @brief Checks if order violates position limits
         * @param order The order to check
         * @return RiskCheckResult with approval decision
         * @throws std::invalid_argument if order is invalid
         */
        RiskCheckResult checkOrder(const Order& order);

    Python: Docstrings
        def check_order(order: Order) -> RiskCheckResult:
            """Check if order violates position limits.

            Args:
                order: The order to check

            Returns:
                RiskCheckResult with approval decision

            Raises:
                ValueError: If order is invalid
            """

    Java: Javadoc
        /**
         * Checks if order violates position limits.
         * @param order the order to check
         * @return risk check result with approval decision
         * @throws IllegalArgumentException if order is invalid
         */
        public RiskCheckResult checkOrder(Order order)

API Documentation:
    - OpenAPI/Swagger for REST APIs
    - Protocol Buffers for gRPC APIs
    - Auto-generated from code

Architecture Documentation:
    - Architecture Decision Records (ADRs)
    - System design documents
    - Component diagrams (PlantUML)
    - Sequence diagrams for complex flows


SECURITY BEST PRACTICES:
------------------------------------------------------------
Secure Coding:
    - Never commit secrets
    - Use parameterized queries
    - Validate all input
    - Sanitize output
    - Use secure random number generators
    - Implement proper error handling

Dependency Management:
    - Keep dependencies up to date
    - Scan for vulnerabilities
        $ ./scripts/scan_dependencies.sh
    - Review security advisories

Access Control:
    - Principle of least privilege
    - Use service accounts
    - Rotate credentials regularly
    - Enable MFA everywhere


================================================================================
SECTION 6: VERSION CONTROL BEST PRACTICES
================================================================================

GIT WORKFLOW:
------------------------------------------------------------
Branch Strategy: GitFlow

Main Branches:
    main: Production-ready code
        - Always stable
        - Tagged with version numbers
        - Never commit directly

    develop: Integration branch
        - Latest development changes
        - Features merge here first
        - Should be stable (all tests pass)

Supporting Branches:
    feature/*: New features
    bugfix/*: Bug fixes
    hotfix/*: Production fixes
    release/*: Release preparation

Branch Lifecycle:
    feature/bugfix:
        Create from: develop
        Merge to: develop
        Lifetime: Until feature complete

    hotfix:
        Create from: main
        Merge to: main AND develop
        Lifetime: Until fix deployed

    release:
        Create from: develop
        Merge to: main AND develop
        Lifetime: Until release deployed


COMMIT BEST PRACTICES:
------------------------------------------------------------
Commit Message Format:
    Subject line (50 chars max):
        [TICKET-###] Brief description

    Body (wrapped at 72 chars):
        - Detailed explanation
        - Why change was needed
        - Any important context
        - Related tickets

    Example:
        [TRADE-1234] Add position limit risk check

        Implements real-time position limit checking to prevent
        traders from exceeding configured position limits.

        The check runs before order submission and rejects orders
        that would breach limits. This prevents regulatory
        violations and limits firm exposure.

        Performance impact: < 50μs latency added to risk checks.

        Related: TRADE-1230, TRADE-1235

Commit Guidelines:
    - One logical change per commit
    - Keep commits small and focused
    - Write clear commit messages
    - Don't mix formatting with logic changes
    - Don't commit broken code
    - Don't commit debugging code

Useful Git Commands:
    Interactive staging:
        $ git add -p

    Amend last commit:
        $ git commit --amend

    Interactive rebase (clean up commits):
        $ git rebase -i HEAD~3

    Stash changes:
        $ git stash save "Work in progress"
        $ git stash pop

    Cherry-pick commit:
        $ git cherry-pick <commit-hash>


================================================================================
SECTION 7: CONTINUOUS INTEGRATION/DEPLOYMENT
================================================================================

CI/CD PIPELINE:
------------------------------------------------------------
Tool: Jenkins
URL: https://jenkins.hftsystem.local/

Pipeline Stages:
    1. Checkout: Clone repository
    2. Build: Compile code (debug + release)
    3. Test: Run unit tests
    4. Static Analysis: clang-tidy, cppcheck, etc.
    5. Coverage: Generate coverage report
    6. Integration Test: Run integration tests
    7. Package: Create deployment artifacts
    8. Deploy to Staging: Automatic for develop branch
    9. Smoke Test: Basic functionality checks
    10. Deploy to Production: Manual approval required

Triggers:
    - Every commit to any branch
    - Every pull request
    - Nightly full regression
    - Manual trigger for releases

Notifications:
    - Slack #dev-team channel
    - Email to commit author
    - GitLab PR status update

Viewing Results:
    Navigate to Jenkins and find your build
    Review console output for failures
    Download artifacts if needed


ARTIFACT MANAGEMENT:
------------------------------------------------------------
Tool: Artifactory
URL: https://artifacts.hftsystem.local/

Artifact Types:
    - Compiled binaries
    - Python packages (wheel files)
    - Java JAR files
    - Docker images
    - Configuration files
    - Documentation

Versioning:
    Format: vMAJOR.MINOR.PATCH-BUILD
    Example: v3.2.1-build-1234

    MAJOR: Breaking changes
    MINOR: New features, backward compatible
    PATCH: Bug fixes
    BUILD: CI build number

Publishing Artifacts:
    Automatic for develop and main branches
    Manual promotion to production repository


DOCKER IMAGES:
------------------------------------------------------------
Registry: registry.hftsystem.local

Building Images:
    $ docker build -t registry.hftsystem.local/hft/trading-system:v3.2.1 .
    $ docker push registry.hftsystem.local/hft/trading-system:v3.2.1

Image Tags:
    - latest: Latest develop build
    - v3.2.1: Specific version
    - stable: Latest production version

Using Images:
    $ docker pull registry.hftsystem.local/hft/trading-system:stable
    $ docker run registry.hftsystem.local/hft/trading-system:stable


================================================================================
SECTION 8: COLLABORATION & COMMUNICATION
================================================================================

COMMUNICATION CHANNELS:
------------------------------------------------------------
Slack Channels:
    #dev-team: General development discussion
    #prod-alerts: Production incidents and alerts
    #deployments: Deployment notifications
    #code-reviews: Code review discussions
    #tech-talks: Technical presentations and sharing

Email Lists:
    dev-team@hftsystem.local: All developers
    dev-leads@hftsystem.local: Senior developers
    on-call@hftsystem.local: Current on-call engineers

Meetings:
    Daily Standup: 8:30 AM ET (15 minutes)
    Sprint Planning: Every 2 weeks, Monday 10:00 AM
    Sprint Retro: Every 2 weeks, Friday 3:00 PM
    Architecture Review: Monthly, first Thursday 2:00 PM
    Tech Talks: Monthly, last Friday 4:00 PM
    1-on-1 with Manager: Biweekly


KNOWLEDGE SHARING:
------------------------------------------------------------
Documentation Wiki:
    URL: https://wiki.hftsystem.local/
    Content:
    - Architecture documentation
    - Design documents
    - Runbooks
    - Best practices
    - Troubleshooting guides

Tech Talks:
    - Monthly presentations
    - Share new technologies
    - Discuss architectural decisions
    - Present completed projects

Code Reviews:
    - Learning opportunity
    - Share knowledge
    - Maintain code quality
    - Mentor junior developers

Pair Programming:
    - Complex problems
    - Knowledge transfer
    - Onboarding new developers
    - Critical bug fixes


MENTORSHIP:
------------------------------------------------------------
For New Developers:
    - Assigned mentor (senior developer)
    - Weekly 1-on-1 check-ins
    - Shadowing and pair programming
    - Gradual increase in responsibility

For All Developers:
    - Encourage questions
    - Share context in reviews
    - Document tribal knowledge
    - Participate in tech talks


================================================================================
SECTION 9: PERFORMANCE OPTIMIZATION
================================================================================

PROFILING:
------------------------------------------------------------
CPU Profiling:
    Tools: perf, Valgrind (callgrind), Intel VTune

    Using perf:
        $ perf record -g ./build/release/trading_engine
        $ perf report

Memory Profiling:
    Tools: Valgrind (massif), Heaptrack

    Using Valgrind:
        $ valgrind --tool=massif ./build/release/trading_engine
        $ ms_print massif.out.12345

Benchmarking:
    Framework: Google Benchmark

    Example:
        static void BM_OrderProcessing(benchmark::State& state) {
            for (auto _ : state) {
                processOrder(createTestOrder());
            }
        }
        BENCHMARK(BM_OrderProcessing);

Latency Measurement:
    - Use high-resolution clocks
    - Measure at multiple points
    - Calculate percentiles (p50, p95, p99, p99.9)
    - Compare against baseline


OPTIMIZATION TECHNIQUES:
------------------------------------------------------------
Low-Latency Coding:
    - Minimize memory allocations
    - Use object pools
    - Avoid virtual function calls in hot path
    - Prefer stack over heap allocation
    - Use move semantics
    - Avoid locks (use lock-free data structures)
    - Optimize cache usage (data locality)
    - Avoid system calls

Example - Object Pool:
    class OrderPool {
        std::vector<Order> pool_;
        std::queue<Order*> available_;

    public:
        Order* acquire() {
            if (available_.empty()) {
                return new Order();  // Fallback
            }
            Order* order = available_.front();
            available_.pop();
            return order;
        }

        void release(Order* order) {
            order->reset();
            available_.push(order);
        }
    };

Algorithmic Optimization:
    - Choose right data structures
    - Reduce algorithmic complexity
    - Use appropriate containers
    - Leverage standard library algorithms


================================================================================
SECTION 10: DEBUGGING TECHNIQUES
================================================================================

DEBUGGING TOOLS:
------------------------------------------------------------
GDB (GNU Debugger):
    Start debugging:
        $ gdb ./build/debug/trading_engine
        (gdb) break main
        (gdb) run
        (gdb) next
        (gdb) print variable_name
        (gdb) backtrace

    Attach to running process:
        $ gdb -p <pid>

LLDB (LLVM Debugger):
    Similar to GDB with slightly different syntax
    Better C++ support

Valgrind:
    Memory leaks:
        $ valgrind --leak-check=full ./trading_engine

    Thread issues:
        $ valgrind --tool=helgrind ./trading_engine

Core Dumps:
    Enable core dumps:
        $ ulimit -c unlimited

    Analyze core dump:
        $ gdb ./trading_engine core.12345


LOGGING:
------------------------------------------------------------
Log Levels:
    TRACE: Very detailed, high-frequency logs
    DEBUG: Detailed information for debugging
    INFO: General informational messages
    WARN: Warning messages (not errors)
    ERROR: Error messages (recoverable)
    FATAL: Fatal errors (unrecoverable)

Logging Best Practices:
    - Log important state transitions
    - Include relevant context (order ID, symbol, etc.)
    - Use appropriate log levels
    - Don't log in extremely hot paths (> 1M times/sec)
    - Use structured logging (JSON format)

Example:
    LOG_INFO("Order submitted",
             {"order_id": order.id,
              "symbol": order.symbol,
              "side": order.side,
              "quantity": order.quantity,
              "price": order.price});

Log Locations:
    Application Logs: /var/log/hft/
    System Logs: /var/log/syslog
    Centralized: ELK Stack (Kibana)


REMOTE DEBUGGING:
------------------------------------------------------------
SSH Port Forwarding:
    $ ssh -L 2345:localhost:2345 dev-shared-01

Start gdbserver on remote:
    $ gdbserver :2345 ./trading_engine

Connect from local:
    $ gdb ./trading_engine
    (gdb) target remote localhost:2345


================================================================================
END OF DEVELOPER WORKFLOW GUIDE
================================================================================

For questions or suggestions, contact:
    Bob Johnson (Infrastructure Lead): bob.johnson@hftsystem.local
