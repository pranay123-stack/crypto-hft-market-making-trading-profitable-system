================================================================================
INTERFACE AND API DESIGN FOR HIGH-FREQUENCY TRADING
================================================================================

This document covers principles and practices for designing clean, efficient
interfaces and APIs for HFT systems with zero-overhead abstractions.

================================================================================
TABLE OF CONTENTS
================================================================================
1. Interface Design Principles
2. Zero-Overhead Abstractions
3. CRTP for Static Polymorphism
4. Type-Safe Interfaces
5. Fluent Interface Design
6. Callback vs Observer Patterns
7. Policy-Based Interface Design
8. Template Interface Patterns
9. Error Handling in Interfaces
10. Versioning and Evolution

================================================================================
1. INTERFACE DESIGN PRINCIPLES FOR HFT
================================================================================

CORE PRINCIPLES:
----------------
1. Performance First: Zero-overhead abstractions
2. Type Safety: Compile-time guarantees
3. Explicit Contracts: Clear preconditions and postconditions
4. Minimal Surface: Small, focused interfaces
5. Const Correctness: Enable compiler optimizations
6. noexcept Guarantees: No exceptions in critical path
7. Inline-Friendly: Short methods for inlining

PERFORMANCE REQUIREMENTS:
-------------------------
- Virtual functions: Use only when polymorphism truly needed
- Prefer static dispatch (templates, CRTP) over dynamic dispatch
- Use final keyword to enable devirtualization
- Consider interface complexity vs performance trade-off

COMPLETE HFT EXAMPLE - Market Data Interface:
----------------------------------------------

#pragma once
#include <cstdint>
#include <string_view>

namespace hft::interface {

// ============================================================================
// BAD INTERFACE: Too many virtual functions, complex hierarchy
// ============================================================================

class BadMarketDataInterface {
public:
    virtual ~BadMarketDataInterface() = default;

    // Too many virtual functions (overhead!)
    virtual void onQuote(uint32_t symbol_id, double bid, double ask) = 0;
    virtual void onTrade(uint32_t symbol_id, double price, int64_t size) = 0;
    virtual void onOrderBook(uint32_t symbol_id, const void* book) = 0;
    virtual void onImbalance(uint32_t symbol_id, int64_t imbalance) = 0;
    virtual void onAuction(uint32_t symbol_id, double price) = 0;

    // Returns dynamically allocated string (allocation!)
    virtual std::string getSymbolName(uint32_t id) = 0;

    // Non-const methods (prevents optimizations)
    virtual void updateSnapshot() = 0;
};

// ============================================================================
// GOOD INTERFACE: Minimal, performance-focused
// ============================================================================

// Market data event (POD structure, no virtuals)
struct MarketDataEvent {
    enum class Type : uint8_t {
        QUOTE,
        TRADE,
        ORDER_BOOK,
        IMBALANCE
    };

    Type type;
    uint32_t symbol_id;
    uint64_t timestamp_ns;
    double price;
    double size;
    uint64_t sequence_number;

    // Inline accessors for zero overhead
    constexpr bool isQuote() const noexcept { return type == Type::QUOTE; }
    constexpr bool isTrade() const noexcept { return type == Type::TRADE; }
};

// Single method interface (one virtual call instead of many)
class IMarketDataHandler {
public:
    virtual ~IMarketDataHandler() = default;

    // Single entry point reduces virtual call overhead
    virtual void onMarketData(const MarketDataEvent& event) noexcept = 0;
};

// Type-safe, zero-allocation symbol interface
class ISymbolResolver {
public:
    virtual ~ISymbolResolver() = default;

    // Returns string_view (no allocation)
    [[nodiscard]] virtual std::string_view
    getSymbolName(uint32_t id) const noexcept = 0;

    // Const methods enable compiler optimizations
    [[nodiscard]] virtual uint32_t
    getSymbolId(std::string_view name) const noexcept = 0;
};

// ============================================================================
// ZERO-OVERHEAD IMPLEMENTATION using CRTP
// ============================================================================

// CRTP base provides interface without virtual overhead
template<typename Derived>
class MarketDataHandlerCRTP {
public:
    void onMarketData(const MarketDataEvent& event) noexcept {
        // Static dispatch - zero overhead
        static_cast<Derived*>(this)->handleEvent(event);
    }

    // Specific event handlers can be inlined
    void onQuote(uint32_t symbol_id, double bid, double ask,
                uint64_t timestamp_ns) noexcept {
        static_cast<Derived*>(this)->handleQuote(symbol_id, bid, ask, timestamp_ns);
    }
};

// Concrete implementation
class FastMarketDataHandler : public MarketDataHandlerCRTP<FastMarketDataHandler> {
public:
    // These methods are called via static dispatch (inlined)
    void handleEvent(const MarketDataEvent& event) noexcept {
        switch (event.type) {
            case MarketDataEvent::Type::QUOTE:
                handleQuote(event.symbol_id, event.price, event.size,
                          event.timestamp_ns);
                break;
            case MarketDataEvent::Type::TRADE:
                handleTrade(event.symbol_id, event.price,
                          static_cast<int64_t>(event.size), event.timestamp_ns);
                break;
            default:
                break;
        }
    }

    void handleQuote(uint32_t symbol_id, double bid, double ask,
                    uint64_t timestamp_ns) noexcept {
        // Fast implementation - fully inlined
    }

    void handleTrade(uint32_t symbol_id, double price, int64_t size,
                    uint64_t timestamp_ns) noexcept {
        // Fast implementation - fully inlined
    }
};

// ============================================================================
// PERFORMANCE COMPARISON
// ============================================================================

/*
Virtual interface (dynamic dispatch):
- Each call: ~5-10ns overhead
- 5 virtual methods per event: ~25-50ns total overhead
- Prevents inlining and optimization

CRTP interface (static dispatch):
- Each call: 0ns overhead (fully inlined)
- Complete event handling: ~10-20ns (actual work only)
- Enables aggressive compiler optimization

Speedup: 2-5x for typical market data processing
*/

} // namespace hft::interface

================================================================================
2. ZERO-OVERHEAD ABSTRACTIONS
================================================================================

THEORY:
-------
C++ allows abstractions that compile down to the same code as hand-written
C code. For HFT, we must ensure our interfaces have zero runtime overhead.

TECHNIQUES:
-----------
1. Templates instead of virtual functions
2. constexpr for compile-time computation
3. inline and [[always_inline]] for guaranteed inlining
4. final keyword for devirtualization
5. Policy-based design for compile-time customization

COMPLETE EXAMPLE - Order Router Interface:
-------------------------------------------

namespace hft::zero_overhead {

// ============================================================================
// Routing Policy (compile-time customization)
// ============================================================================

struct AggressiveRoutingPolicy {
    static constexpr bool shouldCross = true;
    static constexpr bool improvePriceByTick = false;
    static constexpr int maxRetries = 0;

    static constexpr double adjustPrice(double price, char side) noexcept {
        return price;  // No adjustment
    }
};

struct PassiveRoutingPolicy {
    static constexpr bool shouldCross = false;
    static constexpr bool improvePriceByTick = true;
    static constexpr int maxRetries = 3;

    static constexpr double adjustPrice(double price, char side) noexcept {
        constexpr double TICK_SIZE = 0.01;
        return (side == 'B') ? (price - TICK_SIZE) : (price + TICK_SIZE);
    }
};

// ============================================================================
// Zero-overhead router using template policies
// ============================================================================

template<typename RoutingPolicy, typename Encoder, typename Sender>
class OrderRouter {
    RoutingPolicy policy_;
    Encoder encoder_;
    Sender sender_;

public:
    OrderRouter(Encoder enc, Sender snd)
        : encoder_(std::move(enc)), sender_(std::move(snd)) {}

    // Completely inlined, zero overhead routing
    [[gnu::always_inline]]
    bool routeOrder(uint64_t order_id, uint32_t symbol_id,
                   double price, int64_t quantity, char side) noexcept {

        // Policy decision at compile time (no runtime cost)
        if constexpr (!RoutingPolicy::shouldCross) {
            // Skip crossing orders at compile time
            if ((side == 'B' && price >= getMarketAsk(symbol_id)) ||
                (side == 'S' && price <= getMarketBid(symbol_id))) {
                return false;
            }
        }

        // Price adjustment at compile time
        double final_price = RoutingPolicy::adjustPrice(price, side);

        // Encode and send
        char buffer[256];
        size_t len = encoder_.encode(order_id, symbol_id, final_price,
                                    quantity, side, buffer, sizeof(buffer));

        // Retry logic unrolled at compile time
        if constexpr (RoutingPolicy::maxRetries > 0) {
            for (int i = 0; i <= RoutingPolicy::maxRetries; ++i) {
                if (sender_.send(buffer, len)) {
                    return true;
                }
            }
            return false;
        } else {
            return sender_.send(buffer, len);
        }
    }

private:
    double getMarketBid(uint32_t symbol_id) const noexcept;
    double getMarketAsk(uint32_t symbol_id) const noexcept;
};

// ============================================================================
// Simple encoder and sender (zero-overhead)
// ============================================================================

struct FastEncoder {
    [[gnu::always_inline]]
    size_t encode(uint64_t order_id, uint32_t symbol_id, double price,
                 int64_t quantity, char side, char* buffer, size_t size) const noexcept {
        // Fast binary encoding
        struct __attribute__((packed)) BinaryOrder {
            uint64_t order_id;
            uint32_t symbol_id;
            uint64_t price;
            uint64_t quantity;
            char side;
        };

        if (size < sizeof(BinaryOrder)) return 0;

        auto* order = reinterpret_cast<BinaryOrder*>(buffer);
        order->order_id = order_id;
        order->symbol_id = symbol_id;
        order->price = static_cast<uint64_t>(price * 100);
        order->quantity = quantity;
        order->side = side;

        return sizeof(BinaryOrder);
    }
};

struct FastSender {
    int socket_fd_;

    explicit FastSender(int fd) : socket_fd_(fd) {}

    [[gnu::always_inline]]
    bool send(const char* buffer, size_t len) const noexcept {
        return ::send(socket_fd_, buffer, len, MSG_DONTWAIT) ==
               static_cast<ssize_t>(len);
    }
};

// ============================================================================
// Usage - completely inlined, zero overhead
// ============================================================================

/*
// Create routers with different policies (no runtime overhead)
OrderRouter<AggressiveRoutingPolicy, FastEncoder, FastSender>
    aggressive_router(FastEncoder{}, FastSender{socket_fd});

OrderRouter<PassiveRoutingPolicy, FastEncoder, FastSender>
    passive_router(FastEncoder{}, FastSender{socket_fd});

// These calls compile to straight-line code with no abstraction overhead
aggressive_router.routeOrder(12345, 100, 150.25, 1000, 'B');
passive_router.routeOrder(12346, 100, 150.30, 500, 'S');

// Generated assembly is identical to hand-written C code
*/

} // namespace hft::zero_overhead

// ============================================================================
// PERFORMANCE ANALYSIS
// ============================================================================

/*
Traditional Virtual Interface:
------------------------------
- Virtual function calls: ~5-10ns each
- Cannot inline across interface boundary
- Prevents many compiler optimizations
- Runtime policy checks: ~2-5ns per check

Total overhead per order: ~20-40ns

Zero-Overhead Template Interface:
---------------------------------
- All calls inlined: 0ns overhead
- Compile-time policy selection: 0ns overhead
- Aggressive compiler optimization: Better than hand-written
- Loop unrolling, constant propagation, etc.

Total overhead per order: 0ns (only actual work)

Speedup: 2-4x for typical order routing
*/

================================================================================
3. CRTP FOR STATIC POLYMORPHISM
================================================================================

THEORY:
-------
Curiously Recurring Template Pattern (CRTP) provides polymorphism without
virtual functions. The base class is templated on the derived class.

BENEFITS FOR HFT:
----------------
- Zero runtime overhead (static dispatch)
- All calls can be inlined
- Enables compiler optimizations
- Type-safe at compile time
- No vtable overhead

COMPLETE EXAMPLE - Exchange Connector:
---------------------------------------

namespace hft::crtp {

// ============================================================================
// CRTP Base Class
// ============================================================================

template<typename Derived>
class ExchangeConnector {
public:
    // Public interface using static dispatch
    [[nodiscard]] bool connect(const char* host, uint16_t port) noexcept {
        return static_cast<Derived*>(this)->connectImpl(host, port);
    }

    [[nodiscard]] bool sendOrder(const char* buffer, size_t len) noexcept {
        // Can add common logic here (called for all derived classes)
        if (len == 0 || len > 4096) return false;

        // Dispatch to derived implementation
        return static_cast<Derived*>(this)->sendOrderImpl(buffer, len);
    }

    [[nodiscard]] ssize_t receiveData(char* buffer, size_t len) noexcept {
        return static_cast<Derived*>(this)->receiveDataImpl(buffer, len);
    }

    void disconnect() noexcept {
        static_cast<Derived*>(this)->disconnectImpl();
    }

    // Common functionality (available to all derived classes)
    [[nodiscard]] bool isConnected() const noexcept {
        return connected_;
    }

    [[nodiscard]] uint64_t getBytesSent() const noexcept {
        return bytes_sent_;
    }

protected:
    bool connected_ = false;
    uint64_t bytes_sent_ = 0;
    uint64_t bytes_received_ = 0;
};

// ============================================================================
// FIX Exchange Connector
// ============================================================================

class FIXConnector : public ExchangeConnector<FIXConnector> {
    int socket_fd_ = -1;
    char session_id_[32];

public:
    // Implementation methods (called via CRTP)
    [[nodiscard]] bool connectImpl(const char* host, uint16_t port) noexcept {
        socket_fd_ = socket(AF_INET, SOCK_STREAM, 0);
        if (socket_fd_ < 0) return false;

        sockaddr_in addr{};
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        inet_pton(AF_INET, host, &addr.sin_addr);

        if (::connect(socket_fd_, (sockaddr*)&addr, sizeof(addr)) < 0) {
            close(socket_fd_);
            socket_fd_ = -1;
            return false;
        }

        connected_ = true;
        return sendLogon();
    }

    [[nodiscard]] bool sendOrderImpl(const char* buffer, size_t len) noexcept {
        if (!connected_ || socket_fd_ < 0) return false;

        ssize_t sent = ::send(socket_fd_, buffer, len, MSG_DONTWAIT);
        if (sent > 0) {
            bytes_sent_ += sent;
            return sent == static_cast<ssize_t>(len);
        }
        return false;
    }

    [[nodiscard]] ssize_t receiveDataImpl(char* buffer, size_t len) noexcept {
        if (!connected_ || socket_fd_ < 0) return -1;

        ssize_t received = ::recv(socket_fd_, buffer, len, MSG_DONTWAIT);
        if (received > 0) {
            bytes_received_ += received;
        }
        return received;
    }

    void disconnectImpl() noexcept {
        if (socket_fd_ >= 0) {
            sendLogout();
            close(socket_fd_);
            socket_fd_ = -1;
        }
        connected_ = false;
    }

private:
    bool sendLogon() noexcept;
    bool sendLogout() noexcept;
};

// ============================================================================
// Binary Exchange Connector (OUCH, ITCH-style)
// ============================================================================

class BinaryConnector : public ExchangeConnector<BinaryConnector> {
    int udp_fd_ = -1;
    sockaddr_in exchange_addr_;

public:
    [[nodiscard]] bool connectImpl(const char* host, uint16_t port) noexcept {
        udp_fd_ = socket(AF_INET, SOCK_DGRAM, 0);
        if (udp_fd_ < 0) return false;

        exchange_addr_.sin_family = AF_INET;
        exchange_addr_.sin_port = htons(port);
        inet_pton(AF_INET, host, &exchange_addr_.sin_addr);

        connected_ = true;
        return true;
    }

    [[nodiscard]] bool sendOrderImpl(const char* buffer, size_t len) noexcept {
        if (!connected_ || udp_fd_ < 0) return false;

        ssize_t sent = sendto(udp_fd_, buffer, len, MSG_DONTWAIT,
                             (sockaddr*)&exchange_addr_, sizeof(exchange_addr_));
        if (sent > 0) {
            bytes_sent_ += sent;
            return sent == static_cast<ssize_t>(len);
        }
        return false;
    }

    [[nodiscard]] ssize_t receiveDataImpl(char* buffer, size_t len) noexcept {
        if (!connected_ || udp_fd_ < 0) return -1;

        socklen_t addr_len = sizeof(exchange_addr_);
        ssize_t received = recvfrom(udp_fd_, buffer, len, MSG_DONTWAIT,
                                   (sockaddr*)&exchange_addr_, &addr_len);
        if (received > 0) {
            bytes_received_ += received;
        }
        return received;
    }

    void disconnectImpl() noexcept {
        if (udp_fd_ >= 0) {
            close(udp_fd_);
            udp_fd_ = -1;
        }
        connected_ = false;
    }
};

// ============================================================================
// Generic connector handler (works with any CRTP-derived connector)
// ============================================================================

template<typename Connector>
class ConnectorManager {
    Connector connector_;

public:
    bool initialize(const char* host, uint16_t port) noexcept {
        // All calls are statically dispatched and inlined
        return connector_.connect(host, port);
    }

    bool sendOrder(const char* buffer, size_t len) noexcept {
        return connector_.sendOrder(buffer, len);
    }

    void processIncoming(char* buffer, size_t len) noexcept {
        ssize_t received = connector_.receiveData(buffer, len);
        if (received > 0) {
            // Process received data
        }
    }

    void shutdown() noexcept {
        connector_.disconnect();
    }
};

// ============================================================================
// Usage
// ============================================================================

/*
// Create managers with different connector types
ConnectorManager<FIXConnector> fix_manager;
ConnectorManager<BinaryConnector> binary_manager;

// Initialize (all calls inlined, zero overhead)
fix_manager.initialize("fix.exchange.com", 8001);
binary_manager.initialize("binary.exchange.com", 9001);

// Send orders (statically dispatched, fully inlined)
fix_manager.sendOrder(fix_buffer, fix_len);
binary_manager.sendOrder(binary_buffer, binary_len);

// No virtual function overhead, no runtime polymorphism cost
*/

} // namespace hft::crtp

// ============================================================================
// PERFORMANCE COMPARISON: Virtual vs CRTP
// ============================================================================

/*
Virtual Polymorphism:
--------------------
class IConnector {
    virtual bool connect(...) = 0;
    virtual bool sendOrder(...) = 0;
    virtual ssize_t receiveData(...) = 0;
};

Cost per operation:
- Virtual call: ~5-10ns
- Cannot inline: prevents optimization
- Cache pollution: vtable lookups
- Total: ~15-25ns overhead per call

CRTP Static Polymorphism:
-------------------------
template<typename Derived>
class ExchangeConnector { ... };

Cost per operation:
- Static dispatch: 0ns
- Fully inlined: enables optimization
- No cache pollution: no vtable
- Total: 0ns overhead

Speedup: 2-3x for connector operations
Memory: Saves 8 bytes per object (no vptr)
*/

This document continues with remaining sections on type-safe interfaces,
fluent design, callbacks, policy-based design, error handling, and versioning...
