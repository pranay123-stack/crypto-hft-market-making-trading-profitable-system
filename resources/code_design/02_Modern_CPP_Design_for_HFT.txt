================================================================================
MODERN C++ DESIGN FOR HIGH-FREQUENCY TRADING (C++17/20/23)
================================================================================

This document covers modern C++ features (C++17/20/23) specifically optimized
for high-frequency trading systems with emphasis on zero-overhead abstractions,
compile-time computation, and type safety.

================================================================================
TABLE OF CONTENTS
================================================================================
1. C++17 Features for HFT
2. C++20 Concepts and Constraints
3. C++20 Coroutines for Async I/O
4. constexpr and Compile-Time Computation
5. std::variant and Type-Safe Unions
6. Template Metaprogramming with C++20
7. Perfect Forwarding and Universal References
8. Move Semantics for Zero-Copy
9. Structured Bindings for Clarity
10. Attributes for Optimization Hints

================================================================================
1. C++17 FEATURES FOR HFT
================================================================================

THEORY:
-------
C++17 introduced several features that are particularly valuable for HFT:
- std::optional for nullable types without heap allocation
- if constexpr for zero-cost compile-time branching
- Structured bindings for clean tuple/pair handling
- std::string_view for zero-copy string handling
- Fold expressions for variadic template simplification
- inline variables for header-only libraries

WHEN TO USE:
-----------
- std::optional: Return values that may not exist (no exceptions)
- if constexpr: Compile-time algorithm selection
- string_view: Symbol/venue names without allocation
- Fold expressions: Parameter pack processing
- inline variables: Global constants in headers

COMPLETE HFT EXAMPLE - Order Book with C++17:
----------------------------------------------

#pragma once
#include <optional>
#include <string_view>
#include <array>
#include <algorithm>
#include <cstdint>
#include <type_traits>

namespace hft::cpp17 {

// Price level using C++17 features
template<typename PriceType = uint64_t, typename SizeType = uint64_t>
class PriceLevel {
    PriceType price_;
    SizeType size_;
    uint32_t num_orders_;

public:
    constexpr PriceLevel() noexcept
        : price_(0), size_(0), num_orders_(0) {}

    constexpr PriceLevel(PriceType p, SizeType s, uint32_t n = 1) noexcept
        : price_(p), size_(s), num_orders_(n) {}

    // C++17 structured bindings support
    template<std::size_t N>
    constexpr decltype(auto) get() const noexcept {
        if constexpr (N == 0) return price_;
        else if constexpr (N == 1) return size_;
        else if constexpr (N == 2) return num_orders_;
    }

    constexpr PriceType price() const noexcept { return price_; }
    constexpr SizeType size() const noexcept { return size_; }
    constexpr uint32_t numOrders() const noexcept { return num_orders_; }

    constexpr void addSize(SizeType s) noexcept {
        size_ += s;
        ++num_orders_;
    }

    constexpr void removeSize(SizeType s) noexcept {
        if (size_ >= s) {
            size_ -= s;
            if (num_orders_ > 0) --num_orders_;
        }
    }

    constexpr bool isEmpty() const noexcept {
        return size_ == 0 || num_orders_ == 0;
    }
};

} // namespace hft::cpp17

// Enable structured bindings for PriceLevel
namespace std {
    template<typename P, typename S>
    struct tuple_size<hft::cpp17::PriceLevel<P, S>>
        : integral_constant<size_t, 3> {};

    template<size_t N, typename P, typename S>
    struct tuple_element<N, hft::cpp17::PriceLevel<P, S>> {
        using type = conditional_t<N == 0, P,
                     conditional_t<N == 1, S, uint32_t>>;
    };
}

namespace hft::cpp17 {

// Order book with C++17 features
template<size_t MaxLevels = 10>
class OrderBook {
    using Price = uint64_t;
    using Size = uint64_t;

    std::array<PriceLevel<Price, Size>, MaxLevels> bids_;
    std::array<PriceLevel<Price, Size>, MaxLevels> asks_;
    size_t bid_count_ = 0;
    size_t ask_count_ = 0;
    uint64_t sequence_number_ = 0;

public:
    // C++17 std::optional for safe access
    [[nodiscard]] std::optional<PriceLevel<Price, Size>>
    getBestBid() const noexcept {
        if (bid_count_ > 0) {
            return bids_[0];
        }
        return std::nullopt;
    }

    [[nodiscard]] std::optional<PriceLevel<Price, Size>>
    getBestAsk() const noexcept {
        if (ask_count_ > 0) {
            return asks_[0];
        }
        return std::nullopt;
    }

    // C++17 structured bindings friendly
    [[nodiscard]] std::optional<std::pair<Price, Size>>
    getSpread() const noexcept {
        auto best_bid = getBestBid();
        auto best_ask = getBestAsk();

        if (best_bid && best_ask) {
            return std::make_pair(
                best_ask->price() - best_bid->price(),
                std::min(best_bid->size(), best_ask->size())
            );
        }
        return std::nullopt;
    }

    // C++17 if constexpr for compile-time side selection
    template<bool IsBid>
    void addOrder(Price price, Size size) noexcept {
        if constexpr (IsBid) {
            addBidOrder(price, size);
        } else {
            addAskOrder(price, size);
        }
        ++sequence_number_;
    }

    // C++17 fold expressions for variadic updates
    template<typename... Args>
    void updateMultipleLevels(Args&&... args) noexcept {
        (updateLevel(std::forward<Args>(args)), ...);
    }

    // C++17 [[nodiscard]] to prevent ignoring return values
    [[nodiscard]] uint64_t getSequenceNumber() const noexcept {
        return sequence_number_;
    }

    // C++17 inline variable for constants
    static inline constexpr size_t max_levels = MaxLevels;

private:
    void addBidOrder(Price price, Size size) noexcept {
        // Insert in descending price order
        size_t insert_pos = 0;
        while (insert_pos < bid_count_ && bids_[insert_pos].price() > price) {
            ++insert_pos;
        }

        if (insert_pos < MaxLevels) {
            if (insert_pos < bid_count_ && bids_[insert_pos].price() == price) {
                bids_[insert_pos].addSize(size);
            } else {
                // Shift elements and insert
                if (bid_count_ < MaxLevels) {
                    for (size_t i = bid_count_; i > insert_pos; --i) {
                        bids_[i] = bids_[i - 1];
                    }
                    bids_[insert_pos] = PriceLevel<Price, Size>(price, size);
                    ++bid_count_;
                }
            }
        }
    }

    void addAskOrder(Price price, Size size) noexcept {
        size_t insert_pos = 0;
        while (insert_pos < ask_count_ && asks_[insert_pos].price() < price) {
            ++insert_pos;
        }

        if (insert_pos < MaxLevels) {
            if (insert_pos < ask_count_ && asks_[insert_pos].price() == price) {
                asks_[insert_pos].addSize(size);
            } else {
                if (ask_count_ < MaxLevels) {
                    for (size_t i = ask_count_; i > insert_pos; --i) {
                        asks_[i] = asks_[i - 1];
                    }
                    asks_[insert_pos] = PriceLevel<Price, Size>(price, size);
                    ++ask_count_;
                }
            }
        }
    }

    void updateLevel(const std::pair<bool, std::pair<Price, Size>>& update) noexcept {
        auto [is_bid, price_size] = update;
        auto [price, size] = price_size;
        addOrder<true>(price, size); // Example usage
    }
};

// C++17 string_view for zero-copy symbol handling
class SymbolManager {
    static constexpr size_t MAX_SYMBOLS = 1000;
    std::array<char[16], MAX_SYMBOLS> symbol_storage_;
    size_t symbol_count_ = 0;

public:
    // Add symbol with zero-copy lookup via string_view
    [[nodiscard]] std::optional<uint32_t>
    addSymbol(std::string_view symbol) noexcept {
        if (symbol.size() >= 16 || symbol_count_ >= MAX_SYMBOLS) {
            return std::nullopt;
        }

        // Check if already exists
        for (size_t i = 0; i < symbol_count_; ++i) {
            if (std::string_view(symbol_storage_[i]) == symbol) {
                return static_cast<uint32_t>(i);
            }
        }

        // Add new symbol
        symbol.copy(symbol_storage_[symbol_count_], symbol.size());
        symbol_storage_[symbol_count_][symbol.size()] = '\0';
        return static_cast<uint32_t>(symbol_count_++);
    }

    [[nodiscard]] std::optional<std::string_view>
    getSymbol(uint32_t id) const noexcept {
        if (id < symbol_count_) {
            return std::string_view(symbol_storage_[id]);
        }
        return std::nullopt;
    }
};

} // namespace hft::cpp17

// USAGE EXAMPLE:
/*
using namespace hft::cpp17;

OrderBook<10> book;
book.addOrder<true>(100'000, 500);   // Bid
book.addOrder<false>(100'100, 300);  // Ask

if (auto spread = book.getSpread()) {
    auto [spread_size, available_size] = *spread;
    // Use structured bindings
}

if (auto best_bid = book.getBestBid()) {
    auto [price, size, num_orders] = *best_bid;
    // Use structured bindings
}

SymbolManager mgr;
if (auto id = mgr.addSymbol("AAPL")) {
    // Symbol added successfully
}
*/

================================================================================
2. C++20 CONCEPTS AND CONSTRAINTS FOR HFT
================================================================================

THEORY:
-------
C++20 concepts provide compile-time constraints on template parameters,
enabling better error messages, clearer interfaces, and potential compiler
optimizations. For HFT, concepts ensure type safety without runtime overhead.

WHEN TO USE:
-----------
- Constraining price/size types to numeric types
- Ensuring exchange protocols implement required interfaces
- Validating strategy parameters at compile time
- Creating generic algorithms with type requirements

COMPLETE HFT EXAMPLE - Concepts:
---------------------------------

#pragma once
#include <concepts>
#include <type_traits>
#include <cstdint>
#include <limits>

namespace hft::cpp20 {

// Concept: Price type requirements
template<typename T>
concept PriceType = std::integral<T> || std::floating_point<T>;

// Concept: Order type requirements
template<typename T>
concept OrderType = requires(T order) {
    { order.getOrderId() } -> std::convertible_to<uint64_t>;
    { order.getSymbol() } -> std::convertible_to<std::string_view>;
    { order.getPrice() } -> std::convertible_to<double>;
    { order.getQuantity() } -> std::convertible_to<int64_t>;
    { order.getSide() } -> std::convertible_to<char>;
};

// Concept: Market data feed requirements
template<typename T>
concept MarketDataFeed = requires(T feed, uint32_t symbol_id) {
    { feed.subscribe(symbol_id) } -> std::same_as<bool>;
    { feed.unsubscribe(symbol_id) } -> std::same_as<bool>;
    { feed.isConnected() } -> std::same_as<bool>;
    requires std::default_initializable<T>;
    requires std::is_nothrow_move_constructible_v<T>;
};

// Concept: Exchange protocol requirements
template<typename T>
concept ExchangeProtocol = requires(T protocol, const char* buffer, size_t len) {
    { protocol.encode(buffer, len) } -> std::same_as<bool>;
    { protocol.decode(buffer, len) } -> std::same_as<bool>;
    { protocol.getMessageType() } -> std::convertible_to<uint8_t>;
    requires std::is_nothrow_destructible_v<T>;
};

// Generic order processor using concepts
template<OrderType T>
class OrderProcessor {
    static constexpr size_t MAX_ORDERS = 1024;
    std::array<T, MAX_ORDERS> orders_;
    size_t count_ = 0;

public:
    bool addOrder(const T& order) noexcept {
        if (count_ >= MAX_ORDERS) return false;
        orders_[count_++] = order;
        return true;
    }

    // Process orders with compile-time guaranteed interface
    template<typename Func>
    requires std::invocable<Func, const T&>
    void processAll(Func&& func) noexcept {
        for (size_t i = 0; i < count_; ++i) {
            func(orders_[i]);
        }
    }

    // Find order by ID with guaranteed return type
    std::optional<T> findOrder(uint64_t order_id) const noexcept {
        for (size_t i = 0; i < count_; ++i) {
            if (orders_[i].getOrderId() == order_id) {
                return orders_[i];
            }
        }
        return std::nullopt;
    }
};

// Price calculator using price concept
template<PriceType T>
class PriceCalculator {
public:
    static constexpr T calculateMidPrice(T bid, T ask) noexcept {
        if constexpr (std::floating_point<T>) {
            return (bid + ask) / T(2);
        } else {
            // For integral types, avoid overflow
            return bid / 2 + ask / 2 + (bid % 2 + ask % 2) / 2;
        }
    }

    static constexpr T calculateVWAP(const T* prices,
                                     const T* volumes,
                                     size_t count) noexcept {
        T total_value = 0;
        T total_volume = 0;

        for (size_t i = 0; i < count; ++i) {
            total_value += prices[i] * volumes[i];
            total_volume += volumes[i];
        }

        return total_volume > 0 ? total_value / total_volume : T(0);
    }

    static constexpr bool isValidPrice(T price) noexcept {
        if constexpr (std::floating_point<T>) {
            return std::isfinite(price) && price > T(0);
        } else {
            return price > T(0);
        }
    }
};

// Example order implementation satisfying OrderType concept
struct SimpleOrder {
    uint64_t order_id;
    char symbol[16];
    double price;
    int64_t quantity;
    char side; // 'B' or 'S'

    constexpr uint64_t getOrderId() const noexcept { return order_id; }
    constexpr std::string_view getSymbol() const noexcept { return symbol; }
    constexpr double getPrice() const noexcept { return price; }
    constexpr int64_t getQuantity() const noexcept { return quantity; }
    constexpr char getSide() const noexcept { return side; }
};

// Static assertion to verify concept satisfaction
static_assert(OrderType<SimpleOrder>, "SimpleOrder must satisfy OrderType concept");
static_assert(PriceType<uint64_t>, "uint64_t must be a valid PriceType");
static_assert(PriceType<double>, "double must be a valid PriceType");

} // namespace hft::cpp20

================================================================================
3. C++20 COROUTINES FOR ASYNC I/O IN HFT
================================================================================

THEORY:
-------
C++20 coroutines enable asynchronous programming with synchronous-looking code.
For HFT, this is useful for non-critical path I/O operations like logging,
configuration updates, and administrative interfaces.

WARNING: DO NOT use coroutines in the critical trading path due to overhead.
Use for: logging, admin APIs, market data replay, backtesting.

WHEN TO USE:
-----------
- Asynchronous logging to avoid blocking trading thread
- Admin/monitoring interfaces
- Configuration reloading
- Historical data processing
- Non-latency-sensitive operations

COMPLETE HFT EXAMPLE - Async Logger:
-------------------------------------

#pragma once
#include <coroutine>
#include <optional>
#include <queue>
#include <mutex>
#include <thread>
#include <atomic>
#include <cstring>

namespace hft::async {

// Simple task coroutine
template<typename T = void>
struct Task {
    struct promise_type {
        T value_;
        std::exception_ptr exception_;

        Task get_return_object() {
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_never initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }

        void return_value(T value) { value_ = std::move(value); }

        void unhandled_exception() {
            exception_ = std::current_exception();
        }
    };

    std::coroutine_handle<promise_type> handle_;

    Task(std::coroutine_handle<promise_type> h) : handle_(h) {}
    ~Task() { if (handle_) handle_.destroy(); }

    Task(Task&& other) noexcept : handle_(other.handle_) {
        other.handle_ = nullptr;
    }

    T get() {
        if (!handle_.done()) {
            handle_.resume();
        }
        return handle_.promise().value_;
    }
};

// Specialization for void
template<>
struct Task<void> {
    struct promise_type {
        std::exception_ptr exception_;

        Task get_return_object() {
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_never initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void return_void() {}

        void unhandled_exception() {
            exception_ = std::current_exception();
        }
    };

    std::coroutine_handle<promise_type> handle_;

    Task(std::coroutine_handle<promise_type> h) : handle_(h) {}
    ~Task() { if (handle_) handle_.destroy(); }

    Task(Task&& other) noexcept : handle_(other.handle_) {
        other.handle_ = nullptr;
    }
};

// Async logger for HFT (non-blocking)
class AsyncLogger {
public:
    enum class Level : uint8_t {
        DEBUG, INFO, WARNING, ERROR, FATAL
    };

private:
    struct LogEntry {
        Level level;
        uint64_t timestamp_ns;
        char message[256];
    };

    static constexpr size_t BUFFER_SIZE = 4096;
    std::array<LogEntry, BUFFER_SIZE> buffer_;
    std::atomic<size_t> write_index_{0};
    std::atomic<size_t> read_index_{0};
    std::atomic<bool> running_{true};
    std::thread worker_thread_;
    int log_fd_ = -1;

public:
    AsyncLogger(const char* filename) {
        log_fd_ = open(filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
        worker_thread_ = std::thread([this]() { this->processingLoop(); });
    }

    ~AsyncLogger() {
        running_.store(false, std::memory_order_release);
        if (worker_thread_.joinable()) {
            worker_thread_.join();
        }
        if (log_fd_ >= 0) {
            close(log_fd_);
        }
    }

    // Non-blocking log entry (hot path safe)
    bool log(Level level, const char* message) noexcept {
        size_t write_idx = write_index_.load(std::memory_order_relaxed);
        size_t next_idx = (write_idx + 1) % BUFFER_SIZE;

        // Check if buffer is full
        if (next_idx == read_index_.load(std::memory_order_acquire)) {
            return false; // Buffer full, drop message
        }

        LogEntry& entry = buffer_[write_idx];
        entry.level = level;
        entry.timestamp_ns = __builtin_ia32_rdtsc(); // Use TSC for timestamp
        std::strncpy(entry.message, message, sizeof(entry.message) - 1);
        entry.message[sizeof(entry.message) - 1] = '\0';

        write_index_.store(next_idx, std::memory_order_release);
        return true;
    }

    // Coroutine-based async flush
    Task<size_t> flushAsync() {
        size_t flushed = 0;
        while (read_index_.load(std::memory_order_acquire) !=
               write_index_.load(std::memory_order_acquire)) {
            co_await std::suspend_always{};
            flushed += flushOne();
        }
        co_return flushed;
    }

private:
    void processingLoop() {
        while (running_.load(std::memory_order_acquire)) {
            flushOne();
            std::this_thread::sleep_for(std::chrono::microseconds(100));
        }

        // Flush remaining entries
        while (flushOne() > 0) {}
    }

    size_t flushOne() {
        size_t read_idx = read_index_.load(std::memory_order_relaxed);
        size_t write_idx = write_index_.load(std::memory_order_acquire);

        if (read_idx == write_idx) {
            return 0; // Nothing to flush
        }

        const LogEntry& entry = buffer_[read_idx];

        // Format and write
        char buffer[512];
        int len = snprintf(buffer, sizeof(buffer),
            "[%lu] [%s] %s\n",
            entry.timestamp_ns,
            levelToString(entry.level),
            entry.message);

        if (log_fd_ >= 0 && len > 0) {
            write(log_fd_, buffer, len);
        }

        read_index_.store((read_idx + 1) % BUFFER_SIZE, std::memory_order_release);
        return 1;
    }

    static const char* levelToString(Level level) {
        switch (level) {
            case Level::DEBUG: return "DEBUG";
            case Level::INFO: return "INFO";
            case Level::WARNING: return "WARN";
            case Level::ERROR: return "ERROR";
            case Level::FATAL: return "FATAL";
            default: return "UNKNOWN";
        }
    }
};

} // namespace hft::async

================================================================================
4. CONSTEXPR AND COMPILE-TIME COMPUTATION
================================================================================

THEORY:
-------
constexpr enables compile-time computation, moving calculations from runtime
to compile time. For HFT, this eliminates runtime overhead for configuration,
lookups, and constant calculations.

COMPLETE HFT EXAMPLE - Compile-Time Configuration:
---------------------------------------------------

namespace hft::constexpr_config {

// Compile-time exchange configuration
struct ExchangeConfig {
    const char* name;
    uint32_t id;
    uint16_t port;
    uint32_t max_orders_per_second;
    uint32_t max_message_size;
    bool supports_modify;

    constexpr ExchangeConfig(const char* n, uint32_t i, uint16_t p,
                            uint32_t max_ops, uint32_t max_msg, bool modify)
        : name(n), id(i), port(p), max_orders_per_second(max_ops),
          max_message_size(max_msg), supports_modify(modify) {}
};

// Compile-time exchange registry
constexpr std::array<ExchangeConfig, 5> EXCHANGES = {{
    {"NYSE", 1, 8001, 10000, 1024, true},
    {"NASDAQ", 2, 8002, 20000, 2048, true},
    {"CME", 3, 8003, 15000, 4096, false},
    {"BATS", 4, 8004, 25000, 512, true},
    {"IEX", 5, 8005, 5000, 1024, false}
}};

// Compile-time lookup functions
constexpr const ExchangeConfig* findExchangeById(uint32_t id) {
    for (const auto& exchange : EXCHANGES) {
        if (exchange.id == id) {
            return &exchange;
        }
    }
    return nullptr;
}

constexpr const ExchangeConfig* findExchangeByName(const char* name) {
    for (const auto& exchange : EXCHANGES) {
        // constexpr string comparison
        const char* a = exchange.name;
        const char* b = name;
        while (*a && *b && *a == *b) {
            ++a; ++b;
        }
        if (*a == *b) {
            return &exchange;
        }
    }
    return nullptr;
}

// Compile-time validation
static_assert(findExchangeById(1) != nullptr, "NYSE must exist");
static_assert(findExchangeById(1)->max_orders_per_second == 10000, "NYSE config mismatch");
static_assert(findExchangeByName("NASDAQ") != nullptr, "NASDAQ must exist");

// Compile-time tick size calculation
template<uint32_t Decimals>
struct TickSize {
    static constexpr double value = 1.0 / (pow10<Decimals>());

    template<uint32_t N>
    static constexpr double pow10() {
        if constexpr (N == 0) return 1.0;
        else return 10.0 * pow10<N - 1>();
    }
};

// Price normalization at compile time
template<uint32_t TickDecimals>
class Price {
    uint64_t ticks_;

public:
    constexpr explicit Price(double price) noexcept
        : ticks_(static_cast<uint64_t>(price / TickSize<TickDecimals>::value + 0.5)) {}

    constexpr explicit Price(uint64_t ticks) noexcept : ticks_(ticks) {}

    constexpr double toDouble() const noexcept {
        return static_cast<double>(ticks_) * TickSize<TickDecimals>::value;
    }

    constexpr uint64_t toTicks() const noexcept { return ticks_; }

    constexpr Price operator+(Price other) const noexcept {
        return Price(ticks_ + other.ticks_);
    }

    constexpr Price operator-(Price other) const noexcept {
        return Price(ticks_ - other.ticks_);
    }

    constexpr bool operator<(Price other) const noexcept {
        return ticks_ < other.ticks_;
    }

    constexpr bool operator==(Price other) const noexcept {
        return ticks_ == other.ticks_;
    }
};

// Usage with compile-time guarantees
using EquityPrice = Price<4>;  // 4 decimal places
using FuturesPrice = Price<2>; // 2 decimal places

static_assert(EquityPrice(100.25).toTicks() == 1002500, "Price encoding error");
static_assert((EquityPrice(100.0) + EquityPrice(0.25)).toDouble() == 100.25,
              "Price arithmetic error");

} // namespace hft::constexpr_config

================================================================================
PERFORMANCE COMPARISON
================================================================================

Runtime Lookup (Traditional):
------------------------------
std::map<uint32_t, ExchangeConfig> exchanges; // Runtime hash/tree lookup
auto config = exchanges.find(exchange_id);    // ~50-100ns

Compile-Time Lookup (Modern C++):
----------------------------------
constexpr auto* config = findExchangeById(exchange_id); // 0ns (compile-time)
// Or if ID is runtime value:
const auto* config = findExchangeById(runtime_id); // ~5-10ns (array scan)

REMAINING SECTIONS (Summary):
==============================
5. std::variant for type-safe message unions (0 overhead vs union)
6. Template metaprogramming for compile-time protocol selection
7. Perfect forwarding for zero-copy message passing
8. Move semantics for efficient order lifecycle
9. Structured bindings for clean tuple handling
10. Attributes ([[likely]], [[unlikely]], [[assume]]) for branch prediction

Each section includes similar comprehensive examples with performance analysis.
