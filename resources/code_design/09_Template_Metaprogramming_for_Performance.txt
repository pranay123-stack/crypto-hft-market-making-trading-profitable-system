================================================================================
TEMPLATE METAPROGRAMMING FOR PERFORMANCE IN HFT
================================================================================

This document covers advanced template metaprogramming techniques that enable
zero-overhead abstractions and compile-time optimizations critical for HFT
systems.

================================================================================
TABLE OF CONTENTS
================================================================================
1. Compile-Time Computation
2. Type Traits and SFINAE
3. Expression Templates
4. Policy-Based Design
5. Template Specialization for Optimization
6. Variadic Templates and Fold Expressions
7. constexpr Functions and Classes
8. Template Metaprogramming for Protocol Selection
9. Zero-Cost Abstractions
10. Compile-Time String Processing

================================================================================
1. COMPILE-TIME COMPUTATION
================================================================================

THEORY:
-------
Move calculations from runtime to compile time using templates and constexpr.
Benefits for HFT:
- Zero runtime overhead
- Smaller code size
- Better optimization opportunities
- Guaranteed compile-time constants

COMPLETE HFT EXAMPLE - Compile-Time Price Conversion:
------------------------------------------------------

#pragma once
#include <cstdint>
#include <type_traits>

namespace hft::metaprogramming {

// ============================================================================
// COMPILE-TIME POWER CALCULATION
// ============================================================================

template<uint64_t Base, uint64_t Exp>
struct Power {
    static constexpr uint64_t value = Base * Power<Base, Exp - 1>::value;
};

template<uint64_t Base>
struct Power<Base, 0> {
    static constexpr uint64_t value = 1;
};

// Usage: Power<10, 6>::value == 1000000 (computed at compile time)
static_assert(Power<10, 0>::value == 1, "10^0 must equal 1");
static_assert(Power<10, 3>::value == 1000, "10^3 must equal 1000");
static_assert(Power<10, 6>::value == 1000000, "10^6 must equal 1000000");

// ============================================================================
// COMPILE-TIME PRICE PRECISION
// ============================================================================

// Price with compile-time precision
template<uint32_t Precision>
class FixedPointPrice {
    static constexpr uint64_t MULTIPLIER = Power<10, Precision>::value;
    int64_t value_;  // Stored as integer (price * MULTIPLIER)

public:
    // Compile-time construction from double
    constexpr explicit FixedPointPrice(double price) noexcept
        : value_(static_cast<int64_t>(price * MULTIPLIER + 0.5)) {}

    // Compile-time construction from integer ticks
    constexpr explicit FixedPointPrice(int64_t ticks) noexcept
        : value_(ticks) {}

    // Convert back to double
    constexpr double toDouble() const noexcept {
        return static_cast<double>(value_) / MULTIPLIER;
    }

    // Get raw ticks value
    constexpr int64_t toTicks() const noexcept {
        return value_;
    }

    // Arithmetic operations (all constexpr)
    constexpr FixedPointPrice operator+(FixedPointPrice other) const noexcept {
        return FixedPointPrice(value_ + other.value_);
    }

    constexpr FixedPointPrice operator-(FixedPointPrice other) const noexcept {
        return FixedPointPrice(value_ - other.value_);
    }

    constexpr FixedPointPrice operator*(int64_t multiplier) const noexcept {
        return FixedPointPrice(value_ * multiplier);
    }

    constexpr FixedPointPrice operator/(int64_t divisor) const noexcept {
        return FixedPointPrice(value_ / divisor);
    }

    // Comparison operators
    constexpr bool operator<(FixedPointPrice other) const noexcept {
        return value_ < other.value_;
    }

    constexpr bool operator>(FixedPointPrice other) const noexcept {
        return value_ > other.value_;
    }

    constexpr bool operator==(FixedPointPrice other) const noexcept {
        return value_ == other.value_;
    }

    constexpr bool operator<=(FixedPointPrice other) const noexcept {
        return value_ <= other.value_;
    }

    constexpr bool operator>=(FixedPointPrice other) const noexcept {
        return value_ >= other.value_;
    }

    // Tick size operations
    static constexpr double tickSize() noexcept {
        return 1.0 / MULTIPLIER;
    }

    static constexpr uint64_t multiplier() noexcept {
        return MULTIPLIER;
    }
};

// Type aliases for different market conventions
using EquityPrice = FixedPointPrice<4>;    // 4 decimal places
using FuturesPrice = FixedPointPrice<2>;   // 2 decimal places
using ForexPrice = FixedPointPrice<5>;     // 5 decimal places
using CryptoPrice = FixedPointPrice<8>;    // 8 decimal places

// Compile-time tests
static_assert(EquityPrice(100.2525).toTicks() == 1002525);
static_assert((EquityPrice(100.0) + EquityPrice(0.25)).toDouble() == 100.25);
static_assert(EquityPrice::tickSize() == 0.0001);
static_assert(EquityPrice::multiplier() == 10000);

// ============================================================================
// COMPILE-TIME INSTRUMENT CONFIGURATION
// ============================================================================

template<uint32_t SymbolId, uint32_t Precision, uint64_t LotSize>
struct InstrumentConfig {
    static constexpr uint32_t symbol_id = SymbolId;
    static constexpr uint32_t precision = Precision;
    static constexpr uint64_t lot_size = LotSize;
    static constexpr double tick_size = 1.0 / Power<10, Precision>::value;

    using PriceType = FixedPointPrice<Precision>;

    // Compile-time validation
    static constexpr bool isValidQuantity(uint64_t qty) noexcept {
        return qty % lot_size == 0;
    }

    static constexpr bool isValidPrice(double price) noexcept {
        int64_t ticks = static_cast<int64_t>(price / tick_size + 0.5);
        return std::abs(price - ticks * tick_size) < 1e-10;
    }
};

// Define instruments at compile time
using AAPL = InstrumentConfig<1, 4, 1>;      // AAPL: 4 decimals, lot size 1
using ES = InstrumentConfig<2, 2, 1>;        // ES futures: 2 decimals, lot size 1
using EURUSD = InstrumentConfig<3, 5, 1000>; // EUR/USD: 5 decimals, lot size 1000

// Compile-time validation
static_assert(AAPL::isValidQuantity(100), "100 shares is valid for AAPL");
static_assert(!EURUSD::isValidQuantity(500), "500 is not valid for EURUSD (lot size 1000)");
static_assert(ES::tick_size == 0.01, "ES tick size must be 0.01");

// ============================================================================
// COMPILE-TIME LOOP UNROLLING
// ============================================================================

template<size_t N>
struct Unroll {
    template<typename Func>
    static inline void apply(Func&& func) noexcept {
        func(N - 1);
        Unroll<N - 1>::apply(std::forward<Func>(func));
    }
};

template<>
struct Unroll<0> {
    template<typename Func>
    static inline void apply(Func&&) noexcept {}
};

// Example: Unrolled order book level iteration
template<size_t Levels>
class OrderBookWithUnrolling {
    struct PriceLevel {
        uint64_t price;
        uint64_t quantity;
    };

    std::array<PriceLevel, Levels> bids_;
    std::array<PriceLevel, Levels> asks_;

public:
    // Calculate VWAP with compile-time unrolled loop
    uint64_t calculateVWAP() const noexcept {
        uint64_t total_value = 0;
        uint64_t total_quantity = 0;

        // Loop unrolled at compile time
        Unroll<Levels>::apply([&](size_t i) {
            total_value += bids_[i].price * bids_[i].quantity;
            total_quantity += bids_[i].quantity;
        });

        return total_quantity > 0 ? total_value / total_quantity : 0;
    }
};

} // namespace hft::metaprogramming

// ============================================================================
// 2. TYPE TRAITS AND SFINAE
// ============================================================================

namespace hft::traits {

// ============================================================================
// CUSTOM TYPE TRAITS FOR HFT
// ============================================================================

// Check if type is a price type
template<typename T>
struct is_price_type : std::false_type {};

template<uint32_t Precision>
struct is_price_type<hft::metaprogramming::FixedPointPrice<Precision>>
    : std::true_type {};

template<typename T>
inline constexpr bool is_price_type_v = is_price_type<T>::value;

// Check if type is trivially copyable (important for network I/O)
template<typename T>
inline constexpr bool is_network_safe_v =
    std::is_trivially_copyable_v<T> &&
    std::is_standard_layout_v<T> &&
    !std::is_pointer_v<T>;

// SFINAE-based function selection
template<typename T>
std::enable_if_t<is_network_safe_v<T>, bool>
sendToNetwork(const T& data, int socket_fd) noexcept {
    // Direct memory copy for POD types
    return ::send(socket_fd, &data, sizeof(T), MSG_DONTWAIT) == sizeof(T);
}

template<typename T>
std::enable_if_t<!is_network_safe_v<T>, bool>
sendToNetwork(const T& data, int socket_fd) noexcept {
    // Serialize complex types
    char buffer[4096];
    size_t size = data.serialize(buffer, sizeof(buffer));
    return ::send(socket_fd, buffer, size, MSG_DONTWAIT) == static_cast<ssize_t>(size);
}

// ============================================================================
// CONCEPT-BASED CONSTRAINTS (C++20)
// ============================================================================

template<typename T>
concept PriceType = requires(T price) {
    { price.toDouble() } -> std::convertible_to<double>;
    { price.toTicks() } -> std::convertible_to<int64_t>;
    { price + price } -> std::same_as<T>;
    { price - price } -> std::same_as<T>;
    { price < price } -> std::convertible_to<bool>;
};

template<typename T>
concept OrderType = requires(T order) {
    { order.order_id } -> std::convertible_to<uint64_t>;
    { order.price } -> std::convertible_to<double>;
    { order.quantity } -> std::convertible_to<int64_t>;
    { order.side } -> std::convertible_to<char>;
};

// Generic function using concepts
template<PriceType T>
constexpr double calculateSpread(T bid, T ask) noexcept {
    return (ask - bid).toDouble();
}

template<OrderType T>
bool validateOrder(const T& order) noexcept {
    return order.price > 0 && order.quantity > 0;
}

} // namespace hft::traits

// ============================================================================
// 3. EXPRESSION TEMPLATES
// ============================================================================

namespace hft::expr_templates {

// Expression template for efficient vector operations
template<typename E>
class VecExpr {
    const E& expr_;

public:
    constexpr explicit VecExpr(const E& expr) noexcept : expr_(expr) {}

    constexpr double operator[](size_t i) const noexcept {
        return expr_[i];
    }

    constexpr size_t size() const noexcept {
        return expr_.size();
    }
};

// Price vector
template<size_t N>
class PriceVector {
    std::array<double, N> data_;

public:
    constexpr PriceVector() noexcept : data_{} {}

    constexpr double operator[](size_t i) const noexcept {
        return data_[i];
    }

    constexpr double& operator[](size_t i) noexcept {
        return data_[i];
    }

    constexpr size_t size() const noexcept {
        return N;
    }

    // Assignment from expression
    template<typename E>
    PriceVector& operator=(const VecExpr<E>& expr) noexcept {
        for (size_t i = 0; i < N; ++i) {
            data_[i] = expr[i];
        }
        return *this;
    }
};

// Addition expression
template<typename E1, typename E2>
class VecAdd {
    const E1& lhs_;
    const E2& rhs_;

public:
    constexpr VecAdd(const E1& lhs, const E2& rhs) noexcept
        : lhs_(lhs), rhs_(rhs) {}

    constexpr double operator[](size_t i) const noexcept {
        return lhs_[i] + rhs_[i];
    }

    constexpr size_t size() const noexcept {
        return lhs_.size();
    }
};

// Multiplication by scalar
template<typename E>
class VecScale {
    const E& expr_;
    double scale_;

public:
    constexpr VecScale(const E& expr, double scale) noexcept
        : expr_(expr), scale_(scale) {}

    constexpr double operator[](size_t i) const noexcept {
        return expr_[i] * scale_;
    }

    constexpr size_t size() const noexcept {
        return expr_.size();
    }
};

// Operator overloads
template<size_t N>
constexpr VecExpr<VecAdd<PriceVector<N>, PriceVector<N>>>
operator+(const PriceVector<N>& lhs, const PriceVector<N>& rhs) noexcept {
    return VecExpr<VecAdd<PriceVector<N>, PriceVector<N>>>(
        VecAdd<PriceVector<N>, PriceVector<N>>(lhs, rhs)
    );
}

template<typename E>
constexpr VecExpr<VecScale<E>>
operator*(const VecExpr<E>& expr, double scale) noexcept {
    return VecExpr<VecScale<E>>(VecScale<E>(expr, scale));
}

// Usage: Complex expressions evaluated in single pass
/*
PriceVector<10> prices1, prices2, result;
// This creates expression template tree, evaluated once during assignment
result = (prices1 + prices2) * 0.5;  // Single loop, no temporaries
*/

} // namespace hft::expr_templates

// ============================================================================
// 4. POLICY-BASED DESIGN
// ============================================================================

namespace hft::policy {

// Order encoding policy
struct BinaryEncodingPolicy {
    template<typename Order>
    static size_t encode(const Order& order, char* buffer, size_t size) noexcept {
        if (size < sizeof(Order)) return 0;
        std::memcpy(buffer, &order, sizeof(Order));
        return sizeof(Order);
    }
};

struct FIXEncodingPolicy {
    template<typename Order>
    static size_t encode(const Order& order, char* buffer, size_t size) noexcept {
        return snprintf(buffer, size,
            "35=D|55=%u|54=%c|38=%ld|44=%.2f|",
            order.symbol_id, order.side, order.quantity, order.price);
    }
};

// Network sending policy
struct TCPSendingPolicy {
    int socket_fd_;

    explicit TCPSendingPolicy(int fd) : socket_fd_(fd) {}

    bool send(const char* buffer, size_t len) const noexcept {
        return ::send(socket_fd_, buffer, len, MSG_DONTWAIT) ==
               static_cast<ssize_t>(len);
    }
};

struct UDPSendingPolicy {
    int socket_fd_;
    sockaddr_in addr_;

    UDPSendingPolicy(int fd, const sockaddr_in& addr)
        : socket_fd_(fd), addr_(addr) {}

    bool send(const char* buffer, size_t len) const noexcept {
        return sendto(socket_fd_, buffer, len, MSG_DONTWAIT,
                     (sockaddr*)&addr_, sizeof(addr_)) ==
               static_cast<ssize_t>(len);
    }
};

// Order sender with policies (all compile-time)
template<typename EncodingPolicy, typename SendingPolicy>
class OrderSender {
    EncodingPolicy encoder_;
    SendingPolicy sender_;

public:
    OrderSender(SendingPolicy sender)
        : sender_(std::move(sender)) {}

    template<typename Order>
    bool sendOrder(const Order& order) noexcept {
        char buffer[4096];
        size_t len = encoder_.encode(order, buffer, sizeof(buffer));
        if (len == 0) return false;
        return sender_.send(buffer, len);
    }
};

// Usage: Zero-overhead policy selection
/*
// Binary over TCP
OrderSender<BinaryEncodingPolicy, TCPSendingPolicy>
    binary_tcp_sender(TCPSendingPolicy{tcp_fd});

// FIX over UDP
OrderSender<FIXEncodingPolicy, UDPSendingPolicy>
    fix_udp_sender(UDPSendingPolicy{udp_fd, exchange_addr});

// All policy selection happens at compile time - zero overhead
*/

} // namespace hft::policy

// ============================================================================
// PERFORMANCE COMPARISON
// ============================================================================

/*
Runtime Polymorphism (Virtual Functions):
-----------------------------------------
class IEncoder {
    virtual size_t encode(...) = 0;
};

class BinaryEncoder : public IEncoder {
    size_t encode(...) override { ... }
};

Cost: 5-10ns per virtual call + prevents inlining

Template Metaprogramming (Compile-Time):
----------------------------------------
template<typename EncodingPolicy>
class OrderSender {
    EncodingPolicy encoder_;
    // encode() called directly, fully inlined
};

Cost: 0ns - completely inlined, same as hand-written

Speedup: 2-5x depending on complexity
Code Size: Larger (one instance per policy combination) but faster
*/

This document continues with template specialization, variadic templates,
constexpr classes, protocol selection, and advanced metaprogramming patterns...
