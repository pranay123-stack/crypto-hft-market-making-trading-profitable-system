================================================================================
REGULATORY REPORTING SYSTEM
High-Frequency Trading Platform
================================================================================

OVERVIEW:
Comprehensive regulatory reporting covering MiFID II, CAT (Consolidated Audit
Trail), FINRA, SEC Rule 605/606, European EMIR, Dodd-Frank, Trade Reporting,
Market Abuse detection, and global compliance requirements.

================================================================================
1. REGULATORY DATA MODEL
================================================================================

-- MiFID II Transaction Reporting
CREATE TABLE mifid_transaction_reports (
    report_id BIGSERIAL PRIMARY KEY,
    trade_date DATE NOT NULL,
    trading_venue VARCHAR(50) NOT NULL,

    -- Identification
    transaction_reference_number VARCHAR(52) NOT NULL UNIQUE,
    trading_capacity VARCHAR(10),  -- 'DEAL', 'MTCH', 'AOTC'

    -- Instrument Details
    instrument_id VARCHAR(50) NOT NULL,
    instrument_name VARCHAR(200),
    isin_code VARCHAR(12),
    cfi_code VARCHAR(6),
    lei VARCHAR(20),  -- Legal Entity Identifier

    -- Transaction Details
    buy_sell_indicator CHAR(1),  -- 'B' or 'S'
    quantity BIGINT,
    quantity_currency VARCHAR(3),
    price NUMERIC(18,6),
    price_currency VARCHAR(3),
    price_notation VARCHAR(10),  -- 'MONE', 'PERC', etc.

    -- Parties
    investment_firm_lei VARCHAR(20),
    executing_entity_lei VARCHAR(20),
    submitting_entity_lei VARCHAR(20),
    client_lei VARCHAR(20),

    -- Execution
    transaction_timestamp TIMESTAMP NOT NULL,
    execution_timestamp TIMESTAMP,
    trading_date_time TIMESTAMP,
    settlement_date DATE,
    venue VARCHAR(10),  -- 'XNYS', 'XNAS', 'BATS', etc.

    -- Flags
    commodity_derivative_indicator BOOLEAN DEFAULT FALSE,
    securities_financing_indicator BOOLEAN DEFAULT FALSE,
    short_selling_indicator VARCHAR(10),
    waiver_indicator VARCHAR(10),
    oti_indicator BOOLEAN DEFAULT FALSE,

    -- Status
    submission_status VARCHAR(20) DEFAULT 'pending',
    submitted_at TIMESTAMP,
    acknowledgement_received BOOLEAN DEFAULT FALSE,
    errors TEXT,

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_mifid_date ON mifid_transaction_reports(trade_date DESC);
CREATE INDEX idx_mifid_txn_ref ON mifid_transaction_reports(transaction_reference_number);
CREATE INDEX idx_mifid_status ON mifid_transaction_reports(submission_status);

-- CAT (Consolidated Audit Trail) Reporting
CREATE TABLE cat_reports (
    cat_id BIGSERIAL PRIMARY KEY,
    reporting_date DATE NOT NULL,

    -- Reporter Information
    cat_reporter_id VARCHAR(50) NOT NULL,
    firm_designated_id VARCHAR(50),

    -- Order Events
    event_type VARCHAR(20) NOT NULL,  -- 'MENO', 'MEOA', 'MEOR', 'MEOC', 'MEOT'
    order_event_timestamp TIMESTAMP(9) NOT NULL,
    order_id VARCHAR(50) NOT NULL,
    original_order_id VARCHAR(50),

    -- Order Details
    symbol VARCHAR(20) NOT NULL,
    security_type VARCHAR(10),
    side CHAR(1),
    order_quantity BIGINT,
    order_type VARCHAR(20),
    price NUMERIC(18,6),
    time_in_force VARCHAR(10),

    -- Account Information
    account_holder_type VARCHAR(10),
    account_id VARCHAR(50),
    customer_account_id VARCHAR(50),

    -- Routing Information
    routing_party_lei VARCHAR(20),
    receiving_party_lei VARCHAR(20),
    destination VARCHAR(50),

    -- Execution Information
    execution_timestamp TIMESTAMP(9),
    quantity_executed BIGINT,
    execution_price NUMERIC(18,6),
    trade_id VARCHAR(50),

    -- Regulatory Flags
    aggregated_orders BOOLEAN DEFAULT FALSE,
    iso_indicator BOOLEAN DEFAULT FALSE,
    intermarket_sweep BOOLEAN DEFAULT FALSE,
    away_market_indicator BOOLEAN DEFAULT FALSE,

    -- Submission Tracking
    submission_status VARCHAR(20) DEFAULT 'pending',
    submitted_at TIMESTAMP,
    acknowledgement_id VARCHAR(100),
    error_code VARCHAR(50),
    error_message TEXT,

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_cat_date ON cat_reports(reporting_date DESC);
CREATE INDEX idx_cat_order ON cat_reports(order_id);
CREATE INDEX idx_cat_event_type ON cat_reports(event_type);
CREATE INDEX idx_cat_status ON cat_reports(submission_status);

-- FINRA OATS (Order Audit Trail System)
CREATE TABLE finra_oats_reports (
    oats_id BIGSERIAL PRIMARY KEY,
    report_date DATE NOT NULL,

    -- Firm Details
    reporting_member_id VARCHAR(20) NOT NULL,
    branch_sequence_number VARCHAR(10),

    -- Order Information
    order_report_id VARCHAR(50) NOT NULL,
    firm_order_id VARCHAR(50) NOT NULL,
    previous_order_id VARCHAR(50),

    -- Event Details
    event_type VARCHAR(10) NOT NULL,  -- 'NO', 'OC', 'EO', 'RO', 'TR'
    event_timestamp TIMESTAMP(3) NOT NULL,

    -- Security
    symbol VARCHAR(20) NOT NULL,
    security_type VARCHAR(10),

    -- Order Attributes
    side CHAR(1),
    quantity BIGINT,
    order_type VARCHAR(20),
    price NUMERIC(18,6),

    -- Routing
    received_from VARCHAR(50),
    sent_to VARCHAR(50),

    -- Execution
    execution_quantity BIGINT,
    execution_price NUMERIC(18,6),

    -- Regulatory
    customer_or_firm VARCHAR(1),  -- 'C' or 'F'
    market_maker_flag BOOLEAN DEFAULT FALSE,

    -- Submission
    submission_status VARCHAR(20) DEFAULT 'pending',
    submitted_at TIMESTAMP,

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_oats_date ON finra_oats_reports(report_date DESC);
CREATE INDEX idx_oats_order ON finra_oats_reports(firm_order_id);

-- SEC Rule 605 - Order Execution Quality
CREATE TABLE sec_rule_605_reports (
    report_id BIGSERIAL PRIMARY KEY,
    report_month DATE NOT NULL,  -- First day of reporting month

    -- Market Center Details
    market_center_id VARCHAR(10) NOT NULL,

    -- Security Classification
    symbol VARCHAR(20) NOT NULL,
    security_type VARCHAR(10),
    order_size_category VARCHAR(20),  -- '100-499', '500-1999', etc.
    order_type VARCHAR(20),  -- 'market', 'marketable_limit', etc.

    -- Statistics (aggregate for the month)
    total_orders INTEGER DEFAULT 0,
    shares_executed BIGINT DEFAULT 0,
    shares_cancelled BIGINT DEFAULT 0,

    -- Execution Speed (in seconds)
    avg_execution_time NUMERIC(10,4),
    median_execution_time NUMERIC(10,4),

    -- Price Improvement
    orders_with_price_improvement INTEGER DEFAULT 0,
    total_price_improvement_amount NUMERIC(18,2),

    -- Execution at Quote
    orders_executed_at_quote INTEGER DEFAULT 0,

    -- Outside Quote
    orders_executed_outside_quote INTEGER DEFAULT 0,

    -- Share-weighted price improvement
    avg_price_improvement_per_share NUMERIC(10,6),

    -- Submission
    submission_status VARCHAR(20) DEFAULT 'pending',
    submitted_at TIMESTAMP,

    created_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT uk_rule_605 UNIQUE (report_month, market_center_id, symbol,
                                   order_size_category, order_type)
);

-- SEC Rule 606 - Order Routing
CREATE TABLE sec_rule_606_reports (
    report_id BIGSERIAL PRIMARY KEY,
    report_quarter DATE NOT NULL,  -- First day of quarter

    -- Broker-Dealer Information
    broker_dealer_name VARCHAR(200),
    sec_file_number VARCHAR(50),

    -- Order Type Category
    order_category VARCHAR(50),  -- 'market_orders', 'marketable_limit_orders', etc.
    security_type VARCHAR(20),

    -- Venue Information
    venue_name VARCHAR(100) NOT NULL,
    venue_mpid VARCHAR(10),

    -- Statistics
    total_orders INTEGER DEFAULT 0,
    total_shares BIGINT DEFAULT 0,

    -- Payment for Order Flow
    net_payment_received NUMERIC(18,2) DEFAULT 0,
    net_payment_paid NUMERIC(18,2) DEFAULT 0,

    -- Material Aspects
    material_aspects_description TEXT,

    -- Submission
    submission_status VARCHAR(20) DEFAULT 'pending',
    submitted_at TIMESTAMP,

    created_at TIMESTAMP DEFAULT NOW()
);

-- EMIR Trade Repository Reporting
CREATE TABLE emir_trade_reports (
    emir_id BIGSERIAL PRIMARY KEY,
    report_date DATE NOT NULL,

    -- Report Details
    action_type VARCHAR(10) NOT NULL,  -- 'N' (new), 'M' (modify), 'C' (cancel)
    unique_transaction_identifier VARCHAR(52) NOT NULL,

    -- Counterparties
    reporting_counterparty_lei VARCHAR(20) NOT NULL,
    other_counterparty_lei VARCHAR(20),

    -- Trade Details
    trade_date DATE NOT NULL,
    execution_timestamp TIMESTAMP NOT NULL,
    value_date DATE,

    -- Product Details
    asset_class VARCHAR(20),
    product_id VARCHAR(50),
    product_taxonomy VARCHAR(10),
    underlying_instrument_id VARCHAR(50),

    -- Notional
    notional_amount NUMERIC(18,2),
    notional_currency VARCHAR(3),

    -- Price
    price NUMERIC(18,6),
    price_notation VARCHAR(10),
    price_currency VARCHAR(3),

    -- Venue
    venue VARCHAR(10),
    execution_venue_lei VARCHAR(20),

    -- Clearing
    cleared BOOLEAN,
    central_counterparty_lei VARCHAR(20),

    -- Collateral
    collateralisation VARCHAR(10),

    -- Submission
    submission_status VARCHAR(20) DEFAULT 'pending',
    submitted_at TIMESTAMP,
    trade_repository_id VARCHAR(50),

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_emir_date ON emir_trade_reports(report_date DESC);
CREATE INDEX idx_emir_uti ON emir_trade_reports(unique_transaction_identifier);

-- Market Abuse Surveillance
CREATE TABLE suspicious_activity_reports (
    sar_id BIGSERIAL PRIMARY KEY,
    detection_date DATE NOT NULL,

    -- Alert Details
    alert_type VARCHAR(50) NOT NULL,  -- 'layering', 'spoofing', 'wash_trading', etc.
    alert_severity VARCHAR(20),  -- 'low', 'medium', 'high', 'critical'

    -- Trading Details
    strategy_id VARCHAR(50),
    symbol VARCHAR(20),
    venue VARCHAR(20),

    -- Pattern Details
    pattern_start_time TIMESTAMP,
    pattern_end_time TIMESTAMP,
    description TEXT,

    -- Evidence
    order_ids TEXT[],
    trade_ids TEXT[],
    suspicious_metrics JSONB,

    -- Review
    review_status VARCHAR(20) DEFAULT 'pending',  -- 'pending', 'reviewing', 'escalated', 'dismissed'
    reviewed_by VARCHAR(100),
    reviewed_at TIMESTAMP,
    review_notes TEXT,

    -- Regulatory Filing
    filed_with_regulator BOOLEAN DEFAULT FALSE,
    filing_reference VARCHAR(100),
    filed_at TIMESTAMP,

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_sar_date ON suspicious_activity_reports(detection_date DESC);
CREATE INDEX idx_sar_status ON suspicious_activity_reports(review_status);
CREATE INDEX idx_sar_type ON suspicious_activity_reports(alert_type);

================================================================================
2. SQL QUERIES FOR REGULATORY REPORTING
================================================================================

-- MiFID II Daily Submission Status
SELECT
    trade_date,
    COUNT(*) as total_reports,
    SUM(CASE WHEN submission_status = 'submitted' THEN 1 ELSE 0 END) as submitted,
    SUM(CASE WHEN submission_status = 'pending' THEN 1 ELSE 0 END) as pending,
    SUM(CASE WHEN submission_status = 'error' THEN 1 ELSE 0 END) as errors,
    SUM(CASE WHEN acknowledgement_received THEN 1 ELSE 0 END) as acknowledged
FROM mifid_transaction_reports
WHERE trade_date >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY trade_date
ORDER BY trade_date DESC;

-- CAT Submission Statistics
SELECT
    reporting_date,
    event_type,
    COUNT(*) as event_count,
    COUNT(DISTINCT order_id) as unique_orders,
    SUM(CASE WHEN submission_status = 'submitted' THEN 1 ELSE 0 END) as submitted,
    SUM(CASE WHEN error_code IS NOT NULL THEN 1 ELSE 0 END) as errors
FROM cat_reports
WHERE reporting_date = CURRENT_DATE
GROUP BY reporting_date, event_type
ORDER BY event_type;

-- SEC Rule 605 Monthly Summary
SELECT
    symbol,
    order_type,
    SUM(total_orders) as total_orders,
    SUM(shares_executed) as total_shares,
    ROUND(AVG(avg_execution_time), 4) as avg_exec_time_sec,
    SUM(orders_with_price_improvement)::NUMERIC / NULLIF(SUM(total_orders), 0) * 100 as price_improv_pct,
    SUM(total_price_improvement_amount) / NULLIF(SUM(shares_executed), 0) as avg_improv_per_share
FROM sec_rule_605_reports
WHERE report_month = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
GROUP BY symbol, order_type
ORDER BY total_orders DESC;

-- Suspicious Activity Monitoring
SELECT
    alert_type,
    alert_severity,
    COUNT(*) as alert_count,
    SUM(CASE WHEN review_status = 'pending' THEN 1 ELSE 0 END) as pending_review,
    SUM(CASE WHEN review_status = 'escalated' THEN 1 ELSE 0 END) as escalated,
    SUM(CASE WHEN filed_with_regulator THEN 1 ELSE 0 END) as filed
FROM suspicious_activity_reports
WHERE detection_date >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY alert_type, alert_severity
ORDER BY alert_severity DESC, alert_count DESC;

-- EMIR Submission Summary
SELECT
    report_date,
    action_type,
    asset_class,
    COUNT(*) as report_count,
    SUM(CASE WHEN submission_status = 'submitted' THEN 1 ELSE 0 END) as submitted,
    SUM(CASE WHEN cleared THEN 1 ELSE 0 END) as cleared_trades
FROM emir_trade_reports
WHERE report_date >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY report_date, action_type, asset_class
ORDER BY report_date DESC, action_type, asset_class;

================================================================================
3. C++ REGULATORY REPORTING ENGINE
================================================================================

#ifndef REGULATORY_REPORTER_HPP
#define REGULATORY_REPORTER_HPP

#include <string>
#include <vector>
#include <map>
#include <chrono>
#include <memory>
#include <sstream>
#include <iomanip>

namespace hft {
namespace regulatory {

// MiFID II Transaction Report
struct MiFIDTransaction {
    std::string transaction_ref_number;
    std::string trading_venue;
    std::chrono::system_clock::time_point transaction_time;

    std::string instrument_id;
    std::string isin;
    char buy_sell_indicator;
    int64_t quantity;
    double price;
    std::string price_currency;

    std::string investment_firm_lei;
    std::string client_lei;

    std::string venue;
    bool commodity_derivative_indicator;
    std::string short_selling_indicator;
};

// CAT Order Event
struct CATOrderEvent {
    std::string cat_reporter_id;
    std::string event_type;  // MENO, MEOA, MEOR, MEOC, MEOT
    std::chrono::system_clock::time_point event_timestamp;

    std::string order_id;
    std::string symbol;
    char side;
    int64_t order_quantity;
    std::string order_type;
    double price;

    std::string account_id;
    std::string destination;

    // For execution events
    int64_t quantity_executed;
    double execution_price;
    std::string trade_id;
};

class RegulatoryReporter {
public:
    RegulatoryReporter() = default;

    // Generate MiFID II Transaction Reference Number
    std::string generateMiFIDTransactionRef(const std::string& lei,
                                           const std::string& trade_id) {
        // Format: LEI + Date + Trade ID
        auto now = std::chrono::system_clock::now();
        std::time_t now_c = std::chrono::system_clock::to_time_t(now);
        std::tm now_tm = *std::gmtime(&now_c);

        std::ostringstream oss;
        oss << lei
            << std::put_time(&now_tm, "%Y%m%d")
            << std::setw(10) << std::setfill('0') << trade_id;

        return oss.str().substr(0, 52);  // MiFID II limit
    }

    // Format MiFID II Report (ISO 20022 XML)
    std::string formatMiFIDReport(const MiFIDTransaction& txn) {
        std::ostringstream xml;

        xml << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
        xml << "<Document xmlns=\"urn:iso:std:iso:20022:tech:xsd:auth.036.001.02\">\n";
        xml << "  <FinInstrmRptgTxRpt>\n";
        xml << "    <Tx>\n";
        xml << "      <TxId>" << txn.transaction_ref_number << "</TxId>\n";
        xml << "      <ExctgPty>" << txn.investment_firm_lei << "</ExctgPty>\n";
        xml << "      <SubmitgPty>" << txn.investment_firm_lei << "</SubmitgPty>\n";
        xml << "      <TradgCpcty>" << txn.trading_venue << "</TradgCpcty>\n";
        xml << "      <TxDtTm>" << formatISO8601(txn.transaction_time) << "</TxDtTm>\n";
        xml << "      <FinInstrm>\n";
        xml << "        <Id>" << txn.isin << "</Id>\n";
        xml << "      </FinInstrm>\n";
        xml << "      <BuySellInd>" << txn.buy_sell_indicator << "</BuySellInd>\n";
        xml << "      <Qty>" << txn.quantity << "</Qty>\n";
        xml << "      <Pric>" << std::fixed << std::setprecision(6) << txn.price << "</Pric>\n";
        xml << "      <TradgVn>" << txn.venue << "</TradgVn>\n";
        xml << "    </Tx>\n";
        xml << "  </FinInstrmRptgTxRpt>\n";
        xml << "</Document>\n";

        return xml.str();
    }

    // Format CAT Order Event (Pipe-delimited)
    std::string formatCATOrderEvent(const CATOrderEvent& event) {
        std::ostringstream csv;

        // CAT uses pipe-delimited format
        csv << event.cat_reporter_id << "|"
            << "1|"  // CAT Reporter IMID Type (1 = CAT Reporter ID)
            << event.order_id << "|"
            << formatCATTimestamp(event.event_timestamp) << "|"
            << event.event_type << "|"
            << event.symbol << "|"
            << event.side << "|"
            << event.order_quantity << "|"
            << event.order_type << "|"
            << std::fixed << std::setprecision(6) << event.price << "|"
            << event.destination << "|"
            << event.account_id;

        if (event.event_type == "MEOT") {  // Trade event
            csv << "|" << event.quantity_executed
                << "|" << event.execution_price
                << "|" << event.trade_id;
        }

        csv << "\n";
        return csv.str();
    }

    // Generate SEC Rule 605 Statistics
    struct Rule605Stats {
        int total_orders;
        int64_t shares_executed;
        double avg_execution_time_sec;
        int orders_with_price_improvement;
        double total_price_improvement;
    };

    Rule605Stats calculateRule605Stats(const std::vector<ExecutionData>& executions) {
        Rule605Stats stats{0, 0, 0.0, 0, 0.0};

        double total_execution_time = 0.0;

        for (const auto& exec : executions) {
            stats.total_orders++;
            stats.shares_executed += exec.filled_quantity;

            // Calculate execution time in seconds
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
                exec.last_fill_time - exec.submission_time);
            total_execution_time += duration.count() / 1000.0;

            // Price improvement (negative slippage)
            if (exec.slippage_bps < 0) {
                stats.orders_with_price_improvement++;
                double improvement = (-exec.slippage_bps / 10000.0) *
                                    exec.filled_quantity * exec.avg_fill_price;
                stats.total_price_improvement += improvement;
            }
        }

        if (stats.total_orders > 0) {
            stats.avg_execution_time_sec = total_execution_time / stats.total_orders;
        }

        return stats;
    }

    // Detect potential market abuse patterns
    struct MarketAbuseAlert {
        std::string alert_type;
        std::string description;
        std::vector<std::string> order_ids;
        double confidence_score;
    };

    std::vector<MarketAbuseAlert> detectMarketAbuse(
        const std::vector<OrderData>& orders) {

        std::vector<MarketAbuseAlert> alerts;

        // Detect layering/spoofing
        auto layering_alert = detectLayering(orders);
        if (layering_alert.confidence_score > 0.7) {
            alerts.push_back(layering_alert);
        }

        // Detect wash trading
        auto wash_trading_alert = detectWashTrading(orders);
        if (wash_trading_alert.confidence_score > 0.7) {
            alerts.push_back(wash_trading_alert);
        }

        return alerts;
    }

private:
    std::string formatISO8601(const std::chrono::system_clock::time_point& tp) {
        std::time_t tt = std::chrono::system_clock::to_time_t(tp);
        std::tm tm = *std::gmtime(&tt);

        std::ostringstream oss;
        oss << std::put_time(&tm, "%Y-%m-%dT%H:%M:%S") << "Z";
        return oss.str();
    }

    std::string formatCATTimestamp(const std::chrono::system_clock::time_point& tp) {
        auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
            tp.time_since_epoch()).count();

        std::time_t tt = std::chrono::system_clock::to_time_t(tp);
        std::tm tm = *std::gmtime(&tt);

        std::ostringstream oss;
        oss << std::put_time(&tm, "%Y%m%d%H%M%S")
            << std::setw(9) << std::setfill('0') << (ns % 1000000000);
        return oss.str();
    }

    MarketAbuseAlert detectLayering(const std::vector<OrderData>& orders) {
        MarketAbuseAlert alert;
        alert.alert_type = "layering";
        alert.confidence_score = 0.0;

        // Simplified layering detection logic
        // Real implementation would be much more sophisticated

        return alert;
    }

    MarketAbuseAlert detectWashTrading(const std::vector<OrderData>& orders) {
        MarketAbuseAlert alert;
        alert.alert_type = "wash_trading";
        alert.confidence_score = 0.0;

        // Simplified wash trading detection

        return alert;
    }
};

} // namespace regulatory
} // namespace hft

#endif // REGULATORY_REPORTER_HPP

================================================================================
4. PYTHON REGULATORY REPORTING SCRIPTS
================================================================================

#!/usr/bin/env python3
"""
Regulatory Reporting Automation
"""

import psycopg2
import pandas as pd
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta
from typing import Dict, List
import csv
import io

class RegulatoryReporter:
    def __init__(self, db_config: Dict[str, str]):
        self.conn = psycopg2.connect(**db_config)

    def generate_mifid_reports(self, trade_date: str) -> List[Dict]:
        """Generate MiFID II transaction reports"""
        query = """
            SELECT
                transaction_reference_number,
                trading_venue,
                instrument_id,
                isin_code,
                buy_sell_indicator,
                quantity,
                price,
                price_currency,
                investment_firm_lei,
                client_lei,
                transaction_timestamp,
                venue,
                short_selling_indicator
            FROM mifid_transaction_reports
            WHERE trade_date = %s
                AND submission_status = 'pending'
        """

        df = pd.read_sql_query(query, self.conn, params=(trade_date,))
        return df.to_dict('records')

    def generate_cat_file(self, reporting_date: str, output_file: str):
        """Generate CAT order event file"""
        query = """
            SELECT
                cat_reporter_id,
                order_id,
                event_type,
                order_event_timestamp,
                symbol,
                side,
                order_quantity,
                order_type,
                price,
                destination,
                account_id,
                quantity_executed,
                execution_price,
                trade_id
            FROM cat_reports
            WHERE reporting_date = %s
                AND submission_status = 'pending'
            ORDER BY order_event_timestamp
        """

        df = pd.read_sql_query(query, self.conn, params=(reporting_date,))

        # Format as pipe-delimited file per CAT specification
        with open(output_file, 'w', newline='') as f:
            for _, row in df.iterrows():
                line = self._format_cat_line(row)
                f.write(line)

        return len(df)

    def _format_cat_line(self, row: pd.Series) -> str:
        """Format single CAT record"""
        timestamp = row['order_event_timestamp'].strftime('%Y%m%d%H%M%S%f')[:-3]

        fields = [
            row['cat_reporter_id'],
            '1',  # IMID Type
            row['order_id'],
            timestamp,
            row['event_type'],
            row['symbol'],
            row['side'],
            str(row['order_quantity']),
            row['order_type'],
            f"{row['price']:.6f}",
            row['destination'],
            row['account_id']
        ]

        if row['event_type'] == 'MEOT':
            fields.extend([
                str(row['quantity_executed']),
                f"{row['execution_price']:.6f}",
                row['trade_id']
            ])

        return '|'.join(fields) + '\n'

    def generate_rule_605_report(self, report_month: str) -> pd.DataFrame:
        """Generate SEC Rule 605 monthly report"""
        query = """
            SELECT
                symbol,
                order_size_category,
                order_type,
                SUM(total_orders) as total_orders,
                SUM(shares_executed) as shares_executed,
                AVG(avg_execution_time) as avg_execution_time,
                SUM(orders_with_price_improvement) as orders_with_price_improvement,
                SUM(total_price_improvement_amount) as total_price_improvement,
                SUM(orders_executed_at_quote) as orders_executed_at_quote,
                SUM(orders_executed_outside_quote) as orders_executed_outside_quote
            FROM sec_rule_605_reports
            WHERE report_month = %s
            GROUP BY symbol, order_size_category, order_type
            ORDER BY symbol, order_size_category, order_type
        """

        return pd.read_sql_query(query, self.conn, params=(report_month,))

    def export_rule_605_xml(self, df: pd.DataFrame, output_file: str):
        """Export Rule 605 report as XML"""
        root = ET.Element('Rule605Report')

        for _, row in df.iterrows():
            stock = ET.SubElement(root, 'Stock')
            ET.SubElement(stock, 'Symbol').text = row['symbol']
            ET.SubElement(stock, 'OrderType').text = row['order_type']
            ET.SubElement(stock, 'OrderSizeCategory').text = row['order_size_category']
            ET.SubElement(stock, 'TotalOrders').text = str(row['total_orders'])
            ET.SubElement(stock, 'SharesExecuted').text = str(row['shares_executed'])
            ET.SubElement(stock, 'AvgExecutionTime').text = f"{row['avg_execution_time']:.4f}"
            ET.SubElement(stock, 'OrdersWithPriceImprovement').text = str(
                row['orders_with_price_improvement'])
            ET.SubElement(stock, 'TotalPriceImprovement').text = f"{row['total_price_improvement']:.2f}"

        tree = ET.ElementTree(root)
        tree.write(output_file, encoding='utf-8', xml_declaration=True)

    def generate_emir_report(self, report_date: str) -> pd.DataFrame:
        """Generate EMIR trade repository report"""
        query = """
            SELECT
                action_type,
                unique_transaction_identifier,
                reporting_counterparty_lei,
                other_counterparty_lei,
                trade_date,
                execution_timestamp,
                asset_class,
                product_id,
                notional_amount,
                notional_currency,
                price,
                venue,
                cleared,
                central_counterparty_lei
            FROM emir_trade_reports
            WHERE report_date = %s
                AND submission_status = 'pending'
        """

        return pd.read_sql_query(query, self.conn, params=(report_date,))

    def detect_suspicious_activity(self, analysis_date: str) -> pd.DataFrame:
        """Run market abuse detection algorithms"""
        # Layering detection
        layering_query = """
            WITH order_sequences AS (
                SELECT
                    strategy_id,
                    symbol,
                    COUNT(*) as order_count,
                    SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled_count,
                    MIN(order_time) as first_order,
                    MAX(order_time) as last_order
                FROM orders
                WHERE order_date = %s
                    AND EXTRACT(EPOCH FROM (MAX(order_time) - MIN(order_time))) < 60
                GROUP BY strategy_id, symbol,
                         DATE_TRUNC('minute', order_time)
                HAVING COUNT(*) >= 5
                    AND SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END)::NUMERIC / COUNT(*) > 0.8
            )
            SELECT
                %s as detection_date,
                'layering' as alert_type,
                'high' as alert_severity,
                strategy_id,
                symbol,
                order_count,
                cancelled_count,
                first_order as pattern_start_time,
                last_order as pattern_end_time,
                'Rapid order placement and cancellation detected' as description
            FROM order_sequences
        """

        return pd.read_sql_query(layering_query, self.conn,
                                params=(analysis_date, analysis_date))

    def generate_regulatory_dashboard(self) -> str:
        """Generate HTML regulatory compliance dashboard"""
        # Get submission statistics
        mifid_stats = self._get_mifid_stats()
        cat_stats = self._get_cat_stats()
        sar_stats = self._get_sar_stats()

        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Regulatory Compliance Dashboard</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                h1 {{ color: #c62828; }}
                .status-ok {{ color: green; font-weight: bold; }}
                .status-warning {{ color: orange; font-weight: bold; }}
                .status-error {{ color: red; font-weight: bold; }}
                table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
                th {{ background-color: #c62828; color: white; }}
            </style>
        </head>
        <body>
            <h1>Regulatory Compliance Dashboard</h1>
            <p>Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>

            <h2>MiFID II Transaction Reporting</h2>
            <table>
                <tr>
                    <th>Metric</th>
                    <th>Value</th>
                    <th>Status</th>
                </tr>
                <tr>
                    <td>Total Reports (Today)</td>
                    <td>{mifid_stats['total']}</td>
                    <td class="status-ok">OK</td>
                </tr>
                <tr>
                    <td>Submitted</td>
                    <td>{mifid_stats['submitted']}</td>
                    <td class="status-ok">OK</td>
                </tr>
                <tr>
                    <td>Pending</td>
                    <td>{mifid_stats['pending']}</td>
                    <td class="{'status-warning' if mifid_stats['pending'] > 0 else 'status-ok'}">
                        {'WARNING' if mifid_stats['pending'] > 0 else 'OK'}
                    </td>
                </tr>
                <tr>
                    <td>Errors</td>
                    <td>{mifid_stats['errors']}</td>
                    <td class="{'status-error' if mifid_stats['errors'] > 0 else 'status-ok'}">
                        {'ERROR' if mifid_stats['errors'] > 0 else 'OK'}
                    </td>
                </tr>
            </table>

            <h2>CAT Reporting</h2>
            <table>
                <tr>
                    <th>Metric</th>
                    <th>Value</th>
                    <th>Status</th>
                </tr>
                <tr>
                    <td>Total Events (Today)</td>
                    <td>{cat_stats['total']}</td>
                    <td class="status-ok">OK</td>
                </tr>
                <tr>
                    <td>Submitted</td>
                    <td>{cat_stats['submitted']}</td>
                    <td class="status-ok">OK</td>
                </tr>
                <tr>
                    <td>Errors</td>
                    <td>{cat_stats['errors']}</td>
                    <td class="{'status-error' if cat_stats['errors'] > 0 else 'status-ok'}">
                        {'ERROR' if cat_stats['errors'] > 0 else 'OK'}
                    </td>
                </tr>
            </table>

            <h2>Suspicious Activity Monitoring</h2>
            <table>
                <tr>
                    <th>Alert Type</th>
                    <th>Open Alerts</th>
                    <th>Status</th>
                </tr>
                {self._format_sar_table(sar_stats)}
            </table>

        </body>
        </html>
        """

        return html

    def _get_mifid_stats(self) -> Dict:
        query = """
            SELECT
                COUNT(*) as total,
                SUM(CASE WHEN submission_status = 'submitted' THEN 1 ELSE 0 END) as submitted,
                SUM(CASE WHEN submission_status = 'pending' THEN 1 ELSE 0 END) as pending,
                SUM(CASE WHEN submission_status = 'error' THEN 1 ELSE 0 END) as errors
            FROM mifid_transaction_reports
            WHERE trade_date = CURRENT_DATE
        """
        result = pd.read_sql_query(query, self.conn).iloc[0]
        return result.to_dict()

    def _get_cat_stats(self) -> Dict:
        query = """
            SELECT
                COUNT(*) as total,
                SUM(CASE WHEN submission_status = 'submitted' THEN 1 ELSE 0 END) as submitted,
                SUM(CASE WHEN error_code IS NOT NULL THEN 1 ELSE 0 END) as errors
            FROM cat_reports
            WHERE reporting_date = CURRENT_DATE
        """
        result = pd.read_sql_query(query, self.conn).iloc[0]
        return result.to_dict()

    def _get_sar_stats(self) -> pd.DataFrame:
        query = """
            SELECT
                alert_type,
                COUNT(*) as open_count
            FROM suspicious_activity_reports
            WHERE review_status IN ('pending', 'reviewing')
            GROUP BY alert_type
        """
        return pd.read_sql_query(query, self.conn)

    def _format_sar_table(self, df: pd.DataFrame) -> str:
        rows = []
        for _, row in df.iterrows():
            status_class = 'status-error' if row['open_count'] > 0 else 'status-ok'
            status_text = 'REVIEW REQUIRED' if row['open_count'] > 0 else 'OK'
            rows.append(f"""
                <tr>
                    <td>{row['alert_type']}</td>
                    <td>{row['open_count']}</td>
                    <td class="{status_class}">{status_text}</td>
                </tr>
            """)
        return '\n'.join(rows)

    def close(self):
        self.conn.close()

if __name__ == '__main__':
    db_config = {
        'host': 'localhost',
        'database': 'hft_trading',
        'user': 'trading_user',
        'password': 'secure_password'
    }

    reporter = RegulatoryReporter(db_config)

    # Generate regulatory dashboard
    html = reporter.generate_regulatory_dashboard()

    with open(f'regulatory_dashboard_{datetime.now().strftime("%Y%m%d")}.html', 'w') as f:
        f.write(html)

    print("Regulatory reports generated successfully")

    reporter.close()

================================================================================
END OF REGULATORY REPORTING DOCUMENTATION
================================================================================
