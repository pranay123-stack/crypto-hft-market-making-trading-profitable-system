================================================================================
RISK REPORTING SYSTEM
High-Frequency Trading Platform
================================================================================

OVERVIEW:
Comprehensive risk reporting system covering market risk, credit risk,
operational risk, compliance monitoring, VaR calculations, stress testing,
position limits, exposure analysis, and regulatory risk metrics.

================================================================================
1. RISK DATA MODEL
================================================================================

-- PostgreSQL Schema for Risk Management

-- Daily Risk Metrics
CREATE TABLE daily_risk_metrics (
    risk_id BIGSERIAL PRIMARY KEY,
    report_date DATE NOT NULL,
    strategy_id VARCHAR(50),
    symbol VARCHAR(20),

    -- Value at Risk (VaR)
    var_95 NUMERIC(18,4),           -- 95% confidence VaR
    var_99 NUMERIC(18,4),           -- 99% confidence VaR
    cvar_95 NUMERIC(18,4),          -- Conditional VaR (Expected Shortfall)
    var_method VARCHAR(20),         -- 'historical', 'parametric', 'monte_carlo'

    -- Position Risk
    net_position BIGINT,
    gross_position BIGINT,
    notional_exposure NUMERIC(18,2),
    delta_exposure NUMERIC(18,4),
    gamma_exposure NUMERIC(18,4),
    vega_exposure NUMERIC(18,4),

    -- P&L Risk
    daily_pnl NUMERIC(18,4),
    daily_pnl_volatility NUMERIC(18,4),
    max_drawdown NUMERIC(18,4),
    sharpe_ratio NUMERIC(8,4),
    sortino_ratio NUMERIC(8,4),

    -- Concentration Risk
    symbol_concentration_pct NUMERIC(6,2),
    strategy_concentration_pct NUMERIC(6,2),
    venue_concentration_pct NUMERIC(6,2),

    -- Liquidity Risk
    avg_daily_volume BIGINT,
    position_volume_ratio NUMERIC(8,4),
    days_to_liquidate NUMERIC(8,2),
    bid_ask_spread_bps NUMERIC(8,2),

    -- Operational Risk
    system_uptime_pct NUMERIC(6,2),
    order_reject_rate NUMERIC(6,4),
    latency_p99_us INTEGER,
    error_count INTEGER,

    created_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT uk_daily_risk UNIQUE (report_date, strategy_id, symbol)
);

CREATE INDEX idx_daily_risk_date ON daily_risk_metrics(report_date DESC);
CREATE INDEX idx_daily_risk_strategy ON daily_risk_metrics(strategy_id, report_date DESC);

-- Position Limits
CREATE TABLE position_limits (
    limit_id SERIAL PRIMARY KEY,
    strategy_id VARCHAR(50),
    symbol VARCHAR(20),
    account_id VARCHAR(50),

    -- Position Limits
    max_net_position BIGINT NOT NULL,
    max_gross_position BIGINT NOT NULL,
    max_order_size BIGINT NOT NULL,

    -- Risk Limits
    max_notional_exposure NUMERIC(18,2),
    max_daily_loss NUMERIC(18,4),
    max_drawdown_pct NUMERIC(6,2),

    -- Concentration Limits
    max_symbol_pct NUMERIC(6,2),
    max_sector_pct NUMERIC(6,2),
    max_venue_pct NUMERIC(6,2),

    -- Rate Limits
    max_orders_per_second INTEGER,
    max_cancels_per_second INTEGER,

    effective_date DATE NOT NULL,
    expiry_date DATE,
    is_active BOOLEAN DEFAULT TRUE,

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Limit Breaches
CREATE TABLE limit_breaches (
    breach_id BIGSERIAL PRIMARY KEY,
    breach_time TIMESTAMP NOT NULL,
    limit_id INTEGER REFERENCES position_limits(limit_id),
    strategy_id VARCHAR(50),
    symbol VARCHAR(20),

    breach_type VARCHAR(50) NOT NULL,  -- 'position', 'loss', 'concentration', etc.
    limit_value NUMERIC(18,4),
    actual_value NUMERIC(18,4),
    breach_percentage NUMERIC(8,2),

    severity VARCHAR(20),  -- 'warning', 'critical', 'breach'
    auto_action_taken VARCHAR(100),
    resolution_status VARCHAR(20) DEFAULT 'open',
    resolved_at TIMESTAMP,
    resolved_by VARCHAR(50),
    notes TEXT,

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_limit_breaches_time ON limit_breaches(breach_time DESC);
CREATE INDEX idx_limit_breaches_strategy ON limit_breaches(strategy_id, breach_time DESC);
CREATE INDEX idx_limit_breaches_status ON limit_breaches(resolution_status, breach_time DESC);

-- Stress Test Scenarios
CREATE TABLE stress_test_scenarios (
    scenario_id SERIAL PRIMARY KEY,
    scenario_name VARCHAR(100) NOT NULL,
    scenario_type VARCHAR(50),  -- 'historical', 'hypothetical', 'regulatory'
    description TEXT,

    -- Market Shocks
    price_shock_pct NUMERIC(8,4),
    volatility_shock_pct NUMERIC(8,4),
    correlation_shock_pct NUMERIC(8,4),

    -- Liquidity Shocks
    volume_reduction_pct NUMERIC(8,4),
    spread_widening_pct NUMERIC(8,4),

    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Stress Test Results
CREATE TABLE stress_test_results (
    result_id BIGSERIAL PRIMARY KEY,
    test_date DATE NOT NULL,
    scenario_id INTEGER REFERENCES stress_test_scenarios(scenario_id),
    strategy_id VARCHAR(50),
    symbol VARCHAR(20),

    base_pnl NUMERIC(18,4),
    stressed_pnl NUMERIC(18,4),
    pnl_impact NUMERIC(18,4),
    pnl_impact_pct NUMERIC(8,4),

    base_var NUMERIC(18,4),
    stressed_var NUMERIC(18,4),
    var_impact NUMERIC(18,4),

    liquidation_cost NUMERIC(18,4),
    margin_call_risk BOOLEAN,

    created_at TIMESTAMP DEFAULT NOW()
);

-- Real-time Risk Monitoring
CREATE TABLE realtime_risk_events (
    event_id BIGSERIAL PRIMARY KEY,
    event_time TIMESTAMP NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    severity VARCHAR(20) NOT NULL,

    strategy_id VARCHAR(50),
    symbol VARCHAR(20),
    venue VARCHAR(20),

    metric_name VARCHAR(50),
    metric_value NUMERIC(18,4),
    threshold_value NUMERIC(18,4),

    alert_sent BOOLEAN DEFAULT FALSE,
    alert_recipients TEXT[],
    auto_action_taken VARCHAR(200),

    acknowledged BOOLEAN DEFAULT FALSE,
    acknowledged_by VARCHAR(50),
    acknowledged_at TIMESTAMP,

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_realtime_risk_time ON realtime_risk_events(event_time DESC);
CREATE INDEX idx_realtime_risk_severity ON realtime_risk_events(severity, event_time DESC);

================================================================================
2. SQL QUERIES FOR RISK ANALYSIS
================================================================================

-- Daily Risk Summary by Strategy
SELECT
    r.strategy_id,
    COUNT(DISTINCT r.symbol) as num_symbols,
    SUM(r.notional_exposure) as total_exposure,
    AVG(r.var_95) as avg_var_95,
    MAX(r.var_95) as max_var_95,
    SUM(r.daily_pnl) as total_pnl,
    AVG(r.sharpe_ratio) as avg_sharpe,
    MAX(r.max_drawdown) as worst_drawdown,
    AVG(r.position_volume_ratio) as avg_liquidity_ratio,
    AVG(r.system_uptime_pct) as avg_uptime
FROM daily_risk_metrics r
WHERE r.report_date = CURRENT_DATE
GROUP BY r.strategy_id
ORDER BY total_exposure DESC;

-- Top Risk Exposures by Symbol
SELECT
    symbol,
    SUM(net_position) as net_pos,
    SUM(gross_position) as gross_pos,
    SUM(notional_exposure) as total_notional,
    AVG(var_95) as avg_var,
    AVG(cvar_95) as avg_cvar,
    AVG(position_volume_ratio) as liquidity_ratio,
    COUNT(DISTINCT strategy_id) as num_strategies
FROM daily_risk_metrics
WHERE report_date = CURRENT_DATE
GROUP BY symbol
ORDER BY total_notional DESC
LIMIT 20;

-- Recent Limit Breaches
SELECT
    lb.breach_time,
    lb.strategy_id,
    lb.symbol,
    lb.breach_type,
    lb.limit_value,
    lb.actual_value,
    lb.breach_percentage,
    lb.severity,
    lb.resolution_status,
    pl.max_net_position,
    pl.max_daily_loss
FROM limit_breaches lb
LEFT JOIN position_limits pl ON lb.limit_id = pl.limit_id
WHERE lb.breach_time >= CURRENT_DATE - INTERVAL '7 days'
    AND lb.resolution_status IN ('open', 'investigating')
ORDER BY lb.breach_time DESC;

-- VaR Backtesting
WITH var_vs_pnl AS (
    SELECT
        report_date,
        strategy_id,
        var_95,
        daily_pnl,
        CASE WHEN daily_pnl < -var_95 THEN 1 ELSE 0 END as var_breach
    FROM daily_risk_metrics
    WHERE report_date >= CURRENT_DATE - INTERVAL '90 days'
)
SELECT
    strategy_id,
    COUNT(*) as total_days,
    SUM(var_breach) as breach_days,
    ROUND(100.0 * SUM(var_breach) / COUNT(*), 2) as breach_rate_pct,
    AVG(var_95) as avg_var,
    MIN(daily_pnl) as worst_loss
FROM var_vs_pnl
GROUP BY strategy_id
ORDER BY breach_rate_pct DESC;

-- Concentration Risk Analysis
SELECT
    report_date,
    symbol,
    SUM(notional_exposure) as symbol_exposure,
    SUM(notional_exposure) / (SELECT SUM(notional_exposure)
                               FROM daily_risk_metrics
                               WHERE report_date = CURRENT_DATE) * 100 as concentration_pct,
    AVG(days_to_liquidate) as avg_liquidation_days,
    COUNT(DISTINCT strategy_id) as num_strategies
FROM daily_risk_metrics
WHERE report_date = CURRENT_DATE
GROUP BY report_date, symbol
HAVING SUM(notional_exposure) / (SELECT SUM(notional_exposure)
                                  FROM daily_risk_metrics
                                  WHERE report_date = CURRENT_DATE) * 100 > 5.0
ORDER BY concentration_pct DESC;

-- Stress Test Summary
SELECT
    sts.scenario_name,
    sts.scenario_type,
    COUNT(DISTINCT str.strategy_id) as strategies_tested,
    AVG(str.pnl_impact) as avg_pnl_impact,
    MIN(str.pnl_impact) as worst_case_impact,
    AVG(str.pnl_impact_pct) as avg_impact_pct,
    SUM(CASE WHEN str.margin_call_risk THEN 1 ELSE 0 END) as margin_call_risks
FROM stress_test_scenarios sts
JOIN stress_test_results str ON sts.scenario_id = str.scenario_id
WHERE str.test_date >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY sts.scenario_name, sts.scenario_type
ORDER BY worst_case_impact ASC;

-- Real-time Risk Alerts (Last Hour)
SELECT
    event_time,
    event_type,
    severity,
    strategy_id,
    symbol,
    metric_name,
    metric_value,
    threshold_value,
    ROUND((metric_value - threshold_value) / threshold_value * 100, 2) as breach_pct,
    auto_action_taken,
    acknowledged
FROM realtime_risk_events
WHERE event_time >= NOW() - INTERVAL '1 hour'
    AND severity IN ('critical', 'high')
ORDER BY event_time DESC;

================================================================================
3. C++ RISK CALCULATION ENGINE
================================================================================

#ifndef RISK_CALCULATOR_HPP
#define RISK_CALCULATOR_HPP

#include <vector>
#include <map>
#include <string>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <memory>
#include <mutex>

namespace hft {
namespace risk {

struct PositionRisk {
    std::string strategy_id;
    std::string symbol;
    int64_t net_position;
    int64_t gross_position;
    double notional_exposure;
    double current_price;
    double avg_entry_price;
    double unrealized_pnl;
};

struct RiskMetrics {
    double var_95;
    double var_99;
    double cvar_95;
    double sharpe_ratio;
    double sortino_ratio;
    double max_drawdown;
    double volatility;
    double beta;
};

class VaRCalculator {
public:
    // Historical VaR
    static double calculateHistoricalVaR(const std::vector<double>& returns,
                                         double confidence_level) {
        if (returns.empty()) return 0.0;

        std::vector<double> sorted_returns = returns;
        std::sort(sorted_returns.begin(), sorted_returns.end());

        size_t index = static_cast<size_t>((1.0 - confidence_level) * sorted_returns.size());
        index = std::min(index, sorted_returns.size() - 1);

        return -sorted_returns[index];
    }

    // Parametric VaR (assumes normal distribution)
    static double calculateParametricVaR(double mean_return, double std_dev,
                                        double confidence_level, double position_value) {
        // Z-score for confidence level
        double z_score = getZScore(confidence_level);
        return position_value * (z_score * std_dev - mean_return);
    }

    // Conditional VaR (Expected Shortfall)
    static double calculateCVaR(const std::vector<double>& returns,
                               double confidence_level) {
        if (returns.empty()) return 0.0;

        std::vector<double> sorted_returns = returns;
        std::sort(sorted_returns.begin(), sorted_returns.end());

        size_t cutoff = static_cast<size_t>((1.0 - confidence_level) * sorted_returns.size());
        cutoff = std::max(cutoff, size_t(1));

        double sum = 0.0;
        for (size_t i = 0; i < cutoff; ++i) {
            sum += sorted_returns[i];
        }

        return -sum / cutoff;
    }

    // Monte Carlo VaR
    static double calculateMonteCarloVaR(double mean_return, double std_dev,
                                        double position_value, double confidence_level,
                                        int num_simulations = 10000) {
        std::vector<double> simulated_returns;
        simulated_returns.reserve(num_simulations);

        std::random_device rd;
        std::mt19937 gen(rd());
        std::normal_distribution<> d(mean_return, std_dev);

        for (int i = 0; i < num_simulations; ++i) {
            simulated_returns.push_back(d(gen));
        }

        return calculateHistoricalVaR(simulated_returns, confidence_level) * position_value;
    }

private:
    static double getZScore(double confidence_level) {
        // Approximate inverse normal CDF
        if (confidence_level == 0.95) return 1.645;
        if (confidence_level == 0.99) return 2.326;
        if (confidence_level == 0.999) return 3.090;
        return 1.645;  // default to 95%
    }
};

class RiskMonitor {
public:
    RiskMonitor() = default;

    void updatePosition(const PositionRisk& position) {
        std::lock_guard<std::mutex> lock(mutex_);
        std::string key = makeKey(position.strategy_id, position.symbol);
        positions_[key] = position;
    }

    void addPnLReturn(const std::string& strategy_id, double return_value) {
        std::lock_guard<std::mutex> lock(mutex_);
        pnl_history_[strategy_id].push_back(return_value);

        // Keep only last 252 days (1 year of trading days)
        if (pnl_history_[strategy_id].size() > 252) {
            pnl_history_[strategy_id].erase(pnl_history_[strategy_id].begin());
        }
    }

    RiskMetrics calculateRiskMetrics(const std::string& strategy_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        RiskMetrics metrics;
        const auto& returns = pnl_history_[strategy_id];

        if (returns.empty()) {
            return metrics;
        }

        // Calculate VaR
        metrics.var_95 = VaRCalculator::calculateHistoricalVaR(returns, 0.95);
        metrics.var_99 = VaRCalculator::calculateHistoricalVaR(returns, 0.99);
        metrics.cvar_95 = VaRCalculator::calculateCVaR(returns, 0.95);

        // Calculate volatility
        double mean = std::accumulate(returns.begin(), returns.end(), 0.0) / returns.size();
        double sq_sum = 0.0;
        for (double ret : returns) {
            sq_sum += (ret - mean) * (ret - mean);
        }
        metrics.volatility = std::sqrt(sq_sum / returns.size());

        // Calculate Sharpe ratio (assuming risk-free rate = 0)
        metrics.sharpe_ratio = metrics.volatility > 0 ? mean / metrics.volatility : 0.0;
        metrics.sharpe_ratio *= std::sqrt(252);  // Annualize

        // Calculate Sortino ratio (downside deviation)
        double downside_sum = 0.0;
        int downside_count = 0;
        for (double ret : returns) {
            if (ret < 0) {
                downside_sum += ret * ret;
                downside_count++;
            }
        }
        double downside_dev = downside_count > 0 ?
                             std::sqrt(downside_sum / downside_count) : metrics.volatility;
        metrics.sortino_ratio = downside_dev > 0 ? mean / downside_dev : 0.0;
        metrics.sortino_ratio *= std::sqrt(252);  // Annualize

        // Calculate max drawdown
        metrics.max_drawdown = calculateMaxDrawdown(returns);

        return metrics;
    }

    double getTotalExposure(const std::string& strategy_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        double total = 0.0;
        for (const auto& [key, pos] : positions_) {
            if (key.find(strategy_id) == 0) {
                total += std::abs(pos.notional_exposure);
            }
        }
        return total;
    }

    double getNetExposure(const std::string& strategy_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        double net = 0.0;
        for (const auto& [key, pos] : positions_) {
            if (key.find(strategy_id) == 0) {
                net += pos.notional_exposure;
            }
        }
        return net;
    }

    std::map<std::string, double> getSymbolConcentration(const std::string& strategy_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        std::map<std::string, double> concentration;
        double total_exposure = getTotalExposure(strategy_id);

        if (total_exposure == 0.0) return concentration;

        for (const auto& [key, pos] : positions_) {
            if (key.find(strategy_id) == 0) {
                double pct = std::abs(pos.notional_exposure) / total_exposure * 100.0;
                concentration[pos.symbol] = pct;
            }
        }

        return concentration;
    }

private:
    std::map<std::string, PositionRisk> positions_;
    std::map<std::string, std::vector<double>> pnl_history_;
    mutable std::mutex mutex_;

    std::string makeKey(const std::string& strategy_id, const std::string& symbol) {
        return strategy_id + "|" + symbol;
    }

    double calculateMaxDrawdown(const std::vector<double>& returns) {
        if (returns.empty()) return 0.0;

        double cumulative = 0.0;
        double peak = 0.0;
        double max_dd = 0.0;

        for (double ret : returns) {
            cumulative += ret;
            peak = std::max(peak, cumulative);
            double drawdown = peak - cumulative;
            max_dd = std::max(max_dd, drawdown);
        }

        return max_dd;
    }
};

// Limit Checker
class LimitChecker {
public:
    struct Limits {
        int64_t max_net_position;
        int64_t max_gross_position;
        double max_notional_exposure;
        double max_daily_loss;
        double max_drawdown_pct;
        double max_symbol_concentration_pct;
    };

    void setLimits(const std::string& strategy_id, const Limits& limits) {
        std::lock_guard<std::mutex> lock(mutex_);
        limits_[strategy_id] = limits;
    }

    struct LimitBreachInfo {
        bool is_breach;
        std::string breach_type;
        double limit_value;
        double actual_value;
        double breach_percentage;
    };

    LimitBreachInfo checkPositionLimit(const std::string& strategy_id,
                                      int64_t net_position,
                                      int64_t gross_position) {
        std::lock_guard<std::mutex> lock(mutex_);

        LimitBreachInfo info{false, "", 0.0, 0.0, 0.0};

        auto it = limits_.find(strategy_id);
        if (it == limits_.end()) return info;

        const auto& limits = it->second;

        // Check net position
        if (std::abs(net_position) > limits.max_net_position) {
            info.is_breach = true;
            info.breach_type = "net_position";
            info.limit_value = limits.max_net_position;
            info.actual_value = std::abs(net_position);
            info.breach_percentage = (info.actual_value - info.limit_value) / info.limit_value * 100.0;
            return info;
        }

        // Check gross position
        if (gross_position > limits.max_gross_position) {
            info.is_breach = true;
            info.breach_type = "gross_position";
            info.limit_value = limits.max_gross_position;
            info.actual_value = gross_position;
            info.breach_percentage = (info.actual_value - info.limit_value) / info.limit_value * 100.0;
            return info;
        }

        return info;
    }

    LimitBreachInfo checkExposureLimit(const std::string& strategy_id,
                                      double notional_exposure) {
        std::lock_guard<std::mutex> lock(mutex_);

        LimitBreachInfo info{false, "", 0.0, 0.0, 0.0};

        auto it = limits_.find(strategy_id);
        if (it == limits_.end()) return info;

        const auto& limits = it->second;

        if (std::abs(notional_exposure) > limits.max_notional_exposure) {
            info.is_breach = true;
            info.breach_type = "notional_exposure";
            info.limit_value = limits.max_notional_exposure;
            info.actual_value = std::abs(notional_exposure);
            info.breach_percentage = (info.actual_value - info.limit_value) / info.limit_value * 100.0;
        }

        return info;
    }

    LimitBreachInfo checkLossLimit(const std::string& strategy_id, double daily_loss) {
        std::lock_guard<std::mutex> lock(mutex_);

        LimitBreachInfo info{false, "", 0.0, 0.0, 0.0};

        auto it = limits_.find(strategy_id);
        if (it == limits_.end()) return info;

        const auto& limits = it->second;

        if (std::abs(daily_loss) > limits.max_daily_loss) {
            info.is_breach = true;
            info.breach_type = "daily_loss";
            info.limit_value = limits.max_daily_loss;
            info.actual_value = std::abs(daily_loss);
            info.breach_percentage = (info.actual_value - info.limit_value) / info.limit_value * 100.0;
        }

        return info;
    }

private:
    std::map<std::string, Limits> limits_;
    mutable std::mutex mutex_;
};

} // namespace risk
} // namespace hft

#endif // RISK_CALCULATOR_HPP

================================================================================
4. PYTHON RISK ANALYSIS SCRIPTS
================================================================================

#!/usr/bin/env python3
"""
Risk Analysis and Reporting Module
"""

import psycopg2
import pandas as pd
import numpy as np
from scipy import stats
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Dict, List, Tuple
import warnings
warnings.filterwarnings('ignore')

class RiskAnalyzer:
    def __init__(self, db_config: Dict[str, str]):
        self.conn = psycopg2.connect(**db_config)

    def get_risk_metrics(self, report_date: str = None) -> pd.DataFrame:
        """Fetch daily risk metrics"""
        if report_date is None:
            report_date = datetime.now().strftime('%Y-%m-%d')

        query = """
            SELECT * FROM daily_risk_metrics
            WHERE report_date = %s
            ORDER BY notional_exposure DESC
        """
        return pd.read_sql_query(query, self.conn, params=(report_date,))

    def calculate_portfolio_var(self, strategy_id: str,
                                lookback_days: int = 90) -> Dict:
        """Calculate portfolio-level VaR"""
        end_date = datetime.now()
        start_date = end_date - timedelta(days=lookback_days)

        query = """
            SELECT report_date, SUM(daily_pnl) as portfolio_pnl
            FROM daily_risk_metrics
            WHERE strategy_id = %s
                AND report_date BETWEEN %s AND %s
            GROUP BY report_date
            ORDER BY report_date
        """

        df = pd.read_sql_query(query, self.conn,
                               params=(strategy_id, start_date, end_date))

        if df.empty:
            return {}

        returns = df['portfolio_pnl'].values

        var_95 = np.percentile(returns, 5)
        var_99 = np.percentile(returns, 1)
        cvar_95 = returns[returns <= var_95].mean()

        return {
            'var_95': abs(var_95),
            'var_99': abs(var_99),
            'cvar_95': abs(cvar_95),
            'mean_pnl': returns.mean(),
            'std_pnl': returns.std(),
            'min_pnl': returns.min(),
            'max_pnl': returns.max()
        }

    def analyze_concentration_risk(self, report_date: str = None) -> pd.DataFrame:
        """Analyze concentration risk by symbol"""
        if report_date is None:
            report_date = datetime.now().strftime('%Y-%m-%d')

        query = """
            SELECT
                symbol,
                SUM(notional_exposure) as total_exposure,
                AVG(position_volume_ratio) as avg_volume_ratio,
                AVG(days_to_liquidate) as avg_days_to_liquidate,
                COUNT(DISTINCT strategy_id) as num_strategies
            FROM daily_risk_metrics
            WHERE report_date = %s
            GROUP BY symbol
            ORDER BY total_exposure DESC
        """

        df = pd.read_sql_query(query, self.conn, params=(report_date,))

        if not df.empty:
            total_exposure = df['total_exposure'].sum()
            df['concentration_pct'] = (df['total_exposure'] / total_exposure * 100)

        return df

    def get_limit_breaches(self, days: int = 7) -> pd.DataFrame:
        """Get recent limit breaches"""
        start_date = datetime.now() - timedelta(days=days)

        query = """
            SELECT
                breach_time,
                strategy_id,
                symbol,
                breach_type,
                limit_value,
                actual_value,
                breach_percentage,
                severity,
                resolution_status
            FROM limit_breaches
            WHERE breach_time >= %s
            ORDER BY breach_time DESC
        """

        return pd.read_sql_query(query, self.conn, params=(start_date,))

    def backtest_var(self, strategy_id: str, days: int = 90) -> Dict:
        """Backtest VaR model accuracy"""
        query = """
            SELECT
                report_date,
                var_95,
                var_99,
                daily_pnl
            FROM daily_risk_metrics
            WHERE strategy_id = %s
                AND report_date >= CURRENT_DATE - INTERVAL '%s days'
            ORDER BY report_date
        """

        df = pd.read_sql_query(query, self.conn, params=(strategy_id, days))

        if df.empty:
            return {}

        # Check VaR breaches
        var_95_breaches = (df['daily_pnl'] < -df['var_95']).sum()
        var_99_breaches = (df['daily_pnl'] < -df['var_99']).sum()

        total_days = len(df)
        expected_95_breaches = total_days * 0.05
        expected_99_breaches = total_days * 0.01

        return {
            'total_days': total_days,
            'var_95_breaches': var_95_breaches,
            'var_95_breach_rate': var_95_breaches / total_days * 100,
            'expected_95_breach_rate': 5.0,
            'var_99_breaches': var_99_breaches,
            'var_99_breach_rate': var_99_breaches / total_days * 100,
            'expected_99_breach_rate': 1.0,
            'model_accurate_95': abs(var_95_breaches - expected_95_breaches) <= 2,
            'model_accurate_99': abs(var_99_breaches - expected_99_breaches) <= 1
        }

    def generate_risk_dashboard(self, report_date: str = None):
        """Generate comprehensive risk dashboard charts"""
        df = self.get_risk_metrics(report_date)

        fig, axes = plt.subplots(2, 3, figsize=(18, 12))

        # VaR Distribution
        axes[0, 0].hist(df['var_95'].dropna(), bins=30, alpha=0.7, color='blue', edgecolor='black')
        axes[0, 0].set_title('VaR 95% Distribution')
        axes[0, 0].set_xlabel('VaR ($)')
        axes[0, 0].set_ylabel('Frequency')
        axes[0, 0].grid(True, alpha=0.3)

        # Exposure by Strategy
        strategy_exposure = df.groupby('strategy_id')['notional_exposure'].sum().sort_values(ascending=False)
        axes[0, 1].barh(strategy_exposure.index, strategy_exposure.values)
        axes[0, 1].set_title('Notional Exposure by Strategy')
        axes[0, 1].set_xlabel('Exposure ($)')
        axes[0, 1].grid(True, alpha=0.3)

        # Sharpe Ratio Distribution
        axes[0, 2].boxplot(df['sharpe_ratio'].dropna())
        axes[0, 2].set_title('Sharpe Ratio Distribution')
        axes[0, 2].set_ylabel('Sharpe Ratio')
        axes[0, 2].grid(True, alpha=0.3)

        # Position vs Volume Ratio
        axes[1, 0].scatter(df['position_volume_ratio'], df['notional_exposure'], alpha=0.6)
        axes[1, 0].set_xlabel('Position/Volume Ratio')
        axes[1, 0].set_ylabel('Notional Exposure ($)')
        axes[1, 0].set_title('Liquidity Risk Analysis')
        axes[1, 0].grid(True, alpha=0.3)

        # Symbol Concentration
        concentration = self.analyze_concentration_risk(report_date)
        if not concentration.empty:
            top_concentration = concentration.head(10)
            axes[1, 1].bar(range(len(top_concentration)), top_concentration['concentration_pct'])
            axes[1, 1].set_xticks(range(len(top_concentration)))
            axes[1, 1].set_xticklabels(top_concentration['symbol'], rotation=45, ha='right')
            axes[1, 1].set_title('Top 10 Symbol Concentration')
            axes[1, 1].set_ylabel('Concentration (%)')
            axes[1, 1].grid(True, alpha=0.3)

        # Max Drawdown
        axes[1, 2].hist(df['max_drawdown'].dropna(), bins=30, alpha=0.7, color='red', edgecolor='black')
        axes[1, 2].set_title('Max Drawdown Distribution')
        axes[1, 2].set_xlabel('Max Drawdown ($)')
        axes[1, 2].set_ylabel('Frequency')
        axes[1, 2].grid(True, alpha=0.3)

        plt.tight_layout()
        return fig

    def generate_html_risk_report(self, report_date: str = None) -> str:
        """Generate HTML risk report"""
        if report_date is None:
            report_date = datetime.now().strftime('%Y-%m-%d')

        df = self.get_risk_metrics(report_date)
        concentration = self.analyze_concentration_risk(report_date)
        breaches = self.get_limit_breaches(7)

        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Daily Risk Report - {report_date}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                h1 {{ color: #d32f2f; }}
                h2 {{ color: #666; margin-top: 30px; }}
                table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                th, td {{ border: 1px solid #ddd; padding: 12px; text-align: right; }}
                th {{ background-color: #d32f2f; color: white; }}
                tr:nth-child(even) {{ background-color: #f2f2f2; }}
                .warning {{ background-color: #fff3cd; }}
                .critical {{ background-color: #f8d7da; }}
                .good {{ color: green; }}
                .bad {{ color: red; }}
            </style>
        </head>
        <body>
            <h1>Daily Risk Report - {report_date}</h1>

            <h2>Portfolio Risk Summary</h2>
            <table style="width: 60%;">
                <tr><td>Total Exposure:</td><td>${df['notional_exposure'].sum():,.2f}</td></tr>
                <tr><td>Avg VaR 95%:</td><td>${df['var_95'].mean():,.2f}</td></tr>
                <tr><td>Max VaR 95%:</td><td>${df['var_95'].max():,.2f}</td></tr>
                <tr><td>Avg Sharpe Ratio:</td><td>{df['sharpe_ratio'].mean():.3f}</td></tr>
                <tr><td>Worst Drawdown:</td><td class="bad">${df['max_drawdown'].max():,.2f}</td></tr>
                <tr><td>Avg Liquidity Ratio:</td><td>{df['position_volume_ratio'].mean():.3f}</td></tr>
            </table>

            <h2>Top 10 Concentration Risks</h2>
            {concentration.head(10).to_html(index=False)}

            <h2>Recent Limit Breaches (Last 7 Days)</h2>
            {breaches.to_html(index=False) if not breaches.empty else '<p>No limit breaches</p>'}

        </body>
        </html>
        """

        return html

    def close(self):
        self.conn.close()

if __name__ == '__main__':
    db_config = {
        'host': 'localhost',
        'database': 'hft_trading',
        'user': 'trading_user',
        'password': 'secure_password'
    }

    analyzer = RiskAnalyzer(db_config)

    # Generate risk report
    html_report = analyzer.generate_html_risk_report()

    # Save report
    with open(f'risk_report_{datetime.now().strftime("%Y%m%d")}.html', 'w') as f:
        f.write(html_report)

    print("Risk report generated successfully")

    analyzer.close()

================================================================================
5. REAL-TIME RISK MONITORING
================================================================================

-- Trigger for real-time risk monitoring
CREATE OR REPLACE FUNCTION monitor_risk_breaches()
RETURNS TRIGGER AS $$
BEGIN
    -- Check position limits
    IF ABS(NEW.net_position) > (
        SELECT max_net_position FROM position_limits
        WHERE strategy_id = NEW.strategy_id
          AND symbol = NEW.symbol
          AND is_active = TRUE
        LIMIT 1
    ) THEN
        INSERT INTO realtime_risk_events (
            event_time, event_type, severity,
            strategy_id, symbol, metric_name,
            metric_value, threshold_value
        ) VALUES (
            NOW(), 'position_limit_breach', 'critical',
            NEW.strategy_id, NEW.symbol, 'net_position',
            ABS(NEW.net_position),
            (SELECT max_net_position FROM position_limits
             WHERE strategy_id = NEW.strategy_id
               AND symbol = NEW.symbol
               AND is_active = TRUE LIMIT 1)
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER risk_monitoring_trigger
    AFTER INSERT OR UPDATE ON daily_risk_metrics
    FOR EACH ROW
    EXECUTE FUNCTION monitor_risk_breaches();

================================================================================
END OF RISK REPORTING DOCUMENTATION
================================================================================
