================================================================================
PERFORMANCE ATTRIBUTION REPORTING
High-Frequency Trading Platform
================================================================================

OVERVIEW:
Comprehensive performance attribution analysis breaking down returns into
alpha, beta, signal quality, timing, execution, and cost components. Multi-
level attribution across strategies, symbols, time periods, and factors.

================================================================================
1. PERFORMANCE ATTRIBUTION DATA MODEL
================================================================================

-- PostgreSQL Schema for Performance Attribution

-- Daily Strategy Attribution
CREATE TABLE strategy_attribution (
    attribution_id BIGSERIAL PRIMARY KEY,
    report_date DATE NOT NULL,
    strategy_id VARCHAR(50) NOT NULL,

    -- Total Returns
    total_return NUMERIC(12,6),
    total_pnl NUMERIC(18,4),

    -- Return Components (in basis points or dollars)
    alpha_return NUMERIC(12,6),
    beta_return NUMERIC(12,6),
    signal_pnl NUMERIC(18,4),
    timing_pnl NUMERIC(18,4),
    execution_pnl NUMERIC(18,4),
    slippage_cost NUMERIC(18,4),
    transaction_cost NUMERIC(18,4),

    -- Factor Exposures
    market_factor_exposure NUMERIC(12,6),
    size_factor_exposure NUMERIC(12,6),
    value_factor_exposure NUMERIC(12,6),
    momentum_factor_exposure NUMERIC(12,6),

    -- Factor Returns
    market_factor_return NUMERIC(12,6),
    size_factor_return NUMERIC(12,6),
    value_factor_return NUMERIC(12,6),
    momentum_factor_return NUMERIC(12,6),

    -- Risk Metrics
    sharpe_ratio NUMERIC(8,4),
    information_ratio NUMERIC(8,4),
    tracking_error NUMERIC(8,4),

    -- Trading Activity
    num_trades INTEGER,
    turnover_ratio NUMERIC(8,4),

    created_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT uk_strategy_attribution UNIQUE (report_date, strategy_id)
);

CREATE INDEX idx_strategy_attr_date ON strategy_attribution(report_date DESC);
CREATE INDEX idx_strategy_attr_strategy ON strategy_attribution(strategy_id, report_date DESC);

-- Symbol-Level Attribution
CREATE TABLE symbol_attribution (
    symbol_attr_id BIGSERIAL PRIMARY KEY,
    report_date DATE NOT NULL,
    strategy_id VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,

    -- Returns
    symbol_pnl NUMERIC(18,4),
    symbol_return NUMERIC(12,6),

    -- Attribution Components
    selection_effect NUMERIC(18,4),      -- Stock selection
    allocation_effect NUMERIC(18,4),     -- Position sizing
    interaction_effect NUMERIC(18,4),    -- Selection x Allocation

    -- Contribution to Strategy
    contribution_to_return NUMERIC(12,6),
    contribution_to_risk NUMERIC(12,6),

    -- Position Metrics
    avg_position NUMERIC(12,2),
    holding_period_days NUMERIC(8,2),

    created_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT uk_symbol_attribution UNIQUE (report_date, strategy_id, symbol)
);

CREATE INDEX idx_symbol_attr_date ON symbol_attribution(report_date DESC);
CREATE INDEX idx_symbol_attr_strategy ON symbol_attribution(strategy_id, report_date DESC);

-- Factor Attribution (Barra-style)
CREATE TABLE factor_attribution (
    factor_attr_id BIGSERIAL PRIMARY KEY,
    report_date DATE NOT NULL,
    strategy_id VARCHAR(50) NOT NULL,
    factor_name VARCHAR(50) NOT NULL,

    -- Factor Exposure
    factor_exposure NUMERIC(12,6),
    factor_return NUMERIC(12,6),

    -- Contribution
    contribution_to_return NUMERIC(18,4),
    contribution_to_risk NUMERIC(12,6),

    -- Factor Statistics
    factor_volatility NUMERIC(12,6),
    factor_correlation NUMERIC(8,4),

    created_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT uk_factor_attribution UNIQUE (report_date, strategy_id, factor_name)
);

CREATE INDEX idx_factor_attr_date ON factor_attribution(report_date DESC);

-- Trade-Level Attribution
CREATE TABLE trade_attribution (
    trade_attr_id BIGSERIAL PRIMARY KEY,
    trade_id VARCHAR(50) NOT NULL,
    trade_date DATE NOT NULL,
    strategy_id VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,

    -- Trade Details
    entry_price NUMERIC(12,6),
    exit_price NUMERIC(12,6),
    quantity BIGINT,
    holding_period_seconds INTEGER,

    -- P&L Components
    realized_pnl NUMERIC(18,4),
    signal_pnl NUMERIC(18,4),
    market_pnl NUMERIC(18,4),
    timing_pnl NUMERIC(18,4),
    execution_cost NUMERIC(18,4),

    -- Attribution
    signal_quality_score NUMERIC(6,4),
    timing_quality_score NUMERIC(6,4),
    execution_quality_score NUMERIC(6,4),

    -- Market Context
    market_return_during_trade NUMERIC(12,6),
    sector_return_during_trade NUMERIC(12,6),
    stock_specific_return NUMERIC(12,6),

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_trade_attr_date ON trade_attribution(trade_date DESC);
CREATE INDEX idx_trade_attr_strategy ON trade_attribution(strategy_id, trade_date DESC);
CREATE INDEX idx_trade_attr_trade_id ON trade_attribution(trade_id);

-- Intraday Attribution
CREATE TABLE intraday_attribution (
    intraday_attr_id BIGSERIAL PRIMARY KEY,
    snapshot_time TIMESTAMP NOT NULL,
    strategy_id VARCHAR(50) NOT NULL,

    -- Cumulative Intraday Returns
    cumulative_pnl NUMERIC(18,4),
    cumulative_return NUMERIC(12,6),

    -- Hour-by-Hour Attribution
    hour_of_day INTEGER,
    hourly_pnl NUMERIC(18,4),
    hourly_alpha NUMERIC(18,4),

    -- Intraday Factors
    open_effect NUMERIC(18,4),
    close_effect NUMERIC(18,4),
    midday_effect NUMERIC(18,4),

    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_intraday_attr_time ON intraday_attribution(snapshot_time DESC);

-- Attribution Summary (Monthly/Quarterly/Yearly)
CREATE TABLE attribution_summary (
    summary_id BIGSERIAL PRIMARY KEY,
    period_type VARCHAR(20) NOT NULL,  -- 'monthly', 'quarterly', 'yearly'
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    strategy_id VARCHAR(50) NOT NULL,

    -- Aggregate Returns
    total_return NUMERIC(12,6),
    total_pnl NUMERIC(18,4),
    annualized_return NUMERIC(12,6),

    -- Attribution Breakdown (%)
    alpha_contribution_pct NUMERIC(8,4),
    beta_contribution_pct NUMERIC(8,4),
    timing_contribution_pct NUMERIC(8,4),
    selection_contribution_pct NUMERIC(8,4),
    costs_contribution_pct NUMERIC(8,4),

    -- Risk-Adjusted Metrics
    sharpe_ratio NUMERIC(8,4),
    information_ratio NUMERIC(8,4),
    sortino_ratio NUMERIC(8,4),
    calmar_ratio NUMERIC(8,4),

    -- Drawdown Analysis
    max_drawdown NUMERIC(18,4),
    max_drawdown_duration_days INTEGER,
    recovery_time_days INTEGER,

    created_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT uk_attribution_summary UNIQUE (period_type, period_start, strategy_id)
);

CREATE INDEX idx_attr_summary_period ON attribution_summary(period_start DESC);

================================================================================
2. SQL QUERIES FOR PERFORMANCE ATTRIBUTION
================================================================================

-- Daily Strategy Attribution Summary
SELECT
    report_date,
    strategy_id,
    total_pnl,
    signal_pnl,
    timing_pnl,
    execution_pnl,
    slippage_cost,
    transaction_cost,
    alpha_return,
    beta_return,
    sharpe_ratio,
    information_ratio,
    ROUND(signal_pnl / NULLIF(total_pnl, 0) * 100, 2) as signal_contribution_pct,
    ROUND(execution_pnl / NULLIF(total_pnl, 0) * 100, 2) as execution_contribution_pct
FROM strategy_attribution
WHERE report_date >= CURRENT_DATE - INTERVAL '30 days'
ORDER BY report_date DESC, total_pnl DESC;

-- Symbol Contribution Analysis
SELECT
    sa.symbol,
    SUM(sa.symbol_pnl) as total_pnl,
    AVG(sa.contribution_to_return) as avg_contribution,
    AVG(sa.selection_effect) as avg_selection,
    AVG(sa.allocation_effect) as avg_allocation,
    COUNT(DISTINCT sa.report_date) as days_traded,
    SUM(sa.symbol_pnl) / SUM(ABS(sa.symbol_pnl)) * 100 as pnl_contribution_pct
FROM symbol_attribution sa
WHERE sa.report_date >= CURRENT_DATE - INTERVAL '30 days'
    AND sa.strategy_id = 'momentum_strategy_1'
GROUP BY sa.symbol
ORDER BY total_pnl DESC
LIMIT 20;

-- Factor Contribution Analysis
SELECT
    fa.factor_name,
    AVG(fa.factor_exposure) as avg_exposure,
    AVG(fa.factor_return) as avg_return,
    SUM(fa.contribution_to_return) as total_contribution,
    AVG(fa.contribution_to_risk) as avg_risk_contribution,
    STDDEV(fa.factor_exposure) as exposure_volatility
FROM factor_attribution fa
WHERE fa.report_date >= CURRENT_DATE - INTERVAL '90 days'
    AND fa.strategy_id = 'momentum_strategy_1'
GROUP BY fa.factor_name
ORDER BY total_contribution DESC;

-- Best and Worst Trades by Attribution
WITH trade_scores AS (
    SELECT
        trade_id,
        symbol,
        realized_pnl,
        signal_pnl,
        execution_cost,
        signal_quality_score,
        timing_quality_score,
        execution_quality_score,
        (signal_quality_score + timing_quality_score + execution_quality_score) / 3.0 as overall_score
    FROM trade_attribution
    WHERE trade_date >= CURRENT_DATE - INTERVAL '7 days'
        AND strategy_id = 'momentum_strategy_1'
)
SELECT
    'Top Performers' as category,
    trade_id,
    symbol,
    realized_pnl,
    signal_quality_score,
    overall_score
FROM trade_scores
ORDER BY realized_pnl DESC
LIMIT 10

UNION ALL

SELECT
    'Worst Performers' as category,
    trade_id,
    symbol,
    realized_pnl,
    signal_quality_score,
    overall_score
FROM trade_scores
ORDER BY realized_pnl ASC
LIMIT 10;

-- Intraday Performance Pattern
SELECT
    hour_of_day,
    AVG(hourly_pnl) as avg_hourly_pnl,
    STDDEV(hourly_pnl) as pnl_std,
    AVG(hourly_alpha) as avg_hourly_alpha,
    COUNT(*) as sample_count
FROM intraday_attribution
WHERE snapshot_time >= CURRENT_DATE - INTERVAL '30 days'
    AND strategy_id = 'momentum_strategy_1'
GROUP BY hour_of_day
ORDER BY hour_of_day;

-- Monthly Attribution Summary with Comparison
SELECT
    period_start,
    strategy_id,
    total_return * 100 as return_pct,
    alpha_contribution_pct,
    beta_contribution_pct,
    timing_contribution_pct,
    selection_contribution_pct,
    costs_contribution_pct,
    sharpe_ratio,
    information_ratio,
    max_drawdown,
    LAG(total_return, 1) OVER (PARTITION BY strategy_id ORDER BY period_start) as prev_month_return,
    total_return - LAG(total_return, 1) OVER (PARTITION BY strategy_id ORDER BY period_start) as mom_change
FROM attribution_summary
WHERE period_type = 'monthly'
    AND period_start >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '12 months')
ORDER BY strategy_id, period_start DESC;

-- Alpha vs Beta Decomposition
SELECT
    sa.strategy_id,
    sa.report_date,
    sa.total_pnl,
    sa.alpha_return * sa.total_pnl / NULLIF(sa.total_return, 0) as alpha_pnl,
    sa.beta_return * sa.total_pnl / NULLIF(sa.total_return, 0) as beta_pnl,
    sa.market_factor_exposure,
    sa.sharpe_ratio,
    sa.information_ratio
FROM strategy_attribution sa
WHERE sa.report_date >= CURRENT_DATE - INTERVAL '90 days'
ORDER BY sa.report_date DESC, sa.total_pnl DESC;

================================================================================
3. C++ PERFORMANCE ATTRIBUTION ENGINE
================================================================================

#ifndef PERFORMANCE_ATTRIBUTION_HPP
#define PERFORMANCE_ATTRIBUTION_HPP

#include <vector>
#include <map>
#include <string>
#include <cmath>
#include <numeric>
#include <algorithm>

namespace hft {
namespace attribution {

struct TradeData {
    std::string trade_id;
    std::string symbol;
    double entry_price;
    double exit_price;
    int64_t quantity;
    double signal_score;
    double market_return;
    double stock_return;
    int64_t holding_period_ms;
    double execution_cost;
};

struct AttributionResult {
    double total_pnl;
    double signal_pnl;
    double timing_pnl;
    double market_pnl;
    double execution_pnl;
    double alpha;
    double beta;
};

class PerformanceAttributor {
public:
    PerformanceAttributor() : risk_free_rate_(0.0) {}

    // Brinson Attribution (Multi-Period)
    struct BrinsonAttribution {
        double allocation_effect;    // Over/underweight contribution
        double selection_effect;      // Stock selection contribution
        double interaction_effect;    // Allocation x Selection
        double total_active_return;
    };

    BrinsonAttribution calculateBrinsonAttribution(
        const std::vector<double>& portfolio_weights,
        const std::vector<double>& benchmark_weights,
        const std::vector<double>& portfolio_returns,
        const std::vector<double>& benchmark_returns) {

        BrinsonAttribution result{0.0, 0.0, 0.0, 0.0};

        if (portfolio_weights.size() != benchmark_weights.size() ||
            portfolio_weights.size() != portfolio_returns.size()) {
            return result;
        }

        // Calculate benchmark return
        double benchmark_return = 0.0;
        for (size_t i = 0; i < benchmark_weights.size(); ++i) {
            benchmark_return += benchmark_weights[i] * benchmark_returns[i];
        }

        for (size_t i = 0; i < portfolio_weights.size(); ++i) {
            double weight_diff = portfolio_weights[i] - benchmark_weights[i];
            double return_diff = portfolio_returns[i] - benchmark_returns[i];

            // Allocation effect: (wi - wB) * (rB - RB)
            result.allocation_effect += weight_diff * (benchmark_returns[i] - benchmark_return);

            // Selection effect: wB * (ri - rB)
            result.selection_effect += benchmark_weights[i] * return_diff;

            // Interaction effect: (wi - wB) * (ri - rB)
            result.interaction_effect += weight_diff * return_diff;
        }

        result.total_active_return = result.allocation_effect +
                                    result.selection_effect +
                                    result.interaction_effect;

        return result;
    }

    // Trade-Level Attribution
    AttributionResult attributeTrade(const TradeData& trade, double market_return) {
        AttributionResult result;

        // Total P&L
        double price_change = trade.exit_price - trade.entry_price;
        result.total_pnl = price_change * trade.quantity;

        // Market P&L (Beta component)
        double beta = estimateBeta(trade.symbol);
        result.market_pnl = market_return * beta * trade.quantity * trade.entry_price;
        result.beta = beta;

        // Stock-specific return (Alpha component)
        double stock_specific_return = trade.stock_return - (beta * market_return);
        result.alpha = stock_specific_return;
        result.signal_pnl = stock_specific_return * trade.quantity * trade.entry_price;

        // Timing P&L (from holding period optimization)
        result.timing_pnl = estimateTimingContribution(trade);

        // Execution costs
        result.execution_pnl = -trade.execution_cost;

        return result;
    }

    // Factor Attribution (Fama-French style)
    struct FactorAttribution {
        double market_contribution;
        double size_contribution;
        double value_contribution;
        double momentum_contribution;
        double residual_alpha;
    };

    FactorAttribution calculateFactorAttribution(
        double portfolio_return,
        double market_return,
        double size_factor_return,
        double value_factor_return,
        double momentum_factor_return,
        const std::vector<double>& factor_exposures) {

        FactorAttribution result;

        if (factor_exposures.size() < 4) {
            return result;
        }

        // Market beta
        double market_beta = factor_exposures[0];
        result.market_contribution = market_beta * market_return;

        // Size (SMB - Small Minus Big)
        double size_beta = factor_exposures[1];
        result.size_contribution = size_beta * size_factor_return;

        // Value (HML - High Minus Low)
        double value_beta = factor_exposures[2];
        result.value_contribution = value_beta * value_factor_return;

        // Momentum (UMD - Up Minus Down)
        double momentum_beta = factor_exposures[3];
        result.momentum_contribution = momentum_beta * momentum_factor_return;

        // Residual alpha
        result.residual_alpha = portfolio_return -
                               (result.market_contribution +
                                result.size_contribution +
                                result.value_contribution +
                                result.momentum_contribution);

        return result;
    }

    // Signal Quality Attribution
    struct SignalQuality {
        double signal_accuracy;      // % of correct signal directions
        double signal_magnitude;     // Average signal strength
        double signal_timing;        // Signal-to-execution delay impact
        double signal_contribution;  // P&L from signal
    };

    SignalQuality evaluateSignalQuality(const std::vector<TradeData>& trades) {
        SignalQuality quality{0.0, 0.0, 0.0, 0.0};

        if (trades.empty()) return quality;

        int correct_signals = 0;
        double total_signal_strength = 0.0;
        double total_signal_pnl = 0.0;

        for (const auto& trade : trades) {
            // Check if signal direction was correct
            double actual_return = (trade.exit_price - trade.entry_price) / trade.entry_price;
            bool correct = (trade.signal_score * actual_return) > 0;
            if (correct) correct_signals++;

            total_signal_strength += std::abs(trade.signal_score);
            total_signal_pnl += actual_return * trade.quantity * trade.entry_price;
        }

        quality.signal_accuracy = static_cast<double>(correct_signals) / trades.size();
        quality.signal_magnitude = total_signal_strength / trades.size();
        quality.signal_contribution = total_signal_pnl;

        return quality;
    }

    // Information Ratio
    double calculateInformationRatio(const std::vector<double>& active_returns) {
        if (active_returns.empty()) return 0.0;

        double mean_active_return = std::accumulate(active_returns.begin(),
                                                    active_returns.end(), 0.0) / active_returns.size();

        // Tracking error (standard deviation of active returns)
        double sq_sum = 0.0;
        for (double ret : active_returns) {
            sq_sum += (ret - mean_active_return) * (ret - mean_active_return);
        }
        double tracking_error = std::sqrt(sq_sum / active_returns.size());

        return tracking_error > 0 ? mean_active_return / tracking_error : 0.0;
    }

    // Sharpe Ratio
    double calculateSharpeRatio(const std::vector<double>& returns) {
        if (returns.empty()) return 0.0;

        double mean_return = std::accumulate(returns.begin(), returns.end(), 0.0) / returns.size();
        double excess_return = mean_return - risk_free_rate_;

        double sq_sum = 0.0;
        for (double ret : returns) {
            sq_sum += (ret - mean_return) * (ret - mean_return);
        }
        double std_dev = std::sqrt(sq_sum / returns.size());

        return std_dev > 0 ? excess_return / std_dev : 0.0;
    }

    // Generate Attribution Report
    std::string generateAttributionReport(const std::string& strategy_id,
                                         const std::vector<TradeData>& trades) {
        std::ostringstream report;
        report << "=== PERFORMANCE ATTRIBUTION REPORT ===\n";
        report << "Strategy: " << strategy_id << "\n\n";

        AttributionResult total_attr{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
        double total_market_return = 0.0;

        for (const auto& trade : trades) {
            auto attr = attributeTrade(trade, trade.market_return);
            total_attr.total_pnl += attr.total_pnl;
            total_attr.signal_pnl += attr.signal_pnl;
            total_attr.timing_pnl += attr.timing_pnl;
            total_attr.market_pnl += attr.market_pnl;
            total_attr.execution_pnl += attr.execution_pnl;
            total_market_return += trade.market_return;
        }

        report << "Total P&L: $" << std::fixed << std::setprecision(2) << total_attr.total_pnl << "\n\n";

        report << "Attribution Breakdown:\n";
        report << "  Signal P&L:     $" << total_attr.signal_pnl
               << " (" << (total_attr.signal_pnl / total_attr.total_pnl * 100) << "%)\n";
        report << "  Timing P&L:     $" << total_attr.timing_pnl
               << " (" << (total_attr.timing_pnl / total_attr.total_pnl * 100) << "%)\n";
        report << "  Market P&L:     $" << total_attr.market_pnl
               << " (" << (total_attr.market_pnl / total_attr.total_pnl * 100) << "%)\n";
        report << "  Execution Cost: $" << total_attr.execution_pnl
               << " (" << (total_attr.execution_pnl / total_attr.total_pnl * 100) << "%)\n\n";

        // Signal quality
        auto signal_quality = evaluateSignalQuality(trades);
        report << "Signal Quality:\n";
        report << "  Accuracy:  " << (signal_quality.signal_accuracy * 100) << "%\n";
        report << "  Magnitude: " << signal_quality.signal_magnitude << "\n\n";

        return report.str();
    }

private:
    double risk_free_rate_;
    std::map<std::string, double> beta_cache_;

    double estimateBeta(const std::string& symbol) {
        auto it = beta_cache_.find(symbol);
        if (it != beta_cache_.end()) {
            return it->second;
        }
        // Default beta
        return 1.0;
    }

    double estimateTimingContribution(const TradeData& trade) {
        // Simplified timing contribution
        // Real implementation would compare actual holding period to optimal
        return 0.0;
    }
};

} // namespace attribution
} // namespace hft

#endif // PERFORMANCE_ATTRIBUTION_HPP

================================================================================
4. PYTHON ATTRIBUTION ANALYSIS SCRIPTS
================================================================================

#!/usr/bin/env python3
"""
Performance Attribution Analysis Module
"""

import psycopg2
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Dict, List
from scipy import stats

class AttributionAnalyzer:
    def __init__(self, db_config: Dict[str, str]):
        self.conn = psycopg2.connect(**db_config)

    def get_strategy_attribution(self, strategy_id: str, days: int = 30) -> pd.DataFrame:
        """Get strategy-level attribution"""
        query = """
            SELECT * FROM strategy_attribution
            WHERE strategy_id = %s
                AND report_date >= CURRENT_DATE - INTERVAL '%s days'
            ORDER BY report_date DESC
        """
        return pd.read_sql_query(query, self.conn, params=(strategy_id, days))

    def calculate_brinson_attribution(self, portfolio_df: pd.DataFrame,
                                     benchmark_df: pd.DataFrame) -> pd.DataFrame:
        """Calculate Brinson attribution (Allocation and Selection effects)"""
        merged = portfolio_df.merge(benchmark_df, on='symbol', suffixes=('_port', '_bench'))

        # Allocation effect: (w_p - w_b) * (r_b - R_b)
        benchmark_return = (merged['weight_bench'] * merged['return_bench']).sum()
        merged['allocation_effect'] = (
            (merged['weight_port'] - merged['weight_bench']) *
            (merged['return_bench'] - benchmark_return)
        )

        # Selection effect: w_b * (r_p - r_b)
        merged['selection_effect'] = (
            merged['weight_bench'] *
            (merged['return_port'] - merged['return_bench'])
        )

        # Interaction effect: (w_p - w_b) * (r_p - r_b)
        merged['interaction_effect'] = (
            (merged['weight_port'] - merged['weight_bench']) *
            (merged['return_port'] - merged['return_bench'])
        )

        return merged

    def factor_attribution(self, returns: pd.Series, factors: pd.DataFrame) -> Dict:
        """Calculate factor attribution using regression"""
        # Fama-French 3-factor model + Momentum
        from sklearn.linear_model import LinearRegression

        X = factors[['market', 'smb', 'hml', 'umd']].values
        y = returns.values

        model = LinearRegression()
        model.fit(X, y)

        factor_contributions = {
            'market': model.coef_[0] * factors['market'].mean(),
            'size': model.coef_[1] * factors['smb'].mean(),
            'value': model.coef_[2] * factors['hml'].mean(),
            'momentum': model.coef_[3] * factors['umd'].mean(),
            'alpha': model.intercept_
        }

        return factor_contributions

    def trade_level_attribution(self, strategy_id: str, days: int = 7) -> pd.DataFrame:
        """Analyze individual trade attribution"""
        query = """
            SELECT
                trade_id,
                symbol,
                realized_pnl,
                signal_pnl,
                market_pnl,
                timing_pnl,
                execution_cost,
                signal_quality_score,
                timing_quality_score,
                execution_quality_score
            FROM trade_attribution
            WHERE strategy_id = %s
                AND trade_date >= CURRENT_DATE - INTERVAL '%s days'
            ORDER BY realized_pnl DESC
        """
        return pd.read_sql_query(query, self.conn, params=(strategy_id, days))

    def intraday_pattern_analysis(self, strategy_id: str) -> pd.DataFrame:
        """Analyze intraday performance patterns"""
        query = """
            SELECT
                hour_of_day,
                AVG(hourly_pnl) as avg_pnl,
                STDDEV(hourly_pnl) as pnl_std,
                AVG(hourly_alpha) as avg_alpha,
                COUNT(*) as observations
            FROM intraday_attribution
            WHERE strategy_id = %s
                AND snapshot_time >= CURRENT_DATE - INTERVAL '30 days'
            GROUP BY hour_of_day
            ORDER BY hour_of_day
        """
        return pd.read_sql_query(query, self.conn, params=(strategy_id,))

    def attribution_decomposition(self, df: pd.DataFrame) -> Dict:
        """Decompose total returns into attribution components"""
        total_pnl = df['total_pnl'].sum()

        decomp = {
            'total_pnl': total_pnl,
            'signal_contribution': df['signal_pnl'].sum() / total_pnl * 100,
            'timing_contribution': df['timing_pnl'].sum() / total_pnl * 100,
            'execution_contribution': df['execution_pnl'].sum() / total_pnl * 100,
            'cost_contribution': df['transaction_cost'].sum() / total_pnl * 100
        }

        return decomp

    def rolling_attribution(self, strategy_id: str, window: int = 20) -> pd.DataFrame:
        """Calculate rolling attribution metrics"""
        df = self.get_strategy_attribution(strategy_id, days=90)

        df['rolling_sharpe'] = df['total_return'].rolling(window).apply(
            lambda x: x.mean() / x.std() * np.sqrt(252) if x.std() > 0 else 0
        )

        df['rolling_alpha'] = df['alpha_return'].rolling(window).mean()
        df['rolling_ir'] = df['information_ratio'].rolling(window).mean()

        return df

    def visualize_attribution(self, strategy_id: str):
        """Create comprehensive attribution visualizations"""
        df = self.get_strategy_attribution(strategy_id, days=60)

        fig, axes = plt.subplots(2, 3, figsize=(18, 12))

        # 1. P&L Attribution Breakdown
        attribution_components = ['signal_pnl', 'timing_pnl', 'execution_pnl',
                                 'slippage_cost', 'transaction_cost']
        avg_contrib = df[attribution_components].mean()
        axes[0, 0].bar(range(len(avg_contrib)), avg_contrib.values)
        axes[0, 0].set_xticks(range(len(avg_contrib)))
        axes[0, 0].set_xticklabels(['Signal', 'Timing', 'Execution', 'Slippage', 'Costs'],
                                   rotation=45, ha='right')
        axes[0, 0].set_ylabel('Avg Daily Contribution ($)')
        axes[0, 0].set_title('P&L Attribution Components')
        axes[0, 0].grid(True, alpha=0.3)

        # 2. Cumulative Attribution
        df_sorted = df.sort_values('report_date')
        df_sorted['cum_signal'] = df_sorted['signal_pnl'].cumsum()
        df_sorted['cum_timing'] = df_sorted['timing_pnl'].cumsum()
        df_sorted['cum_execution'] = df_sorted['execution_pnl'].cumsum()

        axes[0, 1].plot(df_sorted['report_date'], df_sorted['cum_signal'], label='Signal')
        axes[0, 1].plot(df_sorted['report_date'], df_sorted['cum_timing'], label='Timing')
        axes[0, 1].plot(df_sorted['report_date'], df_sorted['cum_execution'], label='Execution')
        axes[0, 1].set_xlabel('Date')
        axes[0, 1].set_ylabel('Cumulative P&L ($)')
        axes[0, 1].set_title('Cumulative Attribution')
        axes[0, 1].legend()
        axes[0, 1].grid(True, alpha=0.3)
        axes[0, 1].tick_params(axis='x', rotation=45)

        # 3. Alpha vs Beta Returns
        axes[0, 2].scatter(df['beta_return'], df['alpha_return'], alpha=0.6)
        axes[0, 2].axhline(y=0, color='r', linestyle='--', alpha=0.5)
        axes[0, 2].axvline(x=0, color='r', linestyle='--', alpha=0.5)
        axes[0, 2].set_xlabel('Beta Return')
        axes[0, 2].set_ylabel('Alpha Return')
        axes[0, 2].set_title('Alpha vs Beta Decomposition')
        axes[0, 2].grid(True, alpha=0.3)

        # 4. Information Ratio Over Time
        axes[1, 0].plot(df_sorted['report_date'], df_sorted['information_ratio'], marker='o')
        axes[1, 0].axhline(y=1.0, color='g', linestyle='--', label='Good IR (>1.0)')
        axes[1, 0].set_xlabel('Date')
        axes[1, 0].set_ylabel('Information Ratio')
        axes[1, 0].set_title('Information Ratio Time Series')
        axes[1, 0].legend()
        axes[1, 0].grid(True, alpha=0.3)
        axes[1, 0].tick_params(axis='x', rotation=45)

        # 5. Factor Exposures
        factor_cols = ['market_factor_exposure', 'size_factor_exposure',
                      'value_factor_exposure', 'momentum_factor_exposure']
        avg_exposures = df[factor_cols].mean()
        axes[1, 1].barh(range(len(avg_exposures)), avg_exposures.values)
        axes[1, 1].set_yticks(range(len(avg_exposures)))
        axes[1, 1].set_yticklabels(['Market', 'Size', 'Value', 'Momentum'])
        axes[1, 1].set_xlabel('Average Exposure')
        axes[1, 1].set_title('Factor Exposures')
        axes[1, 1].grid(True, alpha=0.3)

        # 6. Sharpe Ratio Distribution
        axes[1, 2].hist(df['sharpe_ratio'].dropna(), bins=30, alpha=0.7, edgecolor='black')
        axes[1, 2].axvline(df['sharpe_ratio'].mean(), color='r', linestyle='--',
                          label=f'Mean: {df["sharpe_ratio"].mean():.2f}')
        axes[1, 2].set_xlabel('Sharpe Ratio')
        axes[1, 2].set_ylabel('Frequency')
        axes[1, 2].set_title('Sharpe Ratio Distribution')
        axes[1, 2].legend()
        axes[1, 2].grid(True, alpha=0.3)

        plt.tight_layout()
        return fig

    def generate_attribution_report(self, strategy_id: str) -> str:
        """Generate comprehensive attribution HTML report"""
        df = self.get_strategy_attribution(strategy_id, days=30)
        decomp = self.attribution_decomposition(df)

        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Performance Attribution Report - {strategy_id}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                h1 {{ color: #1565c0; }}
                table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                th, td {{ border: 1px solid #ddd; padding: 12px; text-align: right; }}
                th {{ background-color: #1565c0; color: white; }}
                .positive {{ color: green; font-weight: bold; }}
                .negative {{ color: red; font-weight: bold; }}
            </style>
        </head>
        <body>
            <h1>Performance Attribution Report</h1>
            <h2>Strategy: {strategy_id}</h2>
            <p>Period: Last 30 days</p>

            <h3>Attribution Summary</h3>
            <table style="width: 60%;">
                <tr><td>Total P&L:</td><td class="{'positive' if decomp['total_pnl'] > 0 else 'negative'}">${decomp['total_pnl']:,.2f}</td></tr>
                <tr><td>Signal Contribution:</td><td>{decomp['signal_contribution']:.1f}%</td></tr>
                <tr><td>Timing Contribution:</td><td>{decomp['timing_contribution']:.1f}%</td></tr>
                <tr><td>Execution Contribution:</td><td>{decomp['execution_contribution']:.1f}%</td></tr>
                <tr><td>Cost Impact:</td><td class="negative">{decomp['cost_contribution']:.1f}%</td></tr>
            </table>

            <h3>Risk-Adjusted Performance</h3>
            <table style="width: 60%;">
                <tr><td>Average Sharpe Ratio:</td><td>{df['sharpe_ratio'].mean():.3f}</td></tr>
                <tr><td>Average Information Ratio:</td><td>{df['information_ratio'].mean():.3f}</td></tr>
                <tr><td>Average Alpha:</td><td>{df['alpha_return'].mean()*100:.3f}%</td></tr>
                <tr><td>Average Beta:</td><td>{df['beta_return'].mean():.3f}</td></tr>
            </table>

            <h3>Daily Attribution</h3>
            {df.to_html(index=False)}

        </body>
        </html>
        """

        return html

    def close(self):
        self.conn.close()

if __name__ == '__main__':
    db_config = {
        'host': 'localhost',
        'database': 'hft_trading',
        'user': 'trading_user',
        'password': 'secure_password'
    }

    analyzer = AttributionAnalyzer(db_config)

    # Generate attribution report
    html = analyzer.generate_attribution_report('momentum_strategy_1')

    with open(f'attribution_report_{datetime.now().strftime("%Y%m%d")}.html', 'w') as f:
        f.write(html)

    print("Attribution report generated successfully")

    analyzer.close()

================================================================================
END OF PERFORMANCE ATTRIBUTION DOCUMENTATION
================================================================================
