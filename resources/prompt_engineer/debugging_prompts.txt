================================================================================
AI PROMPTS FOR DEBUGGING HFT SYSTEMS
================================================================================

These prompts help debug complex issues in high-frequency trading systems.
Use with Claude, GPT-4, or other LLMs for troubleshooting assistance.

⚠️ ALWAYS backup system state before applying fixes in production!

================================================================================
PROMPT 1: DEBUG LATENCY SPIKE
================================================================================

```
Help me debug unexpected latency spikes in my HFT system:

System Details:
- Component: [order processing, market data, risk checks, etc.]
- Normal latency: [X] microseconds
- Spike latency: [Y] microseconds (P99 or P99.9)
- Frequency: [how often spikes occur]
- Pattern: [random, periodic, correlated with events]

Monitoring Data:
[Paste relevant metrics: CPU, memory, network, disk I/O]

Profiling Data:
[Paste perf stat output, flame graphs, or other profiling results]

Recent Changes:
- Code changes: [list recent commits]
- Configuration changes: [any tuning changes]
- System updates: [kernel, libraries, dependencies]
- Load changes: [traffic increase, new strategies]

Environment:
- OS: [Linux kernel version]
- CPU: [model, cores, frequency]
- Memory: [size, type]
- Network: [NIC model, driver version]
- Co-location: [yes/no, which exchange]

Please analyze:
1. Potential root causes (ranked by likelihood)
2. Diagnostic steps to isolate the issue
3. Profiling commands to run
4. Log analysis approach
5. Known issues with similar symptoms
6. Quick fixes vs long-term solutions
7. Monitoring to add for better visibility
8. Prevention strategies
```

================================================================================
PROMPT 2: DEBUG RACE CONDITION
================================================================================

```
I suspect a race condition in this multi-threaded code:

[Paste code with suspected race condition]

Symptoms:
- Manifestation: [crash, incorrect values, deadlock, etc.]
- Frequency: [rare, intermittent, reproducible]
- Conditions: [high load, specific thread timing, etc.]

Threading Model:
- Number of threads: [count and purpose]
- Shared data: [list shared variables/structures]
- Synchronization: [mutexes, atomics, lock-free]
- Thread lifecycle: [creation, destruction]

Observations:
- Core dump available: [yes/no]
- Backtrace: [paste if available]
- TSAN output: [paste ThreadSanitizer results if available]
- Valgrind output: [paste if available]

Please help:
1. Identify potential race conditions
2. Explain the race window
3. Suggest fixes (locks, atomics, redesign)
4. Provide corrected code
5. Add assertions for invariant checking
6. Recommend testing approach (stress test)
7. Suggest tools for race detection
8. Long-term architectural improvements
```

================================================================================
PROMPT 3: DEBUG MEMORY LEAK
================================================================================

```
Investigate memory leak in long-running HFT process:

Memory Behavior:
- Initial memory: [MB at startup]
- Current memory: [MB after X hours]
- Growth rate: [MB per hour]
- Leak pattern: [linear, exponential, stepped]

Symptoms:
- OOM killer invoked: [yes/no]
- Performance degradation: [yes/no, details]
- Time to failure: [hours until restart needed]

Code Areas:
[Paste suspected code sections]

Tools Output:
- Valgrind (memcheck, massif): [paste output]
- AddressSanitizer: [paste output]
- heaptrack: [paste output]
- malloc stats: [paste output]

Recent Changes:
- New features: [list changes]
- Library updates: [which libraries]
- Configuration: [any changes]

Environment:
- Allocator: [system malloc, jemalloc, tcmalloc]
- Compiler: [GCC, Clang with sanitizers]

Please provide:
1. Analysis of leak sources (ranked by impact)
2. Diagnostic steps to pinpoint exact location
3. Valgrind commands with appropriate options
4. Fix recommendations with code
5. Memory management best practices
6. Prevention strategies (smart pointers, RAII)
7. Monitoring approach (memory tracking)
8. Long-term memory management strategy
```

================================================================================
PROMPT 4: DEBUG INCORRECT TRADING BEHAVIOR
================================================================================

```
Debug incorrect trading behavior in my strategy:

Expected Behavior:
[Describe what should happen]

Actual Behavior:
[Describe what is happening]

Strategy Details:
- Type: [market making, arbitrage, momentum, etc.]
- Symbols: [BTC/USD, ETH/USD, etc.]
- Exchanges: [Binance, Coinbase, etc.]

Symptoms:
- Incorrect signals: [buying when should sell, etc.]
- Wrong position sizes: [too large, too small]
- Missing trades: [should have traded but didn't]
- Unexpected trades: [traded when shouldn't]
- P&L impact: [estimated loss]

Strategy Code:
[Paste relevant strategy logic]

Market Data:
[Paste sample market data during incorrect behavior]

Logs:
[Paste relevant log entries]

Trade History:
[Paste recent trades showing the issue]

Risk Checks:
- Are risk limits being hit: [yes/no]
- Position limits: [current vs limit]
- Loss limits: [current vs limit]

Please help:
1. Identify logic errors in strategy code
2. Check for data quality issues
3. Validate risk check implementation
4. Review order flow and timing
5. Suggest unit tests to catch this
6. Provide corrected strategy logic
7. Add logging for better observability
8. Recommend backtesting to validate fix
```

================================================================================
PROMPT 5: DEBUG NETWORK CONNECTIVITY ISSUES
================================================================================

```
Debug network connectivity issues with exchange:

Exchange: [Binance, Coinbase, Kraken, etc.]
Protocol: [FIX, WebSocket, REST]
Connection Type: [market data, order entry]

Symptoms:
- Disconnections: [frequency, pattern]
- Timeouts: [on which operations]
- Missing data: [gaps in market data]
- Rejected orders: [error messages]
- Latency: [higher than expected]

Network Details:
- Latency to exchange: [ping time]
- Packet loss: [percentage]
- Bandwidth: [utilization percentage]
- NIC: [model, driver version]
- Kernel: [version]

Connection Code:
[Paste network/socket code]

Error Messages:
[Paste error logs]

Network Monitoring:
[Paste tcpdump, netstat, ss output]

Recent Changes:
- Code changes: [any network code changes]
- Network changes: [routing, firewall, etc.]
- Exchange changes: [API updates, maintenance]

Please help:
1. Diagnose root cause of connectivity issues
2. Network debugging commands to run
3. Packet capture analysis approach
4. Socket option tuning recommendations
5. Reconnection logic review
6. Heartbeat/keepalive implementation
7. Failover strategy
8. Monitoring and alerting setup
```

================================================================================
PROMPT 6: DEBUG DEADLOCK
================================================================================

```
System is experiencing deadlocks or hangs:

Symptoms:
- Complete freeze: [yes/no]
- Specific threads frozen: [which ones]
- CPU usage: [0% or spinning at 100%]
- Response time: [infinite or timeout]
- Recovery: [requires restart, automatic recovery]

Deadlock Evidence:
- Core dump: [available: yes/no]
- Thread backtrace: [paste gdb output]
- Lock states: [paste lock debugging output]

Code with Locking:
[Paste code using mutexes, locks, or atomics]

Locking Order:
[Describe lock acquisition order if known]

Threading Model:
- Threads: [count and purpose]
- Locks: [list all mutexes, spinlocks, etc.]
- Lock-free structures: [which ones]

Reproduction:
- Reproducible: [yes/no]
- Conditions: [high load, specific sequence]
- Frequency: [how often]

Please help:
1. Analyze potential deadlock scenarios
2. Identify lock ordering issues
3. Suggest deadlock detection at runtime
4. Provide deadlock-free alternative design
5. Add timeout/watchdog mechanisms
6. Testing approach to reproduce
7. Debugging commands (gdb, pstack)
8. Long-term solution (redesign, lock-free)
```

================================================================================
PROMPT 7: DEBUG PERFORMANCE REGRESSION
================================================================================

```
Recent change caused performance regression:

Performance Drop:
- Before: [latency/throughput]
- After: [latency/throughput]
- Regression: [percentage or absolute]
- Component: [which part of system]

Changes Made:
[Paste git diff or describe changes]

Profiling Comparison:
- Before: [paste perf/profile data]
- After: [paste perf/profile data]

Metrics:
- CPU: [before vs after]
- Memory: [before vs after]
- Cache misses: [before vs after]
- Branch mispredictions: [before vs after]
- Context switches: [before vs after]

Environment:
- Same hardware: [yes/no]
- Same configuration: [yes/no]
- Same load: [yes/no]

Please help:
1. Identify root cause of regression
2. Compare profiling data systematically
3. Pinpoint expensive operations introduced
4. Suggest optimizations to recover performance
5. Provide alternative implementation
6. Add performance tests to CI/CD
7. Regression detection strategy
8. Rollback vs fix-forward recommendation
```

================================================================================
PROMPT 8: DEBUG ORDER REJECTIONS
================================================================================

```
Orders are being rejected by exchange or risk system:

Rejection Rate:
- Before: [percentage or count]
- Now: [percentage or count]
- Affected exchanges: [list]
- Affected symbols: [list]

Error Messages:
[Paste rejection error messages]

Order Details:
- Order type: [limit, market, etc.]
- Side: [buy, sell, both]
- Price: [relative to market: aggressive, passive]
- Quantity: [size in base currency]

Risk Checks:
- Position limits: [current vs limit]
- Order size limits: [current vs limit]
- Fat finger detection: [triggered: yes/no]
- Credit checks: [passing: yes/no]
- Duplicate detection: [triggered: yes/no]

Recent Changes:
- Risk parameter changes: [list changes]
- Strategy changes: [list changes]
- Exchange API changes: [any updates]

Order Flow:
[Paste relevant code: order generation → risk checks → submission]

Please help:
1. Identify why orders are being rejected
2. Check risk limits configuration
3. Validate order parameters
4. Review exchange-specific requirements
5. Suggest fix for rejection cause
6. Add better error handling
7. Improve rejection logging
8. Testing approach to prevent regressions
```

================================================================================
PROMPT 9: DEBUG DATA QUALITY ISSUES
================================================================================

```
Suspect data quality issues in market data or executions:

Data Issues:
- Missing data: [gaps, dropped messages]
- Duplicate data: [same message multiple times]
- Out-of-order data: [sequence breaks]
- Invalid data: [impossible prices, sizes]
- Stale data: [old timestamps]

Data Source:
- Exchange: [Binance, Coinbase, etc.]
- Feed type: [WebSocket, multicast, REST]
- Data type: [trades, order book, candles]

Impact:
- Strategy behavior: [incorrect signals]
- P&L: [unreliable calculations]
- Risk: [incorrect position tracking]
- Compliance: [audit trail gaps]

Observations:
[Paste sample bad data]

Validation Code:
[Paste data validation/parsing code]

Monitoring:
[Paste data quality metrics]

Please help:
1. Identify root cause of data issues
2. Implement data validation logic
3. Handle missing/duplicate/out-of-order data
4. Add data quality monitoring
5. Implement data sanitization
6. Design fallback mechanisms
7. Add alerting for data issues
8. Recommend buffer/cache strategies
```

================================================================================
PROMPT 10: DEBUG POSITION RECONCILIATION FAILURE
================================================================================

```
Position tracking is out of sync with exchange:

Discrepancy:
- Internal position: [quantity]
- Exchange position: [quantity]
- Difference: [quantity]
- Symbol: [which symbol]
- Exchange: [which exchange]

Timeline:
- Last reconciliation: [when it was in sync]
- When noticed: [when discrepancy detected]
- Events between: [trades, cancels, fills]

Position Tracking Code:
[Paste position management code]

Order Flow:
[Paste recent order/fill history]

Exchange Responses:
[Paste relevant API responses]

Logs:
[Paste relevant position tracking logs]

Possible Causes:
- Missed fill notification: [yes/no/unknown]
- Duplicate processing: [yes/no/unknown]
- Partial fills: [handling correct?]
- Cancellations: [tracking correct?]

Please help:
1. Identify source of position discrepancy
2. Review position update logic
3. Check for race conditions in updates
4. Validate fill handling (full, partial)
5. Implement reconciliation process
6. Add position audit logging
7. Design recovery procedure
8. Prevent future discrepancies
```

================================================================================
DEBUGGING METHODOLOGY
================================================================================

Systematic debugging approach:

1. **Reproduce the Issue**
   - Create minimal reproducible example
   - Document exact steps to trigger
   - Note required conditions
   - Measure frequency

2. **Gather Information**
   - Logs (application, system, network)
   - Profiling data (CPU, memory, network)
   - Core dumps (if crash)
   - System state (CPU, memory, disk)
   - Recent changes (code, config, environment)

3. **Form Hypotheses**
   - List potential causes
   - Rank by likelihood
   - Identify tests to validate each

4. **Test Hypotheses**
   - One at a time
   - Isolate variables
   - Measure results
   - Document findings

5. **Fix and Validate**
   - Implement fix
   - Test thoroughly
   - Verify no regressions
   - Document solution

6. **Prevent Recurrence**
   - Add unit tests
   - Improve monitoring
   - Update documentation
   - Review root cause

================================================================================
DEBUGGING TOOLS QUICK REFERENCE
================================================================================

**CPU Profiling:**
- perf: perf record -g ./app && perf report
- gprof: g++ -pg && ./app && gprof ./app gmon.out
- Flame graphs: perf record -F 99 -g && flamegraph.pl

**Memory Debugging:**
- Valgrind: valgrind --leak-check=full --show-leak-kinds=all ./app
- ASan: g++ -fsanitize=address && ./app
- heaptrack: heaptrack ./app && heaptrack_gui heaptrack.app.gz

**Thread Debugging:**
- TSan: g++ -fsanitize=thread && ./app
- Helgrind: valgrind --tool=helgrind ./app
- gdb: gdb ./app core (for core dumps)

**Network Debugging:**
- tcpdump: tcpdump -i eth0 -w capture.pcap
- Wireshark: wireshark (GUI analysis)
- netstat: netstat -antp (connections)
- ss: ss -s (socket statistics)

**System Debugging:**
- strace: strace -c ./app (syscall tracing)
- ltrace: ltrace ./app (library call tracing)
- lsof: lsof -p PID (open files)
- /proc: cat /proc/PID/status (process info)

================================================================================
COMMON HFT BUGS AND SOLUTIONS
================================================================================

**1. Latency Spikes**
- Cause: GC pauses, page faults, context switches
- Solution: mlock memory, CPU pinning, huge pages

**2. Lost Updates**
- Cause: Race conditions, missing synchronization
- Solution: Proper atomics, locks, or redesign

**3. Memory Leaks**
- Cause: Forgotten deallocations, circular refs
- Solution: Smart pointers, RAII, Valgrind

**4. Deadlocks**
- Cause: Lock ordering issues, forgotten unlocks
- Solution: Lock ordering discipline, RAII locks

**5. Position Drift**
- Cause: Missed fills, duplicate processing
- Solution: Idempotent updates, reconciliation

**6. Data Corruption**
- Cause: Buffer overflows, race conditions
- Solution: Bounds checking, proper synchronization

**7. Connection Drops**
- Cause: Network issues, keepalive problems
- Solution: Robust reconnect, heartbeats

**8. Performance Regression**
- Cause: Algorithmic complexity, cache issues
- Solution: Profiling, benchmarking in CI/CD

================================================================================
