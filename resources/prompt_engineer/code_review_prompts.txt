================================================================================
AI PROMPTS FOR CODE REVIEW
================================================================================

These prompts help conduct thorough code reviews for HFT C++ code.
Use with Claude, GPT-4, or other LLMs for systematic code analysis.

‚ö†Ô∏è AI reviews supplement, not replace, human expert reviews!

================================================================================
PROMPT 1: COMPREHENSIVE CODE REVIEW
================================================================================

```
Perform a comprehensive code review of this HFT C++ code:

[Paste code here]

Context:
- Purpose: [what this code does]
- Criticality: [hot path / cold path / infrastructure]
- Frequency: [execution frequency]
- Team: [junior / senior developers]

Review Dimensions:

**1. Correctness**
- Logic errors
- Edge cases
- Off-by-one errors
- Integer overflow/underflow
- Floating-point precision issues
- Undefined behavior

**2. Performance**
- Algorithmic complexity
- Cache efficiency
- Branch prediction
- Memory allocations (in hot path?)
- Lock contention
- System calls

**3. Thread Safety**
- Race conditions
- Deadlocks
- Memory ordering
- Atomic usage correctness
- Lock granularity

**4. Memory Safety**
- Buffer overflows
- Memory leaks
- Use-after-free
- Null pointer dereferences
- Dangling pointers

**5. Code Quality**
- Readability
- Maintainability
- Documentation
- Error handling
- Code duplication

**6. HFT-Specific**
- Latency implications
- Deterministic behavior
- Real-time constraints
- Risk management checks
- Compliance (audit logging)

Please provide:
- Issues found (categorized by severity: critical, major, minor)
- Specific line numbers with problems
- Explanation of each issue
- Suggested fixes with code
- Alternative approaches
- Testing recommendations
```

================================================================================
PROMPT 2: SECURITY REVIEW
================================================================================

```
Perform a security review of this code:

[Paste code here]

Security Concerns:
- Input validation
- API key handling
- Authentication/authorization
- Data encryption
- SQL injection (if applicable)
- Command injection
- Buffer overflows
- Integer overflows leading to security issues
- Side-channel attacks (timing)
- Cryptographic issues

Context:
- Data sensitivity: [PII, financial data, API keys]
- Attack surface: [network-exposed, internal-only]
- Compliance: [SOC 2, PCI DSS, GDPR]

Check for:
1. **Input Validation**
   - All external inputs validated
   - Type checking
   - Range checking
   - Sanitization

2. **Authentication & Authorization**
   - Proper credential storage
   - Access control checks
   - Token/session management

3. **Cryptography**
   - Secure random number generation
   - Proper algorithm usage
   - Key management

4. **Secrets Management**
   - No hardcoded secrets
   - Secure storage (env vars, vaults)
   - Secure transmission (TLS)

5. **Error Handling**
   - No sensitive data in errors
   - Proper logging (no secrets)

6. **Dependencies**
   - Known vulnerabilities (CVEs)
   - Outdated libraries

Please provide:
- Security vulnerabilities (ranked by severity)
- Compliance violations
- Secure coding recommendations
- Threat model for this code
- Testing approach (penetration testing)
```

================================================================================
PROMPT 3: PERFORMANCE REVIEW
================================================================================

```
Review this code for performance bottlenecks:

[Paste code here]

Performance Context:
- Execution frequency: [per microsecond, millisecond, second]
- Latency target: [microseconds]
- Throughput target: [operations per second]
- Hardware: [CPU, memory, network specs]

Focus Areas:

**1. Algorithmic Complexity**
- Time complexity: O(?)
- Space complexity: O(?)
- Can complexity be improved?
- Better algorithms available?

**2. Memory Performance**
- Unnecessary allocations
- Memory pools used?
- Cache-friendly layout?
- False sharing?
- NUMA awareness?

**3. CPU Performance**
- Branch mispredictions likely?
- Vectorization possible (SIMD)?
- Instruction-level parallelism?
- Function inlining opportunities?

**4. Lock Contention**
- Lock-free alternatives possible?
- Lock granularity appropriate?
- Read-write locks appropriate?
- Atomic operations optimal?

**5. I/O Performance**
- System calls in hot path?
- Buffering appropriate?
- Async I/O opportunities?
- Zero-copy possible?

**6. Compiler Optimizations**
- Optimization barriers?
- Branch hints needed?
- Alignment annotations?
- Restrict keyword opportunities?

Please provide:
- Performance bottlenecks (ranked by impact)
- Specific optimization recommendations
- Expected improvements (quantified)
- Code with optimizations applied
- Trade-offs to consider
- Profiling approach to validate
```

================================================================================
PROMPT 4: ARCHITECTURE REVIEW
================================================================================

```
Review the architecture and design of this component:

[Paste code or describe architecture]

Architecture Details:
- Component role: [what it does in the system]
- Dependencies: [other components it interacts with]
- Interface: [API, methods, data structures]
- Concurrency model: [threading, async, etc.]

Review Dimensions:

**1. Design Patterns**
- Appropriate patterns used?
- Over-engineering or under-engineering?
- SOLID principles followed?

**2. Modularity**
- Clear separation of concerns?
- Interface design appropriate?
- Coupling level (tight/loose)?
- Cohesion level (high/low)?

**3. Scalability**
- Can it handle 10x load?
- Bottlenecks identified?
- Horizontal scaling possible?

**4. Reliability**
- Error handling comprehensive?
- Failure modes considered?
- Recovery mechanisms?
- Graceful degradation?

**5. Maintainability**
- Code complexity appropriate?
- Documentation adequate?
- Testability good?
- Technical debt level?

**6. Extensibility**
- Easy to add new features?
- Plugin architecture if needed?
- Configuration flexibility?

Please provide:
- Architectural strengths
- Architectural weaknesses
- Refactoring recommendations
- Alternative designs (pros/cons)
- Migration path (if redesign needed)
- Long-term sustainability assessment
```

================================================================================
PROMPT 5: CONCURRENCY REVIEW
================================================================================

```
Review the thread safety and concurrency of this code:

[Paste code here]

Concurrency Context:
- Threading model: [threads, thread pool, async]
- Shared data: [list shared variables/structures]
- Synchronization: [mutexes, atomics, lock-free]
- Expected contention: [low, medium, high]

Check for:

**1. Race Conditions**
- Unsynchronized access to shared data
- Check-then-act patterns
- Non-atomic compound operations
- Missing memory barriers

**2. Deadlocks**
- Lock ordering issues
- Circular dependencies
- Missing unlock (RAII usage?)

**3. Livelocks & Starvation**
- Retry loops without backoff
- Priority inversion
- Unfair locks

**4. Memory Ordering**
- Atomic operations with correct ordering
- Acquire-release semantics proper
- Data races on non-atomic variables

**5. Lock-Free Correctness**
- ABA problem handled?
- Memory reclamation safe?
- Progress guarantees met?

**6. Performance**
- Lock contention minimized?
- Critical sections short?
- False sharing avoided?

Please provide:
- Concurrency issues found (with severity)
- Specific problematic code sections
- Corrected code with proper synchronization
- Testing approach (TSan, stress tests)
- Performance implications
- Alternative concurrency designs
```

================================================================================
PROMPT 6: ERROR HANDLING REVIEW
================================================================================

```
Review error handling in this code:

[Paste code here]

Error Handling Context:
- Error sources: [network, exchange, data, system]
- Criticality: [can it cause data loss, trading loss?]
- Recovery: [automatic, manual, requires restart]

Check for:

**1. Error Detection**
- All error sources checked?
- Return values validated?
- Exception handling present?
- Assertions for invariants?

**2. Error Propagation**
- Errors propagated correctly?
- Error information preserved?
- Context added to errors?

**3. Error Recovery**
- Graceful degradation?
- Retry logic (with backoff)?
- Fallback mechanisms?
- State cleanup on error?

**4. Resource Management**
- RAII used for cleanup?
- No resource leaks on error paths?
- Exception-safe code?

**5. Logging & Monitoring**
- Errors logged with context?
- Error rates monitored?
- Alerts on critical errors?

**6. HFT-Specific**
- Trading halted on critical error?
- Position flat on error?
- Risk manager notified?
- Audit trail maintained?

Please provide:
- Error handling gaps
- Potential failure scenarios
- Improved error handling code
- Testing approach for error paths
- Monitoring recommendations
```

================================================================================
PROMPT 7: TESTING REVIEW
================================================================================

```
Review the test coverage and quality for this code:

[Paste code and tests]

Testing Context:
- Test framework: [Google Test, Catch2, etc.]
- Coverage: [percentage if known]
- Test types: [unit, integration, E2E]

Review Dimensions:

**1. Coverage**
- Code coverage percentage
- Branch coverage
- Edge cases covered?
- Error paths tested?

**2. Test Quality**
- Tests are clear and readable?
- Tests are deterministic?
- Tests are fast?
- Tests are isolated?

**3. Test Completeness**
- Happy path tested?
- Edge cases tested?
- Error cases tested?
- Boundary conditions tested?
- Concurrency tested (if multi-threaded)?

**4. Test Design**
- Appropriate use of mocks/stubs?
- Test data realistic?
- Setup/teardown appropriate?
- Tests independent?

**5. Performance Tests**
- Latency benchmarks?
- Throughput benchmarks?
- Regression tests?
- Stress tests?

**6. HFT-Specific**
- Backtests for strategies?
- Risk limit tests?
- Order flow tests?
- Market data edge cases?

Please provide:
- Testing gaps identified
- Missing test cases (list specific scenarios)
- Test quality improvements
- Additional test code
- Testing strategy recommendations
- CI/CD integration suggestions
```

================================================================================
PROMPT 8: DOCUMENTATION REVIEW
================================================================================

```
Review the documentation for this code:

[Paste code with comments/docs]

Documentation Context:
- Audience: [junior devs, senior devs, external users]
- Complexity: [simple utility, complex algorithm]
- Criticality: [core trading, peripheral]

Check for:

**1. Code Comments**
- Public API documented?
- Complex algorithms explained?
- Why, not just what?
- Comments up-to-date?
- No commented-out code?

**2. Function Documentation**
- Purpose clear?
- Parameters documented?
- Return values documented?
- Exceptions documented?
- Preconditions documented?
- Complexity documented?

**3. Architecture Documentation**
- High-level design described?
- Component interactions clear?
- Data flow documented?
- Threading model explained?

**4. Usage Documentation**
- Examples provided?
- Common patterns shown?
- Configuration explained?
- Error messages documented?

**5. Operational Documentation**
- Deployment steps?
- Monitoring approach?
- Troubleshooting guide?
- Performance tuning?

Please provide:
- Documentation gaps
- Unclear sections
- Improved documentation
- Missing diagrams/examples
- README improvements
```

================================================================================
PROMPT 9: RISK MANAGEMENT REVIEW
================================================================================

```
Review risk management in this trading code:

[Paste code here]

Risk Context:
- Strategy type: [market making, arbitrage, etc.]
- Capital at risk: [dollar amount]
- Max loss tolerance: [daily, per trade]
- Position limits: [by symbol, total]

Check for:

**1. Pre-Trade Checks**
- Position limits enforced?
- Order size limits enforced?
- Fat finger detection?
- Duplicate order prevention?
- Credit checks?
- Execution time: <5 microseconds?

**2. Real-Time Monitoring**
- P&L tracked accurately?
- Positions reconciled?
- Loss limits monitored?
- Exposure calculated?
- VaR computed?

**3. Circuit Breakers**
- Daily loss limit?
- Rapid drawdown detection?
- Automatic position reduction?
- Kill switch implemented?
- Testing frequency?

**4. Position Management**
- Position tracking accurate?
- Fills processed correctly?
- Cancellations handled?
- Partial fills handled?
- Multi-exchange netting?

**5. Audit & Compliance**
- All orders logged?
- Modifications tracked?
- Audit trail immutable?
- Regulatory reporting?

Please provide:
- Risk management gaps (critical!)
- Potential for large loss scenarios
- Improved risk checks (code)
- Testing approach for risk systems
- Monitoring and alerting
- Compliance requirements
```

================================================================================
PROMPT 10: CODE STYLE REVIEW
================================================================================

```
Review code style and adherence to best practices:

[Paste code here]

Style Guide: [Google C++ Style, LLVM, custom]

Check for:

**1. Naming Conventions**
- Consistent naming (snake_case, camelCase)?
- Meaningful names?
- Abbreviations clear?

**2. Code Formatting**
- Consistent indentation?
- Line length reasonable?
- Whitespace consistent?
- Braces style consistent?

**3. C++ Best Practices**
- Modern C++ features used? (C++17, C++20)
- Raw pointers avoided (use smart pointers)?
- RAII for resource management?
- Const correctness?
- Move semantics used?

**4. Code Organization**
- Headers properly structured?
- Include guards or #pragma once?
- Forward declarations used?
- Logical file organization?

**5. Code Complexity**
- Functions too long (>50 lines)?
- Cyclomatic complexity high?
- Deep nesting (>4 levels)?
- Code duplication?

**6. Compiler Warnings**
- Code compiles without warnings?
- Warning level appropriate (-Wall -Wextra)?
- Warnings as errors enabled?

Please provide:
- Style violations
- Best practice violations
- Refactoring suggestions
- Automated formatting recommendations (clang-format)
- Linting tool suggestions (clang-tidy)
```

================================================================================
CODE REVIEW CHECKLIST
================================================================================

Use this checklist for every code review:

**Correctness** ‚úì
‚ñ° Logic is correct
‚ñ° Edge cases handled
‚ñ° No undefined behavior
‚ñ° Thread-safe where needed

**Performance** ‚úì
‚ñ° No unnecessary allocations in hot path
‚ñ° Algorithmic complexity acceptable
‚ñ° Cache-friendly data structures
‚ñ° Branch prediction considered

**Safety** ‚úì
‚ñ° Memory safe (no leaks, overflows)
‚ñ° Exception safe
‚ñ° Resource management (RAII)
‚ñ° Input validation

**Quality** ‚úì
‚ñ° Readable and maintainable
‚ñ° Well documented
‚ñ° Follows style guide
‚ñ° No code duplication

**Testing** ‚úì
‚ñ° Unit tests present
‚ñ° Edge cases tested
‚ñ° Performance benchmarks
‚ñ° Code coverage >80%

**Risk** ‚úì
‚ñ° Risk checks present
‚ñ° Error handling comprehensive
‚ñ° Logging for audit trail
‚ñ° Position tracking correct

**HFT-Specific** ‚úì
‚ñ° Latency optimized
‚ñ° Deterministic behavior
‚ñ° Lock-free where needed
‚ñ° Compiler optimizations enabled

================================================================================
REVIEW SEVERITY LEVELS
================================================================================

**Critical (P0)** üî¥
- Security vulnerabilities
- Data loss potential
- Large financial loss risk
- Crash/deadlock in production
‚Üí Must fix before merge

**Major (P1)** üü†
- Performance regressions
- Memory leaks
- Race conditions
- Incorrect trading logic
‚Üí Should fix before merge

**Minor (P2)** üü°
- Code style violations
- Missing documentation
- Suboptimal performance
- Minor logic issues
‚Üí Can fix after merge

**Nit (P3)** üü¢
- Naming suggestions
- Comment improvements
- Formatting nitpicks
‚Üí Optional, reviewer preference

================================================================================
