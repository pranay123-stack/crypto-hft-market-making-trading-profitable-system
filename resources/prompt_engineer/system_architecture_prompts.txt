================================================================================
AI PROMPTS FOR SYSTEM ARCHITECTURE & DESIGN
================================================================================

These prompts help design scalable, low-latency HFT system architectures.
Use with Claude, GPT-4, or other LLMs for architectural guidance.

⚠️ ALWAYS validate architectural decisions with performance benchmarks!

================================================================================
PROMPT 1: DESIGN LOW-LATENCY TRADING ENGINE
================================================================================

```
Design a high-performance trading engine architecture for HFT with these requirements:

System Type: [Spot Trading / Derivatives / Multi-Asset]
Target Latency: [Tick-to-trade in microseconds]
Throughput: [Orders per second]
Exchanges: [List of exchanges to connect to]
Number of Strategies: [Concurrent strategy count]

Requirements:
1. Sub-microsecond order processing pipeline
2. Lock-free inter-component communication
3. NUMA-aware thread placement
4. Zero-copy data paths
5. Multi-exchange connectivity with failover
6. Real-time risk management (<5μs checks)
7. Market data processing (tick data + order books)
8. Position tracking and reconciliation

Architecture Components:
- Market Data Handler (multicast, UDP, parsing)
- Order Management System (OMS)
- Execution Management System (EMS)
- Risk Manager (pre-trade and post-trade)
- Strategy Container (multiple strategies)
- Exchange Gateway (FIX/REST/WebSocket)
- Monitoring and Logging

Provide:
- High-level system diagram (text-based)
- Component interaction flow
- Data structure designs
- Threading model
- Memory management strategy
- Inter-process communication (IPC) design
- Failover and recovery mechanisms
- Performance bottleneck analysis
- Scalability considerations
```

================================================================================
PROMPT 2: OPTIMIZE EXISTING ARCHITECTURE
================================================================================

```
Review and optimize this HFT system architecture:

[Paste current architecture description or diagram]

Current Performance:
- Tick-to-trade latency: [X] microseconds
- Order throughput: [Y] orders/second
- Market data rate: [Z] messages/second
- CPU utilization: [%]
- Memory usage: [GB]

Bottlenecks Identified:
- [List known bottlenecks]

Optimization Goals:
1. Reduce latency to <[target] microseconds
2. Increase throughput to [target] orders/second
3. Improve resource utilization
4. Add support for [new feature]

Please provide:
- Architectural improvements
- Component refactoring recommendations
- Threading model optimizations
- Data path optimizations
- Memory layout improvements
- Network optimization suggestions
- Trade-offs and migration strategy
- Before/after comparison
- Implementation roadmap
```

================================================================================
PROMPT 3: MULTI-EXCHANGE GATEWAY DESIGN
================================================================================

```
Design a multi-exchange connectivity layer that supports:

Exchanges: [Binance, Coinbase, Kraken, OKX, Bybit, etc.]
Protocols: [FIX 4.2/4.4, REST, WebSocket, proprietary]
Message Rate: [Total messages per second across all exchanges]

Requirements:
1. Unified API for all exchanges
2. Exchange-specific adapter pattern
3. Connection management (connect, disconnect, reconnect)
4. Rate limiting (per exchange)
5. Order routing logic (smart routing, direct routing)
6. Market data aggregation (consolidated order book)
7. Exchange-specific quirks handling
8. Failover and backup connections
9. Message normalization and validation
10. Latency measurement per exchange

Architecture Components:
- Exchange Adapter Interface
- Connection Manager
- Message Parser/Serializer
- Rate Limiter
- Order Router
- Market Data Aggregator
- Health Monitor

Provide:
- Class hierarchy design (C++)
- Message flow diagrams
- Configuration schema
- Error handling strategy
- Testing approach for each exchange
- Performance considerations
- Sample code for critical components
```

================================================================================
PROMPT 4: DATA PIPELINE ARCHITECTURE
================================================================================

```
Design a high-throughput, low-latency data pipeline for HFT:

Data Sources:
- Market data (tick-by-tick, order books)
- Trade executions
- Position updates
- Risk metrics

Data Sinks:
- Real-time strategy engines
- Historical database (TimescaleDB, ClickHouse)
- Monitoring dashboards
- Compliance logs
- Backup/archive

Requirements:
1. Latency: <100 microseconds for real-time path
2. Throughput: 10M+ messages per second
3. Zero data loss (durability)
4. Backpressure handling
5. Late data handling (out-of-order messages)
6. Data validation and sanitization
7. Schema evolution support

Architecture:
- Ingestion layer (network → memory)
- Processing layer (validation, transformation)
- Distribution layer (routing to consumers)
- Storage layer (hot, warm, cold tiers)
- Query layer (historical analysis)

Design Patterns:
- Ring buffer vs message queue
- SPSC vs MPMC queues
- Shared memory vs network IPC
- Batch vs stream processing

Provide:
- Component architecture
- Data flow diagrams
- Storage schema design
- Performance benchmarks
- Scalability analysis
- Monitoring strategy
```

================================================================================
PROMPT 5: MICROSERVICES VS MONOLITH FOR HFT
================================================================================

```
Analyze trade-offs between monolithic and microservices architecture for HFT:

System Scope:
- Trading strategies: [Number and types]
- Exchanges: [Number of exchanges]
- Team size: [Number of developers]
- Deployment frequency: [Per day/week/month]

Current State: [Monolith / Microservices / Hybrid]

Evaluate:
1. Latency implications
   - Inter-process communication overhead
   - Network latency vs shared memory
   - Serialization/deserialization costs

2. Scalability
   - Horizontal scaling capabilities
   - Resource isolation
   - Independent deployment

3. Reliability
   - Fault isolation
   - Cascading failures
   - Recovery time

4. Development velocity
   - Team autonomy
   - Code coupling
   - Testing complexity

5. Operational complexity
   - Monitoring and debugging
   - Deployment coordination
   - Configuration management

Provide:
- Detailed pros/cons for each approach
- Hybrid architecture recommendation
- Migration strategy (if changing)
- Service boundary definitions
- Communication patterns
- Recommended tech stack
- Example architecture diagrams
```

================================================================================
PROMPT 6: DISASTER RECOVERY ARCHITECTURE
================================================================================

```
Design a comprehensive disaster recovery and high-availability system for HFT:

Requirements:
- RTO (Recovery Time Objective): [e.g., <30 seconds]
- RPO (Recovery Point Objective): [e.g., zero data loss]
- Availability target: [e.g., 99.99%]
- Geographic distribution: [Single DC / Multi-DC / Multi-region]

Failure Scenarios:
1. Single server failure
2. Network partition
3. Exchange connectivity loss
4. Data center outage
5. Software bug (crash, deadlock)
6. Database corruption
7. DDoS attack

Architecture Components:
- Primary trading system
- Hot standby system
- Cold backup system
- State replication mechanism
- Failover detection and triggering
- Health checks and monitoring
- Position reconciliation
- Order recovery

Provide:
- High-availability architecture diagram
- Failover procedures (automated and manual)
- State synchronization design
- Network topology (redundant paths)
- Split-brain prevention
- Testing strategy (chaos engineering)
- Recovery procedures
- Cost-benefit analysis
```

================================================================================
PROMPT 7: REAL-TIME MONITORING ARCHITECTURE
================================================================================

```
Design a real-time monitoring and observability system for HFT:

Metrics to Track:
- Latency (P50, P95, P99, P99.9, P99.99)
- Throughput (orders/sec, messages/sec)
- Error rates (by type, by exchange)
- Position and P&L (real-time)
- Risk metrics (VaR, exposure)
- System health (CPU, memory, network)
- Strategy performance (Sharpe, win rate)

Requirements:
1. Monitoring overhead: <1% of system resources
2. Alert latency: <1 second
3. Dashboard refresh: <5 seconds
4. Historical retention: [30 days hot, 1 year warm]
5. Anomaly detection (ML-based)
6. Distributed tracing (request flow)

Tech Stack:
- Metrics: [Prometheus, StatsD, custom]
- Visualization: [Grafana, custom dashboards]
- Logging: [ELK stack, Loki]
- Tracing: [Jaeger, Zipkin]
- Alerting: [PagerDuty, Slack, SMS]

Architecture:
- Metrics collection agents
- Time-series database
- Alert evaluation engine
- Dashboard server
- Log aggregation pipeline
- Trace collection and storage

Provide:
- Monitoring architecture diagram
- Metrics schema design
- Alert rules (with thresholds)
- Dashboard layouts (JSON)
- Performance impact analysis
- Sample implementation code
```

================================================================================
PROMPT 8: BACKTESTING INFRASTRUCTURE DESIGN
================================================================================

```
Design a high-performance backtesting infrastructure:

Scale:
- Historical data: [TB of tick data]
- Backtesting speed: [Years of data per hour]
- Parallel simulations: [Concurrent backtests]
- Parameter combinations: [Grid search size]

Requirements:
1. Event-driven simulation (realistic order matching)
2. Multi-exchange support
3. Realistic slippage and fees
4. Market impact modeling
5. Partial fills and queue position
6. Latency simulation (configurable)
7. Walk-forward optimization
8. Overfitting detection
9. Statistical significance testing

Architecture Components:
- Historical data loader (parquet, HDF5)
- Event simulator (tick replay)
- Order matching engine
- Fee calculator
- Performance analytics
- Parameter optimizer
- Report generator

Advanced Features:
- Distributed backtesting (multiple machines)
- GPU acceleration (CUDA)
- Incremental backtesting (new data)
- Regime detection (bull/bear/sideways)

Provide:
- Backtesting architecture diagram
- Data schema for historical storage
- Order matching algorithm
- Performance analytics implementation
- Parallelization strategy
- Sample backtest results format
- Validation methodology
```

================================================================================
PROMPT 9: LOCK-FREE ARCHITECTURE DESIGN
================================================================================

```
Design a lock-free architecture for critical HFT components:

Components to Make Lock-Free:
1. Order queue (producers: strategies, consumer: gateway)
2. Market data queue (producer: network, consumers: strategies)
3. Execution report queue (producer: gateway, consumers: strategies + risk)
4. Shared order book state

Requirements:
- Wait-free or lock-free guarantees
- SPSC, MPSC, or MPMC patterns
- Memory ordering (acquire-release semantics)
- ABA problem handling
- Memory reclamation (hazard pointers, RCU)

Design Considerations:
1. Queue capacity and overflow handling
2. Batch processing for throughput
3. Busy-wait vs blocking strategies
4. False sharing prevention (cache-line padding)
5. NUMA-aware allocation

Provide:
- Lock-free data structure implementations (C++)
- Memory ordering annotations
- Performance comparison (locks vs lock-free)
- Producer-consumer patterns
- Backpressure handling
- Testing strategy (concurrent stress tests)
- Profiling methodology
- Trade-offs and failure modes
```

================================================================================
PROMPT 10: SECURITY ARCHITECTURE FOR HFT
================================================================================

```
Design a comprehensive security architecture for HFT systems:

Security Requirements:
1. Authentication and authorization
2. API key management (exchange credentials)
3. Secrets management (passwords, tokens)
4. Network security (firewall, VPN)
5. Data encryption (at rest and in transit)
6. Audit logging (compliance)
7. DDoS protection
8. Intrusion detection

Threat Model:
- External attackers (network-based)
- Insider threats (malicious employees)
- Supply chain attacks (dependencies)
- Physical security (data center access)
- Side-channel attacks (timing)

Security Layers:
1. Network perimeter (firewalls, IDS/IPS)
2. Application layer (input validation, rate limiting)
3. Data layer (encryption, access control)
4. Monitoring layer (anomaly detection)

Compliance:
- SOC 2 Type II
- PCI DSS (if handling payments)
- GDPR (if handling EU data)
- Exchange-specific security requirements

Provide:
- Security architecture diagram
- Threat analysis (STRIDE model)
- Security controls matrix
- Secret management strategy (HashiCorp Vault, AWS Secrets Manager)
- Incident response plan
- Penetration testing methodology
- Secure coding guidelines
- Zero-trust architecture considerations
```

================================================================================
TIPS FOR ARCHITECTURAL PROMPTS
================================================================================

1. **Context is King**: Provide detailed requirements, constraints, and current state
2. **Performance First**: Always mention latency and throughput targets
3. **Trade-offs**: Ask for pros/cons of different approaches
4. **Scalability**: Consider future growth (10x, 100x)
5. **Failure Modes**: Request failure analysis and recovery strategies
6. **Cost Analysis**: Ask for infrastructure cost estimates
7. **Migration Path**: If redesigning, ask for migration strategy
8. **Validation**: Request benchmarking and testing strategies
9. **Documentation**: Ask for architecture diagrams and decision rationale
10. **Team Skills**: Consider team expertise in technology choices

Example Follow-up Prompts:
- "What are the latency implications of choice A vs choice B?"
- "How does this architecture handle [specific failure scenario]?"
- "Provide a migration plan from current to proposed architecture"
- "What are the top 3 risks in this design?"
- "Compare this approach with [alternative technology]"

================================================================================
ARCHITECTURE REVIEW CHECKLIST
================================================================================

Before finalizing any architecture, ensure you've addressed:

□ Latency targets clearly defined and validated
□ Throughput requirements specified
□ Failure modes analyzed (FMEA)
□ Scalability path defined (10x growth)
□ Monitoring and observability built-in
□ Security threats analyzed and mitigated
□ Compliance requirements met
□ Operational complexity assessed
□ Cost projections calculated
□ Team capabilities aligned with technology choices
□ Documentation comprehensive (diagrams, decision log)
□ Performance benchmarks planned
□ Disaster recovery tested
□ Deployment strategy defined

================================================================================
