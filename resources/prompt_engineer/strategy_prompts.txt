================================================================================
AI PROMPTS FOR STRATEGY DEVELOPMENT
================================================================================

These prompts are optimized for AI-assisted strategy development for HFT systems.
Use with Claude, GPT-4, or other LLMs.

⚠️ ALWAYS review and test AI-generated code thoroughly before deployment!

================================================================================
PROMPT 1: CREATE NEW TRADING STRATEGY
================================================================================

```
I need you to create a high-frequency trading strategy in C++20 with the following requirements:

Strategy Type: [Market Making / Statistical Arbitrage / Latency Arbitrage / Momentum]
Instruments: [BTC/USD, ETH/USD, etc.]
Exchanges: [Binance, Coinbase, etc.]

Requirements:
1. Sub-microsecond execution time for signal generation
2. Lock-free data structures for order queue
3. NUMA-aware memory allocation
4. Zero dynamic allocations in hot path
5. Comprehensive risk checks (position limits, loss limits)
6. Real-time P&L tracking
7. Detailed logging for audit compliance

Include:
- Complete C++ class implementation
- Signal generation logic with clear comments
- Entry/exit conditions
- Risk management checks
- Position sizing algorithm
- Unit tests using Catch2
- Performance benchmarks
- Expected Sharpe ratio and win rate

Please optimize for latency and include proper error handling.
```

================================================================================
PROMPT 2: OPTIMIZE EXISTING STRATEGY
================================================================================

```
I have an existing trading strategy that needs optimization. Here's the current implementation:

[Paste your strategy code here]

Current Performance:
- Average latency: [X] microseconds
- P99 latency: [Y] microseconds
- Sharpe ratio: [Z]
- Win rate: [W]%

Please optimize this strategy for:
1. Lower latency (target: <100 nanoseconds for signal generation)
2. Better cache utilization
3. SIMD instructions where applicable
4. Reduce branch mispredictions
5. Improve lock-free algorithms

Provide:
- Optimized code with detailed comments on changes
- Before/after performance comparison
- Profiling suggestions
- Memory layout improvements
- Compiler flags for optimal performance
```

================================================================================
PROMPT 3: BACKTEST STRATEGY
================================================================================

```
Create a comprehensive backtesting framework for this strategy:

[Paste strategy code]

Requirements:
1. Event-driven backtesting (not vectorized)
2. Realistic order matching (queue position, partial fills)
3. Slippage modeling (market impact, spread crossing)
4. Transaction costs (exchange fees, network costs)
5. Multi-exchange support with latency simulation
6. Performance metrics:
   - Sharpe ratio, Sortino ratio, Calmar ratio
   - Maximum drawdown, average drawdown
   - Win rate, profit factor
   - Daily/weekly/monthly returns
7. Walk-forward analysis framework
8. Parameter optimization with grid search

Include:
- Complete C++ backtesting engine
- Historical data loader
- Order matching simulator
- Performance analytics
- Visualization export (CSV for plotting)
- Overfitting detection
```

================================================================================
PROMPT 4: RISK MANAGEMENT FOR STRATEGY
================================================================================

```
Add comprehensive risk management to this trading strategy:

[Paste strategy code]

Implement:
1. Pre-trade risk checks (<5 microseconds):
   - Position limits (per symbol, total exposure)
   - Order size limits
   - Fat finger detection
   - Self-trade prevention
   - Duplicate order detection

2. Real-time monitoring:
   - Loss limits (per trade, daily, weekly)
   - Drawdown limits (from peak, intraday)
   - VaR calculation (99% confidence)
   - Exposure concentration
   - Correlation risk

3. Circuit breakers:
   - Kill switch on daily loss limit
   - Automatic position reduction on drawdown
   - Emergency flatten all positions
   - Cool-down periods after breaches

4. Position management:
   - Dynamic position sizing (Kelly criterion)
   - Inventory management for market making
   - Delta hedging for options
   - Cross-exchange netting

Provide lock-free implementation with zero allocations.
```

================================================================================
PROMPT 5: MULTI-EXCHANGE STRATEGY
================================================================================

```
Create a cross-exchange arbitrage strategy in C++ that:

1. Monitors order books on multiple exchanges simultaneously
2. Detects arbitrage opportunities in real-time
3. Executes orders on multiple exchanges atomically
4. Handles exchange-specific quirks (rate limits, APIs, fees)
5. Accounts for transfer times and costs

Exchanges: [Binance, Coinbase, Kraken]
Symbols: [BTC/USD, ETH/USD]

Implementation requirements:
- Lock-free shared order book state
- Sub-millisecond opportunity detection
- Atomic multi-leg execution
- Automatic reconciliation
- Exchange failover handling
- Real-time fee calculation
- Network latency compensation

Include complete error handling and recovery mechanisms.
```

================================================================================
PROMPT 6: MACHINE LEARNING ENHANCED STRATEGY
================================================================================

```
Integrate a machine learning model into this HFT strategy:

[Paste strategy code]

Requirements:
1. Model type: [LSTM / Transformer / XGBoost / LightGBM]
2. Features: Market microstructure (order book imbalance, trade flow, volatility)
3. Prediction target: [Price movement / Spread / Volatility]
4. Inference latency: <1 millisecond

Implementation:
- Train model in Python (PyTorch/TensorFlow)
- Export to ONNX format
- Load and run inference in C++ (ONNX Runtime / TensorRT)
- Feature extraction from market data
- Online learning / model updates
- Model monitoring (drift detection)

Provide:
- Python training code
- Feature engineering
- C++ inference code
- Performance benchmarks
- Model versioning strategy
```

================================================================================
TIPS FOR EFFECTIVE PROMPTS
================================================================================

1. **Be Specific**: Include exact requirements, performance targets, constraints
2. **Provide Context**: Share existing code, performance metrics, pain points
3. **Set Constraints**: Latency targets, memory limits, thread count
4. **Request Tests**: Always ask for unit tests and benchmarks
5. **Iterative Refinement**: Start broad, then refine with follow-up prompts
6. **Safety First**: Explicitly request error handling and edge cases
7. **Performance Focus**: Mention optimization techniques (SIMD, cache, lock-free)
8. **Compliance**: Request audit logging and regulatory compliance

Example Follow-up Prompts:
- "Add more detailed error handling for [specific case]"
- "Optimize the [function name] function for better cache utilization"
- "Add unit tests that cover [specific edge case]"
- "Explain the trade-offs in your design decisions"
- "Provide alternative implementations with pros/cons"

================================================================================
