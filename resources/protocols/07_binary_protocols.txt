================================================================================
                    BINARY PROTOCOLS DOCUMENTATION
              Custom Binary Protocols and FlatBuffers for HFT
                  Zero-Copy, Schema-Based Binary Encoding
================================================================================

TABLE OF CONTENTS
================================================================================
1. Protocol Overview
2. Custom Binary Design
3. FlatBuffers Implementation
4. Protocol Buffers (Protobuf)
5. C++ Implementation
6. Performance Optimization
7. Schema Evolution
8. Benchmarks and Comparison

================================================================================
1. PROTOCOL OVERVIEW
================================================================================

1.1 INTRODUCTION
----------------
Binary protocols provide the most efficient encoding for financial data when
you control both ends of the communication. They offer predictable performance,
minimal overhead, and direct memory mapping capabilities.

Key Characteristics:
- Fixed or variable length encoding
- Native type representation (little/big endian)
- No parsing overhead
- Direct memory access
- Type safety (with schemas)
- Version management

Performance Comparison:
Protocol        Encode    Decode    Wire Size    Zero-Copy
Custom Binary   30ns      25ns      30-60B       Yes
FlatBuffers     45ns      5ns       40-80B       Yes
SBE             50ns      40ns      40-80B       Yes
Protobuf        600ns     520ns     50-100B      No
JSON            2000ns    1800ns    300-600B     No
MessagePack     400ns     350ns     80-150B      No

1.2 USE CASES
-------------
Custom Binary:
- Internal messaging between components
- Proprietary exchange connectivity
- FPGA interfaces
- Ultra-low latency requirements
- Full control over wire format

FlatBuffers:
- Cross-language compatibility needed
- Schema evolution important
- Mixed latency requirements
- Complex nested structures
- Mobile/embedded systems

Protobuf:
- External APIs
- Service-to-service communication
- Good tooling needed
- Moderate performance acceptable

1.3 DESIGN PRINCIPLES
---------------------
1. Alignment: Structure fields on natural boundaries
2. Endianness: Choose consistent byte order (typically little-endian)
3. Padding: Minimize or eliminate padding
4. Versioning: Design for future extensions
5. Type Safety: Use fixed-size types (uint32_t, not int)
6. Zero-Copy: Enable direct memory mapping when possible

Memory Layout Example:
Bad Design (padding):
struct OrderBad {
    uint8_t  type;      // 1 byte
                        // 3 bytes padding
    uint32_t order_id;  // 4 bytes
    uint8_t  side;      // 1 byte
                        // 7 bytes padding
    double   price;     // 8 bytes
};  // Total: 24 bytes (with padding)

Good Design (packed):
struct OrderGood {
    uint32_t order_id;  // 4 bytes
    double   price;     // 8 bytes
    uint8_t  type;      // 1 byte
    uint8_t  side;      // 1 byte
    uint16_t reserved;  // 2 bytes (explicit)
} __attribute__((packed));
// Total: 16 bytes (no hidden padding)

================================================================================
2. CUSTOM BINARY DESIGN
================================================================================

2.1 MESSAGE HEADER
------------------
Standard header for all messages:

struct MessageHeader {
    uint16_t magic;          // 0xABCD (protocol identifier)
    uint16_t version;        // Protocol version
    uint16_t message_type;   // Message type identifier
    uint16_t message_length; // Total message length
    uint64_t sequence_num;   // Sequence number
    uint64_t timestamp;      // Nanosecond timestamp
} __attribute__((packed));
// Total: 24 bytes

Message Type Identifiers:
0x0001 - NewOrder
0x0002 - CancelOrder
0x0003 - ReplaceOrder
0x0004 - ExecutionReport
0x0005 - OrderStatus
0x0006 - MarketData
0x0007 - Heartbeat

2.2 ORDER MESSAGES
------------------
New Order:
struct NewOrderMessage {
    MessageHeader header;
    uint64_t cl_ord_id;      // Client order ID
    uint64_t account_id;     // Account identifier
    uint32_t symbol_id;      // Symbol identifier (not string!)
    uint8_t  side;           // 1=Buy, 2=Sell
    uint8_t  order_type;     // 1=Market, 2=Limit, 3=Stop
    uint16_t time_in_force;  // 0=Day, 1=GTC, 3=IOC, 4=FOK
    uint32_t quantity;       // Order quantity
    int64_t  price;          // Price (fixed-point, e.g., * 10000)
    int64_t  stop_price;     // Stop price (if applicable)
    uint32_t min_quantity;   // Minimum fill quantity
    uint32_t max_show;       // Maximum displayed quantity
    uint8_t  flags;          // Bit flags (IOC, AON, etc.)
    uint8_t  reserved[3];    // Reserved for alignment
} __attribute__((packed));
// Total: 24 + 56 = 80 bytes

Flags Bit Field:
Bit 0: All-or-None
Bit 1: Fill-or-Kill
Bit 2: Immediate-or-Cancel
Bit 3: Hidden
Bit 4: Post-only
Bit 5: Reduce-only
Bit 6-7: Reserved

Execution Report:
struct ExecutionReportMessage {
    MessageHeader header;
    uint64_t order_id;       // Exchange order ID
    uint64_t cl_ord_id;      // Client order ID
    uint64_t exec_id;        // Execution ID
    uint64_t account_id;     // Account identifier
    uint32_t symbol_id;      // Symbol identifier
    uint8_t  exec_type;      // 0=New, 1=PartialFill, 2=Fill, 4=Canceled
    uint8_t  ord_status;     // 0=New, 1=PartialFill, 2=Filled, 4=Canceled
    uint8_t  side;           // 1=Buy, 2=Sell
    uint8_t  order_type;     // Order type
    uint32_t order_qty;      // Original quantity
    int64_t  price;          // Order price
    uint32_t last_qty;       // Last executed quantity
    int64_t  last_px;        // Last executed price
    uint32_t leaves_qty;     // Remaining quantity
    uint32_t cum_qty;        // Cumulative executed quantity
    int64_t  avg_px;         // Average executed price
    uint64_t transact_time;  // Transaction time
} __attribute__((packed));
// Total: 24 + 88 = 112 bytes

2.3 MARKET DATA MESSAGES
-------------------------
Quote Update:
struct QuoteUpdateMessage {
    MessageHeader header;
    uint32_t symbol_id;      // Symbol identifier
    uint32_t reserved;       // Alignment
    int64_t  bid_price;      // Bid price
    uint32_t bid_size;       // Bid quantity
    uint32_t bid_orders;     // Number of bid orders
    int64_t  ask_price;      // Ask price
    uint32_t ask_size;       // Ask quantity
    uint32_t ask_orders;     // Number of ask orders
    uint64_t quote_time;     // Quote timestamp
} __attribute__((packed));
// Total: 24 + 48 = 72 bytes

Trade Update:
struct TradeUpdateMessage {
    MessageHeader header;
    uint64_t trade_id;       // Unique trade ID
    uint32_t symbol_id;      // Symbol identifier
    uint8_t  side;           // Aggressor side
    uint8_t  reserved[3];    // Alignment
    int64_t  price;          // Trade price
    uint32_t quantity;       // Trade quantity
    uint32_t buyer_orders;   // Orders on buy side
    uint32_t seller_orders;  // Orders on sell side
    uint64_t trade_time;     // Trade timestamp
} __attribute__((packed));
// Total: 24 + 40 = 64 bytes

Order Book Snapshot:
struct OrderBookLevel {
    int64_t  price;          // Price level
    uint32_t quantity;       // Total quantity
    uint32_t order_count;    // Number of orders
} __attribute__((packed));
// 16 bytes per level

struct OrderBookSnapshot {
    MessageHeader header;
    uint32_t symbol_id;      // Symbol identifier
    uint16_t bid_levels;     // Number of bid levels
    uint16_t ask_levels;     // Number of ask levels
    uint64_t book_time;      // Snapshot timestamp
    OrderBookLevel levels[0]; // Variable-length array
} __attribute__((packed));
// Header: 24 + 16 = 40 bytes
// Plus: (bid_levels + ask_levels) * 16 bytes

2.4 ENCODING/DECODING
---------------------
Encoding (Direct Memory Write):
void encodeNewOrder(uint8_t* buffer, const Order& order) {
    NewOrderMessage* msg = reinterpret_cast<NewOrderMessage*>(buffer);

    msg->header.magic = 0xABCD;
    msg->header.version = 1;
    msg->header.message_type = 0x0001;
    msg->header.message_length = sizeof(NewOrderMessage);
    msg->header.sequence_num = get_next_sequence();
    msg->header.timestamp = get_timestamp_ns();

    msg->cl_ord_id = order.cl_ord_id;
    msg->account_id = order.account_id;
    msg->symbol_id = symbol_to_id(order.symbol);
    msg->side = order.side;
    msg->order_type = order.order_type;
    msg->time_in_force = order.time_in_force;
    msg->quantity = order.quantity;
    msg->price = order.price * 10000;  // Convert to fixed-point
    msg->stop_price = order.stop_price * 10000;
    msg->min_quantity = order.min_quantity;
    msg->max_show = order.max_show;
    msg->flags = 0;
}

Decoding (Direct Memory Read):
bool decodeNewOrder(const uint8_t* buffer, size_t length, Order& order) {
    if (length < sizeof(NewOrderMessage)) return false;

    const NewOrderMessage* msg =
        reinterpret_cast<const NewOrderMessage*>(buffer);

    // Validate header
    if (msg->header.magic != 0xABCD) return false;
    if (msg->header.message_type != 0x0001) return false;
    if (msg->header.message_length != sizeof(NewOrderMessage)) return false;

    // Extract fields (zero-copy)
    order.cl_ord_id = msg->cl_ord_id;
    order.account_id = msg->account_id;
    order.symbol = id_to_symbol(msg->symbol_id);
    order.side = msg->side;
    order.order_type = msg->order_type;
    order.time_in_force = msg->time_in_force;
    order.quantity = msg->quantity;
    order.price = msg->price / 10000.0;  // Convert from fixed-point
    order.stop_price = msg->stop_price / 10000.0;
    order.min_quantity = msg->min_quantity;
    order.max_show = msg->max_show;

    return true;
}

Performance:
Encode: ~30ns (direct memory write)
Decode: ~25ns (direct memory read, no allocation)

================================================================================
3. FLATBUFFERS IMPLEMENTATION
================================================================================

3.1 SCHEMA DEFINITION
----------------------
FlatBuffers uses IDL (Interface Definition Language) schemas.

// trading.fbs
namespace Trading;

enum Side : byte {
  Buy = 1,
  Sell = 2
}

enum OrderType : byte {
  Market = 1,
  Limit = 2,
  Stop = 3,
  StopLimit = 4
}

enum OrdStatus : byte {
  New = 0,
  PartiallyFilled = 1,
  Filled = 2,
  Canceled = 4,
  Rejected = 8
}

table NewOrder {
  cl_ord_id: ulong;
  account_id: ulong;
  symbol: string;
  side: Side;
  order_type: OrderType;
  quantity: uint;
  price: double;
  stop_price: double = 0.0;
  time_in_force: ushort = 0;
}

table ExecutionReport {
  order_id: ulong;
  cl_ord_id: ulong;
  exec_id: ulong;
  symbol: string;
  side: Side;
  order_type: OrderType;
  exec_type: byte;
  ord_status: OrdStatus;
  order_qty: uint;
  price: double;
  last_qty: uint = 0;
  last_px: double = 0.0;
  leaves_qty: uint;
  cum_qty: uint;
  avg_px: double;
  transact_time: ulong;
}

table Quote {
  symbol_id: uint;
  bid_price: double;
  bid_size: uint;
  ask_price: double;
  ask_size: uint;
  quote_time: ulong;
}

union MessageType {
  NewOrder,
  ExecutionReport,
  Quote
}

table Message {
  seq_num: ulong;
  timestamp: ulong;
  payload: MessageType;
}

root_type Message;

Compile Schema:
$ flatc --cpp trading.fbs

Generates: trading_generated.h

3.2 ENCODING WITH FLATBUFFERS
------------------------------
#include "trading_generated.h"
#include <flatbuffers/flatbuffers.h>

void encodeNewOrderFlatBuffers(const Order& order,
                               uint8_t** buffer,
                               size_t* size) {
    flatbuffers::FlatBufferBuilder builder(256);

    // Create NewOrder
    auto symbol_str = builder.CreateString(order.symbol);

    auto new_order = Trading::CreateNewOrder(
        builder,
        order.cl_ord_id,
        order.account_id,
        symbol_str,
        Trading::Side_Buy,
        Trading::OrderType_Limit,
        order.quantity,
        order.price,
        order.stop_price,
        order.time_in_force
    );

    // Create Message wrapper
    auto message = Trading::CreateMessage(
        builder,
        get_next_sequence(),
        get_timestamp_ns(),
        Trading::MessageType_NewOrder,
        new_order.Union()
    );

    builder.Finish(message);

    // Get buffer
    *buffer = builder.GetBufferPointer();
    *size = builder.GetSize();
}

3.3 DECODING WITH FLATBUFFERS
------------------------------
bool decodeNewOrderFlatBuffers(const uint8_t* buffer,
                               size_t size,
                               Order& order) {
    // Verify buffer
    flatbuffers::Verifier verifier(buffer, size);
    if (!Trading::VerifyMessageBuffer(verifier)) {
        return false;
    }

    // Get message (zero-copy access)
    const Trading::Message* message = Trading::GetMessage(buffer);

    if (message->payload_type() != Trading::MessageType_NewOrder) {
        return false;
    }

    const Trading::NewOrder* new_order =
        message->payload_as_NewOrder();

    // Extract fields (zero-copy)
    order.cl_ord_id = new_order->cl_ord_id();
    order.account_id = new_order->account_id();
    order.symbol = new_order->symbol()->str();  // Copy string
    order.side = new_order->side();
    order.order_type = new_order->order_type();
    order.quantity = new_order->quantity();
    order.price = new_order->price();
    order.stop_price = new_order->stop_price();
    order.time_in_force = new_order->time_in_force();

    return true;
}

3.4 FLATBUFFERS FEATURES
-------------------------
Zero-Copy Access:
const Trading::Quote* quote = message->payload_as_Quote();
double bid = quote->bid_price();  // Direct memory access
uint32_t size = quote->bid_size(); // No parsing

Forward/Backward Compatibility:
// Old schema
table NewOrder {
  cl_ord_id: ulong;
  quantity: uint;
}

// New schema (backward compatible)
table NewOrder {
  cl_ord_id: ulong;
  quantity: uint;
  price: double = 0.0;  // New field with default
  account_id: ulong;     // New field
}

Old code can read new messages (ignores new fields)
New code can read old messages (uses defaults)

Nested Structures:
table Order {
  order_id: ulong;
  parties: [Party];  // Vector of Party objects
}

table Party {
  party_id: ulong;
  party_role: byte;
}

Unions (Polymorphism):
union MessagePayload {
  NewOrder,
  CancelOrder,
  ExecutionReport
}

table Message {
  payload: MessagePayload;
}

================================================================================
4. PROTOCOL BUFFERS (PROTOBUF)
================================================================================

4.1 PROTOBUF SCHEMA
-------------------
// trading.proto
syntax = "proto3";

package trading;

enum Side {
  BUY = 0;
  SELL = 1;
}

enum OrderType {
  MARKET = 0;
  LIMIT = 1;
  STOP = 2;
}

message NewOrder {
  uint64 cl_ord_id = 1;
  uint64 account_id = 2;
  string symbol = 3;
  Side side = 4;
  OrderType order_type = 5;
  uint32 quantity = 6;
  double price = 7;
  double stop_price = 8;
  uint32 time_in_force = 9;
}

message ExecutionReport {
  uint64 order_id = 1;
  uint64 cl_ord_id = 2;
  uint64 exec_id = 3;
  string symbol = 4;
  Side side = 5;
  uint32 exec_type = 6;
  uint32 ord_status = 7;
  uint32 order_qty = 8;
  double price = 9;
  uint32 last_qty = 10;
  double last_px = 11;
  uint32 cum_qty = 12;
  double avg_px = 13;
}

Compile:
$ protoc --cpp_out=. trading.proto

Generates: trading.pb.h, trading.pb.cc

4.2 PROTOBUF ENCODING
----------------------
#include "trading.pb.h"

std::string encodeNewOrderProtobuf(const Order& order) {
    trading::NewOrder pb_order;

    pb_order.set_cl_ord_id(order.cl_ord_id);
    pb_order.set_account_id(order.account_id);
    pb_order.set_symbol(order.symbol);
    pb_order.set_side(trading::Side::BUY);
    pb_order.set_order_type(trading::OrderType::LIMIT);
    pb_order.set_quantity(order.quantity);
    pb_order.set_price(order.price);
    pb_order.set_stop_price(order.stop_price);
    pb_order.set_time_in_force(order.time_in_force);

    std::string serialized;
    pb_order.SerializeToString(&serialized);

    return serialized;
}

4.3 PROTOBUF DECODING
----------------------
bool decodeNewOrderProtobuf(const std::string& data, Order& order) {
    trading::NewOrder pb_order;

    if (!pb_order.ParseFromString(data)) {
        return false;
    }

    order.cl_ord_id = pb_order.cl_ord_id();
    order.account_id = pb_order.account_id();
    order.symbol = pb_order.symbol();
    order.side = pb_order.side();
    order.order_type = pb_order.order_type();
    order.quantity = pb_order.quantity();
    order.price = pb_order.price();
    order.stop_price = pb_order.stop_price();
    order.time_in_force = pb_order.time_in_force();

    return true;
}

4.4 PROTOBUF vs FLATBUFFERS
----------------------------
Feature             Protobuf        FlatBuffers
Encode time         600ns           45ns
Decode time         520ns           5ns
Zero-copy           No              Yes
Wire size           50-100B         40-80B
Schema evolution    Excellent       Good
Language support    Excellent       Good
Complexity          Medium          Low
Memory allocation   Yes             Minimal

Use Protobuf when:
- Cross-language compatibility critical
- Schema evolution very important
- Moderate performance acceptable
- Rich tooling needed

Use FlatBuffers when:
- Low latency critical
- Zero-copy access needed
- Mobile/embedded deployment
- Consistent performance required

================================================================================
5. C++ IMPLEMENTATION
================================================================================

5.1 MESSAGE ENCODER
-------------------
class BinaryMessageEncoder {
private:
    alignas(64) uint8_t buffer_[4096];
    uint64_t sequence_num_;

public:
    BinaryMessageEncoder() : sequence_num_(1) {}

    const uint8_t* encodeNewOrder(const Order& order, size_t& size) {
        NewOrderMessage* msg =
            reinterpret_cast<NewOrderMessage*>(buffer_);

        // Fill header
        msg->header.magic = 0xABCD;
        msg->header.version = 1;
        msg->header.message_type = 0x0001;
        msg->header.message_length = sizeof(NewOrderMessage);
        msg->header.sequence_num = sequence_num_++;
        msg->header.timestamp = rdtsc();  // Use TSC for speed

        // Fill order fields
        msg->cl_ord_id = order.cl_ord_id;
        msg->account_id = order.account_id;
        msg->symbol_id = symbolToId(order.symbol);
        msg->side = order.side;
        msg->order_type = order.order_type;
        msg->time_in_force = order.time_in_force;
        msg->quantity = order.quantity;
        msg->price = doubleToFixed(order.price);
        msg->stop_price = doubleToFixed(order.stop_price);
        msg->min_quantity = order.min_quantity;
        msg->max_show = order.max_show;
        msg->flags = order.flags;

        size = sizeof(NewOrderMessage);
        return buffer_;
    }

private:
    inline uint64_t rdtsc() {
        uint32_t lo, hi;
        __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
        return ((uint64_t)hi << 32) | lo;
    }

    inline int64_t doubleToFixed(double value) {
        return static_cast<int64_t>(value * 10000.0 + 0.5);
    }

    uint32_t symbolToId(const std::string& symbol) {
        // Symbol cache/lookup
        static std::unordered_map<std::string, uint32_t> cache;
        auto it = cache.find(symbol);
        if (it != cache.end()) return it->second;

        // Compute ID (hash or database lookup)
        uint32_t id = std::hash<std::string>{}(symbol);
        cache[symbol] = id;
        return id;
    }
};

5.2 MESSAGE DECODER
-------------------
class BinaryMessageDecoder {
private:
    std::unordered_map<uint32_t, std::string> id_to_symbol_;

public:
    bool decodeMessage(const uint8_t* buffer, size_t length,
                      MessageType& type, void* output) {
        if (length < sizeof(MessageHeader)) return false;

        const MessageHeader* header =
            reinterpret_cast<const MessageHeader*>(buffer);

        // Validate header
        if (header->magic != 0xABCD) return false;
        if (header->version != 1) return false;
        if (header->message_length > length) return false;

        // Dispatch based on type
        switch (header->message_type) {
            case 0x0001:
                return decodeNewOrder(buffer, length,
                                     *static_cast<Order*>(output));

            case 0x0004:
                return decodeExecutionReport(buffer, length,
                                            *static_cast<Execution*>(output));

            case 0x0006:
                return decodeMarketData(buffer, length,
                                       *static_cast<Quote*>(output));

            default:
                return false;
        }
    }

private:
    bool decodeNewOrder(const uint8_t* buffer, size_t length,
                       Order& order) {
        if (length < sizeof(NewOrderMessage)) return false;

        const NewOrderMessage* msg =
            reinterpret_cast<const NewOrderMessage*>(buffer);

        order.cl_ord_id = msg->cl_ord_id;
        order.account_id = msg->account_id;
        order.symbol = idToSymbol(msg->symbol_id);
        order.side = msg->side;
        order.order_type = msg->order_type;
        order.time_in_force = msg->time_in_force;
        order.quantity = msg->quantity;
        order.price = fixedToDouble(msg->price);
        order.stop_price = fixedToDouble(msg->stop_price);
        order.min_quantity = msg->min_quantity;
        order.max_show = msg->max_show;
        order.flags = msg->flags;

        return true;
    }

    inline double fixedToDouble(int64_t value) {
        return value / 10000.0;
    }

    const std::string& idToSymbol(uint32_t id) {
        auto it = id_to_symbol_.find(id);
        if (it != id_to_symbol_.end()) return it->second;

        // Lookup in database/cache
        std::string symbol = lookupSymbol(id);
        id_to_symbol_[id] = symbol;
        return id_to_symbol_[id];
    }

    std::string lookupSymbol(uint32_t id) {
        // Database or cache lookup
        return "UNKNOWN";
    }
};

5.3 ZERO-COPY MESSAGE PROCESSOR
--------------------------------
class ZeroCopyProcessor {
public:
    void processNewOrder(const uint8_t* buffer) {
        // Cast to message structure (zero-copy)
        const NewOrderMessage* msg =
            reinterpret_cast<const NewOrderMessage*>(buffer);

        // Direct field access (no copying)
        uint64_t cl_ord_id = msg->cl_ord_id;
        uint32_t quantity = msg->quantity;
        int64_t price = msg->price;

        // Process order directly from buffer
        submitOrder(cl_ord_id, quantity, price);
    }

    void processMarketData(const uint8_t* buffer) {
        const QuoteUpdateMessage* quote =
            reinterpret_cast<const QuoteUpdateMessage*>(buffer);

        // Update order book directly from buffer
        updateOrderBook(quote->symbol_id,
                       quote->bid_price, quote->bid_size,
                       quote->ask_price, quote->ask_size);
    }

private:
    void submitOrder(uint64_t cl_ord_id, uint32_t qty, int64_t price) {
        // Implementation
    }

    void updateOrderBook(uint32_t symbol_id,
                        int64_t bid_px, uint32_t bid_sz,
                        int64_t ask_px, uint32_t ask_sz) {
        // Implementation
    }
};

================================================================================
6. PERFORMANCE OPTIMIZATION
================================================================================

6.1 MEMORY ALIGNMENT
--------------------
// Align messages to cache lines
alignas(64) struct AlignedNewOrder {
    MessageHeader header;    // 24 bytes
    uint64_t cl_ord_id;      // 8 bytes
    uint64_t account_id;     // 8 bytes
    uint32_t symbol_id;      // 4 bytes
    // ... rest of fields
    uint8_t  padding[20];    // Pad to 64 bytes
} __attribute__((packed));

Benefits:
- Reduced cache misses
- Better memory bandwidth utilization
- Faster memory access

6.2 BATCHING
------------
class BatchEncoder {
private:
    alignas(64) uint8_t buffer_[65536];
    size_t offset_;

public:
    void startBatch() {
        offset_ = 0;
    }

    bool addOrder(const Order& order) {
        if (offset_ + sizeof(NewOrderMessage) > sizeof(buffer_)) {
            return false;
        }

        NewOrderMessage* msg =
            reinterpret_cast<NewOrderMessage*>(buffer_ + offset_);

        // Encode message
        encodeNewOrder(msg, order);

        offset_ += sizeof(NewOrderMessage);
        return true;
    }

    const uint8_t* finalize(size_t& total_size) {
        total_size = offset_;
        return buffer_;
    }
};

Benefits:
- Amortized encoding overhead
- Better network utilization
- Single system call for multiple messages

6.3 SIMD OPTIMIZATION
---------------------
#include <immintrin.h>

// Fast memory copy for fixed-size messages
void copyMessage256(uint8_t* dest, const uint8_t* src) {
    // Copy 256 bytes using AVX2 (32 bytes at a time)
    __m256i* dest_vec = (__m256i*)dest;
    const __m256i* src_vec = (const __m256i*)src;

    for (int i = 0; i < 8; ++i) {
        _mm256_store_si256(dest_vec + i, _mm256_load_si256(src_vec + i));
    }
}

// Fast comparison
bool compareHeaders(const MessageHeader* h1, const MessageHeader* h2) {
    __m128i a = _mm_loadu_si128((__m128i*)h1);
    __m128i b = _mm_loadu_si128((__m128i*)h2);
    __m128i cmp = _mm_cmpeq_epi64(a, b);

    return _mm_movemask_epi8(cmp) == 0xFFFF;
}

================================================================================
7. SCHEMA EVOLUTION
================================================================================

7.1 VERSION MANAGEMENT
-----------------------
Version in Header:
struct MessageHeader {
    uint16_t version;  // Schema version
    // ... other fields
};

Decoding with Version Check:
bool decode(const uint8_t* buffer, Order& order) {
    const MessageHeader* header =
        reinterpret_cast<const MessageHeader*>(buffer);

    switch (header->version) {
        case 1:
            return decodeV1(buffer, order);
        case 2:
            return decodeV2(buffer, order);
        default:
            return false;
    }
}

7.2 BACKWARD COMPATIBILITY
---------------------------
Add New Fields at End:
// Version 1
struct NewOrderV1 {
    MessageHeader header;
    uint64_t cl_ord_id;
    uint32_t quantity;
    int64_t  price;
} __attribute__((packed));

// Version 2 (backward compatible)
struct NewOrderV2 {
    MessageHeader header;
    uint64_t cl_ord_id;
    uint32_t quantity;
    int64_t  price;
    uint64_t account_id;  // New field
    uint8_t  flags;       // New field
    uint8_t  reserved[7]; // Alignment
} __attribute__((packed));

Decoding V1 with V2 Code:
bool decodeV1AsV2(const uint8_t* buffer, Order& order) {
    const NewOrderV1* v1 =
        reinterpret_cast<const NewOrderV1*>(buffer);

    order.cl_ord_id = v1->cl_ord_id;
    order.quantity = v1->quantity;
    order.price = v1->price;
    order.account_id = 0;  // Default for new field
    order.flags = 0;       // Default

    return true;
}

7.3 FEATURE FLAGS
-----------------
Use flags to enable/disable features:

struct MessageHeader {
    uint32_t feature_flags;  // Bit flags
    // ... other fields
};

Feature Flags:
Bit 0: Supports extended order types
Bit 1: Supports iceberg orders
Bit 2: Supports advanced TIF
Bit 3: Supports order tags

Check Features:
bool supportsIcebergOrders(const MessageHeader* header) {
    return (header->feature_flags & (1 << 1)) != 0;
}

================================================================================
8. BENCHMARKS AND COMPARISON
================================================================================

8.1 ENCODING BENCHMARKS
------------------------
Hardware: Intel Xeon E5-2690 v4
Message: NewOrder (80 bytes)

Protocol          Encode    Memory    CPU Cycles
Custom Binary     30ns      0 alloc   78
FlatBuffers       45ns      1 alloc   117
SBE               50ns      0 alloc   130
Protobuf          600ns     3 alloc   1560
JSON (RapidJSON)  1800ns    5 alloc   4680
MessagePack       400ns     2 alloc   1040

8.2 DECODING BENCHMARKS
------------------------
Protocol          Decode    Memory    CPU Cycles
Custom Binary     25ns      0 alloc   65
FlatBuffers       5ns       0 alloc   13 (zero-copy)
SBE               40ns      0 alloc   104
Protobuf          520ns     2 alloc   1352
JSON (RapidJSON)  1500ns    4 alloc   3900
MessagePack       350ns     1 alloc   910

8.3 WIRE SIZE COMPARISON
-------------------------
Message Type      Custom    FlatBuffers  SBE    Protobuf  JSON
NewOrder         80B       92B          88B    68B       245B
ExecReport       112B      128B         120B   85B       320B
Quote            72B       84B          76B    62B       180B
OrderBook (10)   200B      228B         216B   185B      850B

8.4 THROUGHPUT
--------------
Single Thread:
Custom Binary:    33M msgs/sec encode, 40M msgs/sec decode
FlatBuffers:      22M msgs/sec encode, 200M msgs/sec decode
SBE:              20M msgs/sec encode, 25M msgs/sec decode
Protobuf:         1.6M msgs/sec encode, 1.9M msgs/sec decode

Multi-Thread (4 cores):
Custom Binary:    120M msgs/sec
FlatBuffers:      75M msgs/sec (encode limited)
SBE:              70M msgs/sec
Protobuf:         6M msgs/sec

8.5 RECOMMENDATIONS
-------------------
Ultra-Low Latency (<100ns):
- Custom Binary
- Direct memory mapping
- Zero-copy processing

Low Latency (<1us):
- SBE (CME MDP 3.0 compatible)
- FlatBuffers (if zero-copy decode important)

Moderate Latency (<10us):
- Protobuf (good tooling, wide adoption)
- MessagePack (compact, simple)

General Purpose:
- JSON (human-readable, debugging)
- Protobuf (service-to-service)

Mobile/Embedded:
- FlatBuffers (low memory, no parsing)
- Cap'n Proto (similar to FlatBuffers)

================================================================================
END OF BINARY PROTOCOLS DOCUMENTATION
================================================================================
