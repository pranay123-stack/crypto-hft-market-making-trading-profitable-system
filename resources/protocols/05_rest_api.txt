================================================================================
                        REST API DOCUMENTATION
                     RESTful Patterns for Trading Systems
                      HTTP-Based Administrative Operations
================================================================================

TABLE OF CONTENTS
================================================================================
1. Protocol Overview
2. REST Principles
3. API Design Patterns
4. C++ Implementation
5. Authentication & Security
6. Performance Considerations
7. Real-World Examples
8. Error Handling

================================================================================
1. PROTOCOL OVERVIEW
================================================================================

1.1 INTRODUCTION
----------------
REST (Representational State Transfer) APIs provide a standardized way to
interact with trading systems over HTTP. While not suitable for ultra-low
latency operations, REST is ideal for administrative tasks and system
management.

Key Characteristics:
- Stateless communication
- Resource-based URLs
- Standard HTTP methods (GET, POST, PUT, DELETE)
- JSON/XML payloads
- Human-readable
- Wide tooling support

Performance Profile:
Operation          Latency      Use Case
GET /positions     5-15ms       Portfolio queries
POST /orders       10-30ms      Non-urgent orders
PUT /risk-limits   5-10ms       Configuration
DELETE /order/:id  8-20ms       Cancel orders
WebSocket upgrade  10-50ms      Switch to streaming

Comparison:
Protocol    Latency   Suitable For
FIX/SBE     <1ms      Order entry
WebSocket   <1ms      Real-time data
REST        5-50ms    Admin operations
SOAP        20-100ms  Legacy integration

1.2 USE CASES
-------------
Ideal For:
- Administrative operations
- Position/PnL queries
- Risk limit management
- User management
- Historical data retrieval
- System configuration
- Reporting and analytics
- Third-party integrations

Not Suitable For:
- High-frequency trading
- Real-time market data
- Sub-millisecond order entry
- Tick-by-tick data streaming

1.3 ARCHITECTURAL PATTERNS
---------------------------
+------------------+
| REST API Gateway |  (Load balancer, rate limiting)
+------------------+
         |
    +----+----+
    |         |
+--------+ +--------+
| API    | | API    |  (Multiple instances)
| Server | | Server |
+--------+ +--------+
         |
    +----+----+
    |         |
+--------+ +--------+
| Order  | | Market |  (Business services)
| Mgmt   | | Data   |
+--------+ +--------+
         |
+------------------+
| Database/Cache   |
+------------------+

================================================================================
2. REST PRINCIPLES
================================================================================

2.1 RESOURCE-BASED URLS
------------------------
Resources represent entities in the trading system:

Good URL Design:
GET    /api/v1/accounts/{accountId}
GET    /api/v1/accounts/{accountId}/positions
GET    /api/v1/accounts/{accountId}/orders
POST   /api/v1/accounts/{accountId}/orders
DELETE /api/v1/accounts/{accountId}/orders/{orderId}
GET    /api/v1/markets/{symbol}/quote
GET    /api/v1/markets/{symbol}/history

Bad URL Design (Avoid):
GET    /api/getAccount?id=123
POST   /api/createOrder
GET    /api/order_list
DELETE /api/deleteOrderById/123

2.2 HTTP METHODS
----------------
GET - Retrieve resource(s)
  - Idempotent (safe to retry)
  - No request body
  - Cacheable
  Example: GET /api/v1/positions

POST - Create new resource
  - Not idempotent
  - Request body required
  - Returns 201 Created
  Example: POST /api/v1/orders

PUT - Update entire resource
  - Idempotent
  - Request body required
  - Returns 200 OK or 204 No Content
  Example: PUT /api/v1/orders/{orderId}

PATCH - Partial update
  - Not necessarily idempotent
  - Request body with changes only
  Example: PATCH /api/v1/orders/{orderId}

DELETE - Remove resource
  - Idempotent
  - Returns 204 No Content
  Example: DELETE /api/v1/orders/{orderId}

2.3 STATUS CODES
----------------
Success:
200 OK              - Request succeeded
201 Created         - Resource created
202 Accepted        - Async operation queued
204 No Content      - Success, no response body

Client Errors:
400 Bad Request     - Invalid request format
401 Unauthorized    - Authentication required
403 Forbidden       - Insufficient permissions
404 Not Found       - Resource doesn't exist
409 Conflict        - Resource state conflict
422 Unprocessable   - Validation failed
429 Too Many Req.   - Rate limit exceeded

Server Errors:
500 Internal Error  - Server error
502 Bad Gateway     - Upstream service error
503 Service Unavail - Temporary unavailability
504 Gateway Timeout - Upstream timeout

2.4 REQUEST/RESPONSE FORMAT
----------------------------
Request Headers:
POST /api/v1/orders HTTP/1.1
Host: api.trading.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Content-Type: application/json
Accept: application/json
X-Request-ID: req-12345

Request Body (JSON):
{
  "symbol": "AAPL",
  "side": "buy",
  "quantity": 100,
  "price": 150.50,
  "orderType": "limit",
  "timeInForce": "day"
}

Response:
HTTP/1.1 201 Created
Content-Type: application/json
Location: /api/v1/orders/ORD-789
X-Request-ID: req-12345

{
  "orderId": "ORD-789",
  "clOrdId": "CLIENT-123",
  "symbol": "AAPL",
  "side": "buy",
  "quantity": 100,
  "price": 150.50,
  "status": "new",
  "timestamp": "2025-01-26T10:30:00.000Z"
}

================================================================================
3. API DESIGN PATTERNS
================================================================================

3.1 PAGINATION
--------------
Query Parameters:
GET /api/v1/orders?page=2&pageSize=50&sortBy=timestamp&order=desc

Response:
{
  "data": [
    { "orderId": "ORD-100", ... },
    { "orderId": "ORD-101", ... }
  ],
  "pagination": {
    "page": 2,
    "pageSize": 50,
    "totalPages": 10,
    "totalRecords": 487
  },
  "links": {
    "first": "/api/v1/orders?page=1&pageSize=50",
    "prev": "/api/v1/orders?page=1&pageSize=50",
    "next": "/api/v1/orders?page=3&pageSize=50",
    "last": "/api/v1/orders?page=10&pageSize=50"
  }
}

Cursor-Based Pagination (Better for real-time data):
GET /api/v1/trades?cursor=MTIzNDU2Nzg5MA==&limit=100

Response:
{
  "data": [...],
  "nextCursor": "MTIzNDU2ODAwMA==",
  "hasMore": true
}

3.2 FILTERING AND SEARCH
-------------------------
GET /api/v1/orders?symbol=AAPL&status=open&minQty=100

GET /api/v1/trades?startDate=2025-01-01&endDate=2025-01-31&side=buy

GET /api/v1/positions?account=ACC-123&minValue=10000

Complex Filters (JSON in query param):
GET /api/v1/orders?filter={"and":[{"field":"symbol","op":"in","value":["AAPL","MSFT"]},{"field":"quantity","op":"gte","value":100}]}

3.3 BATCH OPERATIONS
--------------------
POST /api/v1/orders/batch
{
  "orders": [
    { "symbol": "AAPL", "side": "buy", "quantity": 100, "price": 150.50 },
    { "symbol": "MSFT", "side": "sell", "quantity": 50, "price": 380.00 }
  ]
}

Response:
{
  "results": [
    { "index": 0, "orderId": "ORD-100", "status": "success" },
    { "index": 1, "orderId": "ORD-101", "status": "success" }
  ],
  "summary": {
    "total": 2,
    "successful": 2,
    "failed": 0
  }
}

3.4 ASYNC OPERATIONS
--------------------
POST /api/v1/reports/generate
{
  "reportType": "positionReport",
  "startDate": "2025-01-01",
  "endDate": "2025-01-31"
}

Response (202 Accepted):
{
  "jobId": "JOB-12345",
  "status": "processing",
  "estimatedTime": 30,
  "statusUrl": "/api/v1/jobs/JOB-12345"
}

Check Status:
GET /api/v1/jobs/JOB-12345

Response:
{
  "jobId": "JOB-12345",
  "status": "completed",
  "progress": 100,
  "result": {
    "reportUrl": "/api/v1/reports/download/RPT-789"
  }
}

3.5 VERSIONING
--------------
URL Versioning:
/api/v1/orders
/api/v2/orders

Header Versioning:
GET /api/orders
Accept: application/vnd.trading.v2+json

Query Parameter:
GET /api/orders?version=2

Version Deprecation:
HTTP/1.1 200 OK
X-API-Deprecation: version=1 sunset=2025-12-31
X-API-Version: 1

================================================================================
4. C++ IMPLEMENTATION
================================================================================

4.1 HTTP SERVER (BOOST.BEAST)
------------------------------
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/asio.hpp>
#include <nlohmann/json.hpp>
#include <memory>
#include <string>

namespace beast = boost::beast;
namespace http = beast::http;
namespace net = boost::asio;
using tcp = net::ip::tcp;
using json = nlohmann::json;

class RestSession : public std::enable_shared_from_this<RestSession> {
private:
    tcp::socket socket_;
    beast::flat_buffer buffer_;
    http::request<http::string_body> request_;
    http::response<http::string_body> response_;

public:
    RestSession(tcp::socket socket)
        : socket_(std::move(socket)) {
    }

    void run() {
        doRead();
    }

private:
    void doRead() {
        auto self = shared_from_this();

        http::async_read(socket_, buffer_, request_,
            [self](beast::error_code ec, std::size_t) {
                if (!ec) {
                    self->handleRequest();
                }
            });
    }

    void handleRequest() {
        response_.version(request_.version());
        response_.keep_alive(request_.keep_alive());

        std::string target = request_.target();
        http::verb method = request_.method();

        // Route handling
        if (method == http::verb::get && target.find("/api/v1/positions") == 0) {
            handleGetPositions();
        } else if (method == http::verb::get && target.find("/api/v1/orders") == 0) {
            handleGetOrders();
        } else if (method == http::verb::post && target == "/api/v1/orders") {
            handlePostOrder();
        } else if (method == http::verb::delete_ && target.find("/api/v1/orders/") == 0) {
            handleDeleteOrder(target);
        } else if (method == http::verb::get && target.find("/api/v1/markets/") == 0) {
            handleGetQuote(target);
        } else {
            response_.result(http::status::not_found);
            response_.set(http::field::content_type, "application/json");
            json error;
            error["error"] = "Not found";
            error["message"] = "Resource not found";
            response_.body() = error.dump();
        }

        response_.prepare_payload();
        doWrite();
    }

    void handleGetPositions() {
        // Extract query parameters
        std::string target = request_.target();
        std::string account_id = extractQueryParam(target, "accountId");

        // Fetch positions from database
        json positions = fetchPositions(account_id);

        response_.result(http::status::ok);
        response_.set(http::field::content_type, "application/json");
        response_.body() = positions.dump();
    }

    void handleGetOrders() {
        std::string target = request_.target();

        // Parse pagination params
        int page = std::stoi(extractQueryParam(target, "page", "1"));
        int page_size = std::stoi(extractQueryParam(target, "pageSize", "50"));
        std::string status = extractQueryParam(target, "status");

        // Fetch orders
        json result;
        result["data"] = fetchOrders(page, page_size, status);
        result["pagination"] = {
            {"page", page},
            {"pageSize", page_size},
            {"totalRecords", getTotalOrders(status)}
        };

        response_.result(http::status::ok);
        response_.set(http::field::content_type, "application/json");
        response_.body() = result.dump();
    }

    void handlePostOrder() {
        try {
            // Parse request body
            json order_req = json::parse(request_.body());

            // Validate
            if (!order_req.contains("symbol") ||
                !order_req.contains("side") ||
                !order_req.contains("quantity")) {
                response_.result(http::status::bad_request);
                json error;
                error["error"] = "Bad request";
                error["message"] = "Missing required fields";
                response_.body() = error.dump();
                return;
            }

            // Submit order
            std::string order_id = submitOrder(order_req);

            // Build response
            json order_resp;
            order_resp["orderId"] = order_id;
            order_resp["symbol"] = order_req["symbol"];
            order_resp["side"] = order_req["side"];
            order_resp["quantity"] = order_req["quantity"];
            order_resp["price"] = order_req.value("price", 0.0);
            order_resp["status"] = "new";

            response_.result(http::status::created);
            response_.set(http::field::content_type, "application/json");
            response_.set(http::field::location, "/api/v1/orders/" + order_id);
            response_.body() = order_resp.dump();

        } catch (const std::exception& e) {
            response_.result(http::status::internal_server_error);
            json error;
            error["error"] = "Internal error";
            error["message"] = e.what();
            response_.body() = error.dump();
        }
    }

    void handleDeleteOrder(const std::string& target) {
        // Extract order ID from URL
        size_t pos = target.find_last_of('/');
        std::string order_id = target.substr(pos + 1);

        if (cancelOrder(order_id)) {
            response_.result(http::status::no_content);
        } else {
            response_.result(http::status::not_found);
            json error;
            error["error"] = "Not found";
            error["message"] = "Order not found or already completed";
            response_.body() = error.dump();
        }
    }

    void handleGetQuote(const std::string& target) {
        // Extract symbol: /api/v1/markets/{symbol}/quote
        std::string path = target;
        size_t markets_pos = path.find("/markets/");
        size_t quote_pos = path.find("/quote");

        if (markets_pos != std::string::npos && quote_pos != std::string::npos) {
            std::string symbol = path.substr(markets_pos + 9,
                                           quote_pos - markets_pos - 9);

            json quote = getQuote(symbol);

            if (!quote.empty()) {
                response_.result(http::status::ok);
                response_.set(http::field::content_type, "application/json");
                response_.body() = quote.dump();
            } else {
                response_.result(http::status::not_found);
                json error;
                error["error"] = "Not found";
                error["message"] = "Symbol not found";
                response_.body() = error.dump();
            }
        } else {
            response_.result(http::status::bad_request);
        }
    }

    void doWrite() {
        auto self = shared_from_this();

        http::async_write(socket_, response_,
            [self](beast::error_code ec, std::size_t) {
                if (ec) return;

                self->socket_.shutdown(tcp::socket::shutdown_send, ec);
            });
    }

    std::string extractQueryParam(const std::string& url,
                                 const std::string& param,
                                 const std::string& default_val = "") {
        size_t pos = url.find(param + "=");
        if (pos == std::string::npos) return default_val;

        size_t start = pos + param.length() + 1;
        size_t end = url.find('&', start);

        if (end == std::string::npos) {
            return url.substr(start);
        } else {
            return url.substr(start, end - start);
        }
    }

    json fetchPositions(const std::string& account_id) {
        // Database query implementation
        json positions = json::array();
        positions.push_back({
            {"symbol", "AAPL"},
            {"quantity", 100},
            {"avgPrice", 150.25},
            {"currentPrice", 151.50},
            {"unrealizedPnL", 125.00}
        });
        return positions;
    }

    json fetchOrders(int page, int page_size, const std::string& status) {
        // Database query implementation
        return json::array();
    }

    int getTotalOrders(const std::string& status) {
        // Database count implementation
        return 100;
    }

    std::string submitOrder(const json& order) {
        // Order submission implementation
        return "ORD-" + std::to_string(rand());
    }

    bool cancelOrder(const std::string& order_id) {
        // Order cancellation implementation
        return true;
    }

    json getQuote(const std::string& symbol) {
        // Market data query implementation
        return {
            {"symbol", symbol},
            {"bid", 150.25},
            {"ask", 150.27},
            {"last", 150.26},
            {"volume", 1000000},
            {"timestamp", "2025-01-26T10:30:00.000Z"}
        };
    }
};

class RestServer {
private:
    net::io_context ioc_;
    tcp::acceptor acceptor_;

public:
    RestServer(uint16_t port)
        : acceptor_(ioc_, tcp::endpoint(tcp::v4(), port)) {
    }

    void run() {
        doAccept();
        ioc_.run();
    }

private:
    void doAccept() {
        acceptor_.async_accept(
            [this](beast::error_code ec, tcp::socket socket) {
                if (!ec) {
                    std::make_shared<RestSession>(std::move(socket))->run();
                }
                doAccept();
            });
    }
};

4.2 REST CLIENT
---------------
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/asio.hpp>
#include <nlohmann/json.hpp>

class RestClient {
private:
    net::io_context ioc_;
    tcp::resolver resolver_;
    beast::tcp_stream stream_;
    std::string host_;
    std::string port_;

public:
    RestClient(const std::string& host, const std::string& port = "80")
        : resolver_(ioc_)
        , stream_(ioc_)
        , host_(host)
        , port_(port) {
    }

    json get(const std::string& target) {
        http::request<http::string_body> req{http::verb::get, target, 11};
        req.set(http::field::host, host_);
        req.set(http::field::user_agent, "TradingClient/1.0");

        return executeRequest(req);
    }

    json post(const std::string& target, const json& body) {
        http::request<http::string_body> req{http::verb::post, target, 11};
        req.set(http::field::host, host_);
        req.set(http::field::user_agent, "TradingClient/1.0");
        req.set(http::field::content_type, "application/json");
        req.body() = body.dump();
        req.prepare_payload();

        return executeRequest(req);
    }

    bool delete_(const std::string& target) {
        http::request<http::string_body> req{http::verb::delete_, target, 11};
        req.set(http::field::host, host_);
        req.set(http::field::user_agent, "TradingClient/1.0");

        json response = executeRequest(req);
        return !response.empty();
    }

private:
    json executeRequest(http::request<http::string_body>& req) {
        // Resolve hostname
        auto results = resolver_.resolve(host_, port_);

        // Connect
        stream_.connect(results);

        // Send request
        http::write(stream_, req);

        // Read response
        beast::flat_buffer buffer;
        http::response<http::string_body> res;
        http::read(stream_, buffer, res);

        // Parse JSON response
        if (res.result() == http::status::no_content) {
            return json();
        }

        json j = json::parse(res.body());

        // Gracefully close socket
        beast::error_code ec;
        stream_.socket().shutdown(tcp::socket::shutdown_both, ec);

        return j;
    }
};

// Usage example
int main() {
    RestClient client("api.trading.com", "443");

    // Get positions
    json positions = client.get("/api/v1/positions?accountId=ACC-123");
    std::cout << positions.dump(2) << "\n";

    // Submit order
    json order;
    order["symbol"] = "AAPL";
    order["side"] = "buy";
    order["quantity"] = 100;
    order["price"] = 150.50;
    order["orderType"] = "limit";

    json order_resp = client.post("/api/v1/orders", order);
    std::cout << "Order ID: " << order_resp["orderId"] << "\n";

    // Cancel order
    std::string order_id = order_resp["orderId"];
    bool cancelled = client.delete_("/api/v1/orders/" + order_id);
    std::cout << "Cancelled: " << (cancelled ? "yes" : "no") << "\n";

    return 0;
}

================================================================================
5. AUTHENTICATION & SECURITY
================================================================================

5.1 API KEY AUTHENTICATION
---------------------------
Request:
GET /api/v1/positions HTTP/1.1
Host: api.trading.com
X-API-Key: abc123def456
X-API-Secret: xyz789uvw012

Server Validation:
bool validateApiKey(const std::string& api_key,
                   const std::string& api_secret) {
    // Look up in database
    auto credentials = db.query(
        "SELECT secret, permissions FROM api_keys WHERE key = ?", api_key);

    if (credentials.empty()) return false;

    // Verify secret
    if (credentials[0]["secret"] != api_secret) return false;

    // Check permissions
    return hasPermission(credentials[0]["permissions"], "read:positions");
}

5.2 JWT AUTHENTICATION
----------------------
Request:
GET /api/v1/positions HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

Token Structure:
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "user123",
    "account": "ACC-123",
    "permissions": ["read:positions", "write:orders"],
    "exp": 1234567890
  },
  "signature": "..."
}

Validation:
#include <jwt-cpp/jwt.h>

bool validateJWT(const std::string& token) {
    try {
        auto decoded = jwt::decode(token);

        // Verify signature
        auto verifier = jwt::verify()
            .allow_algorithm(jwt::algorithm::hs256{"secret"})
            .with_issuer("trading-system");

        verifier.verify(decoded);

        // Check expiration
        auto exp = decoded.get_expires_at();
        if (exp < std::chrono::system_clock::now()) {
            return false;
        }

        return true;
    } catch (const std::exception&) {
        return false;
    }
}

5.3 OAUTH 2.0
-------------
Authorization Flow:
1. Client redirects user to authorization server
2. User authenticates and grants permissions
3. Authorization server redirects back with code
4. Client exchanges code for access token
5. Client uses access token for API requests

Request Access Token:
POST /oauth/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code=AUTH_CODE&
redirect_uri=https://client.com/callback&
client_id=CLIENT_ID&
client_secret=CLIENT_SECRET

Response:
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "tGzv3JOkF0XG5Qx2TlKW"
}

Use Access Token:
GET /api/v1/positions HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...

5.4 RATE LIMITING
-----------------
class RateLimiter {
private:
    std::unordered_map<std::string, TokenBucket> buckets_;
    std::mutex mutex_;

public:
    bool allowRequest(const std::string& api_key) {
        std::lock_guard<std::mutex> lock(mutex_);

        auto& bucket = buckets_[api_key];
        return bucket.consume(1);
    }

    void setLimit(const std::string& api_key, int rate, int burst) {
        std::lock_guard<std::mutex> lock(mutex_);
        buckets_[api_key] = TokenBucket(rate, burst);
    }
};

class TokenBucket {
private:
    int rate_;       // Tokens per second
    int capacity_;   // Maximum tokens
    double tokens_;  // Current tokens
    std::chrono::steady_clock::time_point last_update_;

public:
    TokenBucket(int rate = 100, int capacity = 200)
        : rate_(rate)
        , capacity_(capacity)
        , tokens_(capacity)
        , last_update_(std::chrono::steady_clock::now()) {
    }

    bool consume(int count) {
        refill();

        if (tokens_ >= count) {
            tokens_ -= count;
            return true;
        }

        return false;
    }

private:
    void refill() {
        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            now - last_update_).count() / 1000.0;

        tokens_ = std::min(capacity_,
                          static_cast<int>(tokens_ + rate_ * elapsed));
        last_update_ = now;
    }
};

Response Headers:
HTTP/1.1 200 OK
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1234567890

Rate Limit Exceeded:
HTTP/1.1 429 Too Many Requests
Retry-After: 60

{
  "error": "Rate limit exceeded",
  "message": "Too many requests, please try again later"
}

================================================================================
6. PERFORMANCE CONSIDERATIONS
================================================================================

6.1 CACHING
-----------
// In-memory cache
class ResponseCache {
private:
    std::unordered_map<std::string, CacheEntry> cache_;
    std::mutex mutex_;

    struct CacheEntry {
        json data;
        std::chrono::steady_clock::time_point expiry;
    };

public:
    bool get(const std::string& key, json& data) {
        std::lock_guard<std::mutex> lock(mutex_);

        auto it = cache_.find(key);
        if (it == cache_.end()) return false;

        if (it->second.expiry < std::chrono::steady_clock::now()) {
            cache_.erase(it);
            return false;
        }

        data = it->second.data;
        return true;
    }

    void set(const std::string& key, const json& data, int ttl_seconds) {
        std::lock_guard<std::mutex> lock(mutex_);

        CacheEntry entry;
        entry.data = data;
        entry.expiry = std::chrono::steady_clock::now() +
                      std::chrono::seconds(ttl_seconds);

        cache_[key] = entry;
    }
};

Cache Headers:
GET /api/v1/markets/AAPL/quote HTTP/1.1

Response:
HTTP/1.1 200 OK
Cache-Control: max-age=1, public
ETag: "abc123"

Conditional Request:
GET /api/v1/markets/AAPL/quote HTTP/1.1
If-None-Match: "abc123"

Response (Not Modified):
HTTP/1.1 304 Not Modified

6.2 CONNECTION POOLING
-----------------------
class ConnectionPool {
private:
    std::queue<tcp::socket> available_;
    std::mutex mutex_;
    const size_t max_connections_ = 10;

public:
    tcp::socket acquire() {
        std::lock_guard<std::mutex> lock(mutex_);

        if (!available_.empty()) {
            auto socket = std::move(available_.front());
            available_.pop();
            return socket;
        }

        // Create new connection
        net::io_context ioc;
        tcp::resolver resolver(ioc);
        auto results = resolver.resolve("api.trading.com", "80");

        tcp::socket socket(ioc);
        net::connect(socket, results);

        return socket;
    }

    void release(tcp::socket socket) {
        std::lock_guard<std::mutex> lock(mutex_);

        if (available_.size() < max_connections_) {
            available_.push(std::move(socket));
        }
    }
};

6.3 COMPRESSION
---------------
// gzip compression
#include <boost/iostreams/filtering_stream.hpp>
#include <boost/iostreams/filter/gzip.hpp>

std::string compressResponse(const std::string& data) {
    namespace bio = boost::iostreams;

    std::stringstream compressed;
    bio::filtering_ostream out;
    out.push(bio::gzip_compressor());
    out.push(compressed);
    out << data;
    bio::close(out);

    return compressed.str();
}

Request:
GET /api/v1/positions HTTP/1.1
Accept-Encoding: gzip

Response:
HTTP/1.1 200 OK
Content-Encoding: gzip
Content-Length: 512

[compressed data]

6.4 BENCHMARK RESULTS
---------------------
Hardware: Intel Xeon E5-2690 v4
Network: Localhost

Operation              Latency    Throughput
GET /positions         2.5ms      400 req/s
POST /orders           8.2ms      122 req/s
GET /quote (cached)    0.8ms      1,250 req/s
GET /quote (uncached)  4.5ms      222 req/s
Batch orders (10)      15ms       67 batches/s

With optimizations:
Connection pooling:    -30% latency
Response caching:      -60% latency (cache hit)
gzip compression:      -70% bandwidth
Keep-alive:            -20% latency

================================================================================
7. REAL-WORLD EXAMPLES
================================================================================

7.1 ALPACA API
--------------
// Get account
GET https://paper-api.alpaca.markets/v2/account
Headers:
  APCA-API-KEY-ID: {your-key}
  APCA-API-SECRET-KEY: {your-secret}

// Submit order
POST https://paper-api.alpaca.markets/v2/orders
{
  "symbol": "AAPL",
  "qty": 1,
  "side": "buy",
  "type": "market",
  "time_in_force": "day"
}

// Get positions
GET https://paper-api.alpaca.markets/v2/positions

7.2 INTERACTIVE BROKERS
-----------------------
// Authenticate
POST /v1/api/iserver/auth/ssodh/init

// Get portfolio
GET /v1/api/portfolio/{accountId}/positions/0

// Place order
POST /v1/api/iserver/account/{accountId}/orders
{
  "conid": 265598,
  "orderType": "LMT",
  "price": 150.50,
  "side": "BUY",
  "quantity": 100,
  "tif": "DAY"
}

7.3 COINBASE PRO
----------------
// Get accounts
GET https://api.pro.coinbase.com/accounts
Headers:
  CB-ACCESS-KEY: {key}
  CB-ACCESS-SIGN: {signature}
  CB-ACCESS-TIMESTAMP: {timestamp}
  CB-ACCESS-PASSPHRASE: {passphrase}

// Place order
POST https://api.pro.coinbase.com/orders
{
  "product_id": "BTC-USD",
  "side": "buy",
  "type": "limit",
  "price": "50000.00",
  "size": "0.01"
}

================================================================================
8. ERROR HANDLING
================================================================================

8.1 ERROR RESPONSE FORMAT
--------------------------
{
  "error": {
    "code": "INSUFFICIENT_BALANCE",
    "message": "Insufficient balance to place order",
    "details": {
      "required": 15050.00,
      "available": 10000.00
    },
    "timestamp": "2025-01-26T10:30:00.000Z",
    "requestId": "req-12345"
  }
}

8.2 VALIDATION ERRORS
----------------------
HTTP/1.1 422 Unprocessable Entity

{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Request validation failed",
    "fields": [
      {
        "field": "quantity",
        "error": "Must be greater than 0"
      },
      {
        "field": "price",
        "error": "Must be a positive number"
      }
    ]
  }
}

8.3 RETRY STRATEGY
------------------
class RetryClient {
private:
    RestClient client_;
    const int max_retries_ = 3;
    const int base_delay_ms_ = 100;

public:
    json getWithRetry(const std::string& target) {
        for (int attempt = 0; attempt < max_retries_; ++attempt) {
            try {
                return client_.get(target);
            } catch (const std::exception& e) {
                if (attempt == max_retries_ - 1) throw;

                // Exponential backoff
                int delay = base_delay_ms_ * (1 << attempt);
                std::this_thread::sleep_for(std::chrono::milliseconds(delay));
            }
        }

        throw std::runtime_error("Max retries exceeded");
    }
};

================================================================================
END OF REST API DOCUMENTATION
================================================================================
