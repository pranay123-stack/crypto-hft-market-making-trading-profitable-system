================================================================================
                   PROTOCOL TESTING DOCUMENTATION
              Protocol Conformance Testing and Validation
                   Testing Strategies for Trading Protocols
================================================================================

TABLE OF CONTENTS
================================================================================
1. Overview
2. Unit Testing
3. Integration Testing
4. Conformance Testing
5. Performance Testing
6. Fuzz Testing
7. Real-World Testing
8. Continuous Testing

================================================================================
1. OVERVIEW
================================================================================

1.1 TESTING OBJECTIVES
----------------------
Goals:
- Correctness: Protocol implementation matches specification
- Interoperability: Works with other implementations
- Performance: Meets latency/throughput requirements
- Reliability: Handles errors gracefully
- Security: Resistant to attacks

Testing Pyramid:
    /\
   /  \        E2E Tests (5%)
  /____\
 /      \      Integration Tests (15%)
/__________\   Unit Tests (80%)

Testing Types:
1. Unit Tests: Individual components
2. Integration Tests: Component interaction
3. Conformance Tests: Protocol compliance
4. Performance Tests: Latency/throughput
5. Fuzz Tests: Random/invalid input
6. Security Tests: Attack resistance
7. Stress Tests: High load scenarios

1.2 TEST FRAMEWORKS
-------------------
C++ Testing Frameworks:
- Google Test (gtest): Most popular
- Catch2: Header-only, BDD-style
- Boost.Test: Part of Boost
- doctest: Fast, lightweight

Performance Testing:
- Google Benchmark: Micro-benchmarks
- Catch2 Benchmark: Integrated
- Custom timing: rdtsc-based

Mock Frameworks:
- Google Mock (gmock): With gtest
- FakeIt: Header-only
- Trompeloeil: Modern C++

1.3 TEST ENVIRONMENT SETUP
---------------------------
#include <gtest/gtest.h>
#include <gmock/gmock.h>

// Test fixture
class ProtocolTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Initialize test environment
    }

    void TearDown() override {
        // Cleanup
    }

    // Helper functions
    void createTestMessage(uint8_t* buffer, size_t& size) {
        // Create valid test message
    }
};

// Test case
TEST_F(ProtocolTest, DecodeValidMessage) {
    uint8_t buffer[256];
    size_t size;

    createTestMessage(buffer, size);

    Message msg;
    ASSERT_TRUE(decoder.decode(buffer, size, msg));
    EXPECT_EQ(msg.type, MessageType::NewOrder);
}

================================================================================
2. UNIT TESTING
================================================================================

2.1 MESSAGE ENCODING TESTS
---------------------------
#include "protocol.h"
#include <gtest/gtest.h>

class MessageEncoderTest : public ::testing::Test {
protected:
    BinaryMessageEncoder encoder;
    uint8_t buffer[4096];
};

TEST_F(MessageEncoderTest, EncodeNewOrder) {
    Order order;
    order.cl_ord_id = 123456;
    order.symbol = "AAPL";
    order.side = 1;  // Buy
    order.quantity = 100;
    order.price = 150.50;

    size_t size;
    const uint8_t* encoded = encoder.encodeNewOrder(order, size);

    ASSERT_NE(encoded, nullptr);
    ASSERT_GT(size, 0);

    // Verify header
    const MessageHeader* header =
        reinterpret_cast<const MessageHeader*>(encoded);

    EXPECT_EQ(header->magic, 0xABCD);
    EXPECT_EQ(header->version, 1);
    EXPECT_EQ(header->message_type, 0x0001);
    EXPECT_EQ(header->message_length, size);

    // Verify order fields
    const NewOrderMessage* msg =
        reinterpret_cast<const NewOrderMessage*>(encoded);

    EXPECT_EQ(msg->cl_ord_id, 123456);
    EXPECT_EQ(msg->side, 1);
    EXPECT_EQ(msg->quantity, 100);
    EXPECT_EQ(msg->price, 1505000);  // Fixed-point
}

TEST_F(MessageEncoderTest, EncodeMultipleMessages) {
    Order order1, order2, order3;
    // Initialize orders...

    size_t size1, size2, size3;
    encoder.encodeNewOrder(order1, size1);
    encoder.encodeNewOrder(order2, size2);
    encoder.encodeNewOrder(order3, size3);

    // Verify sequence numbers
    const MessageHeader* h1 =
        reinterpret_cast<const MessageHeader*>(buffer);
    // Check seq_num increments...
}

TEST_F(MessageEncoderTest, EncodeInvalidOrder) {
    Order order;
    order.cl_ord_id = 0;  // Invalid
    order.quantity = 0;   // Invalid

    size_t size;
    const uint8_t* encoded = encoder.encodeNewOrder(order, size);

    // Should encode but validation should fail later
    ASSERT_NE(encoded, nullptr);
}

2.2 MESSAGE DECODING TESTS
---------------------------
class MessageDecoderTest : public ::testing::Test {
protected:
    BinaryMessageDecoder decoder;

    void createValidMessage(uint8_t* buffer, size_t& size) {
        NewOrderMessage* msg =
            reinterpret_cast<NewOrderMessage*>(buffer);

        msg->header.magic = 0xABCD;
        msg->header.version = 1;
        msg->header.message_type = 0x0001;
        msg->header.message_length = sizeof(NewOrderMessage);
        msg->header.sequence_num = 1;
        msg->header.timestamp = 1234567890;

        msg->cl_ord_id = 123456;
        msg->symbol_id = 1;
        msg->side = 1;
        msg->quantity = 100;
        msg->price = 1505000;

        size = sizeof(NewOrderMessage);
    }
};

TEST_F(MessageDecoderTest, DecodeValidNewOrder) {
    uint8_t buffer[256];
    size_t size;

    createValidMessage(buffer, size);

    Order order;
    MessageType type;

    ASSERT_TRUE(decoder.decodeMessage(buffer, size, type, &order));
    EXPECT_EQ(type, MessageType::NewOrder);
    EXPECT_EQ(order.cl_ord_id, 123456);
    EXPECT_EQ(order.side, 1);
    EXPECT_EQ(order.quantity, 100);
    EXPECT_DOUBLE_EQ(order.price, 150.50);
}

TEST_F(MessageDecoderTest, DecodeInvalidMagic) {
    uint8_t buffer[256];
    size_t size;

    createValidMessage(buffer, size);

    MessageHeader* header =
        reinterpret_cast<MessageHeader*>(buffer);
    header->magic = 0xDEAD;  // Invalid

    Order order;
    MessageType type;

    EXPECT_FALSE(decoder.decodeMessage(buffer, size, type, &order));
}

TEST_F(MessageDecoderTest, DecodeTruncatedMessage) {
    uint8_t buffer[256];
    size_t size;

    createValidMessage(buffer, size);

    // Truncate message
    size = sizeof(MessageHeader) - 1;

    Order order;
    MessageType type;

    EXPECT_FALSE(decoder.decodeMessage(buffer, size, type, &order));
}

TEST_F(MessageDecoderTest, DecodeLengthMismatch) {
    uint8_t buffer[256];
    size_t size;

    createValidMessage(buffer, size);

    MessageHeader* header =
        reinterpret_cast<MessageHeader*>(buffer);
    header->message_length = 999;  // Wrong length

    Order order;
    MessageType type;

    EXPECT_FALSE(decoder.decodeMessage(buffer, size, type, &order));
}

2.3 PARAMETERIZED TESTS
------------------------
class MessageRoundTripTest :
    public ::testing::TestWithParam<Order> {
protected:
    BinaryMessageEncoder encoder;
    BinaryMessageDecoder decoder;
};

TEST_P(MessageRoundTripTest, EncodeDecodeRoundTrip) {
    Order original = GetParam();

    // Encode
    size_t size;
    const uint8_t* encoded = encoder.encodeNewOrder(original, size);
    ASSERT_NE(encoded, nullptr);

    // Decode
    Order decoded;
    MessageType type;
    ASSERT_TRUE(decoder.decodeMessage(encoded, size, type, &decoded));

    // Compare
    EXPECT_EQ(decoded.cl_ord_id, original.cl_ord_id);
    EXPECT_EQ(decoded.symbol, original.symbol);
    EXPECT_EQ(decoded.side, original.side);
    EXPECT_EQ(decoded.quantity, original.quantity);
    EXPECT_DOUBLE_EQ(decoded.price, original.price);
}

INSTANTIATE_TEST_SUITE_P(
    OrderVariations,
    MessageRoundTripTest,
    ::testing::Values(
        Order{123, "AAPL", 1, 100, 150.50},
        Order{456, "MSFT", 2, 50, 380.00},
        Order{789, "GOOGL", 1, 10, 2800.00},
        Order{999, "TSLA", 2, 200, 250.00}
    )
);

2.4 MOCK OBJECTS
----------------
using ::testing::Return;
using ::testing::_;

class MockNetworkInterface {
public:
    MOCK_METHOD(ssize_t, send, (const void* data, size_t length), ());
    MOCK_METHOD(ssize_t, receive, (void* buffer, size_t size), ());
};

TEST(ProtocolSenderTest, SendMessage) {
    MockNetworkInterface network;
    ProtocolSender sender(&network);

    Order order;
    order.cl_ord_id = 123;
    order.quantity = 100;

    // Expect send to be called with correct size
    EXPECT_CALL(network, send(_, sizeof(NewOrderMessage)))
        .Times(1)
        .WillOnce(Return(sizeof(NewOrderMessage)));

    ASSERT_TRUE(sender.sendOrder(order));
}

================================================================================
3. INTEGRATION TESTING
================================================================================

3.1 END-TO-END MESSAGE FLOW
----------------------------
class IntegrationTest : public ::testing::Test {
protected:
    NetworkServer server;
    NetworkClient client;
    const int TEST_PORT = 12345;

    void SetUp() override {
        // Start server
        server.start(TEST_PORT);

        // Connect client
        client.connect("localhost", TEST_PORT);
    }

    void TearDown() override {
        client.disconnect();
        server.stop();
    }
};

TEST_F(IntegrationTest, SendReceiveOrder) {
    // Client sends order
    Order order;
    order.cl_ord_id = 123;
    order.symbol = "AAPL";
    order.quantity = 100;

    ASSERT_TRUE(client.sendOrder(order));

    // Server receives order
    Order received;
    ASSERT_TRUE(server.receiveOrder(received, 1000));  // 1s timeout

    // Verify
    EXPECT_EQ(received.cl_ord_id, order.cl_ord_id);
    EXPECT_EQ(received.symbol, order.symbol);
    EXPECT_EQ(received.quantity, order.quantity);

    // Server sends execution report
    Execution exec;
    exec.order_id = 789;
    exec.cl_ord_id = 123;
    exec.exec_type = ExecType::Fill;

    ASSERT_TRUE(server.sendExecution(exec));

    // Client receives execution
    Execution received_exec;
    ASSERT_TRUE(client.receiveExecution(received_exec, 1000));

    // Verify
    EXPECT_EQ(received_exec.order_id, exec.order_id);
    EXPECT_EQ(received_exec.cl_ord_id, exec.cl_ord_id);
    EXPECT_EQ(received_exec.exec_type, exec.exec_type);
}

TEST_F(IntegrationTest, MultipleClients) {
    NetworkClient client2, client3;

    ASSERT_TRUE(client2.connect("localhost", TEST_PORT));
    ASSERT_TRUE(client3.connect("localhost", TEST_PORT));

    // Each client sends order
    Order order1, order2, order3;
    order1.cl_ord_id = 1;
    order2.cl_ord_id = 2;
    order3.cl_ord_id = 3;

    ASSERT_TRUE(client.sendOrder(order1));
    ASSERT_TRUE(client2.sendOrder(order2));
    ASSERT_TRUE(client3.sendOrder(order3));

    // Server receives all orders
    Order received1, received2, received3;
    ASSERT_TRUE(server.receiveOrder(received1, 1000));
    ASSERT_TRUE(server.receiveOrder(received2, 1000));
    ASSERT_TRUE(server.receiveOrder(received3, 1000));

    // Verify (order may not match due to concurrency)
    std::set<uint64_t> received_ids = {
        received1.cl_ord_id,
        received2.cl_ord_id,
        received3.cl_ord_id
    };

    EXPECT_EQ(received_ids.count(1), 1);
    EXPECT_EQ(received_ids.count(2), 1);
    EXPECT_EQ(received_ids.count(3), 1);

    client2.disconnect();
    client3.disconnect();
}

3.2 ERROR HANDLING TESTS
-------------------------
TEST_F(IntegrationTest, NetworkDisconnect) {
    // Send order
    Order order;
    order.cl_ord_id = 123;

    ASSERT_TRUE(client.sendOrder(order));

    // Disconnect
    server.stop();

    // Try to send another order
    Order order2;
    order2.cl_ord_id = 456;

    EXPECT_FALSE(client.sendOrder(order2));

    // Verify error handling
    EXPECT_EQ(client.getLastError(), ErrorCode::ConnectionLost);
}

TEST_F(IntegrationTest, SequenceGap) {
    // Send messages with sequence gap
    Order order1, order2;
    order1.cl_ord_id = 1;
    order2.cl_ord_id = 3;  // Gap: missing seq 2

    ASSERT_TRUE(client.sendOrder(order1));

    // Artificially skip sequence number
    client.setNextSequence(3);

    ASSERT_TRUE(client.sendOrder(order2));

    // Server detects gap
    Order received1, received2;
    ASSERT_TRUE(server.receiveOrder(received1, 1000));

    // Server should request resend
    ASSERT_TRUE(server.hasGapDetected());

    // Server sends resend request
    ResendRequest req = server.getResendRequest();
    EXPECT_EQ(req.start_seq, 2);
    EXPECT_EQ(req.end_seq, 2);
}

================================================================================
4. CONFORMANCE TESTING
================================================================================

4.1 FIX CONFORMANCE
-------------------
class FIXConformanceTest : public ::testing::Test {
protected:
    FIXParser parser;
    FIXBuilder builder;
};

TEST_F(FIXConformanceTest, ValidLogonMessage) {
    // Build FIX logon
    builder.beginMessage("A", "SENDER", "TARGET");
    builder.addField(98, 0);   // EncryptMethod
    builder.addField(108, 30); // HeartBtInt

    size_t size = builder.finalize();
    const char* message = builder.data();

    // Parse
    FIXMessage parsed;
    ASSERT_TRUE(parsed.parse(message, size));

    // Verify required fields
    EXPECT_TRUE(parsed.hasField(8));   // BeginString
    EXPECT_TRUE(parsed.hasField(9));   // BodyLength
    EXPECT_TRUE(parsed.hasField(35));  // MsgType
    EXPECT_TRUE(parsed.hasField(49));  // SenderCompID
    EXPECT_TRUE(parsed.hasField(56));  // TargetCompID
    EXPECT_TRUE(parsed.hasField(34));  // MsgSeqNum
    EXPECT_TRUE(parsed.hasField(52));  // SendingTime
    EXPECT_TRUE(parsed.hasField(10));  // CheckSum

    // Verify message type
    EXPECT_EQ(parsed.getMsgType(), 'A');

    // Verify field values
    std::string sender, target;
    ASSERT_TRUE(parsed.getField(49, sender));
    ASSERT_TRUE(parsed.getField(56, target));

    EXPECT_EQ(sender, "SENDER");
    EXPECT_EQ(target, "TARGET");

    int64_t heartbeat;
    ASSERT_TRUE(parsed.getFieldInt(108, heartbeat));
    EXPECT_EQ(heartbeat, 30);
}

TEST_F(FIXConformanceTest, ChecksumValidation) {
    builder.beginMessage("0", "SENDER", "TARGET");
    size_t size = builder.finalize();
    const char* message = builder.data();

    // Parse
    FIXMessage parsed;
    ASSERT_TRUE(parsed.parse(message, size));

    // Manually corrupt checksum
    char corrupted[1024];
    memcpy(corrupted, message, size);

    // Find checksum field
    char* checksum = strstr(corrupted, "\x01" "10=");
    ASSERT_NE(checksum, nullptr);

    // Corrupt it
    checksum[4] = '0';
    checksum[5] = '0';
    checksum[6] = '0';

    // Should fail validation
    FIXMessage corrupted_msg;
    EXPECT_FALSE(corrupted_msg.parse(corrupted, size));
}

4.2 SBE CONFORMANCE
-------------------
TEST(SBEConformanceTest, SchemaVersion) {
    uint8_t buffer[256];

    MessageHeader* header =
        reinterpret_cast<MessageHeader*>(buffer);

    header->blockLength = 100;
    header->templateId = 1;
    header->schemaId = 1;
    header->version = 0;

    // Decoder should accept version 0
    NewOrderSingle order;
    ASSERT_NO_THROW(
        order.wrapForDecode(reinterpret_cast<char*>(buffer),
                          8, 100, 0, 256)
    );

    // Decoder should reject unknown version
    header->version = 999;

    ASSERT_THROW(
        order.wrapForDecode(reinterpret_cast<char*>(buffer),
                          8, 100, 999, 256),
        std::runtime_error
    );
}

TEST(SBEConformanceTest, FieldAlignment) {
    // Verify field alignment
    EXPECT_EQ(offsetof(NewOrderMessage, cl_ord_id) % 8, 0);
    EXPECT_EQ(offsetof(NewOrderMessage, price) % 8, 0);

    // Verify structure size
    EXPECT_EQ(sizeof(NewOrderMessage) % 8, 0);
}

4.3 FAST CONFORMANCE
--------------------
TEST(FASTConformanceTest, PresenceMapEncoding) {
    std::vector<bool> pmap = {true, false, true, true, false};

    uint8_t buffer[16];
    FASTEncoder encoder;

    size_t written = encoder.writePresenceMap(pmap, buffer);

    ASSERT_GT(written, 0);

    // Decode
    FASTDecoder decoder;
    std::vector<bool> decoded_pmap;

    ASSERT_TRUE(decoder.readPresenceMap(buffer, decoded_pmap));

    EXPECT_EQ(decoded_pmap.size(), pmap.size());

    for (size_t i = 0; i < pmap.size(); ++i) {
        EXPECT_EQ(decoded_pmap[i], pmap[i]);
    }
}

TEST(FASTConformanceTest, DeltaEncoding) {
    FASTEncoder encoder;
    FASTDecoder decoder;

    TemplateDef tmpl;
    FieldDef field;
    field.type = FieldType::DECIMAL;
    field.op = OperatorType::DELTA;
    tmpl.fields.push_back(field);

    encoder.addTemplate(tmpl);
    decoder.addTemplate(tmpl);

    // Encode sequence of prices
    double prices[] = {100.50, 100.52, 100.48, 100.51};

    for (double price : prices) {
        std::unordered_map<uint32_t, std::string> fields;
        fields[1] = std::to_string(price);

        size_t size = encoder.encode(1, fields);
        ASSERT_GT(size, 0);

        // Decode
        uint32_t template_id;
        std::unordered_map<uint32_t, std::string> decoded;

        ASSERT_TRUE(decoder.decode(encoder.data(), size,
                                  template_id, decoded));

        double decoded_price = std::stod(decoded[1]);
        EXPECT_DOUBLE_EQ(decoded_price, price);
    }
}

================================================================================
5. PERFORMANCE TESTING
================================================================================

5.1 LATENCY BENCHMARKS
----------------------
#include <benchmark/benchmark.h>

static void BM_EncodeNewOrder(benchmark::State& state) {
    BinaryMessageEncoder encoder;
    Order order;
    order.cl_ord_id = 123;
    order.quantity = 100;
    order.price = 150.50;

    for (auto _ : state) {
        size_t size;
        const uint8_t* encoded = encoder.encodeNewOrder(order, size);
        benchmark::DoNotOptimize(encoded);
        benchmark::ClobberMemory();
    }

    state.SetItemsProcessed(state.iterations());
}

BENCHMARK(BM_EncodeNewOrder);

static void BM_DecodeNewOrder(benchmark::State& state) {
    BinaryMessageEncoder encoder;
    BinaryMessageDecoder decoder;

    Order order;
    order.cl_ord_id = 123;
    order.quantity = 100;

    size_t size;
    const uint8_t* encoded = encoder.encodeNewOrder(order, size);

    for (auto _ : state) {
        Order decoded;
        MessageType type;
        bool result = decoder.decodeMessage(encoded, size, type, &decoded);
        benchmark::DoNotOptimize(result);
        benchmark::ClobberMemory();
    }

    state.SetItemsProcessed(state.iterations());
}

BENCHMARK(BM_DecodeNewOrder);

static void BM_RoundTrip(benchmark::State& state) {
    BinaryMessageEncoder encoder;
    BinaryMessageDecoder decoder;

    Order order;
    order.cl_ord_id = 123;
    order.quantity = 100;

    for (auto _ : state) {
        size_t size;
        const uint8_t* encoded = encoder.encodeNewOrder(order, size);

        Order decoded;
        MessageType type;
        decoder.decodeMessage(encoded, size, type, &decoded);

        benchmark::DoNotOptimize(decoded);
        benchmark::ClobberMemory();
    }

    state.SetItemsProcessed(state.iterations());
}

BENCHMARK(BM_RoundTrip);

// Run benchmarks
int main(int argc, char** argv) {
    benchmark::Initialize(&argc, argv);
    benchmark::RunSpecifiedBenchmarks();
    return 0;
}

Results:
------------------------------------------------------------
Benchmark                     Time        CPU   Iterations
------------------------------------------------------------
BM_EncodeNewOrder            32 ns       32 ns   21875000
BM_DecodeNewOrder            28 ns       28 ns   25000000
BM_RoundTrip                 58 ns       58 ns   12031250

5.2 THROUGHPUT BENCHMARKS
--------------------------
void benchmarkThroughput() {
    const size_t MESSAGE_COUNT = 1000000;

    BinaryMessageEncoder encoder;
    Order order;
    order.cl_ord_id = 123;
    order.quantity = 100;

    auto start = std::chrono::high_resolution_clock::now();

    for (size_t i = 0; i < MESSAGE_COUNT; ++i) {
        size_t size;
        encoder.encodeNewOrder(order, size);
    }

    auto end = std::chrono::high_resolution_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
        end - start).count();

    double messages_per_second = MESSAGE_COUNT * 1000000.0 / duration;

    std::cout << "Throughput: " << messages_per_second / 1000000.0
             << " M msg/s" << std::endl;
}

Results:
Throughput: 31.25 M msg/s (32ns per message)

5.3 MEMORY BENCHMARKS
----------------------
TEST(MemoryTest, NoMemoryLeaks) {
    const size_t ITERATIONS = 10000;

    size_t initial_mem = getCurrentMemoryUsage();

    for (size_t i = 0; i < ITERATIONS; ++i) {
        BinaryMessageEncoder encoder;
        Order order;
        order.cl_ord_id = i;

        size_t size;
        encoder.encodeNewOrder(order, size);
    }

    size_t final_mem = getCurrentMemoryUsage();

    // Memory usage should not increase significantly
    EXPECT_LT(final_mem - initial_mem, 1024 * 1024);  // < 1 MB
}

TEST(MemoryTest, ObjectPoolEfficiency) {
    ObjectPool<Order, 1024> pool;

    // Acquire all objects
    std::vector<Order*> orders;
    for (size_t i = 0; i < 1024; ++i) {
        orders.push_back(pool.acquire());
    }

    EXPECT_EQ(pool.available(), 0);

    // Release all
    for (auto order : orders) {
        pool.release(order);
    }

    EXPECT_EQ(pool.available(), 1024);

    // Memory should not grow
    size_t initial_mem = getCurrentMemoryUsage();

    for (size_t i = 0; i < 10000; ++i) {
        Order* order = pool.acquire();
        // Use order...
        pool.release(order);
    }

    size_t final_mem = getCurrentMemoryUsage();

    EXPECT_LT(final_mem - initial_mem, 4096);  // < 4 KB
}

================================================================================
6. FUZZ TESTING
================================================================================

6.1 RANDOM INPUT TESTING
-------------------------
#include <random>

TEST(FuzzTest, RandomBinaryInput) {
    BinaryMessageDecoder decoder;

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 255);

    const size_t ITERATIONS = 10000;

    for (size_t i = 0; i < ITERATIONS; ++i) {
        uint8_t buffer[256];
        size_t size = dis(gen) % 256;

        // Fill with random bytes
        for (size_t j = 0; j < size; ++j) {
            buffer[j] = dis(gen);
        }

        // Decoder should not crash
        Order order;
        MessageType type;
        decoder.decodeMessage(buffer, size, type, &order);
    }
}

TEST(FuzzTest, BoundaryConditions) {
    BinaryMessageDecoder decoder;

    // Zero-length message
    {
        uint8_t buffer[1];
        Order order;
        MessageType type;
        EXPECT_FALSE(decoder.decodeMessage(buffer, 0, type, &order));
    }

    // Maximum-length message
    {
        uint8_t buffer[65536];
        memset(buffer, 0xFF, sizeof(buffer));

        Order order;
        MessageType type;
        decoder.decodeMessage(buffer, sizeof(buffer), type, &order);
    }

    // Null pointer
    {
        Order order;
        MessageType type;
        EXPECT_FALSE(decoder.decodeMessage(nullptr, 100, type, &order));
    }
}

6.2 LIBFUZZER INTEGRATION
--------------------------
// Compile with: clang++ -fsanitize=fuzzer,address

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
    BinaryMessageDecoder decoder;

    Order order;
    MessageType type;

    // Decoder should handle any input without crashing
    decoder.decodeMessage(data, size, type, &order);

    return 0;
}

// Run:
// $ ./fuzzer -max_len=4096 -runs=1000000

6.3 SANITIZERS
--------------
// Compile with sanitizers:
// -fsanitize=address      (AddressSanitizer)
// -fsanitize=thread       (ThreadSanitizer)
// -fsanitize=undefined    (UndefinedBehaviorSanitizer)
// -fsanitize=memory       (MemorySanitizer)

TEST(SanitizerTest, BufferOverflow) {
    uint8_t buffer[10];

    // Should be caught by AddressSanitizer
    // buffer[100] = 0;  // Uncomment to test

    SUCCEED();
}

TEST(SanitizerTest, UseAfterFree) {
    Order* order = new Order();
    delete order;

    // Should be caught by AddressSanitizer
    // order->cl_ord_id = 123;  // Uncomment to test

    SUCCEED();
}

================================================================================
7. REAL-WORLD TESTING
================================================================================

7.1 EXCHANGE CONNECTIVITY
--------------------------
class ExchangeTest : public ::testing::Test {
protected:
    // Test with actual exchange test environment
    ExchangeClient client;

    void SetUp() override {
        // Connect to exchange test environment
        client.connect("test.exchange.com", 12345,
                      "test_cert.pem", "test_key.pem");
    }
};

TEST_F(ExchangeTest, Logon) {
    ASSERT_TRUE(client.logon("TESTUSER", "TESTPASS"));
    EXPECT_TRUE(client.isLoggedIn());
}

TEST_F(ExchangeTest, SubmitOrder) {
    ASSERT_TRUE(client.logon("TESTUSER", "TESTPASS"));

    Order order;
    order.cl_ord_id = 123456;
    order.symbol = "TESTSTOCK";
    order.side = Side::Buy;
    order.quantity = 100;
    order.price = 50.00;
    order.order_type = OrderType::Limit;

    std::string order_id;
    ASSERT_TRUE(client.submitOrder(order, order_id));

    // Wait for execution report
    Execution exec;
    ASSERT_TRUE(client.waitForExecution(exec, 5000));

    EXPECT_EQ(exec.cl_ord_id, order.cl_ord_id);
    EXPECT_EQ(exec.exec_type, ExecType::New);
}

TEST_F(ExchangeTest, CancelOrder) {
    // Submit order
    Order order;
    std::string order_id;
    ASSERT_TRUE(client.submitOrder(order, order_id));

    // Cancel
    ASSERT_TRUE(client.cancelOrder(order_id));

    // Verify cancellation
    Execution exec;
    ASSERT_TRUE(client.waitForExecution(exec, 5000));
    EXPECT_EQ(exec.exec_type, ExecType::Canceled);
}

7.2 LOAD TESTING
----------------
TEST(LoadTest, HighVolumeOrders) {
    ExchangeClient client;
    client.connect("test.exchange.com", 12345);
    client.logon("TESTUSER", "TESTPASS");

    const size_t ORDER_COUNT = 10000;
    std::vector<std::string> order_ids;

    auto start = std::chrono::high_resolution_clock::now();

    for (size_t i = 0; i < ORDER_COUNT; ++i) {
        Order order;
        order.cl_ord_id = i + 1;
        order.symbol = "TESTSTOCK";
        order.quantity = 100;
        order.price = 50.00;

        std::string order_id;
        ASSERT_TRUE(client.submitOrder(order, order_id));
        order_ids.push_back(order_id);

        if ((i + 1) % 100 == 0) {
            std::cout << "Submitted " << (i + 1) << " orders\n";
        }
    }

    auto end = std::chrono::high_resolution_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
        end - start).count();

    double orders_per_second = ORDER_COUNT * 1000.0 / duration;

    std::cout << "Order submission rate: " << orders_per_second
             << " orders/sec" << std::endl;

    // Cancel all orders
    for (const auto& order_id : order_ids) {
        client.cancelOrder(order_id);
    }
}

7.3 STRESS TESTING
------------------
TEST(StressTest, ConnectionStability) {
    const size_t ITERATIONS = 1000;

    for (size_t i = 0; i < ITERATIONS; ++i) {
        ExchangeClient client;

        ASSERT_TRUE(client.connect("test.exchange.com", 12345));
        ASSERT_TRUE(client.logon("TESTUSER", "TESTPASS"));

        // Submit order
        Order order;
        std::string order_id;
        ASSERT_TRUE(client.submitOrder(order, order_id));

        // Disconnect
        client.disconnect();

        if ((i + 1) % 100 == 0) {
            std::cout << "Completed " << (i + 1) << " iterations\n";
        }
    }
}

================================================================================
8. CONTINUOUS TESTING
========