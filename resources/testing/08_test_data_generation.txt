================================================================================
TEST DATA GENERATION FOR HFT SYSTEMS
Market Data and Order Scenario Generation
================================================================================

TABLE OF CONTENTS
-----------------
1. Test Data Generation Overview
2. Market Data Generation
3. Order Scenario Generation
4. Historical Data Synthesis
5. Realistic Price Movements
6. Order Book Generation
7. Trade Sequence Generation
8. Edge Case Data Generation
9. Data Validation
10. Data Export and Storage

================================================================================
1. TEST DATA GENERATION OVERVIEW
================================================================================

1.1 Purpose of Test Data Generation
------------------------------------
Objectives:
- Create realistic market data for testing
- Generate diverse order scenarios
- Produce edge cases and stress scenarios
- Enable reproducible testing
- Support backtesting and simulation

Data Types:
- Market quotes (bid/ask)
- Trade ticks
- Order books (multi-level)
- Order sequences
- Fill reports
- Exchange messages


1.2 Test Data Generator Framework
----------------------------------
// include/testing/test_data_generator.h
#ifndef TEST_DATA_GENERATOR_H
#define TEST_DATA_GENERATOR_H

#include <vector>
#include <string>
#include <random>
#include "market_data.h"
#include "order.h"

class TestDataGenerator {
public:
    TestDataGenerator(unsigned int seed = 0);

    // Market data generation
    std::vector<Quote> generateQuotes(
        const std::string& symbol,
        size_t count,
        double initial_price = 150.0,
        double volatility = 0.01
    );

    std::vector<Trade> generateTrades(
        const std::string& symbol,
        size_t count,
        double initial_price = 150.0
    );

    std::vector<OrderBook> generateOrderBooks(
        const std::string& symbol,
        size_t count,
        int depth = 10
    );

    // Order generation
    std::vector<Order> generateRandomOrders(
        const std::vector<std::string>& symbols,
        size_t count
    );

    std::vector<Order> generateScenario(
        const std::string& scenario_name,
        const std::map<std::string, std::string>& parameters
    );

    // Price movement patterns
    std::vector<double> generateRandomWalk(
        double initial_price,
        size_t steps,
        double volatility
    );

    std::vector<double> generateTrendingPrices(
        double initial_price,
        size_t steps,
        double trend_rate,
        double volatility
    );

    std::vector<double> generateMeanRevertingPrices(
        double mean_price,
        size_t steps,
        double reversion_rate,
        double volatility
    );

    // Configuration
    void setSeed(unsigned int seed);
    void setPriceRange(double min, double max);
    void setQuantityRange(int min, int max);
    void setTimestampStart(system_clock::time_point start);

private:
    std::mt19937 rng_;
    std::uniform_real_distribution<> price_dist_{100.0, 200.0};
    std::uniform_int_distribution<> quantity_dist_{100, 10000};
    std::normal_distribution<> volatility_dist_{0.0, 0.01};

    system_clock::time_point timestamp_start_;
    microseconds timestamp_increment_{1000};  // 1ms between ticks
};

#endif // TEST_DATA_GENERATOR_H


================================================================================
2. MARKET DATA GENERATION
================================================================================

2.1 Quote Generation
--------------------
// src/testing/test_data_generator.cpp
#include "test_data_generator.h"

TestDataGenerator::TestDataGenerator(unsigned int seed)
    : timestamp_start_(system_clock::now()) {

    if (seed == 0) {
        std::random_device rd;
        rng_.seed(rd());
    } else {
        rng_.seed(seed);
    }
}

std::vector<Quote> TestDataGenerator::generateQuotes(
    const std::string& symbol,
    size_t count,
    double initial_price,
    double volatility
) {
    std::vector<Quote> quotes;
    quotes.reserve(count);

    double current_price = initial_price;
    auto current_time = timestamp_start_;

    std::normal_distribution<> price_change(0.0, volatility);
    std::uniform_int_distribution<> size_dist(100, 10000);
    std::uniform_real_distribution<> spread_dist(0.01, 0.10);

    for (size_t i = 0; i < count; ++i) {
        // Random walk price movement
        current_price += price_change(rng_);
        current_price = std::max(0.01, current_price);  // Price > 0

        double spread = spread_dist(rng_);

        Quote quote;
        quote.symbol = symbol;
        quote.timestamp = current_time;
        quote.bid_price = current_price - spread / 2.0;
        quote.ask_price = current_price + spread / 2.0;
        quote.bid_size = size_dist(rng_);
        quote.ask_size = size_dist(rng_);

        quotes.push_back(quote);

        current_time += timestamp_increment_;
    }

    return quotes;
}


2.2 Trade Generation
--------------------
std::vector<Trade> TestDataGenerator::generateTrades(
    const std::string& symbol,
    size_t count,
    double initial_price
) {
    std::vector<Trade> trades;
    trades.reserve(count);

    double current_price = initial_price;
    auto current_time = timestamp_start_;

    std::normal_distribution<> price_change(0.0, 0.005);
    std::uniform_int_distribution<> size_dist(10, 1000);
    std::uniform_int_distribution<> side_dist(0, 1);

    for (size_t i = 0; i < count; ++i) {
        current_price += price_change(rng_);
        current_price = std::max(0.01, current_price);

        Trade trade;
        trade.symbol = symbol;
        trade.timestamp = current_time;
        trade.price = current_price;
        trade.size = size_dist(rng_);
        trade.side = (side_dist(rng_) == 0) ? TradeSide::BUY : TradeSide::SELL;
        trade.trade_id = i + 1;

        trades.push_back(trade);

        // Random inter-arrival time
        std::exponential_distribution<> arrival_dist(1000.0);  // Avg 1ms
        auto delay = microseconds(static_cast<long>(arrival_dist(rng_)));
        current_time += delay;
    }

    return trades;
}


2.3 Order Book Generation
--------------------------
std::vector<OrderBook> TestDataGenerator::generateOrderBooks(
    const std::string& symbol,
    size_t count,
    int depth
) {
    std::vector<OrderBook> books;
    books.reserve(count);

    double current_mid = 150.0;
    auto current_time = timestamp_start_;

    std::normal_distribution<> price_change(0.0, 0.01);
    std::uniform_int_distribution<> size_dist(100, 5000);

    for (size_t i = 0; i < count; ++i) {
        current_mid += price_change(rng_);

        OrderBook book;
        book.symbol = symbol;
        book.timestamp = current_time;

        // Generate bid levels
        for (int level = 0; level < depth; ++level) {
            double price = current_mid - (level + 1) * 0.01;
            int size = size_dist(rng_);
            book.addBid(price, size);
        }

        // Generate ask levels
        for (int level = 0; level < depth; ++level) {
            double price = current_mid + (level + 1) * 0.01;
            int size = size_dist(rng_);
            book.addAsk(price, size);
        }

        books.push_back(book);
        current_time += timestamp_increment_;
    }

    return books;
}


================================================================================
3. ORDER SCENARIO GENERATION
================================================================================

3.1 Random Order Generation
----------------------------
std::vector<Order> TestDataGenerator::generateRandomOrders(
    const std::vector<std::string>& symbols,
    size_t count
) {
    std::vector<Order> orders;
    orders.reserve(count);

    std::uniform_int_distribution<> symbol_dist(0, symbols.size() - 1);
    std::uniform_int_distribution<> side_dist(0, 1);
    std::uniform_int_distribution<> type_dist(0, 2);

    for (size_t i = 0; i < count; ++i) {
        Order order;
        order.order_id = i + 1;
        order.symbol = symbols[symbol_dist(rng_)];
        order.side = (side_dist(rng_) == 0) ? OrderSide::BUY : OrderSide::SELL;
        order.price = price_dist_(rng_);
        order.quantity = quantity_dist_(rng_);
        order.timestamp = timestamp_start_ + microseconds(i * 1000);

        // Order type
        int type = type_dist(rng_);
        if (type == 0) {
            order.order_type = OrderType::LIMIT;
        } else if (type == 1) {
            order.order_type = OrderType::MARKET;
        } else {
            order.order_type = OrderType::STOP;
            order.stop_price = order.price * 0.98;  // 2% below
        }

        orders.push_back(order);
    }

    return orders;
}


3.2 Scenario-Based Order Generation
------------------------------------
std::vector<Order> TestDataGenerator::generateScenario(
    const std::string& scenario_name,
    const std::map<std::string, std::string>& parameters
) {
    std::vector<Order> orders;

    if (scenario_name == "aggressive_buying") {
        return generateAggressiveBuyingScenario(parameters);
    } else if (scenario_name == "iceberg_orders") {
        return generateIcebergScenario(parameters);
    } else if (scenario_name == "market_making") {
        return generateMarketMakingScenario(parameters);
    } else if (scenario_name == "momentum_trading") {
        return generateMomentumScenario(parameters);
    } else if (scenario_name == "cancel_replace_cycle") {
        return generateCancelReplaceScenario(parameters);
    }

    return orders;
}

std::vector<Order> generateAggressiveBuyingScenario(
    const std::map<std::string, std::string>& params
) {
    std::vector<Order> orders;

    std::string symbol = params.at("symbol");
    double start_price = std::stod(params.at("start_price"));
    int total_quantity = std::stoi(params.at("total_quantity"));
    int num_orders = std::stoi(params.at("num_orders"));

    int qty_per_order = total_quantity / num_orders;

    for (int i = 0; i < num_orders; ++i) {
        Order order;
        order.order_id = i + 1;
        order.symbol = symbol;
        order.side = OrderSide::BUY;
        order.order_type = OrderType::LIMIT;
        order.price = start_price + i * 0.01;  // Walk up the book
        order.quantity = qty_per_order;
        order.timestamp = system_clock::now() + milliseconds(i * 100);

        orders.push_back(order);
    }

    return orders;
}

std::vector<Order> generateIcebergScenario(
    const std::map<std::string, std::string>& params
) {
    std::vector<Order> orders;

    std::string symbol = params.at("symbol");
    double price = std::stod(params.at("price"));
    int total_quantity = std::stoi(params.at("total_quantity"));
    int display_quantity = std::stoi(params.at("display_quantity"));

    Order iceberg_order;
    iceberg_order.order_id = 1;
    iceberg_order.symbol = symbol;
    iceberg_order.side = OrderSide::BUY;
    iceberg_order.price = price;
    iceberg_order.quantity = total_quantity;
    iceberg_order.display_quantity = display_quantity;
    iceberg_order.order_type = OrderType::ICEBERG;
    iceberg_order.timestamp = system_clock::now();

    orders.push_back(iceberg_order);

    return orders;
}

std::vector<Order> generateMarketMakingScenario(
    const std::map<std::string, std::string>& params
) {
    std::vector<Order> orders;

    std::string symbol = params.at("symbol");
    double mid_price = std::stod(params.at("mid_price"));
    int quantity = std::stoi(params.at("quantity"));
    double spread = std::stod(params.at("spread"));

    // Buy side
    Order buy_order;
    buy_order.order_id = 1;
    buy_order.symbol = symbol;
    buy_order.side = OrderSide::BUY;
    buy_order.price = mid_price - spread / 2.0;
    buy_order.quantity = quantity;
    buy_order.order_type = OrderType::LIMIT;
    buy_order.time_in_force = TimeInForce::GTC;
    orders.push_back(buy_order);

    // Sell side
    Order sell_order;
    sell_order.order_id = 2;
    sell_order.symbol = symbol;
    sell_order.side = OrderSide::SELL;
    sell_order.price = mid_price + spread / 2.0;
    sell_order.quantity = quantity;
    sell_order.order_type = OrderType::LIMIT;
    sell_order.time_in_force = TimeInForce::GTC;
    orders.push_back(sell_order);

    return orders;
}


================================================================================
4. HISTORICAL DATA SYNTHESIS
================================================================================

4.1 Synthetic Historical Data
------------------------------
class HistoricalDataSynthesizer {
public:
    struct MarketDay {
        system_clock::time_point date;
        double open;
        double high;
        double low;
        double close;
        uint64_t volume;
        std::vector<Quote> intraday_quotes;
        std::vector<Trade> intraday_trades;
    };

    MarketDay generateTradingDay(
        const std::string& symbol,
        const system_clock::time_point& date,
        double open_price
    ) {
        MarketDay day;
        day.date = date;
        day.open = open_price;

        // Market hours: 9:30 AM - 4:00 PM (6.5 hours)
        auto market_open = date + hours(9) + minutes(30);
        auto market_close = date + hours(16);

        double current_price = open_price;
        double high = open_price;
        double low = open_price;
        uint64_t total_volume = 0;

        auto current_time = market_open;

        std::mt19937 rng(std::random_device{}());
        std::normal_distribution<> price_change(0.0, 0.001);  // 0.1% volatility
        std::poisson_distribution<> trade_arrival(100);  // 100 trades per minute

        while (current_time < market_close) {
            // Generate quote
            Quote quote;
            quote.symbol = symbol;
            quote.timestamp = current_time;

            current_price += price_change(rng);
            current_price = std::max(0.01, current_price);

            quote.bid_price = current_price - 0.01;
            quote.ask_price = current_price + 0.01;
            quote.bid_size = 1000;
            quote.ask_size = 1000;

            day.intraday_quotes.push_back(quote);

            // Update high/low
            high = std::max(high, current_price);
            low = std::min(low, current_price);

            // Generate trades
            int num_trades = trade_arrival(rng);
            for (int i = 0; i < num_trades; ++i) {
                Trade trade;
                trade.symbol = symbol;
                trade.timestamp = current_time + microseconds(i * 600);  // Spread within minute
                trade.price = current_price;
                trade.size = 100;
                trade.side = (price_change(rng_) > 0) ? TradeSide::BUY : TradeSide::SELL;

                day.intraday_trades.push_back(trade);
                total_volume += trade.size;
            }

            current_time += minutes(1);
        }

        day.high = high;
        day.low = low;
        day.close = current_price;
        day.volume = total_volume;

        return day;
    }

    std::vector<MarketDay> generateHistoricalPeriod(
        const std::string& symbol,
        const system_clock::time_point& start_date,
        int num_trading_days,
        double initial_price
    ) {
        std::vector<MarketDay> history;

        double current_price = initial_price;
        auto current_date = start_date;

        for (int i = 0; i < num_trading_days; ++i) {
            // Skip weekends
            auto weekday = getWeekday(current_date);
            if (weekday == 6 || weekday == 0) {  // Saturday or Sunday
                current_date += hours(24);
                continue;
            }

            MarketDay day = generateTradingDay(symbol, current_date, current_price);
            history.push_back(day);

            current_price = day.close;
            current_date += hours(24);
        }

        return history;
    }
};


================================================================================
5. REALISTIC PRICE MOVEMENTS
================================================================================

5.1 Random Walk
---------------
std::vector<double> TestDataGenerator::generateRandomWalk(
    double initial_price,
    size_t steps,
    double volatility
) {
    std::vector<double> prices;
    prices.reserve(steps);

    double current_price = initial_price;
    std::normal_distribution<> change_dist(0.0, volatility);

    for (size_t i = 0; i < steps; ++i) {
        current_price += change_dist(rng_);
        current_price = std::max(0.01, current_price);
        prices.push_back(current_price);
    }

    return prices;
}


5.2 Trending Prices
-------------------
std::vector<double> TestDataGenerator::generateTrendingPrices(
    double initial_price,
    size_t steps,
    double trend_rate,
    double volatility
) {
    std::vector<double> prices;
    prices.reserve(steps);

    double current_price = initial_price;
    std::normal_distribution<> noise_dist(0.0, volatility);

    for (size_t i = 0; i < steps; ++i) {
        // Trend component + noise
        current_price += trend_rate + noise_dist(rng_);
        current_price = std::max(0.01, current_price);
        prices.push_back(current_price);
    }

    return prices;
}


5.3 Mean Reverting Prices
--------------------------
std::vector<double> TestDataGenerator::generateMeanRevertingPrices(
    double mean_price,
    size_t steps,
    double reversion_rate,
    double volatility
) {
    std::vector<double> prices;
    prices.reserve(steps);

    double current_price = mean_price;
    std::normal_distribution<> noise_dist(0.0, volatility);

    for (size_t i = 0; i < steps; ++i) {
        // Mean reversion: price moves toward mean
        double deviation = current_price - mean_price;
        current_price -= deviation * reversion_rate;
        current_price += noise_dist(rng_);
        current_price = std::max(0.01, current_price);
        prices.push_back(current_price);
    }

    return prices;
}


5.4 Jump Diffusion Process
---------------------------
std::vector<double> generateJumpDiffusionPrices(
    double initial_price,
    size_t steps,
    double volatility,
    double jump_intensity,  // Jumps per step
    double jump_size        // Average jump size
) {
    std::vector<double> prices;
    prices.reserve(steps);

    std::mt19937 rng(std::random_device{}());
    std::normal_distribution<> drift_dist(0.0, volatility);
    std::poisson_distribution<> jump_dist(jump_intensity);
    std::normal_distribution<> jump_size_dist(0.0, jump_size);

    double current_price = initial_price;

    for (size_t i = 0; i < steps; ++i) {
        // Regular drift
        current_price += drift_dist(rng);

        // Add jumps
        int num_jumps = jump_dist(rng);
        for (int j = 0; j < num_jumps; ++j) {
            current_price += jump_size_dist(rng);
        }

        current_price = std::max(0.01, current_price);
        prices.push_back(current_price);
    }

    return prices;
}


================================================================================
6. EDGE CASE DATA GENERATION
================================================================================

6.1 Extreme Value Generation
-----------------------------
class EdgeCaseDataGenerator {
public:
    // Extreme prices
    std::vector<Order> generateExtremePriceOrders() {
        std::vector<Order> orders;

        Order order;
        order.symbol = "TEST";
        order.side = OrderSide::BUY;
        order.quantity = 100;

        // Test cases
        std::vector<double> test_prices = {
            0.0001,          // Very small
            999999.99,       // Very large
            0.0,             // Zero (should be rejected)
            -100.0,          // Negative (should be rejected)
            INFINITY,        // Infinite (should be rejected)
            NAN              // NaN (should be rejected)
        };

        for (size_t i = 0; i < test_prices.size(); ++i) {
            order.order_id = i + 1;
            order.price = test_prices[i];
            orders.push_back(order);
        }

        return orders;
    }

    // Extreme quantities
    std::vector<Order> generateExtremeQuantityOrders() {
        std::vector<Order> orders;

        Order order;
        order.symbol = "TEST";
        order.side = OrderSide::BUY;
        order.price = 150.0;

        std::vector<int> test_quantities = {
            1,               // Minimum
            1000000000,      // Very large
            0,               // Zero (should be rejected)
            -100,            // Negative (should be rejected)
            INT_MAX          // Max int (overflow risk)
        };

        for (size_t i = 0; i < test_quantities.size(); ++i) {
            order.order_id = i + 1;
            order.quantity = test_quantities[i];
            orders.push_back(order);
        }

        return orders;
    }

    // Special characters in symbols
    std::vector<Order> generateSpecialSymbolOrders() {
        std::vector<std::string> test_symbols = {
            "AAPL",          // Normal
            "BRK.A",         // With dot
            "",              // Empty (should be rejected)
            "A",             // Single character
            "VERYLONGSYMBOLNAME",  // Very long
            "TEST\0HIDDEN",  // Null byte
            "日本株",         // Unicode
            "TEST\n\r\t"     // Control characters
        };

        std::vector<Order> orders;

        for (size_t i = 0; i < test_symbols.size(); ++i) {
            Order order;
            order.order_id = i + 1;
            order.symbol = test_symbols[i];
            order.side = OrderSide::BUY;
            order.price = 150.0;
            order.quantity = 100;
            orders.push_back(order);
        }

        return orders;
    }

    // Race condition scenarios
    std::vector<Order> generateRaceConditionOrders() {
        std::vector<Order> orders;

        uint64_t order_id = 12345;

        // Submit order
        Order submit_order;
        submit_order.order_id = order_id;
        submit_order.symbol = "AAPL";
        submit_order.side = OrderSide::BUY;
        submit_order.price = 150.0;
        submit_order.quantity = 100;
        orders.push_back(submit_order);

        // Simultaneous cancel and modify
        Order cancel_order;
        cancel_order.order_id = order_id;
        cancel_order.action = OrderAction::CANCEL;
        orders.push_back(cancel_order);

        Order modify_order;
        modify_order.order_id = order_id;
        modify_order.action = OrderAction::MODIFY;
        modify_order.price = 151.0;
        modify_order.quantity = 200;
        orders.push_back(modify_order);

        return orders;
    }
};


================================================================================
7. DATA VALIDATION
================================================================================

7.1 Data Quality Validator
---------------------------
class TestDataValidator {
public:
    struct ValidationResult {
        bool valid;
        std::vector<std::string> errors;
        std::vector<std::string> warnings;
    };

    ValidationResult validateQuotes(const std::vector<Quote>& quotes) {
        ValidationResult result;
        result.valid = true;

        for (size_t i = 0; i < quotes.size(); ++i) {
            const Quote& quote = quotes[i];

            // Check prices
            if (quote.bid_price <= 0 || quote.ask_price <= 0) {
                result.errors.push_back("Invalid price at index " + std::to_string(i));
                result.valid = false;
            }

            if (quote.ask_price <= quote.bid_price) {
                result.errors.push_back("Crossed market at index " + std::to_string(i));
                result.valid = false;
            }

            // Check sizes
            if (quote.bid_size <= 0 || quote.ask_size <= 0) {
                result.errors.push_back("Invalid size at index " + std::to_string(i));
                result.valid = false;
            }

            // Check timestamp ordering
            if (i > 0 && quote.timestamp < quotes[i-1].timestamp) {
                result.warnings.push_back("Out of order timestamp at index " + std::to_string(i));
            }

            // Check for unrealistic spreads
            double spread_pct = (quote.ask_price - quote.bid_price) / quote.bid_price;
            if (spread_pct > 0.10) {  // > 10%
                result.warnings.push_back("Large spread at index " + std::to_string(i));
            }
        }

        return result;
    }

    ValidationResult validateOrders(const std::vector<Order>& orders) {
        ValidationResult result;
        result.valid = true;

        for (size_t i = 0; i < orders.size(); ++i) {
            const Order& order = orders[i];

            if (order.symbol.empty()) {
                result.errors.push_back("Empty symbol at index " + std::to_string(i));
                result.valid = false;
            }

            if (order.quantity <= 0) {
                result.errors.push_back("Invalid quantity at index " + std::to_string(i));
                result.valid = false;
            }

            if (order.order_type == OrderType::LIMIT && order.price <= 0) {
                result.errors.push_back("Invalid limit price at index " + std::to_string(i));
                result.valid = false;
            }
        }

        return result;
    }
};


================================================================================
8. DATA EXPORT AND STORAGE
================================================================================

8.1 CSV Export
--------------
class TestDataExporter {
public:
    void exportQuotesToCSV(
        const std::vector<Quote>& quotes,
        const std::string& filename
    ) {
        std::ofstream file(filename);

        // Header
        file << "timestamp,symbol,bid_price,bid_size,ask_price,ask_size\n";

        // Data
        for (const auto& quote : quotes) {
            file << formatTimestamp(quote.timestamp) << ","
                 << quote.symbol << ","
                 << quote.bid_price << ","
                 << quote.bid_size << ","
                 << quote.ask_price << ","
                 << quote.ask_size << "\n";
        }

        std::cout << "Exported " << quotes.size() << " quotes to " << filename << std::endl;
    }

    void exportTradesToCSV(
        const std::vector<Trade>& trades,
        const std::string& filename
    ) {
        std::ofstream file(filename);

        file << "timestamp,symbol,price,size,side\n";

        for (const auto& trade : trades) {
            file << formatTimestamp(trade.timestamp) << ","
                 << trade.symbol << ","
                 << trade.price << ","
                 << trade.size << ","
                 << (trade.side == TradeSide::BUY ? "BUY" : "SELL") << "\n";
        }

        std::cout << "Exported " << trades.size() << " trades to " << filename << std::endl;
    }

    void exportOrdersToCSV(
        const std::vector<Order>& orders,
        const std::string& filename
    ) {
        std::ofstream file(filename);

        file << "order_id,timestamp,symbol,side,price,quantity,type\n";

        for (const auto& order : orders) {
            file << order.order_id << ","
                 << formatTimestamp(order.timestamp) << ","
                 << order.symbol << ","
                 << (order.side == OrderSide::BUY ? "BUY" : "SELL") << ","
                 << order.price << ","
                 << order.quantity << ","
                 << orderTypeToString(order.order_type) << "\n";
        }

        std::cout << "Exported " << orders.size() << " orders to " << filename << std::endl;
    }
};


8.2 Binary Format Export
-------------------------
void exportQuotesToBinary(
    const std::vector<Quote>& quotes,
    const std::string& filename
) {
    std::ofstream file(filename, std::ios::binary);

    // Write header
    uint64_t count = quotes.size();
    file.write(reinterpret_cast<const char*>(&count), sizeof(count));

    // Write quotes
    for (const auto& quote : quotes) {
        // Convert to binary struct for efficient storage
        BinaryQuote bq;
        bq.timestamp_ns = duration_cast<nanoseconds>(
            quote.timestamp.time_since_epoch()
        ).count();
        strncpy(bq.symbol, quote.symbol.c_str(), sizeof(bq.symbol));
        bq.bid_price = quote.bid_price;
        bq.ask_price = quote.ask_price;
        bq.bid_size = quote.bid_size;
        bq.ask_size = quote.ask_size;

        file.write(reinterpret_cast<const char*>(&bq), sizeof(bq));
    }
}


================================================================================
9. EXAMPLE USAGE
================================================================================

9.1 Generate Complete Test Dataset
-----------------------------------
int main() {
    TestDataGenerator generator(42);  // Fixed seed for reproducibility

    // Generate quotes
    std::vector<std::string> symbols = {"AAPL", "GOOGL", "MSFT"};

    for (const auto& symbol : symbols) {
        // Generate 1 million quotes
        auto quotes = generator.generateQuotes(symbol, 1000000, 150.0, 0.01);

        // Validate
        TestDataValidator validator;
        auto validation = validator.validateQuotes(quotes);

        if (!validation.valid) {
            std::cerr << "Validation failed!" << std::endl;
            for (const auto& error : validation.errors) {
                std::cerr << "  ERROR: " << error << std::endl;
            }
            continue;
        }

        // Export
        TestDataExporter exporter;
        exporter.exportQuotesToCSV(quotes, symbol + "_quotes.csv");
        exportQuotesToBinary(quotes, symbol + "_quotes.bin");

        std::cout << "Generated and exported data for " << symbol << std::endl;
    }

    // Generate order scenarios
    auto aggressive_orders = generator.generateScenario("aggressive_buying", {
        {"symbol", "AAPL"},
        {"start_price", "150.0"},
        {"total_quantity", "10000"},
        {"num_orders", "100"}
    });

    TestDataExporter exporter;
    exporter.exportOrdersToCSV(aggressive_orders, "aggressive_buying_scenario.csv");

    return 0;
}


================================================================================
END OF TEST DATA GENERATION
================================================================================
