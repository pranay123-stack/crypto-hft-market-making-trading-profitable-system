================================================================================
POST-TRADE RISK MONITORING - HFT RISK MANAGEMENT SYSTEM
================================================================================
Version: 2.1.0
Last Updated: 2025-11-25
Author: HFT Risk Management Team
Purpose: Real-time post-trade monitoring, reconciliation, and anomaly detection

================================================================================
1. POST-TRADE MONITORING FRAMEWORK
================================================================================

1.1 Overview and Objectives
----------------------------

Post-trade risk monitoring provides continuous surveillance of:

1. Trade Execution Quality
   - Fill prices vs expected prices
   - Slippage analysis
   - Market impact assessment
   - Execution venue performance

2. Position Reconciliation
   - Real-time position tracking
   - Trade vs order book reconciliation
   - Position vs exchange reports
   - Break detection and resolution

3. PnL Monitoring
   - Real-time PnL calculation
   - PnL attribution analysis
   - Unexpected PnL swings
   - PnL vs risk model validation

4. Compliance Monitoring
   - Trade reporting obligations
   - Best execution compliance
   - Short sale rule compliance
   - Wash trade detection

5. Anomaly Detection
   - Statistical anomalies
   - Pattern-based anomalies
   - Machine learning anomalies
   - Market manipulation indicators

================================================================================
2. C++ POST-TRADE MONITORING ENGINE
================================================================================

2.1 Core Post-Trade Monitor Implementation
-------------------------------------------

```cpp
// posttrade_monitor.hpp
#ifndef POSTTRADE_MONITOR_HPP
#define POSTTRADE_MONITOR_HPP

#include <string>
#include <unordered_map>
#include <vector>
#include <deque>
#include <mutex>
#include <shared_mutex>
#include <atomic>
#include <chrono>
#include <optional>
#include <memory>

namespace hft {
namespace risk {

// Trade record
struct TradeRecord {
    std::string trade_id;
    std::string order_id;
    std::string symbol;
    std::string account_id;
    std::string strategy_id;
    std::string venue;

    char side;              // 'B' or 'S'
    int64_t quantity;
    double price;
    double commission;
    double fees;

    // Timing
    std::chrono::nanoseconds order_timestamp;
    std::chrono::nanoseconds execution_timestamp;
    std::chrono::microseconds order_to_fill_latency;

    // Reference prices at execution time
    double market_price;    // Mid price
    double bid_price;
    double ask_price;

    // Derived metrics
    double slippage;        // Price vs expected
    double market_impact;   // Price movement caused by order
    bool is_aggressive;     // Crossed the spread

    // Status
    bool reconciled;
    std::string reconciliation_status;
};

// Position snapshot
struct PositionSnapshot {
    std::string symbol;
    std::string account_id;
    std::string strategy_id;

    int64_t quantity;
    double average_price;
    double market_value;
    double unrealized_pnl;
    double realized_pnl_today;

    std::chrono::system_clock::time_point timestamp;
};

// PnL snapshot
struct PnLSnapshot {
    std::string strategy_id;

    // Realized PnL
    double realized_pnl_today;
    double realized_pnl_mtd;
    double realized_pnl_ytd;

    // Unrealized PnL
    double unrealized_pnl;

    // Total PnL
    double total_pnl_today;
    double total_pnl_mtd;
    double total_pnl_ytd;

    // Breakdown
    double trading_pnl;
    double commission_fees;
    double funding_costs;
    double slippage_cost;

    // Attribution
    std::unordered_map<std::string, double> symbol_pnl;
    std::unordered_map<std::string, double> venue_pnl;

    std::chrono::system_clock::time_point timestamp;
};

// Anomaly detection result
enum class AnomalyType {
    NONE,
    ABNORMAL_SLIPPAGE,
    EXCESSIVE_MARKET_IMPACT,
    UNUSUAL_FILL_PRICE,
    RAPID_POSITION_CHANGE,
    UNEXPLAINED_PNL_SWING,
    WASH_TRADE_SUSPECTED,
    LAYERING_DETECTED,
    SPOOFING_DETECTED,
    POSITION_RECONCILIATION_BREAK,
    DUPLICATE_FILL,
    LATE_FILL,
    VENUE_ANOMALY
};

struct Anomaly {
    std::string anomaly_id;
    AnomalyType type;
    std::string symbol;
    std::string strategy_id;

    std::string description;
    double severity_score;  // 0-100
    bool requires_investigation;

    // Related data
    std::vector<std::string> related_trade_ids;
    std::string raw_data;

    std::chrono::system_clock::time_point detection_time;
    std::chrono::system_clock::time_point resolution_time;
    bool resolved;
    std::string resolution_note;
};

// Reconciliation break
struct ReconciliationBreak {
    std::string break_id;
    std::string symbol;
    std::string account_id;

    // Position discrepancy
    int64_t internal_position;
    int64_t exchange_position;
    int64_t difference;

    // Value discrepancy
    double internal_value;
    double exchange_value;
    double value_difference;

    // Timing
    std::chrono::system_clock::time_point detection_time;
    std::chrono::system_clock::time_point resolution_time;

    // Status
    bool resolved;
    std::string root_cause;
    std::string resolution_action;
};

class PostTradeMonitor {
public:
    PostTradeMonitor();
    ~PostTradeMonitor();

    // Trade processing
    void processTrade(const TradeRecord& trade);

    void processMultipleTrades(const std::vector<TradeRecord>& trades);

    // Position updates
    void updatePosition(const std::string& symbol,
                       const std::string& account_id,
                       int64_t quantity_change,
                       double price);

    PositionSnapshot getPosition(const std::string& symbol,
                                const std::string& account_id) const;

    std::vector<PositionSnapshot> getAllPositions() const;

    // Position reconciliation
    void reconcilePosition(const std::string& symbol,
                          const std::string& account_id,
                          int64_t exchange_position);

    std::vector<ReconciliationBreak> getReconciliationBreaks() const;

    void resolveBreak(const std::string& break_id,
                     const std::string& resolution_action);

    // PnL calculation
    PnLSnapshot calculatePnL(const std::string& strategy_id) const;

    void updateMarketPrices(const std::unordered_map<std::string, double>& prices);

    // Slippage analysis
    struct SlippageAnalysis {
        double avg_slippage_bps;
        double max_slippage_bps;
        double min_slippage_bps;
        double std_slippage_bps;
        size_t num_trades;
        double total_slippage_cost;

        std::unordered_map<std::string, double> slippage_by_symbol;
        std::unordered_map<std::string, double> slippage_by_venue;
    };

    SlippageAnalysis analyzeSlippage(
        const std::string& strategy_id,
        std::chrono::system_clock::time_point start_time,
        std::chrono::system_clock::time_point end_time) const;

    // Market impact analysis
    struct MarketImpactAnalysis {
        double avg_impact_bps;
        double max_impact_bps;
        double total_impact_cost;
        size_t num_trades;

        std::unordered_map<std::string, double> impact_by_symbol;
    };

    MarketImpactAnalysis analyzeMarketImpact(
        const std::string& strategy_id,
        std::chrono::system_clock::time_point start_time,
        std::chrono::system_clock::time_point end_time) const;

    // Anomaly detection
    std::vector<Anomaly> detectAnomalies(
        const std::string& strategy_id,
        std::chrono::minutes lookback_window = std::chrono::minutes(60));

    std::vector<Anomaly> getActiveAnomalies() const;

    void resolveAnomaly(const std::string& anomaly_id,
                       const std::string& resolution_note);

    // Wash trade detection
    bool detectWashTrade(const TradeRecord& trade) const;

    std::vector<std::pair<std::string, std::string>>
    findWashTradePairs(std::chrono::minutes window) const;

    // Best execution monitoring
    struct BestExecutionMetrics {
        double avg_effective_spread;
        double realization_shortfall;
        double price_improvement_rate;
        double adverse_selection_rate;

        std::unordered_map<std::string, double> venue_quality_scores;
    };

    BestExecutionMetrics analyzeBestExecution(
        const std::string& strategy_id,
        std::chrono::hours lookback = std::chrono::hours(1)) const;

    // Statistics and reporting
    struct TradingStatistics {
        uint64_t total_trades;
        uint64_t buy_trades;
        uint64_t sell_trades;

        int64_t total_volume;
        double total_value_traded;

        double total_commissions;
        double total_fees;

        double avg_fill_price;
        double avg_trade_size;

        std::chrono::microseconds avg_execution_latency;
    };

    TradingStatistics getStatistics(
        const std::string& strategy_id,
        std::chrono::hours lookback = std::chrono::hours(24)) const;

    // Trade history
    std::vector<TradeRecord> getTradeHistory(
        const std::string& strategy_id,
        std::chrono::hours lookback = std::chrono::hours(24)) const;

    std::vector<TradeRecord> getTradesBySymbol(
        const std::string& symbol,
        std::chrono::hours lookback = std::chrono::hours(24)) const;

private:
    // Internal processing methods
    void calculateTradeMetrics(TradeRecord& trade);

    void updatePositionFromTrade(const TradeRecord& trade);

    void updatePnLFromTrade(const TradeRecord& trade);

    void checkForAnomalies(const TradeRecord& trade);

    bool isAbnormalSlippage(const TradeRecord& trade) const;

    bool isExcessiveMarketImpact(const TradeRecord& trade) const;

    bool isUnusualFillPrice(const TradeRecord& trade) const;

    double calculateSlippage(const TradeRecord& trade) const;

    double calculateMarketImpact(const TradeRecord& trade) const;

    // Data structures
    mutable std::shared_mutex trades_mutex_;
    std::deque<TradeRecord> trade_history_;
    std::unordered_map<std::string, std::vector<TradeRecord>> trades_by_strategy_;

    mutable std::shared_mutex positions_mutex_;
    std::unordered_map<std::string, PositionSnapshot> positions_;

    mutable std::shared_mutex pnl_mutex_;
    std::unordered_map<std::string, PnLSnapshot> pnl_snapshots_;

    mutable std::shared_mutex anomalies_mutex_;
    std::deque<Anomaly> anomaly_history_;

    mutable std::shared_mutex breaks_mutex_;
    std::vector<ReconciliationBreak> reconciliation_breaks_;

    mutable std::shared_mutex market_data_mutex_;
    std::unordered_map<std::string, double> current_prices_;

    // Configuration
    double abnormal_slippage_threshold_bps_ = 10.0;
    double excessive_impact_threshold_bps_ = 5.0;
    size_t max_trade_history_ = 1000000;

    // Statistics
    std::atomic<uint64_t> total_trades_processed_{0};
    std::atomic<uint64_t> total_anomalies_detected_{0};
    std::atomic<uint64_t> total_breaks_detected_{0};
};

// Implementation
inline void PostTradeMonitor::processTrade(const TradeRecord& trade) {
    total_trades_processed_.fetch_add(1, std::memory_order_relaxed);

    // Make a copy to modify
    TradeRecord processed_trade = trade;

    // Calculate derived metrics
    calculateTradeMetrics(processed_trade);

    // Store trade
    {
        std::unique_lock<std::shared_mutex> lock(trades_mutex_);

        trade_history_.push_back(processed_trade);
        trades_by_strategy_[trade.strategy_id].push_back(processed_trade);

        // Trim history if needed
        if (trade_history_.size() > max_trade_history_) {
            trade_history_.pop_front();
        }
    }

    // Update position
    updatePositionFromTrade(processed_trade);

    // Update PnL
    updatePnLFromTrade(processed_trade);

    // Check for anomalies
    checkForAnomalies(processed_trade);
}

inline void PostTradeMonitor::calculateTradeMetrics(TradeRecord& trade) {
    // Calculate slippage
    trade.slippage = calculateSlippage(trade);

    // Calculate market impact
    trade.market_impact = calculateMarketImpact(trade);

    // Determine if aggressive
    if (trade.side == 'B') {
        trade.is_aggressive = trade.price >= trade.ask_price;
    } else {
        trade.is_aggressive = trade.price <= trade.bid_price;
    }

    // Calculate latency
    trade.order_to_fill_latency = std::chrono::duration_cast<
        std::chrono::microseconds>(
            trade.execution_timestamp - trade.order_timestamp);
}

inline double PostTradeMonitor::calculateSlippage(const TradeRecord& trade) const {
    // Slippage vs mid price
    double mid_price = (trade.bid_price + trade.ask_price) / 2.0;

    if (mid_price <= 0) {
        return 0.0;
    }

    double slippage = 0.0;
    if (trade.side == 'B') {
        slippage = trade.price - mid_price;
    } else {
        slippage = mid_price - trade.price;
    }

    // Return in basis points
    return (slippage / mid_price) * 10000.0;
}

inline double PostTradeMonitor::calculateMarketImpact(
    const TradeRecord& trade) const {

    // Market impact: difference from market price before trade
    if (trade.market_price <= 0) {
        return 0.0;
    }

    double impact = 0.0;
    if (trade.side == 'B') {
        impact = trade.price - trade.market_price;
    } else {
        impact = trade.market_price - trade.price;
    }

    // Return in basis points
    return (impact / trade.market_price) * 10000.0;
}

inline void PostTradeMonitor::updatePositionFromTrade(const TradeRecord& trade) {
    std::unique_lock<std::shared_mutex> lock(positions_mutex_);

    std::string key = trade.symbol + "|" + trade.account_id;
    auto& position = positions_[key];

    position.symbol = trade.symbol;
    position.account_id = trade.account_id;
    position.strategy_id = trade.strategy_id;

    // Update quantity and average price
    int64_t old_quantity = position.quantity;
    double old_avg_price = position.average_price;

    int64_t quantity_delta = (trade.side == 'B') ? trade.quantity : -trade.quantity;
    int64_t new_quantity = old_quantity + quantity_delta;

    // Update average price using weighted average
    if (new_quantity != 0) {
        double total_cost = old_quantity * old_avg_price +
                           quantity_delta * trade.price;
        position.average_price = total_cost / new_quantity;
    } else {
        position.average_price = 0.0;
    }

    position.quantity = new_quantity;

    // Update timestamp
    position.timestamp = std::chrono::system_clock::now();

    // Realized PnL calculation
    if ((old_quantity > 0 && quantity_delta < 0) ||
        (old_quantity < 0 && quantity_delta > 0)) {
        // Closing or reducing position
        int64_t closed_quantity = std::min(std::abs(old_quantity),
                                          std::abs(quantity_delta));

        double realized_pnl = 0.0;
        if (old_quantity > 0) {
            // Closing long
            realized_pnl = closed_quantity * (trade.price - old_avg_price);
        } else {
            // Closing short
            realized_pnl = closed_quantity * (old_avg_price - trade.price);
        }

        position.realized_pnl_today += realized_pnl;
    }
}

inline void PostTradeMonitor::updatePnLFromTrade(const TradeRecord& trade) {
    std::unique_lock<std::shared_mutex> lock(pnl_mutex_);

    auto& pnl = pnl_snapshots_[trade.strategy_id];
    pnl.strategy_id = trade.strategy_id;

    // Add commissions and fees
    pnl.commission_fees += trade.commission + trade.fees;

    // Add slippage cost
    double slippage_cost = (std::abs(trade.slippage) / 10000.0) *
                          trade.quantity * trade.price;
    pnl.slippage_cost += slippage_cost;

    // Update symbol PnL breakdown
    pnl.symbol_pnl[trade.symbol] += 0;  // Will be updated with position PnL

    // Update venue PnL breakdown
    pnl.venue_pnl[trade.venue] += 0;

    pnl.timestamp = std::chrono::system_clock::now();
}

inline void PostTradeMonitor::checkForAnomalies(const TradeRecord& trade) {
    std::vector<Anomaly> detected_anomalies;

    // Check for abnormal slippage
    if (isAbnormalSlippage(trade)) {
        Anomaly anomaly;
        anomaly.anomaly_id = "ANO_" + std::to_string(
            total_anomalies_detected_.fetch_add(1));
        anomaly.type = AnomalyType::ABNORMAL_SLIPPAGE;
        anomaly.symbol = trade.symbol;
        anomaly.strategy_id = trade.strategy_id;
        anomaly.description = "Abnormal slippage detected: " +
                            std::to_string(trade.slippage) + " bps";
        anomaly.severity_score = std::min(100.0, std::abs(trade.slippage));
        anomaly.requires_investigation = true;
        anomaly.related_trade_ids.push_back(trade.trade_id);
        anomaly.detection_time = std::chrono::system_clock::now();
        anomaly.resolved = false;

        detected_anomalies.push_back(anomaly);
    }

    // Check for excessive market impact
    if (isExcessiveMarketImpact(trade)) {
        Anomaly anomaly;
        anomaly.anomaly_id = "ANO_" + std::to_string(
            total_anomalies_detected_.fetch_add(1));
        anomaly.type = AnomalyType::EXCESSIVE_MARKET_IMPACT;
        anomaly.symbol = trade.symbol;
        anomaly.strategy_id = trade.strategy_id;
        anomaly.description = "Excessive market impact: " +
                            std::to_string(trade.market_impact) + " bps";
        anomaly.severity_score = std::min(100.0, std::abs(trade.market_impact) * 2);
        anomaly.requires_investigation = true;
        anomaly.related_trade_ids.push_back(trade.trade_id);
        anomaly.detection_time = std::chrono::system_clock::now();
        anomaly.resolved = false;

        detected_anomalies.push_back(anomaly);
    }

    // Check for unusual fill price
    if (isUnusualFillPrice(trade)) {
        Anomaly anomaly;
        anomaly.anomaly_id = "ANO_" + std::to_string(
            total_anomalies_detected_.fetch_add(1));
        anomaly.type = AnomalyType::UNUSUAL_FILL_PRICE;
        anomaly.symbol = trade.symbol;
        anomaly.strategy_id = trade.strategy_id;
        anomaly.description = "Unusual fill price detected";
        anomaly.severity_score = 60.0;
        anomaly.requires_investigation = true;
        anomaly.related_trade_ids.push_back(trade.trade_id);
        anomaly.detection_time = std::chrono::system_clock::now();
        anomaly.resolved = false;

        detected_anomalies.push_back(anomaly);
    }

    // Check for wash trade
    if (detectWashTrade(trade)) {
        Anomaly anomaly;
        anomaly.anomaly_id = "ANO_" + std::to_string(
            total_anomalies_detected_.fetch_add(1));
        anomaly.type = AnomalyType::WASH_TRADE_SUSPECTED;
        anomaly.symbol = trade.symbol;
        anomaly.strategy_id = trade.strategy_id;
        anomaly.description = "Potential wash trade detected";
        anomaly.severity_score = 90.0;
        anomaly.requires_investigation = true;
        anomaly.related_trade_ids.push_back(trade.trade_id);
        anomaly.detection_time = std::chrono::system_clock::now();
        anomaly.resolved = false;

        detected_anomalies.push_back(anomaly);
    }

    // Store anomalies
    if (!detected_anomalies.empty()) {
        std::unique_lock<std::shared_mutex> lock(anomalies_mutex_);
        for (const auto& anomaly : detected_anomalies) {
            anomaly_history_.push_back(anomaly);
        }
    }
}

inline bool PostTradeMonitor::isAbnormalSlippage(const TradeRecord& trade) const {
    return std::abs(trade.slippage) > abnormal_slippage_threshold_bps_;
}

inline bool PostTradeMonitor::isExcessiveMarketImpact(
    const TradeRecord& trade) const {
    return std::abs(trade.market_impact) > excessive_impact_threshold_bps_;
}

inline bool PostTradeMonitor::isUnusualFillPrice(const TradeRecord& trade) const {
    // Check if fill price is outside bid-ask spread significantly
    double spread = trade.ask_price - trade.bid_price;

    if (trade.side == 'B') {
        // Buy should be near or above ask
        if (trade.price < trade.bid_price - spread * 0.5) {
            return true;  // Unusually good price for buy
        }
        if (trade.price > trade.ask_price + spread * 2.0) {
            return true;  // Unusually bad price for buy
        }
    } else {
        // Sell should be near or below bid
        if (trade.price > trade.ask_price + spread * 0.5) {
            return true;  // Unusually good price for sell
        }
        if (trade.price < trade.bid_price - spread * 2.0) {
            return true;  // Unusually bad price for sell
        }
    }

    return false;
}

inline void PostTradeMonitor::reconcilePosition(
    const std::string& symbol,
    const std::string& account_id,
    int64_t exchange_position) {

    std::shared_lock<std::shared_mutex> pos_lock(positions_mutex_);

    std::string key = symbol + "|" + account_id;
    auto it = positions_.find(key);

    int64_t internal_position = (it != positions_.end()) ? it->second.quantity : 0;

    pos_lock.unlock();

    // Check for discrepancy
    int64_t difference = internal_position - exchange_position;

    if (difference != 0) {
        // Create reconciliation break
        ReconciliationBreak break_record;
        break_record.break_id = "BRK_" + std::to_string(
            total_breaks_detected_.fetch_add(1));
        break_record.symbol = symbol;
        break_record.account_id = account_id;
        break_record.internal_position = internal_position;
        break_record.exchange_position = exchange_position;
        break_record.difference = difference;
        break_record.detection_time = std::chrono::system_clock::now();
        break_record.resolved = false;

        // Store break
        std::unique_lock<std::shared_mutex> break_lock(breaks_mutex_);
        reconciliation_breaks_.push_back(break_record);
    }
}

inline bool PostTradeMonitor::detectWashTrade(const TradeRecord& trade) const {
    std::shared_lock<std::shared_mutex> lock(trades_mutex_);

    // Look for offsetting trade within short time window
    auto cutoff_time = trade.execution_timestamp - std::chrono::minutes(5);

    for (const auto& historical_trade : trade_history_) {
        if (historical_trade.execution_timestamp < cutoff_time) {
            continue;
        }

        // Check if it's an offsetting trade
        if (historical_trade.symbol == trade.symbol &&
            historical_trade.account_id == trade.account_id &&
            historical_trade.side != trade.side &&
            historical_trade.quantity == trade.quantity &&
            std::abs(historical_trade.price - trade.price) < 0.01) {

            return true;  // Potential wash trade
        }
    }

    return false;
}

} // namespace risk
} // namespace hft

#endif // POSTTRADE_MONITOR_HPP
```

================================================================================
3. SLIPPAGE ANALYSIS ALGORITHMS
================================================================================

3.1 Advanced Slippage Calculation
----------------------------------

```cpp
// slippage_analyzer.hpp

namespace hft {
namespace risk {

class SlippageAnalyzer {
public:
    // Calculate implementation shortfall
    static double calculateImplementationShortfall(
        const std::vector<TradeRecord>& trades,
        double decision_price) {

        double total_shortfall = 0.0;
        double total_value = 0.0;

        for (const auto& trade : trades) {
            double trade_value = trade.quantity * trade.price;
            double ideal_value = trade.quantity * decision_price;

            if (trade.side == 'B') {
                total_shortfall += trade_value - ideal_value;
            } else {
                total_shortfall += ideal_value - trade_value;
            }

            total_value += std::abs(ideal_value);
        }

        if (total_value == 0) return 0.0;

        // Return as basis points
        return (total_shortfall / total_value) * 10000.0;
    }

    // Calculate arrival price slippage
    static double calculateArrivalPriceSlippage(
        const TradeRecord& trade,
        double arrival_price) {

        if (arrival_price <= 0) return 0.0;

        double slippage = 0.0;
        if (trade.side == 'B') {
            slippage = trade.price - arrival_price;
        } else {
            slippage = arrival_price - trade.price;
        }

        return (slippage / arrival_price) * 10000.0;
    }

    // Calculate VWAP slippage
    static double calculateVWAPSlippage(
        const std::vector<TradeRecord>& trades,
        double market_vwap) {

        if (market_vwap <= 0) return 0.0;

        double total_value = 0.0;
        double total_quantity = 0.0;

        for (const auto& trade : trades) {
            total_value += trade.quantity * trade.price;
            total_quantity += trade.quantity;
        }

        if (total_quantity == 0) return 0.0;

        double execution_vwap = total_value / total_quantity;
        double slippage = execution_vwap - market_vwap;

        return (slippage / market_vwap) * 10000.0;
    }

    // Analyze slippage by time of day
    struct TimeOfDaySlippage {
        int hour;
        double avg_slippage_bps;
        size_t trade_count;
    };

    static std::vector<TimeOfDaySlippage> analyzeByTimeOfDay(
        const std::vector<TradeRecord>& trades) {

        std::unordered_map<int, std::vector<double>> slippage_by_hour;

        for (const auto& trade : trades) {
            auto tp = std::chrono::system_clock::time_point(trade.execution_timestamp);
            auto tt = std::chrono::system_clock::to_time_t(tp);
            auto tm = std::localtime(&tt);

            slippage_by_hour[tm->tm_hour].push_back(trade.slippage);
        }

        std::vector<TimeOfDaySlippage> result;
        for (const auto& [hour, slippages] : slippage_by_hour) {
            TimeOfDaySlippage tod;
            tod.hour = hour;
            tod.trade_count = slippages.size();

            double sum = 0.0;
            for (double s : slippages) {
                sum += s;
            }
            tod.avg_slippage_bps = sum / slippages.size();

            result.push_back(tod);
        }

        return result;
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
4. MARKET IMPACT MODELS
================================================================================

4.1 Market Impact Estimation
-----------------------------

```cpp
// market_impact_model.hpp

namespace hft {
namespace risk {

class MarketImpactModel {
public:
    // Almgren-Chriss market impact model
    static double estimateAlmgrenChrissImpact(
        double quantity,
        double daily_volume,
        double volatility,
        double participation_rate) {

        // Temporary impact: proportional to participation rate
        double temp_impact = 0.5 * volatility * std::sqrt(
            participation_rate / daily_volume);

        // Permanent impact: square root of quantity
        double perm_impact = 0.1 * volatility * std::pow(
            quantity / daily_volume, 0.6);

        return (temp_impact + perm_impact) * 10000.0;  // Convert to bps
    }

    // Kyle's lambda model
    static double estimateKyleLambda(
        const std::vector<TradeRecord>& trades,
        const std::vector<double>& price_changes) {

        if (trades.size() != price_changes.size() || trades.empty()) {
            return 0.0;
        }

        // Linear regression: price_change = lambda * signed_volume
        double sum_x = 0.0, sum_y = 0.0, sum_xy = 0.0, sum_x2 = 0.0;
        size_t n = trades.size();

        for (size_t i = 0; i < n; i++) {
            double signed_volume = (trades[i].side == 'B') ?
                                  trades[i].quantity : -trades[i].quantity;
            double price_change = price_changes[i];

            sum_x += signed_volume;
            sum_y += price_change;
            sum_xy += signed_volume * price_change;
            sum_x2 += signed_volume * signed_volume;
        }

        // Calculate lambda (slope)
        double lambda = (n * sum_xy - sum_x * sum_y) /
                       (n * sum_x2 - sum_x * sum_x);

        return lambda;
    }

    // Market impact decay model
    static double calculateDecayedImpact(
        double initial_impact,
        std::chrono::seconds time_elapsed,
        std::chrono::seconds half_life = std::chrono::seconds(300)) {

        // Exponential decay
        double decay_factor = std::exp(-0.693147 * time_elapsed.count() /
                                      half_life.count());

        return initial_impact * decay_factor;
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
5. WASH TRADE DETECTION
================================================================================

5.1 Advanced Wash Trade Detection
----------------------------------

```cpp
// wash_trade_detector.hpp

namespace hft {
namespace risk {

class WashTradeDetector {
public:
    struct WashTradePattern {
        std::vector<std::string> trade_ids;
        std::string symbol;
        std::string account_id;
        double total_volume;
        double price_range;
        std::chrono::milliseconds time_span;
        double confidence_score;  // 0-100
    };

    // Detect wash trades using multiple heuristics
    static std::vector<WashTradePattern> detectWashTrades(
        const std::vector<TradeRecord>& trades,
        std::chrono::minutes window = std::chrono::minutes(30)) {

        std::vector<WashTradePattern> patterns;

        // Group trades by symbol and account
        std::unordered_map<std::string, std::vector<TradeRecord>> grouped_trades;
        for (const auto& trade : trades) {
            std::string key = trade.symbol + "|" + trade.account_id;
            grouped_trades[key].push_back(trade);
        }

        // Analyze each group
        for (const auto& [key, group_trades] : grouped_trades) {
            auto detected = analyzeTradeGroup(group_trades, window);
            patterns.insert(patterns.end(), detected.begin(), detected.end());
        }

        return patterns;
    }

private:
    static std::vector<WashTradePattern> analyzeTradeGroup(
        const std::vector<TradeRecord>& trades,
        std::chrono::minutes window) {

        std::vector<WashTradePattern> patterns;

        // Pattern 1: Offsetting trades within window
        for (size_t i = 0; i < trades.size(); i++) {
            for (size_t j = i + 1; j < trades.size(); j++) {
                const auto& trade1 = trades[i];
                const auto& trade2 = trades[j];

                // Check time window
                auto time_diff = std::chrono::abs(
                    trade1.execution_timestamp - trade2.execution_timestamp);

                if (time_diff > window) {
                    continue;
                }

                // Check if offsetting
                if (trade1.side != trade2.side &&
                    trade1.quantity == trade2.quantity &&
                    std::abs(trade1.price - trade2.price) < 0.01) {

                    WashTradePattern pattern;
                    pattern.trade_ids = {trade1.trade_id, trade2.trade_id};
                    pattern.symbol = trade1.symbol;
                    pattern.account_id = trade1.account_id;
                    pattern.total_volume = trade1.quantity + trade2.quantity;
                    pattern.price_range = std::abs(trade1.price - trade2.price);
                    pattern.time_span = std::chrono::duration_cast<
                        std::chrono::milliseconds>(time_diff);
                    pattern.confidence_score = calculateConfidence(trade1, trade2);

                    patterns.push_back(pattern);
                }
            }
        }

        // Pattern 2: Rapid buy-sell-buy-sell sequences
        // (Add more sophisticated patterns here)

        return patterns;
    }

    static double calculateConfidence(
        const TradeRecord& trade1,
        const TradeRecord& trade2) {

        double confidence = 50.0;  // Base confidence

        // Same quantity: +20
        if (trade1.quantity == trade2.quantity) {
            confidence += 20.0;
        }

        // Same price: +20
        if (std::abs(trade1.price - trade2.price) < 0.01) {
            confidence += 20.0;
        }

        // Within 1 minute: +10
        auto time_diff = std::chrono::abs(
            trade1.execution_timestamp - trade2.execution_timestamp);
        if (time_diff < std::chrono::minutes(1)) {
            confidence += 10.0;
        }

        return std::min(100.0, confidence);
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
6. PNL ATTRIBUTION ANALYSIS
================================================================================

6.1 Detailed PnL Attribution
-----------------------------

```cpp
// pnl_attribution.hpp

namespace hft {
namespace risk {

class PnLAttribution {
public:
    struct AttributionBreakdown {
        // By component
        double trading_pnl;
        double commission_cost;
        double slippage_cost;
        double market_impact_cost;
        double funding_cost;
        double fee_rebates;

        // By symbol
        std::unordered_map<std::string, double> symbol_pnl;

        // By strategy
        std::unordered_map<std::string, double> strategy_pnl;

        // By venue
        std::unordered_map<std::string, double> venue_pnl;

        // By side
        double long_pnl;
        double short_pnl;

        // Time-based
        std::vector<std::pair<int, double>> hourly_pnl;  // Hour -> PnL
    };

    static AttributionBreakdown attributePnL(
        const std::vector<TradeRecord>& trades,
        const std::unordered_map<std::string, PositionSnapshot>& positions) {

        AttributionBreakdown attribution;
        attribution.trading_pnl = 0.0;
        attribution.commission_cost = 0.0;
        attribution.slippage_cost = 0.0;
        attribution.market_impact_cost = 0.0;
        attribution.long_pnl = 0.0;
        attribution.short_pnl = 0.0;

        // Analyze each trade
        for (const auto& trade : trades) {
            // Commissions
            attribution.commission_cost += trade.commission + trade.fees;

            // Slippage cost
            double slippage_dollars = (trade.slippage / 10000.0) *
                                     trade.quantity * trade.price;
            attribution.slippage_cost += std::abs(slippage_dollars);

            // Market impact cost
            double impact_dollars = (trade.market_impact / 10000.0) *
                                   trade.quantity * trade.price;
            attribution.market_impact_cost += std::abs(impact_dollars);

            // Symbol attribution
            attribution.symbol_pnl[trade.symbol] += 0;  // To be calculated from positions

            // Strategy attribution
            attribution.strategy_pnl[trade.strategy_id] += 0;

            // Venue attribution
            attribution.venue_pnl[trade.venue] += 0;
        }

        // Calculate trading PnL from positions
        for (const auto& [key, position] : positions) {
            attribution.trading_pnl += position.realized_pnl_today +
                                     position.unrealized_pnl;

            attribution.symbol_pnl[position.symbol] += position.realized_pnl_today +
                                                      position.unrealized_pnl;

            if (position.quantity > 0) {
                attribution.long_pnl += position.unrealized_pnl;
            } else if (position.quantity < 0) {
                attribution.short_pnl += position.unrealized_pnl;
            }
        }

        return attribution;
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
7. CONFIGURATION AND MONITORING
================================================================================

7.1 Post-Trade Monitoring Configuration
----------------------------------------

```json
{
  "posttrade_monitoring": {
    "global_settings": {
      "enable_monitoring": true,
      "monitoring_frequency_ms": 1000,
      "max_trade_history": 1000000
    },

    "slippage_monitoring": {
      "enable": true,
      "abnormal_threshold_bps": 10.0,
      "alert_threshold_bps": 20.0,
      "calculation_method": "mid_price"
    },

    "market_impact_monitoring": {
      "enable": true,
      "excessive_threshold_bps": 5.0,
      "alert_threshold_bps": 10.0
    },

    "reconciliation": {
      "enable": true,
      "reconcile_frequency_seconds": 60,
      "tolerance_shares": 0,
      "auto_resolve_small_breaks": false
    },

    "anomaly_detection": {
      "enable": true,
      "detection_methods": [
        "statistical",
        "rule_based",
        "pattern_matching"
      ],
      "min_severity_for_alert": 60
    },

    "wash_trade_detection": {
      "enable": true,
      "time_window_minutes": 30,
      "quantity_tolerance": 0,
      "price_tolerance": 0.01,
      "confidence_threshold": 70.0
    },

    "best_execution": {
      "enable_analysis": true,
      "analyze_frequency_minutes": 15,
      "metrics": [
        "effective_spread",
        "realization_shortfall",
        "price_improvement"
      ]
    },

    "pnl_calculation": {
      "enable": true,
      "calculation_frequency_ms": 100,
      "include_unrealized": true,
      "mark_to_market_source": "last_trade"
    }
  }
}
```

================================================================================
8. TESTING FRAMEWORK
================================================================================

8.1 Post-Trade Monitoring Tests
--------------------------------

```cpp
// Unit tests for post-trade monitoring

TEST(PostTradeMonitor, CalculatesSlippageCorrectly) {
    PostTradeMonitor monitor;

    TradeRecord trade;
    trade.trade_id = "TEST001";
    trade.symbol = "AAPL";
    trade.side = 'B';
    trade.quantity = 100;
    trade.price = 150.50;
    trade.bid_price = 150.00;
    trade.ask_price = 151.00;

    double mid_price = (trade.bid_price + trade.ask_price) / 2.0;
    double expected_slippage = ((trade.price - mid_price) / mid_price) * 10000.0;

    monitor.processTrade(trade);

    // Verify slippage calculation
    auto trades = monitor.getTradeHistory("", std::chrono::hours(1));
    ASSERT_EQ(trades.size(), 1);
    EXPECT_NEAR(trades[0].slippage, expected_slippage, 0.01);
}

TEST(PostTradeMonitor, DetectsWashTrade) {
    PostTradeMonitor monitor;

    // Trade 1: Buy 100 @ 150
    TradeRecord trade1;
    trade1.trade_id = "TEST001";
    trade1.symbol = "AAPL";
    trade1.account_id = "ACC001";
    trade1.side = 'B';
    trade1.quantity = 100;
    trade1.price = 150.00;
    trade1.execution_timestamp = std::chrono::nanoseconds(1000000000);

    monitor.processTrade(trade1);

    // Trade 2: Sell 100 @ 150 (offsetting)
    TradeRecord trade2;
    trade2.trade_id = "TEST002";
    trade2.symbol = "AAPL";
    trade2.account_id = "ACC001";
    trade2.side = 'S';
    trade2.quantity = 100;
    trade2.price = 150.00;
    trade2.execution_timestamp = std::chrono::nanoseconds(1001000000);

    monitor.processTrade(trade2);

    // Check for wash trade detection
    auto anomalies = monitor.getActiveAnomalies();
    bool wash_trade_detected = false;
    for (const auto& anomaly : anomalies) {
        if (anomaly.type == AnomalyType::WASH_TRADE_SUSPECTED) {
            wash_trade_detected = true;
            break;
        }
    }

    EXPECT_TRUE(wash_trade_detected);
}

TEST(PostTradeMonitor, ReconciliationDetectsBreaks) {
    PostTradeMonitor monitor;

    // Initialize position
    monitor.updatePosition("AAPL", "ACC001", 100, 150.0);

    // Reconcile with exchange (different position)
    monitor.reconcilePosition("AAPL", "ACC001", 90);

    auto breaks = monitor.getReconciliationBreaks();
    ASSERT_EQ(breaks.size(), 1);
    EXPECT_EQ(breaks[0].difference, 10);
}

================================================================================
END OF POST-TRADE RISK MONITORING DOCUMENTATION
================================================================================
