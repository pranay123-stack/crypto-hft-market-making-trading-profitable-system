================================================================================
EXPOSURE MANAGEMENT - HFT RISK MANAGEMENT SYSTEM
================================================================================
Version: 2.1.0
Last Updated: 2025-11-25
Author: HFT Risk Management Team
Purpose: Real-time exposure tracking, limits, and hedging strategies

================================================================================
1. EXPOSURE MANAGEMENT FRAMEWORK
================================================================================

1.1 Exposure Types and Categories
----------------------------------

Primary Exposure Types:

1. Market Exposure
   - Directional equity exposure (beta)
   - Index exposure
   - Sector rotation exposure
   - Factor exposures

2. Notional Exposure
   - Gross notional (long + short)
   - Net notional (long - short)
   - Leverage ratios
   - Currency-adjusted notional

3. Delta Exposure
   - Equity delta
   - Options delta
   - Futures delta
   - Total portfolio delta

4. Vega Exposure
   - Volatility risk
   - Implied volatility exposure
   - Vega by maturity
   - Correlation vega

5. Sector Exposure
   - GICS sector classification
   - Industry group exposure
   - Geographic exposure
   - Market cap exposure

6. Currency Exposure
   - FX delta
   - Cross-currency exposure
   - Translation risk
   - Transaction risk

7. Concentration Risk
   - Single name concentration
   - Issuer concentration
   - Counterparty concentration
   - Venue concentration

================================================================================
2. C++ EXPOSURE MANAGEMENT ENGINE
================================================================================

2.1 Core Exposure Manager Implementation
-----------------------------------------

```cpp
// exposure_manager.hpp
#ifndef EXPOSURE_MANAGER_HPP
#define EXPOSURE_MANAGER_HPP

#include <string>
#include <unordered_map>
#include <vector>
#include <mutex>
#include <shared_mutex>
#include <atomic>
#include <chrono>
#include <optional>
#include <memory>

namespace hft {
namespace risk {

// Exposure categories
enum class ExposureCategory {
    MARKET,
    SECTOR,
    GEOGRAPHY,
    CURRENCY,
    ASSET_CLASS,
    STRATEGY,
    COUNTERPARTY,
    VENUE
};

// Exposure record
struct ExposureRecord {
    std::string exposure_id;
    ExposureCategory category;
    std::string subcategory;        // e.g., "Technology" for SECTOR

    // Monetary exposure
    double gross_exposure;          // Total absolute exposure
    double net_exposure;            // Long - Short
    double long_exposure;
    double short_exposure;

    // Percentage of portfolio
    double gross_exposure_pct;
    double net_exposure_pct;

    // Greeks exposure
    double delta_exposure;
    double gamma_exposure;
    double vega_exposure;

    // Risk metrics
    double var_contribution;
    double marginal_var;
    double component_var;

    // Limits
    double gross_limit;
    double net_limit;
    bool limit_breached;

    std::chrono::system_clock::time_point timestamp;
};

// Exposure limit configuration
struct ExposureLimit {
    ExposureCategory category;
    std::string subcategory;

    // Monetary limits
    double max_gross_exposure;
    double max_net_exposure;
    double max_long_exposure;
    double max_short_exposure;

    // Percentage limits
    double max_gross_pct;
    double max_net_pct;

    // Greek limits
    double max_delta_exposure;
    double max_vega_exposure;

    // Number of positions limit
    int max_num_positions;

    // Alert thresholds
    double warning_threshold_pct;   // % of limit for warning
    double critical_threshold_pct;  // % of limit for critical alert

    bool auto_hedge_on_breach;
    double target_hedge_ratio;      // Target hedge level (0-1)
};

// Hedge recommendation
struct HedgeRecommendation {
    std::string hedge_id;
    std::string exposure_type;
    std::string instrument;         // Instrument to hedge with

    // Hedge details
    char side;                      // 'B' or 'S'
    double quantity;
    double notional;
    double expected_hedge_ratio;    // How much exposure is hedged

    // Cost analysis
    double estimated_cost;
    double slippage_estimate;
    double expected_pnl_impact;

    // Priority
    int priority;                   // 1 = highest
    std::string reason;

    std::chrono::system_clock::time_point recommendation_time;
};

class ExposureManager {
public:
    ExposureManager();
    ~ExposureManager();

    // Exposure calculation
    void updatePosition(const std::string& symbol,
                       const std::string& account,
                       double quantity,
                       double price,
                       const std::unordered_map<std::string, std::string>& attributes);

    ExposureRecord calculateExposure(ExposureCategory category,
                                    const std::string& subcategory) const;

    std::vector<ExposureRecord> calculateAllExposures() const;

    // Exposure by dimension
    std::unordered_map<std::string, double> getExposureBySymbol() const;

    std::unordered_map<std::string, double> getExposureBySector() const;

    std::unordered_map<std::string, double> getExposureByGeography() const;

    std::unordered_map<std::string, double> getExposureByCurrency() const;

    std::unordered_map<std::string, double> getExposureByStrategy() const;

    // Greek exposures
    struct GreekExposures {
        double total_delta;
        double total_gamma;
        double total_vega;
        double total_theta;

        std::unordered_map<std::string, double> delta_by_underlying;
        std::unordered_map<std::string, double> vega_by_strike;
        std::unordered_map<std::string, double> theta_by_expiry;
    };

    GreekExposures calculateGreekExposures() const;

    // Concentration metrics
    struct ConcentrationMetrics {
        double herfindahl_index;
        double top_5_concentration_pct;
        double top_10_concentration_pct;
        std::string largest_exposure_symbol;
        double largest_exposure_pct;
        int num_positions;
    };

    ConcentrationMetrics calculateConcentration() const;

    // Limit management
    void setExposureLimit(const ExposureLimit& limit);

    bool checkExposureLimit(ExposureCategory category,
                           const std::string& subcategory,
                           double additional_exposure,
                           std::string& rejection_reason) const;

    std::vector<ExposureRecord> getExposuresNearLimit(
        double threshold_pct = 80.0) const;

    std::vector<ExposureRecord> getBreachedLimits() const;

    // Hedging
    std::vector<HedgeRecommendation> generateHedgeRecommendations(
        double max_exposure_deviation = 0.10) const;

    void executeHedge(const HedgeRecommendation& hedge);

    bool autoHedgeIfNeeded();

    // Exposure decomposition
    struct ExposureDecomposition {
        std::string primary_factor;
        std::unordered_map<std::string, double> factor_contributions;
        double systematic_exposure;
        double idiosyncratic_exposure;
    };

    ExposureDecomposition decomposeExposure(
        const std::string& symbol) const;

    // Stress testing exposure
    struct ExposureStressResult {
        std::string scenario_name;
        double baseline_exposure;
        double stressed_exposure;
        double exposure_change_pct;
        bool would_breach_limits;
    };

    std::vector<ExposureStressResult> stressTestExposures(
        const std::vector<std::pair<std::string, double>>& market_shocks) const;

    // Real-time monitoring
    void startMonitoring(std::chrono::milliseconds update_interval);

    void stopMonitoring();

    // Statistics
    struct ExposureStatistics {
        double avg_gross_exposure;
        double avg_net_exposure;
        double max_gross_exposure_today;
        double min_net_exposure_today;
        int limit_breaches_today;
        int auto_hedges_executed_today;
    };

    ExposureStatistics getStatistics() const;

private:
    // Internal structures
    struct PositionRecord {
        std::string symbol;
        std::string account;
        double quantity;
        double price;
        double market_value;

        // Attributes for classification
        std::string sector;
        std::string geography;
        std::string currency;
        std::string strategy;
        std::string asset_class;

        // Greeks (if options)
        double delta;
        double gamma;
        double vega;
        double theta;

        std::chrono::system_clock::time_point last_update;
    };

    // Helper methods
    void classifyPosition(PositionRecord& position);

    double calculatePortfolioValue() const;

    std::vector<PositionRecord> getPositionsByCategory(
        ExposureCategory category,
        const std::string& subcategory) const;

    bool shouldAutoHedge(const ExposureRecord& exposure,
                        const ExposureLimit& limit) const;

    HedgeRecommendation createHedgeForExposure(
        const ExposureRecord& exposure) const;

    void monitoringLoop();

    // Data structures
    mutable std::shared_mutex positions_mutex_;
    std::unordered_map<std::string, PositionRecord> positions_;

    mutable std::shared_mutex limits_mutex_;
    std::unordered_map<std::string, ExposureLimit> exposure_limits_;

    mutable std::shared_mutex hedge_mutex_;
    std::vector<HedgeRecommendation> active_hedges_;

    // Monitoring
    std::atomic<bool> monitoring_active_{false};
    std::thread monitoring_thread_;
    std::chrono::milliseconds update_interval_;

    // Statistics
    std::atomic<uint64_t> limit_breaches_count_{0};
    std::atomic<uint64_t> auto_hedges_count_{0};
};

// Implementation
inline void ExposureManager::updatePosition(
    const std::string& symbol,
    const std::string& account,
    double quantity,
    double price,
    const std::unordered_map<std::string, std::string>& attributes) {

    std::unique_lock<std::shared_mutex> lock(positions_mutex_);

    std::string key = symbol + "|" + account;
    auto& position = positions_[key];

    position.symbol = symbol;
    position.account = account;
    position.quantity = quantity;
    position.price = price;
    position.market_value = quantity * price;
    position.last_update = std::chrono::system_clock::now();

    // Extract attributes
    auto it = attributes.find("sector");
    if (it != attributes.end()) {
        position.sector = it->second;
    }

    it = attributes.find("geography");
    if (it != attributes.end()) {
        position.geography = it->second;
    }

    it = attributes.find("currency");
    if (it != attributes.end()) {
        position.currency = it->second;
    }

    it = attributes.find("strategy");
    if (it != attributes.end()) {
        position.strategy = it->second;
    }

    // Extract Greeks if provided
    it = attributes.find("delta");
    if (it != attributes.end()) {
        position.delta = std::stod(it->second);
    }

    it = attributes.find("gamma");
    if (it != attributes.end()) {
        position.gamma = std::stod(it->second);
    }

    it = attributes.find("vega");
    if (it != attributes.end()) {
        position.vega = std::stod(it->second);
    }

    // Classify position if needed
    if (position.sector.empty() || position.geography.empty()) {
        classifyPosition(position);
    }
}

inline ExposureRecord ExposureManager::calculateExposure(
    ExposureCategory category,
    const std::string& subcategory) const {

    std::shared_lock<std::shared_mutex> lock(positions_mutex_);

    ExposureRecord exposure;
    exposure.category = category;
    exposure.subcategory = subcategory;
    exposure.gross_exposure = 0.0;
    exposure.net_exposure = 0.0;
    exposure.long_exposure = 0.0;
    exposure.short_exposure = 0.0;
    exposure.delta_exposure = 0.0;
    exposure.gamma_exposure = 0.0;
    exposure.vega_exposure = 0.0;

    // Get positions in this category
    auto positions = getPositionsByCategory(category, subcategory);

    // Calculate exposures
    for (const auto& pos : positions) {
        double abs_value = std::abs(pos.market_value);
        exposure.gross_exposure += abs_value;

        if (pos.quantity > 0) {
            exposure.long_exposure += abs_value;
            exposure.net_exposure += abs_value;
        } else {
            exposure.short_exposure += abs_value;
            exposure.net_exposure -= abs_value;
        }

        // Greeks
        exposure.delta_exposure += pos.delta * pos.quantity;
        exposure.gamma_exposure += pos.gamma * pos.quantity;
        exposure.vega_exposure += pos.vega * pos.quantity;
    }

    // Calculate percentages
    double portfolio_value = calculatePortfolioValue();
    if (portfolio_value > 0) {
        exposure.gross_exposure_pct = (exposure.gross_exposure / portfolio_value) * 100.0;
        exposure.net_exposure_pct = (exposure.net_exposure / portfolio_value) * 100.0;
    }

    exposure.timestamp = std::chrono::system_clock::now();

    return exposure;
}

inline std::vector<ExposureManager::PositionRecord>
ExposureManager::getPositionsByCategory(
    ExposureCategory category,
    const std::string& subcategory) const {

    std::vector<PositionRecord> result;

    for (const auto& [key, pos] : positions_) {
        bool matches = false;

        switch (category) {
            case ExposureCategory::SECTOR:
                matches = (pos.sector == subcategory);
                break;
            case ExposureCategory::GEOGRAPHY:
                matches = (pos.geography == subcategory);
                break;
            case ExposureCategory::CURRENCY:
                matches = (pos.currency == subcategory);
                break;
            case ExposureCategory::STRATEGY:
                matches = (pos.strategy == subcategory);
                break;
            case ExposureCategory::ASSET_CLASS:
                matches = (pos.asset_class == subcategory);
                break;
            default:
                break;
        }

        if (matches) {
            result.push_back(pos);
        }
    }

    return result;
}

inline std::unordered_map<std::string, double>
ExposureManager::getExposureBySector() const {

    std::shared_lock<std::shared_mutex> lock(positions_mutex_);
    std::unordered_map<std::string, double> sector_exposures;

    for (const auto& [key, pos] : positions_) {
        if (!pos.sector.empty()) {
            sector_exposures[pos.sector] += pos.market_value;
        }
    }

    return sector_exposures;
}

inline std::unordered_map<std::string, double>
ExposureManager::getExposureByGeography() const {

    std::shared_lock<std::shared_mutex> lock(positions_mutex_);
    std::unordered_map<std::string, double> geo_exposures;

    for (const auto& [key, pos] : positions_) {
        if (!pos.geography.empty()) {
            geo_exposures[pos.geography] += pos.market_value;
        }
    }

    return geo_exposures;
}

inline ExposureManager::GreekExposures
ExposureManager::calculateGreekExposures() const {

    std::shared_lock<std::shared_mutex> lock(positions_mutex_);

    GreekExposures greeks;
    greeks.total_delta = 0.0;
    greeks.total_gamma = 0.0;
    greeks.total_vega = 0.0;
    greeks.total_theta = 0.0;

    for (const auto& [key, pos] : positions_) {
        double position_delta = pos.delta * pos.quantity;
        double position_gamma = pos.gamma * pos.quantity;
        double position_vega = pos.vega * pos.quantity;
        double position_theta = pos.theta * pos.quantity;

        greeks.total_delta += position_delta;
        greeks.total_gamma += position_gamma;
        greeks.total_vega += position_vega;
        greeks.total_theta += position_theta;

        // By underlying
        greeks.delta_by_underlying[pos.symbol] += position_delta;
    }

    return greeks;
}

inline ExposureManager::ConcentrationMetrics
ExposureManager::calculateConcentration() const {

    std::shared_lock<std::shared_mutex> lock(positions_mutex_);

    ConcentrationMetrics metrics;
    metrics.herfindahl_index = 0.0;
    metrics.top_5_concentration_pct = 0.0;
    metrics.top_10_concentration_pct = 0.0;
    metrics.num_positions = positions_.size();

    // Calculate portfolio value
    double total_value = calculatePortfolioValue();

    if (total_value == 0 || positions_.empty()) {
        return metrics;
    }

    // Calculate position weights and sort
    std::vector<std::pair<std::string, double>> position_weights;
    for (const auto& [key, pos] : positions_) {
        double weight = std::abs(pos.market_value) / total_value;
        position_weights.push_back({pos.symbol, weight});

        // Herfindahl Index
        metrics.herfindahl_index += weight * weight;
    }

    // Sort by weight (descending)
    std::sort(position_weights.begin(), position_weights.end(),
             [](const auto& a, const auto& b) {
                 return a.second > b.second;
             });

    // Largest position
    if (!position_weights.empty()) {
        metrics.largest_exposure_symbol = position_weights[0].first;
        metrics.largest_exposure_pct = position_weights[0].second * 100.0;
    }

    // Top 5 concentration
    for (size_t i = 0; i < std::min(size_t(5), position_weights.size()); i++) {
        metrics.top_5_concentration_pct += position_weights[i].second * 100.0;
    }

    // Top 10 concentration
    for (size_t i = 0; i < std::min(size_t(10), position_weights.size()); i++) {
        metrics.top_10_concentration_pct += position_weights[i].second * 100.0;
    }

    // Scale HHI to 0-10000
    metrics.herfindahl_index *= 10000.0;

    return metrics;
}

inline bool ExposureManager::checkExposureLimit(
    ExposureCategory category,
    const std::string& subcategory,
    double additional_exposure,
    std::string& rejection_reason) const {

    // Calculate current exposure
    auto current_exposure = calculateExposure(category, subcategory);

    // Get limit
    std::shared_lock<std::shared_mutex> lock(limits_mutex_);
    std::string limit_key = std::to_string(static_cast<int>(category)) +
                           "|" + subcategory;

    auto it = exposure_limits_.find(limit_key);
    if (it == exposure_limits_.end()) {
        return true;  // No limit configured
    }

    const auto& limit = it->second;
    lock.unlock();

    // Project new exposure
    double projected_gross = current_exposure.gross_exposure + std::abs(additional_exposure);
    double projected_net = current_exposure.net_exposure + additional_exposure;

    // Check gross limit
    if (limit.max_gross_exposure > 0 && projected_gross > limit.max_gross_exposure) {
        rejection_reason = "Projected gross exposure " +
                          std::to_string(projected_gross) +
                          " exceeds limit " +
                          std::to_string(limit.max_gross_exposure) +
                          " for " + subcategory;
        return false;
    }

    // Check net limit
    if (limit.max_net_exposure > 0 &&
        std::abs(projected_net) > limit.max_net_exposure) {
        rejection_reason = "Projected net exposure " +
                          std::to_string(projected_net) +
                          " exceeds limit " +
                          std::to_string(limit.max_net_exposure) +
                          " for " + subcategory;
        return false;
    }

    // Check percentage limits
    double portfolio_value = calculatePortfolioValue();
    if (portfolio_value > 0) {
        double projected_gross_pct = (projected_gross / portfolio_value) * 100.0;
        if (limit.max_gross_pct > 0 && projected_gross_pct > limit.max_gross_pct) {
            rejection_reason = "Projected gross exposure " +
                              std::to_string(projected_gross_pct) +
                              "% exceeds limit " +
                              std::to_string(limit.max_gross_pct) +
                              "% for " + subcategory;
            return false;
        }
    }

    return true;
}

inline std::vector<HedgeRecommendation>
ExposureManager::generateHedgeRecommendations(
    double max_exposure_deviation) const {

    std::vector<HedgeRecommendation> recommendations;

    // Get all exposures
    auto exposures = calculateAllExposures();

    for (const auto& exposure : exposures) {
        // Check if exposure exceeds target
        if (exposure.limit_breached ||
            std::abs(exposure.net_exposure) > exposure.gross_limit * max_exposure_deviation) {

            // Generate hedge recommendation
            HedgeRecommendation hedge = createHedgeForExposure(exposure);
            recommendations.push_back(hedge);
        }
    }

    // Sort by priority
    std::sort(recommendations.begin(), recommendations.end(),
             [](const auto& a, const auto& b) {
                 return a.priority < b.priority;
             });

    return recommendations;
}

inline HedgeRecommendation ExposureManager::createHedgeForExposure(
    const ExposureRecord& exposure) const {

    HedgeRecommendation hedge;
    hedge.hedge_id = "HDG_" + std::to_string(
        std::chrono::system_clock::now().time_since_epoch().count());
    hedge.exposure_type = exposure.subcategory;

    // Determine hedge instrument (simplified)
    if (exposure.category == ExposureCategory::SECTOR) {
        // Use sector ETF
        hedge.instrument = exposure.subcategory + "_ETF";
    } else if (exposure.category == ExposureCategory::MARKET) {
        // Use index futures
        hedge.instrument = "SPY";  // S&P 500 ETF
    }

    // Calculate hedge quantity
    // Simplified: hedge 100% of net exposure
    hedge.notional = std::abs(exposure.net_exposure);

    // Side: opposite of current exposure
    hedge.side = (exposure.net_exposure > 0) ? 'S' : 'B';

    // Priority: based on how much limit is breached
    if (exposure.limit_breached) {
        hedge.priority = 1;  // High priority
    } else {
        hedge.priority = 3;  // Medium priority
    }

    hedge.reason = "Reduce " + exposure.subcategory + " exposure";
    hedge.recommendation_time = std::chrono::system_clock::now();

    return hedge;
}

} // namespace risk
} // namespace hft

#endif // EXPOSURE_MANAGER_HPP
```

================================================================================
3. SECTOR EXPOSURE CLASSIFICATION
================================================================================

3.1 GICS Sector Classification
-------------------------------

```cpp
// sector_classifier.hpp

namespace hft {
namespace risk {

class SectorClassifier {
public:
    // GICS Level 1 Sectors
    enum class GICSSector {
        ENERGY,
        MATERIALS,
        INDUSTRIALS,
        CONSUMER_DISCRETIONARY,
        CONSUMER_STAPLES,
        HEALTHCARE,
        FINANCIALS,
        INFORMATION_TECHNOLOGY,
        COMMUNICATION_SERVICES,
        UTILITIES,
        REAL_ESTATE
    };

    // Classify symbol to sector
    static GICSSector classifySymbol(const std::string& symbol) {
        // In production, lookup from database or reference data
        // Simplified mapping
        static const std::unordered_map<std::string, GICSSector> sector_map = {
            {"AAPL", GICSSector::INFORMATION_TECHNOLOGY},
            {"MSFT", GICSSector::INFORMATION_TECHNOLOGY},
            {"GOOGL", GICSSector::COMMUNICATION_SERVICES},
            {"JPM", GICSSector::FINANCIALS},
            {"XOM", GICSSector::ENERGY},
            {"JNJ", GICSSector::HEALTHCARE},
            {"WMT", GICSSector::CONSUMER_STAPLES},
            {"AMZN", GICSSector::CONSUMER_DISCRETIONARY}
        };

        auto it = sector_map.find(symbol);
        if (it != sector_map.end()) {
            return it->second;
        }

        return GICSSector::INDUSTRIALS;  // Default
    }

    static std::string sectorToString(GICSSector sector) {
        switch (sector) {
            case GICSSector::ENERGY: return "Energy";
            case GICSSector::MATERIALS: return "Materials";
            case GICSSector::INDUSTRIALS: return "Industrials";
            case GICSSector::CONSUMER_DISCRETIONARY: return "Consumer Discretionary";
            case GICSSector::CONSUMER_STAPLES: return "Consumer Staples";
            case GICSSector::HEALTHCARE: return "Healthcare";
            case GICSSector::FINANCIALS: return "Financials";
            case GICSSector::INFORMATION_TECHNOLOGY: return "Information Technology";
            case GICSSector::COMMUNICATION_SERVICES: return "Communication Services";
            case GICSSector::UTILITIES: return "Utilities";
            case GICSSector::REAL_ESTATE: return "Real Estate";
            default: return "Unknown";
        }
    }

    // Get sector correlations
    static double getSectorCorrelation(GICSSector sector1, GICSSector sector2) {
        // In production, calculate from historical data
        // Simplified correlation matrix
        if (sector1 == sector2) {
            return 1.0;
        }

        // Tech and Communication tend to be correlated
        if ((sector1 == GICSSector::INFORMATION_TECHNOLOGY &&
             sector2 == GICSSector::COMMUNICATION_SERVICES) ||
            (sector2 == GICSSector::INFORMATION_TECHNOLOGY &&
             sector1 == GICSSector::COMMUNICATION_SERVICES)) {
            return 0.7;
        }

        // Default inter-sector correlation
        return 0.3;
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
4. CURRENCY EXPOSURE MANAGEMENT
================================================================================

4.1 FX Exposure Tracking
-------------------------

```cpp
// fx_exposure_manager.hpp

namespace hft {
namespace risk {

class FXExposureManager {
public:
    struct CurrencyExposure {
        std::string currency;
        double net_exposure_base;       // In base currency (USD)
        double net_exposure_foreign;    // In foreign currency
        double fx_rate;                 // Current FX rate
        double fx_delta;                // Sensitivity to FX move
        double fx_var;                  // FX VaR component
    };

    // Calculate FX exposure
    std::vector<CurrencyExposure> calculateFXExposure(
        const std::string& base_currency) const {

        std::vector<CurrencyExposure> exposures;
        std::unordered_map<std::string, double> currency_totals;

        // Aggregate positions by currency
        for (const auto& [key, pos] : positions_) {
            if (pos.currency != base_currency) {
                currency_totals[pos.currency] += pos.market_value;
            }
        }

        // Create exposure records
        for (const auto& [currency, exposure] : currency_totals) {
            CurrencyExposure fx_exp;
            fx_exp.currency = currency;
            fx_exp.net_exposure_base = exposure;
            fx_exp.fx_rate = getFXRate(currency, base_currency);
            fx_exp.net_exposure_foreign = exposure * fx_exp.fx_rate;

            // Calculate FX delta (1% move in FX)
            fx_exp.fx_delta = exposure * 0.01;

            exposures.push_back(fx_exp);
        }

        return exposures;
    }

    // Generate FX hedge recommendations
    std::vector<HedgeRecommendation> generateFXHedges(
        const std::vector<CurrencyExposure>& exposures,
        double hedge_ratio = 0.8) const {

        std::vector<HedgeRecommendation> hedges;

        for (const auto& exp : exposures) {
            if (std::abs(exp.net_exposure_base) > 1000000) {  // $1M threshold
                HedgeRecommendation hedge;
                hedge.exposure_type = "FX_" + exp.currency;
                hedge.instrument = exp.currency + "USD_FWD";  // FX forward
                hedge.notional = exp.net_exposure_base * hedge_ratio;
                hedge.side = (exp.net_exposure_base > 0) ? 'S' : 'B';
                hedge.reason = "Hedge FX exposure in " + exp.currency;
                hedge.priority = 2;

                hedges.push_back(hedge);
            }
        }

        return hedges;
    }

private:
    double getFXRate(const std::string& from_currency,
                    const std::string& to_currency) const {
        // In production, get from FX rate service
        return 1.0;  // Placeholder
    }

    std::unordered_map<std::string, PositionRecord> positions_;
};

} // namespace risk
} // namespace hft
```

================================================================================
5. AUTOMATED HEDGING SYSTEM
================================================================================

5.1 Dynamic Hedging Engine
---------------------------

```cpp
// dynamic_hedging.hpp

namespace hft {
namespace risk {

class DynamicHedgingEngine {
public:
    struct HedgingStrategy {
        std::string name;
        double target_hedge_ratio;      // 0-1 (0% - 100%)
        double rehedge_threshold;       // % deviation to trigger rehedge
        std::chrono::minutes rehedge_interval;
        bool enable_dynamic_adjustment;
        double cost_threshold;          // Max cost for hedge
    };

    // Calculate optimal hedge ratio
    static double calculateOptimalHedgeRatio(
        double exposure,
        double hedging_cost,
        double expected_return,
        double risk_aversion) {

        // Simplified optimization
        // In production, use more sophisticated optimization
        double cost_penalty = hedging_cost * risk_aversion;
        double optimal_ratio = 1.0 - cost_penalty / expected_return;

        return std::clamp(optimal_ratio, 0.0, 1.0);
    }

    // Dynamic delta hedging for options
    struct DeltaHedge {
        double current_delta;
        double target_delta;
        double hedge_quantity;
        std::string hedge_instrument;
        double estimated_cost;
    };

    static DeltaHedge calculateDeltaHedge(
        double current_delta,
        double target_delta,
        const std::string& underlying) {

        DeltaHedge hedge;
        hedge.current_delta = current_delta;
        hedge.target_delta = target_delta;
        hedge.hedge_quantity = target_delta - current_delta;
        hedge.hedge_instrument = underlying;
        hedge.estimated_cost = std::abs(hedge.hedge_quantity) * 0.001;  // Estimate

        return hedge;
    }

    // Gamma scalping strategy
    struct GammaScalpingSignal {
        double realized_pnl;
        double theorical_pnl;
        double gamma_pnl;
        bool should_rehedge;
        double rehedge_quantity;
    };

    static GammaScalpingSignal evaluateGammaScalping(
        double gamma,
        double spot_change,
        double hedge_cost) {

        GammaScalpingSignal signal;

        // Gamma P&L from spot movement
        signal.gamma_pnl = 0.5 * gamma * spot_change * spot_change;

        // Should rehedge if profit exceeds cost
        signal.should_rehedge = (signal.gamma_pnl > hedge_cost * 2);

        if (signal.should_rehedge) {
            signal.rehedge_quantity = gamma * spot_change;
        }

        return signal;
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
6. EXPOSURE LIMITS CONFIGURATION
================================================================================

6.1 Exposure Limit Configuration File
--------------------------------------

```json
{
  "exposure_limits": {
    "global_settings": {
      "enable_exposure_monitoring": true,
      "monitoring_frequency_ms": 1000,
      "auto_hedge_enabled": false,
      "default_hedge_ratio": 0.8
    },

    "sector_limits": [
      {
        "sector": "Information Technology",
        "max_gross_exposure": 50000000,
        "max_net_exposure": 25000000,
        "max_gross_pct": 30.0,
        "max_net_pct": 15.0,
        "warning_threshold_pct": 80.0,
        "auto_hedge_on_breach": true
      },
      {
        "sector": "Financials",
        "max_gross_exposure": 30000000,
        "max_net_exposure": 15000000,
        "max_gross_pct": 20.0,
        "max_net_pct": 10.0
      }
    ],

    "geography_limits": [
      {
        "geography": "United States",
        "max_gross_exposure": 100000000,
        "max_net_exposure": 50000000,
        "max_gross_pct": 60.0
      },
      {
        "geography": "Europe",
        "max_gross_exposure": 40000000,
        "max_net_exposure": 20000000,
        "max_gross_pct": 25.0
      },
      {
        "geography": "Asia",
        "max_gross_exposure": 30000000,
        "max_net_exposure": 15000000,
        "max_gross_pct": 20.0
      }
    ],

    "currency_limits": [
      {
        "currency": "EUR",
        "max_exposure": 20000000,
        "auto_hedge_threshold": 10000000,
        "target_hedge_ratio": 0.9
      },
      {
        "currency": "GBP",
        "max_exposure": 15000000,
        "auto_hedge_threshold": 8000000,
        "target_hedge_ratio": 0.9
      }
    ],

    "greek_limits": {
      "max_delta_exposure": 10000000,
      "max_gamma_per_percent": 50000,
      "max_vega_exposure": 100000,
      "max_theta_per_day": -50000
    },

    "concentration_limits": {
      "max_single_position_pct": 5.0,
      "max_top_5_concentration_pct": 20.0,
      "max_top_10_concentration_pct": 35.0,
      "max_herfindahl_index": 1000
    }
  }
}
```

================================================================================
7. TESTING FRAMEWORK
================================================================================

7.1 Exposure Management Tests
------------------------------

```cpp
TEST(ExposureManager, CalculatesSectorExposure) {
    ExposureManager manager;

    // Add tech positions
    std::unordered_map<std::string, std::string> attrs;
    attrs["sector"] = "Technology";

    manager.updatePosition("AAPL", "ACC001", 1000, 150.0, attrs);
    manager.updatePosition("MSFT", "ACC001", 500, 300.0, attrs);

    auto tech_exposure = manager.calculateExposure(
        ExposureCategory::SECTOR, "Technology");

    EXPECT_DOUBLE_EQ(tech_exposure.gross_exposure, 150000 + 150000);
    EXPECT_DOUBLE_EQ(tech_exposure.net_exposure, 300000);
}

TEST(ExposureManager, DetectsLimitBreach) {
    ExposureManager manager;

    ExposureLimit limit;
    limit.category = ExposureCategory::SECTOR;
    limit.subcategory = "Technology";
    limit.max_gross_exposure = 200000;

    manager.setExposureLimit(limit);

    std::string rejection_reason;
    bool can_add = manager.checkExposureLimit(
        ExposureCategory::SECTOR,
        "Technology",
        250000,  // Would exceed limit
        rejection_reason);

    EXPECT_FALSE(can_add);
    EXPECT_NE(rejection_reason.find("exceeds limit"), std::string::npos);
}

================================================================================
END OF EXPOSURE MANAGEMENT DOCUMENTATION
================================================================================
