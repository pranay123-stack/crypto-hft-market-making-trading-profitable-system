================================================================================
POSITION LIMITS AND CONTROLS - HFT RISK MANAGEMENT SYSTEM
================================================================================
Version: 2.1.0
Last Updated: 2025-11-25
Author: HFT Risk Management Team
Purpose: Real-time position limit enforcement and control mechanisms

================================================================================
1. POSITION LIMIT FRAMEWORK
================================================================================

1.1 Multi-Tier Position Limit Architecture
-------------------------------------------

Position limits are enforced at multiple hierarchical levels:

Level 1: Instrument-Level Limits
  - Per-symbol position limits
  - Notional exposure limits
  - Order size restrictions
  - Time-based position decay

Level 2: Strategy-Level Limits
  - Total strategy exposure
  - Cross-instrument correlations
  - Strategy-specific risk budgets
  - Alpha model confidence thresholds

Level 3: Portfolio-Level Limits
  - Global net exposure
  - Gross leverage limits
  - Sector concentration limits
  - Geographic exposure limits

Level 4: Regulatory Limits
  - Exchange position limits
  - Large trader reporting thresholds
  - Market manipulation safeguards
  - Circuit breaker compliance

================================================================================
2. C++ POSITION LIMIT ENGINE IMPLEMENTATION
================================================================================

2.1 Core Position Limit Manager
--------------------------------

```cpp
// position_limit_manager.hpp
#ifndef POSITION_LIMIT_MANAGER_HPP
#define POSITION_LIMIT_MANAGER_HPP

#include <string>
#include <unordered_map>
#include <shared_mutex>
#include <atomic>
#include <chrono>
#include <vector>
#include <optional>
#include <memory>

namespace hft {
namespace risk {

// Position limit types enumeration
enum class LimitType {
    HARD_LIMIT,           // Absolute hard stop
    SOFT_LIMIT,           // Warning threshold
    REGULATORY_LIMIT,     // Exchange/regulatory limit
    INTERNAL_LIMIT,       // Firm internal limit
    DYNAMIC_LIMIT         // Adaptive limit based on market conditions
};

// Limit violation severity
enum class ViolationSeverity {
    INFO,                 // Informational
    WARNING,              // Approaching limit
    CRITICAL,             // At limit threshold
    EMERGENCY             // Exceeded limit - emergency action
};

// Position limit configuration
struct PositionLimit {
    std::string symbol;
    std::string strategy_id;

    // Quantity limits
    int64_t max_long_position;
    int64_t max_short_position;
    int64_t max_gross_position;

    // Notional limits (in base currency)
    double max_long_notional;
    double max_short_notional;
    double max_gross_notional;

    // Order size limits
    int64_t max_order_size;
    int64_t max_orders_per_second;

    // Time-based limits
    int64_t max_daily_volume;
    double max_daily_pnl_loss;

    // Limit metadata
    LimitType limit_type;
    double warning_threshold_pct;  // % of limit for warning
    bool auto_liquidate_on_breach;

    // Dynamic limit parameters
    bool is_dynamic;
    double volatility_scaling_factor;
    double liquidity_scaling_factor;

    std::chrono::system_clock::time_point effective_time;
    std::chrono::system_clock::time_point expiry_time;
};

// Position state tracking
struct PositionState {
    std::string symbol;
    std::string strategy_id;

    // Current positions
    int64_t long_position;
    int64_t short_position;
    int64_t net_position;
    int64_t gross_position;

    // Current notional
    double long_notional;
    double short_notional;
    double net_notional;
    double gross_notional;

    // Intraday metrics
    int64_t orders_sent_today;
    int64_t volume_traded_today;
    double realized_pnl_today;
    double unrealized_pnl;

    // Timestamps
    std::chrono::system_clock::time_point last_update;
    std::chrono::system_clock::time_point session_start;
};

// Limit violation event
struct LimitViolation {
    std::string violation_id;
    std::string symbol;
    std::string strategy_id;

    LimitType limit_type;
    ViolationSeverity severity;

    std::string limit_field;      // Which limit was violated
    double limit_value;
    double current_value;
    double breach_amount;
    double breach_percentage;

    std::string action_taken;
    bool auto_resolved;

    std::chrono::system_clock::time_point violation_time;
    std::chrono::system_clock::time_point resolution_time;

    std::string description;
};

class PositionLimitManager {
public:
    PositionLimitManager();
    ~PositionLimitManager();

    // Limit configuration
    bool addLimit(const std::string& symbol,
                  const std::string& strategy_id,
                  const PositionLimit& limit);

    bool updateLimit(const std::string& symbol,
                     const std::string& strategy_id,
                     const PositionLimit& limit);

    bool removeLimit(const std::string& symbol,
                     const std::string& strategy_id);

    std::optional<PositionLimit> getLimit(const std::string& symbol,
                                          const std::string& strategy_id) const;

    // Pre-trade limit checks
    bool canTrade(const std::string& symbol,
                  const std::string& strategy_id,
                  int64_t quantity,
                  double price,
                  std::string& rejection_reason);

    bool checkOrderSize(const std::string& symbol,
                       const std::string& strategy_id,
                       int64_t quantity,
                       std::string& rejection_reason);

    bool checkPositionLimit(const std::string& symbol,
                           const std::string& strategy_id,
                           int64_t quantity,
                           std::string& rejection_reason);

    bool checkNotionalLimit(const std::string& symbol,
                           const std::string& strategy_id,
                           double notional_delta,
                           std::string& rejection_reason);

    bool checkRateLimit(const std::string& symbol,
                       const std::string& strategy_id,
                       std::string& rejection_reason);

    // Position state updates
    void updatePosition(const std::string& symbol,
                       const std::string& strategy_id,
                       int64_t quantity,
                       double price);

    void updatePnL(const std::string& symbol,
                   const std::string& strategy_id,
                   double realized_pnl,
                   double unrealized_pnl);

    PositionState getPositionState(const std::string& symbol,
                                   const std::string& strategy_id) const;

    // Limit monitoring
    std::vector<LimitViolation> checkAllLimits();
    std::vector<std::string> getSymbolsNearLimit(double threshold_pct) const;

    // Dynamic limit adjustment
    void adjustDynamicLimits(const std::string& symbol,
                            double volatility,
                            double liquidity_factor);

    void scaleAllLimits(double scaling_factor);

    // Session management
    void startNewSession();
    void endSession();
    void resetDailyCounters();

    // Statistics and reporting
    struct LimitUtilization {
        std::string symbol;
        std::string strategy_id;
        double position_utilization_pct;
        double notional_utilization_pct;
        double order_rate_utilization_pct;
    };

    std::vector<LimitUtilization> getLimitUtilization() const;

    size_t getViolationCount() const { return violation_count_.load(); }
    std::vector<LimitViolation> getRecentViolations(size_t max_count) const;

private:
    // Internal key generation
    std::string makeKey(const std::string& symbol,
                       const std::string& strategy_id) const;

    // Limit checking helpers
    bool checkSingleLimit(const PositionLimit& limit,
                         const PositionState& state,
                         int64_t quantity_delta,
                         double notional_delta,
                         std::string& rejection_reason);

    ViolationSeverity calculateViolationSeverity(double current,
                                                 double limit,
                                                 double warning_threshold_pct);

    void recordViolation(const LimitViolation& violation);
    void handleLimitBreach(const LimitViolation& violation);

    // Data structures
    mutable std::shared_mutex limits_mutex_;
    std::unordered_map<std::string, PositionLimit> limits_;

    mutable std::shared_mutex positions_mutex_;
    std::unordered_map<std::string, PositionState> positions_;

    mutable std::shared_mutex violations_mutex_;
    std::vector<LimitViolation> violations_history_;

    // Counters
    std::atomic<uint64_t> violation_count_{0};
    std::atomic<uint64_t> check_count_{0};

    // Session state
    std::chrono::system_clock::time_point session_start_;
    std::atomic<bool> session_active_{false};
};

// Implementation
inline std::string PositionLimitManager::makeKey(
    const std::string& symbol,
    const std::string& strategy_id) const {
    return symbol + "|" + strategy_id;
}

inline bool PositionLimitManager::addLimit(
    const std::string& symbol,
    const std::string& strategy_id,
    const PositionLimit& limit) {

    std::unique_lock<std::shared_mutex> lock(limits_mutex_);
    std::string key = makeKey(symbol, strategy_id);
    limits_[key] = limit;
    return true;
}

inline bool PositionLimitManager::updateLimit(
    const std::string& symbol,
    const std::string& strategy_id,
    const PositionLimit& limit) {

    return addLimit(symbol, strategy_id, limit);
}

inline bool PositionLimitManager::removeLimit(
    const std::string& symbol,
    const std::string& strategy_id) {

    std::unique_lock<std::shared_mutex> lock(limits_mutex_);
    std::string key = makeKey(symbol, strategy_id);
    return limits_.erase(key) > 0;
}

inline std::optional<PositionLimit> PositionLimitManager::getLimit(
    const std::string& symbol,
    const std::string& strategy_id) const {

    std::shared_lock<std::shared_mutex> lock(limits_mutex_);
    std::string key = makeKey(symbol, strategy_id);
    auto it = limits_.find(key);
    if (it != limits_.end()) {
        return it->second;
    }
    return std::nullopt;
}

inline bool PositionLimitManager::canTrade(
    const std::string& symbol,
    const std::string& strategy_id,
    int64_t quantity,
    double price,
    std::string& rejection_reason) {

    check_count_.fetch_add(1, std::memory_order_relaxed);

    // Check order size limit
    if (!checkOrderSize(symbol, strategy_id, quantity, rejection_reason)) {
        return false;
    }

    // Check rate limit
    if (!checkRateLimit(symbol, strategy_id, rejection_reason)) {
        return false;
    }

    // Check position limit
    if (!checkPositionLimit(symbol, strategy_id, quantity, rejection_reason)) {
        return false;
    }

    // Check notional limit
    double notional_delta = std::abs(quantity * price);
    if (!checkNotionalLimit(symbol, strategy_id, notional_delta, rejection_reason)) {
        return false;
    }

    return true;
}

inline bool PositionLimitManager::checkOrderSize(
    const std::string& symbol,
    const std::string& strategy_id,
    int64_t quantity,
    std::string& rejection_reason) {

    auto limit_opt = getLimit(symbol, strategy_id);
    if (!limit_opt) {
        return true; // No limit configured
    }

    const auto& limit = *limit_opt;
    if (std::abs(quantity) > limit.max_order_size) {
        rejection_reason = "Order size " + std::to_string(std::abs(quantity)) +
                          " exceeds limit " + std::to_string(limit.max_order_size);
        return false;
    }

    return true;
}

inline bool PositionLimitManager::checkPositionLimit(
    const std::string& symbol,
    const std::string& strategy_id,
    int64_t quantity,
    std::string& rejection_reason) {

    auto limit_opt = getLimit(symbol, strategy_id);
    if (!limit_opt) {
        return true;
    }

    const auto& limit = *limit_opt;
    auto state = getPositionState(symbol, strategy_id);

    int64_t projected_position = state.net_position + quantity;

    // Check long position limit
    if (projected_position > limit.max_long_position) {
        rejection_reason = "Projected long position " +
                          std::to_string(projected_position) +
                          " exceeds limit " +
                          std::to_string(limit.max_long_position);
        return false;
    }

    // Check short position limit
    if (projected_position < -limit.max_short_position) {
        rejection_reason = "Projected short position " +
                          std::to_string(-projected_position) +
                          " exceeds limit " +
                          std::to_string(limit.max_short_position);
        return false;
    }

    // Check gross position limit
    int64_t projected_gross = std::abs(projected_position);
    if (projected_gross > limit.max_gross_position) {
        rejection_reason = "Projected gross position " +
                          std::to_string(projected_gross) +
                          " exceeds limit " +
                          std::to_string(limit.max_gross_position);
        return false;
    }

    return true;
}

inline void PositionLimitManager::updatePosition(
    const std::string& symbol,
    const std::string& strategy_id,
    int64_t quantity,
    double price) {

    std::unique_lock<std::shared_mutex> lock(positions_mutex_);
    std::string key = makeKey(symbol, strategy_id);

    auto& state = positions_[key];
    state.symbol = symbol;
    state.strategy_id = strategy_id;

    // Update position
    state.net_position += quantity;
    if (quantity > 0) {
        state.long_position += quantity;
        state.long_notional += quantity * price;
    } else {
        state.short_position += std::abs(quantity);
        state.short_notional += std::abs(quantity * price);
    }

    state.gross_position = std::abs(state.net_position);
    state.net_notional = state.long_notional - state.short_notional;
    state.gross_notional = state.long_notional + state.short_notional;

    // Update intraday metrics
    state.volume_traded_today += std::abs(quantity);
    state.orders_sent_today++;

    state.last_update = std::chrono::system_clock::now();
}

} // namespace risk
} // namespace hft

#endif // POSITION_LIMIT_MANAGER_HPP
```

================================================================================
3. POSITION CONTROL ALGORITHMS
================================================================================

3.1 Adaptive Position Sizing
-----------------------------

Algorithm: Volatility-Adjusted Position Limits

```cpp
// adaptive_position_control.hpp

namespace hft {
namespace risk {

class AdaptivePositionControl {
public:
    // Calculate optimal position size based on volatility
    static int64_t calculateOptimalSize(
        int64_t base_limit,
        double current_volatility,
        double reference_volatility,
        double max_scaling = 2.0,
        double min_scaling = 0.5) {

        if (current_volatility <= 0 || reference_volatility <= 0) {
            return base_limit;
        }

        // Inverse volatility scaling
        double volatility_ratio = reference_volatility / current_volatility;
        double scaling_factor = std::clamp(volatility_ratio, min_scaling, max_scaling);

        return static_cast<int64_t>(base_limit * scaling_factor);
    }

    // Kelly Criterion position sizing
    static int64_t kellyPositionSize(
        double win_probability,
        double win_loss_ratio,
        int64_t max_capital,
        double kelly_fraction = 0.25) {  // Use fractional Kelly for safety

        if (win_probability <= 0 || win_probability >= 1) {
            return 0;
        }

        // Kelly formula: f = (p * b - q) / b
        // where p = win prob, q = loss prob, b = win/loss ratio
        double kelly_pct = (win_probability * win_loss_ratio - (1 - win_probability))
                          / win_loss_ratio;

        kelly_pct = std::max(0.0, kelly_pct) * kelly_fraction;

        return static_cast<int64_t>(max_capital * kelly_pct);
    }

    // Time-based position decay
    static int64_t applyTimeDecay(
        int64_t base_limit,
        std::chrono::seconds time_in_position,
        std::chrono::seconds half_life) {

        if (time_in_position.count() <= 0) {
            return base_limit;
        }

        double decay_factor = std::exp(-0.693147 * time_in_position.count()
                                      / half_life.count());

        return static_cast<int64_t>(base_limit * decay_factor);
    }

    // Liquidity-adjusted position limits
    static int64_t liquidityAdjustedLimit(
        int64_t base_limit,
        double average_daily_volume,
        double participation_rate_limit = 0.05) {  // Max 5% of ADV

        int64_t liquidity_limit = static_cast<int64_t>(
            average_daily_volume * participation_rate_limit
        );

        return std::min(base_limit, liquidity_limit);
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
4. POSITION CONCENTRATION CONTROLS
================================================================================

4.1 Sector and Geographic Concentration Limits
-----------------------------------------------

```cpp
// concentration_control.hpp

namespace hft {
namespace risk {

struct ConcentrationLimit {
    std::string category;           // Sector, geography, asset class
    double max_net_exposure_pct;    // Max net exposure as % of portfolio
    double max_gross_exposure_pct;  // Max gross exposure as % of portfolio
    int max_number_of_positions;    // Max number of positions in category
    double correlation_threshold;    // Max avg correlation within category
};

class ConcentrationMonitor {
public:
    // Check sector concentration
    bool checkSectorConcentration(
        const std::string& sector,
        double portfolio_nav,
        double additional_exposure,
        const ConcentrationLimit& limit,
        std::string& rejection_reason) {

        double current_exposure = getSectorExposure(sector);
        double projected_exposure = current_exposure + additional_exposure;
        double exposure_pct = (projected_exposure / portfolio_nav) * 100.0;

        if (exposure_pct > limit.max_gross_exposure_pct) {
            rejection_reason = "Sector " + sector + " exposure " +
                             std::to_string(exposure_pct) + "% exceeds limit " +
                             std::to_string(limit.max_gross_exposure_pct) + "%";
            return false;
        }

        return true;
    }

    // Calculate correlation-based concentration risk
    double calculateConcentrationRisk(
        const std::vector<std::string>& symbols,
        const std::vector<double>& weights) {

        if (symbols.size() != weights.size() || symbols.empty()) {
            return 0.0;
        }

        // Simplified Herfindahl-Hirschman Index (HHI)
        double hhi = 0.0;
        for (double weight : weights) {
            hhi += weight * weight;
        }

        // Normalize to 0-1 scale
        return hhi * 10000.0;  // Traditional HHI scaling
    }

private:
    double getSectorExposure(const std::string& sector) {
        // Implementation to calculate current sector exposure
        return 0.0;  // Placeholder
    }

    std::unordered_map<std::string, double> sector_exposures_;
};

} // namespace risk
} // namespace hft
```

================================================================================
5. KILL SWITCH IMPLEMENTATION
================================================================================

5.1 Position Limit Kill Switch
-------------------------------

```cpp
// position_kill_switch.hpp

namespace hft {
namespace risk {

enum class KillSwitchTrigger {
    POSITION_LIMIT_BREACH,
    RAPID_POSITION_BUILDUP,
    UNAUTHORIZED_POSITION,
    SYSTEM_ANOMALY,
    MANUAL_TRIGGER
};

class PositionKillSwitch {
public:
    PositionKillSwitch() : engaged_(false) {}

    // Engage kill switch - stops all trading
    void engage(KillSwitchTrigger trigger, const std::string& reason) {
        std::unique_lock<std::mutex> lock(mutex_);

        if (engaged_.load()) {
            return;  // Already engaged
        }

        engaged_.store(true);
        trigger_ = trigger;
        reason_ = reason;
        trigger_time_ = std::chrono::system_clock::now();

        // Log critical event
        logCriticalEvent("KILL SWITCH ENGAGED", reason);

        // Cancel all pending orders
        cancelAllOrders();

        // Flatten positions if configured
        if (auto_flatten_on_trigger_) {
            flattenAllPositions();
        }

        // Notify stakeholders
        notifyStakeholders(trigger, reason);
    }

    // Disengage kill switch - requires manual approval
    bool disengage(const std::string& authorized_user,
                   const std::string& approval_code) {

        if (!verifyAuthorization(authorized_user, approval_code)) {
            return false;
        }

        std::unique_lock<std::mutex> lock(mutex_);
        engaged_.store(false);
        disengage_time_ = std::chrono::system_clock::now();

        logCriticalEvent("KILL SWITCH DISENGAGED",
                        "Disengaged by " + authorized_user);

        return true;
    }

    bool isEngaged() const { return engaged_.load(); }

    // Pre-trade check
    bool allowTrade() const {
        return !engaged_.load();
    }

private:
    void cancelAllOrders() {
        // Implementation to cancel all active orders
    }

    void flattenAllPositions() {
        // Implementation to flatten all positions
    }

    void notifyStakeholders(KillSwitchTrigger trigger,
                           const std::string& reason) {
        // Send alerts to risk managers, traders, compliance
    }

    bool verifyAuthorization(const std::string& user,
                            const std::string& code) {
        // Verify user has authority to disengage kill switch
        return true;  // Placeholder
    }

    void logCriticalEvent(const std::string& event,
                         const std::string& details) {
        // Log to critical event log
    }

    std::atomic<bool> engaged_;
    KillSwitchTrigger trigger_;
    std::string reason_;
    std::chrono::system_clock::time_point trigger_time_;
    std::chrono::system_clock::time_point disengage_time_;

    bool auto_flatten_on_trigger_ = true;
    std::mutex mutex_;
};

} // namespace risk
} // namespace hft
```

================================================================================
6. ALERT MECHANISMS
================================================================================

6.1 Position Limit Alert System
--------------------------------

```cpp
// position_alerts.hpp

namespace hft {
namespace risk {

enum class AlertLevel {
    INFO,
    WARNING,
    CRITICAL,
    EMERGENCY
};

struct PositionAlert {
    std::string alert_id;
    AlertLevel level;
    std::string symbol;
    std::string strategy_id;
    std::string message;
    std::chrono::system_clock::time_point timestamp;
    bool acknowledged;
};

class PositionAlertManager {
public:
    // Configure alert thresholds
    void setAlertThreshold(const std::string& symbol,
                          const std::string& metric,
                          double warning_level,
                          double critical_level) {
        std::unique_lock<std::mutex> lock(mutex_);

        std::string key = symbol + "|" + metric;
        thresholds_[key] = {warning_level, critical_level};
    }

    // Check and generate alerts
    void checkPositionAlerts(const PositionState& state,
                            const PositionLimit& limit) {

        // Check position utilization
        double long_utilization = (double)state.long_position / limit.max_long_position;
        if (long_utilization > 0.9) {
            generateAlert(AlertLevel::CRITICAL, state.symbol, state.strategy_id,
                        "Long position at " + std::to_string(long_utilization * 100) +
                        "% of limit");
        } else if (long_utilization > 0.75) {
            generateAlert(AlertLevel::WARNING, state.symbol, state.strategy_id,
                        "Long position at " + std::to_string(long_utilization * 100) +
                        "% of limit");
        }

        // Check notional utilization
        double notional_utilization = state.gross_notional / limit.max_gross_notional;
        if (notional_utilization > 0.9) {
            generateAlert(AlertLevel::CRITICAL, state.symbol, state.strategy_id,
                        "Notional exposure at " +
                        std::to_string(notional_utilization * 100) + "% of limit");
        }

        // Check PnL losses
        if (state.realized_pnl_today < -limit.max_daily_pnl_loss * 0.8) {
            generateAlert(AlertLevel::WARNING, state.symbol, state.strategy_id,
                        "Daily PnL loss at " +
                        std::to_string(state.realized_pnl_today));
        }
    }

    void generateAlert(AlertLevel level,
                      const std::string& symbol,
                      const std::string& strategy_id,
                      const std::string& message) {

        PositionAlert alert;
        alert.alert_id = generateAlertId();
        alert.level = level;
        alert.symbol = symbol;
        alert.strategy_id = strategy_id;
        alert.message = message;
        alert.timestamp = std::chrono::system_clock::now();
        alert.acknowledged = false;

        {
            std::unique_lock<std::mutex> lock(mutex_);
            active_alerts_.push_back(alert);
        }

        // Send notifications based on alert level
        if (level >= AlertLevel::CRITICAL) {
            sendEmail(alert);
            sendSMS(alert);
        }

        logAlert(alert);
    }

private:
    std::string generateAlertId() {
        static std::atomic<uint64_t> counter{0};
        return "ALT" + std::to_string(counter.fetch_add(1));
    }

    void sendEmail(const PositionAlert& alert) {
        // Email notification implementation
    }

    void sendSMS(const PositionAlert& alert) {
        // SMS notification implementation
    }

    void logAlert(const PositionAlert& alert) {
        // Log alert to database/file
    }

    std::vector<PositionAlert> active_alerts_;
    std::unordered_map<std::string, std::pair<double, double>> thresholds_;
    std::mutex mutex_;
};

} // namespace risk
} // namespace hft
```

================================================================================
7. CONFIGURATION PARAMETERS
================================================================================

7.1 Position Limit Configuration File
--------------------------------------

```json
{
  "position_limits": {
    "global_settings": {
      "enable_position_limits": true,
      "auto_liquidate_on_breach": false,
      "warning_threshold_pct": 75.0,
      "kill_switch_enabled": true
    },

    "instrument_limits": [
      {
        "symbol": "AAPL",
        "strategy_id": "MM_EQUITY_001",
        "max_long_position": 100000,
        "max_short_position": 100000,
        "max_gross_position": 150000,
        "max_long_notional": 15000000.0,
        "max_short_notional": 15000000.0,
        "max_gross_notional": 20000000.0,
        "max_order_size": 5000,
        "max_orders_per_second": 10,
        "max_daily_volume": 500000,
        "max_daily_pnl_loss": 50000.0,
        "limit_type": "INTERNAL_LIMIT",
        "is_dynamic": true,
        "volatility_scaling_factor": 0.5,
        "liquidity_scaling_factor": 0.3
      }
    ],

    "strategy_limits": [
      {
        "strategy_id": "MM_EQUITY_001",
        "max_gross_notional": 100000000.0,
        "max_net_exposure": 50000000.0,
        "max_daily_pnl_loss": 500000.0,
        "max_number_of_positions": 50
      }
    ],

    "portfolio_limits": {
      "max_gross_leverage": 3.0,
      "max_net_exposure_pct": 50.0,
      "max_sector_concentration_pct": 25.0,
      "max_single_stock_pct": 5.0
    }
  }
}
```

================================================================================
8. REAL-TIME MONITORING DASHBOARD
================================================================================

8.1 Position Limit Dashboard Metrics
-------------------------------------

Key Metrics to Display:

1. Position Utilization
   - Current position vs limit (%)
   - Long/Short breakdown
   - Time series chart

2. Notional Exposure
   - Current notional vs limit (%)
   - Gross/Net exposure
   - Currency breakdown

3. Limit Violations
   - Count of violations today
   - Severity breakdown
   - Recent violation details

4. Alert Status
   - Active alerts by level
   - Unacknowledged critical alerts
   - Alert frequency trends

5. Kill Switch Status
   - Current state (Active/Inactive)
   - Last trigger time
   - Auto-flatten status

Dashboard Implementation (Pseudo-code):

```cpp
struct DashboardMetrics {
    // Position metrics
    std::map<std::string, double> position_utilization;
    std::map<std::string, double> notional_utilization;

    // Violation metrics
    uint64_t total_violations;
    uint64_t critical_violations;
    std::vector<LimitViolation> recent_violations;

    // Alert metrics
    uint64_t active_alerts;
    uint64_t unacknowledged_critical;

    // System status
    bool kill_switch_engaged;
    std::chrono::system_clock::time_point last_update;
};
```

================================================================================
9. REGULATORY COMPLIANCE
================================================================================

9.1 Exchange Position Limit Compliance
---------------------------------------

Major exchanges have position limit requirements:

CME Futures Position Limits:
- ES (S&P 500): 20,000 contracts net position
- NQ (NASDAQ): 10,000 contracts net position
- GC (Gold): 3,000 contracts net position

CFTC Large Trader Reporting:
- Report positions exceeding specific thresholds
- Daily position reports required
- Aggregation across related accounts

Implementation:

```cpp
class RegulatoryLimitMonitor {
public:
    bool checkExchangeLimit(const std::string& symbol,
                           int64_t current_position,
                           int64_t exchange_limit) {
        return std::abs(current_position) <= exchange_limit;
    }

    bool requiresLargeTraderReport(const std::string& symbol,
                                   int64_t position) {
        auto threshold = getLargeTraderThreshold(symbol);
        return std::abs(position) >= threshold;
    }

private:
    int64_t getLargeTraderThreshold(const std::string& symbol) {
        // Return regulatory threshold for symbol
        return 25;  // Example threshold
    }
};
```

================================================================================
10. TESTING AND VALIDATION
================================================================================

10.1 Position Limit Testing Framework
--------------------------------------

```cpp
// Unit test example
TEST(PositionLimitManagerTest, ExceedLongPositionLimit) {
    PositionLimitManager manager;

    PositionLimit limit;
    limit.symbol = "AAPL";
    limit.strategy_id = "TEST_STRAT";
    limit.max_long_position = 1000;
    limit.max_short_position = 1000;
    limit.max_order_size = 100;

    manager.addLimit("AAPL", "TEST_STRAT", limit);

    // Execute trades up to limit
    for (int i = 0; i < 10; i++) {
        manager.updatePosition("AAPL", "TEST_STRAT", 100, 150.0);
    }

    // Try to exceed limit
    std::string rejection_reason;
    bool can_trade = manager.canTrade("AAPL", "TEST_STRAT", 100, 150.0,
                                     rejection_reason);

    EXPECT_FALSE(can_trade);
    EXPECT_NE(rejection_reason.find("exceeds limit"), std::string::npos);
}
```

================================================================================
END OF POSITION LIMITS AND CONTROLS DOCUMENTATION
================================================================================
