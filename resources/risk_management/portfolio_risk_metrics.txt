================================================================================
PORTFOLIO RISK METRICS (VaR, GREEKS) - HFT RISK MANAGEMENT
================================================================================
Version: 2.1.0
Last Updated: 2025-11-25
Author: HFT Risk Management Team
Purpose: Advanced portfolio risk measurement and Greek exposure management

================================================================================
1. PORTFOLIO RISK FRAMEWORK
================================================================================

1.1 Risk Metrics Overview
--------------------------

Primary Risk Metrics:

1. Value at Risk (VaR)
   - Measures potential loss over time horizon
   - Multiple calculation methods
   - Confidence levels: 95%, 99%, 99.9%

2. Expected Shortfall (ES/CVaR)
   - Average loss beyond VaR
   - Coherent risk measure
   - Better for tail risk

3. Greeks (Options Risk)
   - Delta: Price sensitivity
   - Gamma: Delta sensitivity
   - Vega: Volatility sensitivity
   - Theta: Time decay
   - Rho: Interest rate sensitivity

4. Factor Exposures
   - Market beta
   - Sector exposures
   - Style factors
   - Risk factor decomposition

5. Correlation Risk
   - Portfolio correlation
   - Correlation breakdown risk
   - Diversification metrics

================================================================================
2. C++ VALUE AT RISK IMPLEMENTATION
================================================================================

2.1 VaR Calculation Engine
---------------------------

```cpp
// var_calculator.hpp
#ifndef VAR_CALCULATOR_HPP
#define VAR_CALCULATOR_HPP

#include <vector>
#include <string>
#include <unordered_map>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <memory>

namespace hft {
namespace risk {

// VaR calculation methods
enum class VaRMethod {
    HISTORICAL,         // Historical simulation
    PARAMETRIC,         // Variance-covariance
    MONTE_CARLO,        // Monte Carlo simulation
    CORNISH_FISHER,     // Cornish-Fisher expansion
    EXTREME_VALUE       // Extreme value theory
};

// Portfolio position
struct Position {
    std::string symbol;
    std::string asset_class;
    double quantity;
    double market_price;
    double market_value;
    double beta;                    // Market beta
    std::vector<double> factor_exposures;
};

// VaR result
struct VaRResult {
    VaRMethod method;
    double confidence_level;
    int time_horizon_days;

    // VaR metrics
    double var_dollars;
    double var_pct;

    // Expected shortfall (CVaR)
    double expected_shortfall_dollars;
    double expected_shortfall_pct;

    // Component VaR
    std::unordered_map<std::string, double> component_var;

    // Marginal VaR
    std::unordered_map<std::string, double> marginal_var;

    // Incremental VaR
    std::unordered_map<std::string, double> incremental_var;

    std::chrono::system_clock::time_point calculation_time;
};

class VaRCalculator {
public:
    VaRCalculator();
    ~VaRCalculator();

    // Set portfolio positions
    void setPortfolio(const std::vector<Position>& positions);

    // Set historical returns data
    void setHistoricalReturns(
        const std::unordered_map<std::string, std::vector<double>>& returns);

    // Calculate VaR using different methods
    VaRResult calculateHistoricalVaR(
        double confidence_level = 0.99,
        int lookback_days = 250,
        int horizon_days = 1);

    VaRResult calculateParametricVaR(
        double confidence_level = 0.99,
        int horizon_days = 1);

    VaRResult calculateMonteCarloVaR(
        double confidence_level = 0.99,
        int horizon_days = 1,
        int num_simulations = 10000);

    VaRResult calculateCornishFisherVaR(
        double confidence_level = 0.99,
        int horizon_days = 1);

    // Calculate Expected Shortfall (CVaR)
    double calculateExpectedShortfall(
        const VaRResult& var_result);

    // Component VaR calculation
    std::unordered_map<std::string, double> calculateComponentVaR(
        const VaRResult& var_result);

    // Marginal VaR calculation
    std::unordered_map<std::string, double> calculateMarginalVaR();

    // Incremental VaR calculation
    double calculateIncrementalVaR(
        const std::string& symbol,
        double quantity_change);

    // Stress testing
    struct StressScenario {
        std::string name;
        std::unordered_map<std::string, double> symbol_shocks;  // % change
        double correlation_shock;                                // New correlation
    };

    double stressTest(const StressScenario& scenario);

    std::vector<std::pair<std::string, double>> runStressScenarios(
        const std::vector<StressScenario>& scenarios);

private:
    // Helper methods
    std::vector<double> calculatePortfolioReturns() const;

    Eigen::MatrixXd calculateCovarianceMatrix() const;

    double calculatePortfolioVariance(
        const Eigen::VectorXd& weights,
        const Eigen::MatrixXd& cov_matrix) const;

    double getZScore(double confidence_level) const;

    std::vector<double> generateCorrelatedReturns(
        const Eigen::MatrixXd& cov_matrix,
        int num_samples);

    // Data
    std::vector<Position> portfolio_;
    std::unordered_map<std::string, std::vector<double>> historical_returns_;

    // Cache
    mutable Eigen::MatrixXd covariance_matrix_;
    mutable bool covariance_valid_;
};

// Implementation
inline VaRResult VaRCalculator::calculateHistoricalVaR(
    double confidence_level,
    int lookback_days,
    int horizon_days) {

    VaRResult result;
    result.method = VaRMethod::HISTORICAL;
    result.confidence_level = confidence_level;
    result.time_horizon_days = horizon_days;

    // Calculate historical portfolio returns
    std::vector<double> portfolio_returns = calculatePortfolioReturns();

    if (portfolio_returns.empty()) {
        result.var_dollars = 0.0;
        result.var_pct = 0.0;
        return result;
    }

    // Trim to lookback period
    if (portfolio_returns.size() > static_cast<size_t>(lookback_days)) {
        portfolio_returns.resize(lookback_days);
    }

    // Sort returns (ascending order)
    std::sort(portfolio_returns.begin(), portfolio_returns.end());

    // Find VaR at confidence level
    size_t var_index = static_cast<size_t>(
        (1.0 - confidence_level) * portfolio_returns.size());

    double var_return = portfolio_returns[var_index];

    // Scale to horizon
    double scaling_factor = std::sqrt(static_cast<double>(horizon_days));
    var_return *= scaling_factor;

    // Calculate portfolio value
    double portfolio_value = 0.0;
    for (const auto& pos : portfolio_) {
        portfolio_value += pos.market_value;
    }

    result.var_pct = -var_return * 100.0;  // Negative for loss
    result.var_dollars = portfolio_value * (-var_return);

    // Calculate expected shortfall
    double es_sum = 0.0;
    size_t es_count = 0;
    for (size_t i = 0; i <= var_index; i++) {
        es_sum += portfolio_returns[i];
        es_count++;
    }

    if (es_count > 0) {
        double es_return = (es_sum / es_count) * scaling_factor;
        result.expected_shortfall_pct = -es_return * 100.0;
        result.expected_shortfall_dollars = portfolio_value * (-es_return);
    }

    result.calculation_time = std::chrono::system_clock::now();

    return result;
}

inline VaRResult VaRCalculator::calculateParametricVaR(
    double confidence_level,
    int horizon_days) {

    VaRResult result;
    result.method = VaRMethod::PARAMETRIC;
    result.confidence_level = confidence_level;
    result.time_horizon_days = horizon_days;

    // Calculate covariance matrix
    Eigen::MatrixXd cov_matrix = calculateCovarianceMatrix();

    // Get portfolio weights
    double total_value = 0.0;
    for (const auto& pos : portfolio_) {
        total_value += pos.market_value;
    }

    Eigen::VectorXd weights(portfolio_.size());
    for (size_t i = 0; i < portfolio_.size(); i++) {
        weights(i) = portfolio_[i].market_value / total_value;
    }

    // Calculate portfolio variance
    double portfolio_variance = calculatePortfolioVariance(weights, cov_matrix);
    double portfolio_std = std::sqrt(portfolio_variance);

    // Scale to horizon
    double scaling_factor = std::sqrt(static_cast<double>(horizon_days));
    portfolio_std *= scaling_factor;

    // Get z-score for confidence level
    double z_score = getZScore(confidence_level);

    // Calculate VaR
    result.var_pct = z_score * portfolio_std * 100.0;
    result.var_dollars = total_value * z_score * portfolio_std;

    // Expected shortfall for normal distribution
    double pdf_at_var = std::exp(-z_score * z_score / 2.0) / std::sqrt(2.0 * M_PI);
    double es_multiplier = pdf_at_var / (1.0 - confidence_level);

    result.expected_shortfall_pct = es_multiplier * portfolio_std * 100.0;
    result.expected_shortfall_dollars = total_value * es_multiplier * portfolio_std;

    result.calculation_time = std::chrono::system_clock::now();

    return result;
}

inline VaRResult VaRCalculator::calculateMonteCarloVaR(
    double confidence_level,
    int horizon_days,
    int num_simulations) {

    VaRResult result;
    result.method = VaRMethod::MONTE_CARLO;
    result.confidence_level = confidence_level;
    result.time_horizon_days = horizon_days;

    // Calculate covariance matrix
    Eigen::MatrixXd cov_matrix = calculateCovarianceMatrix();

    // Scale covariance to horizon
    cov_matrix *= horizon_days;

    // Generate correlated random returns
    std::vector<double> simulated_portfolio_returns;
    simulated_portfolio_returns.reserve(num_simulations);

    // Use Cholesky decomposition for correlated random numbers
    Eigen::LLT<Eigen::MatrixXd> cholesky(cov_matrix);
    Eigen::MatrixXd L = cholesky.matrixL();

    std::random_device rd;
    std::mt19937 gen(rd());
    std::normal_distribution<> normal(0.0, 1.0);

    for (int sim = 0; sim < num_simulations; sim++) {
        // Generate uncorrelated random numbers
        Eigen::VectorXd random_vec(portfolio_.size());
        for (size_t i = 0; i < portfolio_.size(); i++) {
            random_vec(i) = normal(gen);
        }

        // Apply correlation
        Eigen::VectorXd correlated_returns = L * random_vec;

        // Calculate portfolio return
        double portfolio_return = 0.0;
        double total_value = 0.0;
        for (size_t i = 0; i < portfolio_.size(); i++) {
            total_value += portfolio_[i].market_value;
        }

        for (size_t i = 0; i < portfolio_.size(); i++) {
            double weight = portfolio_[i].market_value / total_value;
            portfolio_return += weight * correlated_returns(i);
        }

        simulated_portfolio_returns.push_back(portfolio_return);
    }

    // Sort simulated returns
    std::sort(simulated_portfolio_returns.begin(),
             simulated_portfolio_returns.end());

    // Find VaR
    size_t var_index = static_cast<size_t>(
        (1.0 - confidence_level) * num_simulations);

    double var_return = simulated_portfolio_returns[var_index];

    // Calculate portfolio value
    double portfolio_value = 0.0;
    for (const auto& pos : portfolio_) {
        portfolio_value += pos.market_value;
    }

    result.var_pct = -var_return * 100.0;
    result.var_dollars = portfolio_value * (-var_return);

    // Calculate expected shortfall
    double es_sum = 0.0;
    for (size_t i = 0; i <= var_index; i++) {
        es_sum += simulated_portfolio_returns[i];
    }
    double es_return = es_sum / (var_index + 1);

    result.expected_shortfall_pct = -es_return * 100.0;
    result.expected_shortfall_dollars = portfolio_value * (-es_return);

    result.calculation_time = std::chrono::system_clock::now();

    return result;
}

inline double VaRCalculator::getZScore(double confidence_level) const {
    // Approximate inverse normal CDF
    // For common confidence levels
    if (std::abs(confidence_level - 0.95) < 0.001) return 1.645;
    if (std::abs(confidence_level - 0.99) < 0.001) return 2.326;
    if (std::abs(confidence_level - 0.999) < 0.001) return 3.090;

    // Use approximation for other levels
    double p = 1.0 - confidence_level;
    double t = std::sqrt(-2.0 * std::log(p));

    double c0 = 2.515517;
    double c1 = 0.802853;
    double c2 = 0.010328;
    double d1 = 1.432788;
    double d2 = 0.189269;
    double d3 = 0.001308;

    double z = t - (c0 + c1*t + c2*t*t) / (1.0 + d1*t + d2*t*t + d3*t*t*t);

    return z;
}

inline std::vector<double> VaRCalculator::calculatePortfolioReturns() const {
    if (portfolio_.empty() || historical_returns_.empty()) {
        return {};
    }

    // Get the length of return series (assume all have same length)
    size_t series_length = historical_returns_.begin()->second.size();

    std::vector<double> portfolio_returns(series_length, 0.0);

    // Calculate total portfolio value
    double total_value = 0.0;
    for (const auto& pos : portfolio_) {
        total_value += pos.market_value;
    }

    if (total_value == 0.0) {
        return {};
    }

    // Calculate weighted portfolio returns
    for (const auto& pos : portfolio_) {
        auto it = historical_returns_.find(pos.symbol);
        if (it == historical_returns_.end()) {
            continue;
        }

        double weight = pos.market_value / total_value;
        const auto& symbol_returns = it->second;

        for (size_t i = 0; i < std::min(series_length, symbol_returns.size()); i++) {
            portfolio_returns[i] += weight * symbol_returns[i];
        }
    }

    return portfolio_returns;
}

} // namespace risk
} // namespace hft

#endif // VAR_CALCULATOR_HPP
```

================================================================================
3. GREEKS CALCULATION ENGINE
================================================================================

3.1 Option Greeks Implementation
---------------------------------

```cpp
// greeks_calculator.hpp
#ifndef GREEKS_CALCULATOR_HPP
#define GREEKS_CALCULATOR_HPP

#include <cmath>
#include <string>
#include <unordered_map>
#include <vector>

namespace hft {
namespace risk {

// Option specification
struct OptionContract {
    std::string symbol;
    char option_type;           // 'C' for call, 'P' for put
    double strike;
    double expiry_time_years;   // Time to expiration in years
    double underlying_price;
    double volatility;
    double risk_free_rate;
    double dividend_yield;

    // Position
    double quantity;            // Number of contracts
    double contract_multiplier; // Typically 100 for equity options
};

// Greeks values
struct Greeks {
    double delta;               // dV/dS
    double gamma;               // d²V/dS²
    double vega;                // dV/dσ
    double theta;               // dV/dt
    double rho;                 // dV/dr

    // Higher order
    double vanna;               // d²V/dS/dσ
    double volga;               // d²V/dσ²
    double charm;               // d²V/dS/dt

    // Dollar Greeks (position-adjusted)
    double dollar_delta;
    double dollar_gamma;
    double dollar_vega;
    double dollar_theta;
};

// Portfolio Greeks
struct PortfolioGreeks {
    // Net Greeks
    double net_delta;
    double net_gamma;
    double net_vega;
    double net_theta;
    double net_rho;

    // Greeks by underlying
    std::unordered_map<std::string, Greeks> greeks_by_underlying;

    // Greeks by expiry bucket
    std::unordered_map<std::string, Greeks> greeks_by_expiry;

    // Risk metrics
    double gamma_dollars_per_percent;
    double vega_dollars_per_point;
    double theta_dollars_per_day;

    std::chrono::system_clock::time_point calculation_time;
};

class GreeksCalculator {
public:
    // Calculate Greeks for single option
    static Greeks calculateBlackScholesGreeks(const OptionContract& option);

    // Calculate portfolio Greeks
    static PortfolioGreeks calculatePortfolioGreeks(
        const std::vector<OptionContract>& options);

    // Greek ladder (Greeks at different spot levels)
    struct GreekLadder {
        std::vector<double> spot_levels;
        std::vector<double> delta_values;
        std::vector<double> gamma_values;
        std::vector<double> pnl_values;
    };

    static GreekLadder generateGreekLadder(
        const OptionContract& option,
        double spot_range_pct = 0.10,
        int num_points = 21);

    // Volatility surface Greeks
    static double calculateVegaByStrike(
        const std::vector<OptionContract>& options,
        double strike);

    // Time decay analysis
    struct ThetaDecay {
        std::vector<double> days_to_expiry;
        std::vector<double> theta_values;
        std::vector<double> cumulative_decay;
    };

    static ThetaDecay analyzeThetaDecay(
        const OptionContract& option,
        int days = 30);

private:
    // Black-Scholes helper functions
    static double normalCDF(double x);
    static double normalPDF(double x);

    static double calculateD1(
        double S, double K, double T, double r, double q, double sigma);

    static double calculateD2(
        double S, double K, double T, double r, double q, double sigma);

    static double blackScholesPrice(
        const OptionContract& option);
};

// Implementation
inline Greeks GreeksCalculator::calculateBlackScholesGreeks(
    const OptionContract& option) {

    Greeks greeks;

    double S = option.underlying_price;
    double K = option.strike;
    double T = option.expiry_time_years;
    double r = option.risk_free_rate;
    double q = option.dividend_yield;
    double sigma = option.volatility;

    if (T <= 0) {
        // Option expired
        greeks.delta = 0.0;
        greeks.gamma = 0.0;
        greeks.vega = 0.0;
        greeks.theta = 0.0;
        greeks.rho = 0.0;
        return greeks;
    }

    double d1 = calculateD1(S, K, T, r, q, sigma);
    double d2 = calculateD2(S, K, T, r, q, sigma);

    double N_d1 = normalCDF(d1);
    double N_d2 = normalCDF(d2);
    double n_d1 = normalPDF(d1);

    // Delta
    if (option.option_type == 'C') {
        greeks.delta = std::exp(-q * T) * N_d1;
    } else {
        greeks.delta = std::exp(-q * T) * (N_d1 - 1.0);
    }

    // Gamma (same for call and put)
    greeks.gamma = std::exp(-q * T) * n_d1 / (S * sigma * std::sqrt(T));

    // Vega (same for call and put)
    greeks.vega = S * std::exp(-q * T) * n_d1 * std::sqrt(T) / 100.0;

    // Theta
    double term1 = -(S * n_d1 * sigma * std::exp(-q * T)) / (2.0 * std::sqrt(T));
    if (option.option_type == 'C') {
        double term2 = r * K * std::exp(-r * T) * N_d2;
        double term3 = q * S * std::exp(-q * T) * N_d1;
        greeks.theta = (term1 - term2 + term3) / 365.0;
    } else {
        double term2 = r * K * std::exp(-r * T) * normalCDF(-d2);
        double term3 = q * S * std::exp(-q * T) * normalCDF(-d1);
        greeks.theta = (term1 + term2 - term3) / 365.0;
    }

    // Rho
    if (option.option_type == 'C') {
        greeks.rho = K * T * std::exp(-r * T) * N_d2 / 100.0;
    } else {
        greeks.rho = -K * T * std::exp(-r * T) * normalCDF(-d2) / 100.0;
    }

    // Vanna (dDelta/dVol)
    greeks.vanna = -std::exp(-q * T) * n_d1 * d2 / sigma;

    // Volga (dVega/dVol)
    greeks.volga = S * std::exp(-q * T) * n_d1 * std::sqrt(T) * d1 * d2 / sigma;

    // Charm (dDelta/dTime)
    if (option.option_type == 'C') {
        greeks.charm = q * std::exp(-q * T) * N_d1 -
                      std::exp(-q * T) * n_d1 *
                      (2.0 * (r - q) * T - d2 * sigma * std::sqrt(T)) /
                      (2.0 * T * sigma * std::sqrt(T));
    } else {
        greeks.charm = q * std::exp(-q * T) * (N_d1 - 1.0) -
                      std::exp(-q * T) * n_d1 *
                      (2.0 * (r - q) * T - d2 * sigma * std::sqrt(T)) /
                      (2.0 * T * sigma * std::sqrt(T));
    }

    // Dollar Greeks
    double position_size = option.quantity * option.contract_multiplier;
    greeks.dollar_delta = greeks.delta * position_size * S;
    greeks.dollar_gamma = greeks.gamma * position_size * S * S / 100.0;
    greeks.dollar_vega = greeks.vega * position_size;
    greeks.dollar_theta = greeks.theta * position_size;

    return greeks;
}

inline double GreeksCalculator::calculateD1(
    double S, double K, double T, double r, double q, double sigma) {

    return (std::log(S / K) + (r - q + 0.5 * sigma * sigma) * T) /
           (sigma * std::sqrt(T));
}

inline double GreeksCalculator::calculateD2(
    double S, double K, double T, double r, double q, double sigma) {

    return calculateD1(S, K, T, r, q, sigma) - sigma * std::sqrt(T);
}

inline double GreeksCalculator::normalCDF(double x) {
    return 0.5 * std::erfc(-x * M_SQRT1_2);
}

inline double GreeksCalculator::normalPDF(double x) {
    return std::exp(-0.5 * x * x) / std::sqrt(2.0 * M_PI);
}

inline PortfolioGreeks GreeksCalculator::calculatePortfolioGreeks(
    const std::vector<OptionContract>& options) {

    PortfolioGreeks portfolio_greeks;
    portfolio_greeks.net_delta = 0.0;
    portfolio_greeks.net_gamma = 0.0;
    portfolio_greeks.net_vega = 0.0;
    portfolio_greeks.net_theta = 0.0;
    portfolio_greeks.net_rho = 0.0;

    for (const auto& option : options) {
        Greeks greeks = calculateBlackScholesGreeks(option);

        // Aggregate net Greeks
        portfolio_greeks.net_delta += greeks.dollar_delta;
        portfolio_greeks.net_gamma += greeks.dollar_gamma;
        portfolio_greeks.net_vega += greeks.dollar_vega;
        portfolio_greeks.net_theta += greeks.dollar_theta;
        portfolio_greeks.net_rho += greeks.rho * option.quantity *
                                   option.contract_multiplier;

        // Aggregate by underlying
        auto& underlying_greeks = portfolio_greeks.greeks_by_underlying[option.symbol];
        underlying_greeks.delta += greeks.delta * option.quantity;
        underlying_greeks.gamma += greeks.gamma * option.quantity;
        underlying_greeks.vega += greeks.vega * option.quantity;
        underlying_greeks.theta += greeks.theta * option.quantity;
        underlying_greeks.rho += greeks.rho * option.quantity;
    }

    // Calculate risk metrics
    portfolio_greeks.gamma_dollars_per_percent = portfolio_greeks.net_gamma;
    portfolio_greeks.vega_dollars_per_point = portfolio_greeks.net_vega;
    portfolio_greeks.theta_dollars_per_day = portfolio_greeks.net_theta;

    portfolio_greeks.calculation_time = std::chrono::system_clock::now();

    return portfolio_greeks;
}

inline GreeksCalculator::GreekLadder GreeksCalculator::generateGreekLadder(
    const OptionContract& option,
    double spot_range_pct,
    int num_points) {

    GreekLadder ladder;

    double current_spot = option.underlying_price;
    double lower_bound = current_spot * (1.0 - spot_range_pct);
    double upper_bound = current_spot * (1.0 + spot_range_pct);
    double step = (upper_bound - lower_bound) / (num_points - 1);

    // Generate spot levels
    for (int i = 0; i < num_points; i++) {
        double spot = lower_bound + i * step;
        ladder.spot_levels.push_back(spot);

        // Calculate Greeks at this spot level
        OptionContract temp_option = option;
        temp_option.underlying_price = spot;

        Greeks greeks = calculateBlackScholesGreeks(temp_option);
        ladder.delta_values.push_back(greeks.delta);
        ladder.gamma_values.push_back(greeks.gamma);

        // Calculate PnL
        double spot_change = spot - current_spot;
        double pnl = greeks.delta * spot_change +
                    0.5 * greeks.gamma * spot_change * spot_change;
        ladder.pnl_values.push_back(pnl * option.quantity *
                                   option.contract_multiplier);
    }

    return ladder;
}

} // namespace risk
} // namespace hft

#endif // GREEKS_CALCULATOR_HPP
```

================================================================================
4. FACTOR RISK DECOMPOSITION
================================================================================

4.1 Multi-Factor Risk Model
----------------------------

```cpp
// factor_risk_model.hpp

namespace hft {
namespace risk {

// Risk factors
enum class RiskFactor {
    MARKET,             // Market beta
    SIZE,               // Market cap factor
    VALUE,              // Value vs growth
    MOMENTUM,           // Price momentum
    VOLATILITY,         // Volatility factor
    LIQUIDITY,          // Liquidity factor
    SECTOR_TECH,        // Technology sector
    SECTOR_FINANCE,     // Financial sector
    SECTOR_HEALTHCARE,  // Healthcare sector
    SECTOR_ENERGY,      // Energy sector
    INTEREST_RATE,      // Interest rate sensitivity
    CREDIT_SPREAD,      // Credit spread sensitivity
    FX_USD,             // USD currency exposure
    COMMODITY_OIL       // Oil price exposure
};

struct FactorExposure {
    RiskFactor factor;
    double exposure;            // Factor loading/beta
    double marginal_contribution;   // Contribution to portfolio risk
    double percent_contribution;    // % of total risk
};

class FactorRiskModel {
public:
    // Set factor returns and covariance
    void setFactorReturns(
        const std::unordered_map<RiskFactor, std::vector<double>>& returns);

    void setFactorCovariance(const Eigen::MatrixXd& factor_cov);

    // Calculate factor exposures for portfolio
    std::vector<FactorExposure> calculateFactorExposures(
        const std::vector<Position>& portfolio);

    // Factor risk contribution
    double calculateFactorRisk(const std::vector<FactorExposure>& exposures);

    // Decompose portfolio variance into factor components
    struct VarianceDecomposition {
        double systematic_variance;     // Explained by factors
        double idiosyncratic_variance;  // Stock-specific
        double total_variance;

        std::unordered_map<RiskFactor, double> factor_contributions;
    };

    VarianceDecomposition decomposeVariance(
        const std::vector<Position>& portfolio);

    // Stress test factors
    struct FactorShock {
        RiskFactor factor;
        double shock_size;      // Standard deviations
    };

    double stressTestFactors(
        const std::vector<Position>& portfolio,
        const std::vector<FactorShock>& shocks);

private:
    Eigen::MatrixXd factor_covariance_;
    std::unordered_map<RiskFactor, std::vector<double>> factor_returns_;
};

} // namespace risk
} // namespace hft
```

================================================================================
5. RISK AGGREGATION AND REPORTING
================================================================================

5.1 Comprehensive Risk Dashboard
---------------------------------

```cpp
// risk_dashboard.hpp

namespace hft {
namespace risk {

struct ComprehensiveRiskReport {
    // VaR metrics
    VaRResult var_95;
    VaRResult var_99;
    VaRResult var_999;

    // Greeks (if options portfolio)
    PortfolioGreeks greeks;

    // Factor exposures
    std::vector<FactorExposure> factor_exposures;

    // Concentration metrics
    double herfindahl_index;
    double max_position_pct;
    std::unordered_map<std::string, double> sector_exposures;

    // Liquidity metrics
    double weighted_avg_liquidity_score;
    double days_to_liquidate;

    // Correlation metrics
    double avg_correlation;
    double max_correlation;
    double diversification_ratio;

    // Tail risk metrics
    double skewness;
    double kurtosis;
    double max_drawdown_pct;

    // Leverage
    double gross_leverage;
    double net_leverage;

    std::chrono::system_clock::time_point report_time;
};

class RiskDashboard {
public:
    ComprehensiveRiskReport generateReport(
        const std::vector<Position>& portfolio,
        const VaRCalculator& var_calc,
        const GreeksCalculator& greeks_calc);

    // Real-time risk monitoring
    void updateRealTime(const std::vector<Position>& portfolio);

    // Risk limit monitoring
    struct RiskLimit {
        std::string metric_name;
        double current_value;
        double limit_value;
        double utilization_pct;
        bool breached;
    };

    std::vector<RiskLimit> checkRiskLimits(
        const ComprehensiveRiskReport& report);

private:
    double calculateHerfindahlIndex(const std::vector<Position>& portfolio);
    double calculateDiversificationRatio(const std::vector<Position>& portfolio);
    double calculateSkewness(const std::vector<double>& returns);
    double calculateKurtosis(const std::vector<double>& returns);
};

} // namespace risk
} // namespace hft
```

================================================================================
6. CONFIGURATION AND PARAMETERS
================================================================================

6.1 Risk Metrics Configuration
-------------------------------

```json
{
  "portfolio_risk_metrics": {
    "var_calculation": {
      "enabled": true,
      "methods": ["historical", "parametric", "monte_carlo"],
      "default_method": "historical",
      "confidence_levels": [0.95, 0.99, 0.999],
      "time_horizon_days": 1,
      "lookback_days": 250,
      "monte_carlo_simulations": 10000,
      "calculation_frequency_seconds": 60
    },

    "expected_shortfall": {
      "enabled": true,
      "confidence_levels": [0.95, 0.99]
    },

    "greeks_calculation": {
      "enabled": true,
      "calculate_higher_order": true,
      "greek_ladder_enabled": true,
      "spot_range_pct": 0.10,
      "theta_decay_days": 30
    },

    "factor_risk": {
      "enabled": true,
      "risk_model": "multi_factor",
      "factors": [
        "market",
        "size",
        "value",
        "momentum",
        "volatility",
        "sector"
      ],
      "decompose_variance": true
    },

    "stress_testing": {
      "enabled": true,
      "scenarios": [
        {
          "name": "Market Crash",
          "market_shock_pct": -10.0,
          "volatility_shock_pct": 50.0,
          "correlation_shock": 0.9
        },
        {
          "name": "Flash Crash",
          "market_shock_pct": -5.0,
          "volatility_shock_pct": 200.0,
          "liquidity_shock_pct": -80.0
        },
        {
          "name": "Interest Rate Spike",
          "rate_shock_bps": 100,
          "credit_spread_shock_bps": 50
        }
      ]
    },

    "risk_limits": {
      "max_var_99_pct": 2.0,
      "max_expected_shortfall_pct": 3.0,
      "max_delta_dollars": 10000000,
      "max_gamma_dollars_per_pct": 50000,
      "max_vega_dollars": 100000,
      "max_gross_leverage": 3.0,
      "max_single_position_pct": 5.0,
      "max_sector_concentration_pct": 25.0
    }
  }
}
```

================================================================================
7. TESTING FRAMEWORK
================================================================================

7.1 Risk Metrics Unit Tests
----------------------------

```cpp
// Test VaR calculation
TEST(VaRCalculator, HistoricalVaRCalculation) {
    VaRCalculator calc;

    // Set up portfolio
    std::vector<Position> portfolio;
    Position pos;
    pos.symbol = "AAPL";
    pos.quantity = 1000;
    pos.market_price = 150.0;
    pos.market_value = 150000.0;
    portfolio.push_back(pos);

    calc.setPortfolio(portfolio);

    // Set historical returns (simulated)
    std::unordered_map<std::string, std::vector<double>> returns;
    std::vector<double> aapl_returns;
    // Generate 250 days of returns
    std::random_device rd;
    std::mt19937 gen(rd());
    std::normal_distribution<> d(0.0005, 0.02);  // 0.05% mean, 2% std

    for (int i = 0; i < 250; i++) {
        aapl_returns.push_back(d(gen));
    }
    returns["AAPL"] = aapl_returns;
    calc.setHistoricalReturns(returns);

    // Calculate VaR
    auto var_result = calc.calculateHistoricalVaR(0.99, 250, 1);

    EXPECT_GT(var_result.var_dollars, 0.0);
    EXPECT_GT(var_result.var_pct, 0.0);
    EXPECT_GT(var_result.expected_shortfall_dollars, var_result.var_dollars);
}

// Test Greeks calculation
TEST(GreeksCalculator, BlackScholesGreeks) {
    OptionContract option;
    option.symbol = "AAPL";
    option.option_type = 'C';
    option.strike = 150.0;
    option.expiry_time_years = 0.25;  // 3 months
    option.underlying_price = 150.0;
    option.volatility = 0.25;         // 25% volatility
    option.risk_free_rate = 0.05;
    option.dividend_yield = 0.0;
    option.quantity = 10;
    option.contract_multiplier = 100;

    Greeks greeks = GreeksCalculator::calculateBlackScholesGreeks(option);

    // At-the-money call should have delta around 0.5
    EXPECT_GT(greeks.delta, 0.4);
    EXPECT_LT(greeks.delta, 0.6);

    // Gamma should be positive
    EXPECT_GT(greeks.gamma, 0.0);

    // Vega should be positive
    EXPECT_GT(greeks.vega, 0.0);

    // Theta should be negative for long call
    EXPECT_LT(greeks.theta, 0.0);
}

================================================================================
END OF PORTFOLIO RISK METRICS DOCUMENTATION
================================================================================
