================================================================================
MARKET RISK (VOLATILITY, LIQUIDITY) - HFT RISK MANAGEMENT SYSTEM
================================================================================
Version: 2.1.0
Last Updated: 2025-11-25
Author: HFT Risk Management Team
Purpose: Market risk monitoring, volatility management, and liquidity risk

================================================================================
1. MARKET RISK FRAMEWORK
================================================================================

1.1 Market Risk Components
---------------------------

Primary Market Risk Types:

1. Price Risk
   - Directional price movements
   - Gap risk
   - Slippage risk
   - Market impact

2. Volatility Risk
   - Realized volatility changes
   - Implied volatility changes
   - Volatility smile/skew risk
   - Vol-of-vol risk

3. Liquidity Risk
   - Bid-ask spread widening
   - Market depth reduction
   - Price impact amplification
   - Execution uncertainty

4. Correlation Risk
   - Correlation breakdown
   - Correlation regime changes
   - Cross-asset correlations
   - Diversification failure

5. Basis Risk
   - Cash-futures basis
   - Cross-exchange spreads
   - Index arbitrage basis
   - Calendar spread risk

================================================================================
2. C++ MARKET RISK ENGINE
================================================================================

2.1 Volatility Monitor Implementation
--------------------------------------

```cpp
// volatility_monitor.hpp
#ifndef VOLATILITY_MONITOR_HPP
#define VOLATILITY_MONITOR_HPP

#include <string>
#include <vector>
#include <deque>
#include <unordered_map>
#include <cmath>
#include <chrono>
#include <mutex>
#include <shared_mutex>

namespace hft {
namespace risk {

// Volatility metrics
struct VolatilityMetrics {
    std::string symbol;

    // Realized volatility
    double realized_vol_1min;
    double realized_vol_5min;
    double realized_vol_1hour;
    double realized_vol_1day;

    // Historical percentiles
    double vol_percentile_20day;
    double vol_percentile_60day;

    // Implied volatility (if options)
    double implied_vol_atm;
    double implied_vol_25delta_put;
    double implied_vol_25delta_call;

    // Volatility regime
    enum class VolRegime {
        LOW,        // < 25th percentile
        NORMAL,     // 25-75th percentile
        HIGH,       // > 75th percentile
        EXTREME     // > 95th percentile
    };
    VolRegime vol_regime;

    // Intraday patterns
    double opening_vol;
    double midday_vol;
    double closing_vol;

    // Forecasts
    double garch_forecast_1day;
    double ewma_forecast;

    std::chrono::system_clock::time_point timestamp;
};

// Volatility alert
struct VolatilityAlert {
    std::string symbol;
    enum class AlertType {
        VOL_SPIKE,
        VOL_CRUSH,
        REGIME_CHANGE,
        EXTREME_MOVE
    };
    AlertType type;

    double current_vol;
    double reference_vol;
    double vol_change_pct;

    std::string message;
    int severity;  // 1-5

    std::chrono::system_clock::time_point timestamp;
};

class VolatilityMonitor {
public:
    VolatilityMonitor();
    ~VolatilityMonitor();

    // Price update
    void updatePrice(const std::string& symbol,
                    double price,
                    std::chrono::nanoseconds timestamp);

    // Calculate volatility metrics
    VolatilityMetrics calculateVolatility(const std::string& symbol) const;

    // Realized volatility calculation
    double calculateRealizedVol(const std::string& symbol,
                               std::chrono::minutes window) const;

    double calculateParkinsonVol(const std::string& symbol,
                                const std::vector<std::pair<double, double>>& high_low) const;

    double calculateGarmanKlassVol(const std::string& symbol) const;

    // GARCH forecasting
    double forecastGARCH(const std::string& symbol,
                        int horizon_days = 1) const;

    // EWMA volatility
    double calculateEWMA(const std::string& symbol,
                        double lambda = 0.94) const;

    // Volatility regime detection
    VolatilityMetrics::VolRegime detectVolRegime(
        const std::string& symbol) const;

    // Check for volatility alerts
    std::vector<VolatilityAlert> checkVolatilityAlerts();

    // Intraday volatility patterns
    struct IntradayVolPattern {
        std::vector<int> hour;
        std::vector<double> avg_vol;
        double opening_vol_ratio;
        double closing_vol_ratio;
    };

    IntradayVolPattern analyzeIntradayPattern(
        const std::string& symbol,
        int lookback_days = 20) const;

    // Volatility surface (for options)
    struct VolSurface {
        std::vector<double> strikes;
        std::vector<double> expiries;
        std::vector<std::vector<double>> vols;  // 2D grid
        double atm_vol;
        double skew_25delta;
        double smile_curvature;
    };

    VolSurface buildVolSurface(const std::string& underlying) const;

    // Statistics
    struct VolStatistics {
        std::string symbol;
        double avg_daily_vol;
        double max_vol_observed;
        double min_vol_observed;
        int high_vol_days;
        int vol_spikes_detected;
    };

    VolStatistics getStatistics(const std::string& symbol) const;

private:
    // Price history
    struct PriceRecord {
        double price;
        std::chrono::nanoseconds timestamp;
    };

    mutable std::shared_mutex prices_mutex_;
    std::unordered_map<std::string, std::deque<PriceRecord>> price_history_;

    // Returns calculation
    std::vector<double> calculateReturns(
        const std::string& symbol,
        std::chrono::minutes window) const;

    double calculateVolatility(const std::vector<double>& returns) const;

    // GARCH parameters
    struct GARCHParams {
        double omega;
        double alpha;
        double beta;
    };

    std::unordered_map<std::string, GARCHParams> garch_params_;

    // Configuration
    static constexpr size_t MAX_PRICE_HISTORY = 100000;
    double vol_spike_threshold_ = 2.0;  // 2x average vol
};

// Implementation
inline void VolatilityMonitor::updatePrice(
    const std::string& symbol,
    double price,
    std::chrono::nanoseconds timestamp) {

    std::unique_lock<std::shared_mutex> lock(prices_mutex_);

    auto& history = price_history_[symbol];
    history.push_back({price, timestamp});

    // Trim history
    if (history.size() > MAX_PRICE_HISTORY) {
        history.pop_front();
    }
}

inline double VolatilityMonitor::calculateRealizedVol(
    const std::string& symbol,
    std::chrono::minutes window) const {

    auto returns = calculateReturns(symbol, window);

    if (returns.empty()) {
        return 0.0;
    }

    return calculateVolatility(returns);
}

inline std::vector<double> VolatilityMonitor::calculateReturns(
    const std::string& symbol,
    std::chrono::minutes window) const {

    std::shared_lock<std::shared_mutex> lock(prices_mutex_);

    auto it = price_history_.find(symbol);
    if (it == price_history_.end() || it->second.empty()) {
        return {};
    }

    const auto& history = it->second;
    std::vector<double> returns;

    auto window_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(window);
    auto cutoff_time = history.back().timestamp - window_ns;

    // Calculate log returns
    for (size_t i = 1; i < history.size(); i++) {
        if (history[i].timestamp >= cutoff_time) {
            double log_return = std::log(history[i].price / history[i-1].price);
            returns.push_back(log_return);
        }
    }

    return returns;
}

inline double VolatilityMonitor::calculateVolatility(
    const std::vector<double>& returns) const {

    if (returns.empty()) {
        return 0.0;
    }

    // Calculate mean
    double mean = 0.0;
    for (double r : returns) {
        mean += r;
    }
    mean /= returns.size();

    // Calculate variance
    double variance = 0.0;
    for (double r : returns) {
        double diff = r - mean;
        variance += diff * diff;
    }
    variance /= (returns.size() - 1);

    // Annualize (assuming 252 trading days, 6.5 trading hours)
    double periods_per_day = (252.0 * 6.5 * 60.0) / returns.size();
    double annual_vol = std::sqrt(variance * periods_per_day * 252.0);

    return annual_vol;
}

inline double VolatilityMonitor::calculateEWMA(
    const std::string& symbol,
    double lambda) const {

    auto returns = calculateReturns(symbol, std::chrono::hours(24));

    if (returns.size() < 2) {
        return 0.0;
    }

    // EWMA volatility
    double ewma_var = returns[0] * returns[0];

    for (size_t i = 1; i < returns.size(); i++) {
        ewma_var = lambda * ewma_var + (1.0 - lambda) * returns[i] * returns[i];
    }

    // Annualize
    return std::sqrt(ewma_var * 252.0);
}

inline double VolatilityMonitor::forecastGARCH(
    const std::string& symbol,
    int horizon_days) const {

    // Simplified GARCH(1,1) forecast
    // sigma²_t+1 = omega + alpha * epsilon²_t + beta * sigma²_t

    auto it = garch_params_.find(symbol);
    if (it == garch_params_.end()) {
        // Use default parameters
        return calculateRealizedVol(symbol, std::chrono::hours(24));
    }

    const auto& params = it->second;

    // Get recent returns
    auto returns = calculateReturns(symbol, std::chrono::hours(24));
    if (returns.empty()) {
        return 0.0;
    }

    // Current variance estimate
    double current_var = calculateVolatility(returns);
    current_var = current_var * current_var / 252.0;  // Daily variance

    double recent_return = returns.back();
    double recent_var = recent_return * recent_return;

    // Forecast variance
    double forecast_var = params.omega + params.alpha * recent_var +
                         params.beta * current_var;

    // Multi-period forecast
    double long_run_var = params.omega / (1.0 - params.alpha - params.beta);

    for (int h = 1; h < horizon_days; h++) {
        forecast_var = long_run_var + (params.alpha + params.beta) *
                      (forecast_var - long_run_var);
    }

    // Annualize
    return std::sqrt(forecast_var * 252.0);
}

inline VolatilityMetrics::VolRegime VolatilityMonitor::detectVolRegime(
    const std::string& symbol) const {

    double current_vol = calculateRealizedVol(symbol, std::chrono::hours(1));

    // Get historical volatility distribution
    std::vector<double> historical_vols;
    for (int i = 0; i < 60; i++) {  // 60 days
        double daily_vol = calculateRealizedVol(
            symbol,
            std::chrono::hours(24)
        );
        if (daily_vol > 0) {
            historical_vols.push_back(daily_vol);
        }
    }

    if (historical_vols.empty()) {
        return VolatilityMetrics::VolRegime::NORMAL;
    }

    // Sort to find percentiles
    std::sort(historical_vols.begin(), historical_vols.end());

    size_t p25_idx = historical_vols.size() / 4;
    size_t p75_idx = historical_vols.size() * 3 / 4;
    size_t p95_idx = historical_vols.size() * 95 / 100;

    double p25 = historical_vols[p25_idx];
    double p75 = historical_vols[p75_idx];
    double p95 = historical_vols[p95_idx];

    if (current_vol > p95) {
        return VolatilityMetrics::VolRegime::EXTREME;
    } else if (current_vol > p75) {
        return VolatilityMetrics::VolRegime::HIGH;
    } else if (current_vol < p25) {
        return VolatilityMetrics::VolRegime::LOW;
    } else {
        return VolatilityMetrics::VolRegime::NORMAL;
    }
}

} // namespace risk
} // namespace hft

#endif // VOLATILITY_MONITOR_HPP
```

================================================================================
3. LIQUIDITY RISK MONITOR
================================================================================

3.1 Liquidity Risk Tracking
----------------------------

```cpp
// liquidity_monitor.hpp
#ifndef LIQUIDITY_MONITOR_HPP
#define LIQUIDITY_MONITOR_HPP

#include <string>
#include <vector>
#include <deque>
#include <unordered_map>
#include <chrono>

namespace hft {
namespace risk {

// Liquidity metrics
struct LiquidityMetrics {
    std::string symbol;

    // Spread metrics
    double bid_ask_spread_bps;
    double quoted_spread_bps;
    double effective_spread_bps;
    double realized_spread_bps;

    // Depth metrics
    double bid_depth_dollars;
    double ask_depth_dollars;
    double total_depth_dollars;
    int num_price_levels;

    // Volume metrics
    double avg_daily_volume;
    double current_volume_pct_adv;  // % of ADV traded
    double volume_participation_rate;

    // Market impact
    double market_impact_bps;
    double price_impact_coefficient;

    // Liquidity scores
    double liquidity_score;         // 0-100
    int liquidity_bucket;           // 1-5 (1=most liquid)

    // Time-based
    double time_to_liquidate_hours;
    double max_position_size;       // Max size tradeable without impact

    // Alerts
    bool is_illiquid;
    bool spread_warning;
    bool depth_warning;

    std::chrono::system_clock::time_point timestamp;
};

// Liquidity event
struct LiquidityEvent {
    std::string symbol;
    enum class EventType {
        SPREAD_WIDENING,
        DEPTH_REDUCTION,
        VOLUME_SPIKE,
        VOLUME_DROUGHT,
        FLASH_CRASH,
        MARKET_HALT
    };
    EventType type;

    double metric_before;
    double metric_after;
    double change_pct;

    std::string description;
    int severity;

    std::chrono::system_clock::time_point timestamp;
};

class LiquidityMonitor {
public:
    LiquidityMonitor();

    // Update market data
    void updateOrderBook(const std::string& symbol,
                        const std::vector<std::pair<double, int64_t>>& bids,
                        const std::vector<std::pair<double, int64_t>>& asks);

    void updateTrade(const std::string& symbol,
                    double price,
                    int64_t quantity);

    // Calculate liquidity metrics
    LiquidityMetrics calculateLiquidity(const std::string& symbol) const;

    // Liquidity score (composite measure)
    double calculateLiquidityScore(const std::string& symbol) const;

    // Market impact estimation
    double estimateMarketImpact(const std::string& symbol,
                               int64_t quantity) const;

    // Time to liquidate
    double estimateTimeToLiquidate(const std::string& symbol,
                                  int64_t position,
                                  double max_participation_rate = 0.10) const;

    // Liquidity stress testing
    struct LiquidityStressScenario {
        double spread_multiplier;
        double depth_multiplier;
        double volume_multiplier;
    };

    LiquidityMetrics stressTestLiquidity(
        const std::string& symbol,
        const LiquidityStressScenario& scenario) const;

    // Check for liquidity events
    std::vector<LiquidityEvent> detectLiquidityEvents();

    // Liquidity-adjusted position limits
    int64_t calculateLiquidityAdjustedLimit(
        const std::string& symbol,
        int64_t base_limit) const;

private:
    struct OrderBookSnapshot {
        std::vector<std::pair<double, int64_t>> bids;
        std::vector<std::pair<double, int64_t>> asks;
        std::chrono::system_clock::time_point timestamp;
    };

    std::unordered_map<std::string, OrderBookSnapshot> order_books_;

    struct TradeRecord {
        double price;
        int64_t quantity;
        std::chrono::system_clock::time_point timestamp;
    };

    std::unordered_map<std::string, std::deque<TradeRecord>> trade_history_;

    // Calculate spread metrics
    double calculateBidAskSpread(const std::string& symbol) const;
    double calculateEffectiveSpread(const std::string& symbol) const;

    // Calculate depth metrics
    double calculateDepth(const std::string& symbol,
                         int num_levels = 5) const;

    // ADV calculation
    double calculateADV(const std::string& symbol) const;

    // Configuration
    static constexpr double ILLIQUID_SPREAD_THRESHOLD_BPS = 50.0;
    static constexpr double MIN_DEPTH_THRESHOLD = 100000.0;
};

inline double LiquidityMonitor::calculateLiquidityScore(
    const std::string& symbol) const {

    auto metrics = calculateLiquidity(symbol);

    // Composite score (0-100)
    double score = 100.0;

    // Penalize wide spreads
    score -= std::min(50.0, metrics.bid_ask_spread_bps);

    // Penalize low depth
    if (metrics.total_depth_dollars < 100000) {
        score -= 20.0;
    } else if (metrics.total_depth_dollars < 500000) {
        score -= 10.0;
    }

    // Penalize low volume
    if (metrics.avg_daily_volume < 100000) {
        score -= 20.0;
    } else if (metrics.avg_daily_volume < 1000000) {
        score -= 10.0;
    }

    return std::max(0.0, score);
}

inline double LiquidityMonitor::estimateMarketImpact(
    const std::string& symbol,
    int64_t quantity) const {

    // Square-root market impact model
    // Impact = sigma * sqrt(quantity / ADV)

    auto metrics = calculateLiquidity(symbol);

    double adv = metrics.avg_daily_volume;
    if (adv <= 0) {
        return 100.0;  // High impact if no ADV data
    }

    double volatility = 0.20;  // Assume 20% annual vol
    double impact_bps = volatility * 10000.0 * std::sqrt(
        std::abs(quantity) / adv);

    return impact_bps;
}

inline double LiquidityMonitor::estimateTimeToLiquidate(
    const std::string& symbol,
    int64_t position,
    double max_participation_rate) const {

    auto metrics = calculateLiquidity(symbol);

    double adv = metrics.avg_daily_volume;
    if (adv <= 0) {
        return 999.0;  // Cannot estimate
    }

    // Daily volume we can participate in
    double daily_capacity = adv * max_participation_rate;

    // Days to liquidate
    double days = std::abs(position) / daily_capacity;

    // Convert to hours (assume 6.5 trading hours per day)
    return days * 6.5;
}

} // namespace risk
} // namespace hft

#endif // LIQUIDITY_MONITOR_HPP
```

================================================================================
4. CORRELATION RISK MONITOR
================================================================================

4.1 Correlation Tracking
-------------------------

```cpp
// correlation_monitor.hpp

namespace hft {
namespace risk {

class CorrelationMonitor {
public:
    // Calculate correlation matrix
    Eigen::MatrixXd calculateCorrelationMatrix(
        const std::vector<std::string>& symbols,
        int lookback_days = 60) const;

    // Detect correlation breakdown
    struct CorrelationBreakdown {
        std::string symbol1;
        std::string symbol2;
        double historical_correlation;
        double current_correlation;
        double correlation_change;
        bool breakdown_detected;
    };

    std::vector<CorrelationBreakdown> detectCorrelationBreakdowns() const;

    // Correlation regime detection
    enum class CorrelationRegime {
        NORMAL,
        CRISIS,           // High correlations
        DISPERSION        // Low correlations
    };

    CorrelationRegime detectCorrelationRegime(
        const Eigen::MatrixXd& correlation_matrix) const;

    // Diversification benefit calculation
    double calculateDiversificationRatio(
        const std::vector<double>& weights,
        const Eigen::MatrixXd& correlation_matrix) const;

private:
    std::unordered_map<std::string, std::vector<double>> return_history_;
};

} // namespace risk
} // namespace hft
```

================================================================================
5. MARKET REGIME DETECTION
================================================================================

5.1 Regime Detection Algorithm
-------------------------------

```cpp
// market_regime_detector.hpp

namespace hft {
namespace risk {

class MarketRegimeDetector {
public:
    enum class MarketRegime {
        BULL_LOW_VOL,
        BULL_HIGH_VOL,
        BEAR_LOW_VOL,
        BEAR_HIGH_VOL,
        SIDEWAYS,
        CRISIS
    };

    // Detect current market regime
    static MarketRegime detectRegime(
        double market_return_20d,
        double volatility,
        double correlation_avg) {

        // Crisis: High vol + high correlation
        if (volatility > 0.30 && correlation_avg > 0.7) {
            return MarketRegime::CRISIS;
        }

        // Bull vs Bear
        bool is_bull = market_return_20d > 0;

        // High vs Low vol
        bool is_high_vol = volatility > 0.20;

        if (is_bull) {
            return is_high_vol ? MarketRegime::BULL_HIGH_VOL :
                                MarketRegime::BULL_LOW_VOL;
        } else {
            if (std::abs(market_return_20d) < 0.02) {
                return MarketRegime::SIDEWAYS;
            }
            return is_high_vol ? MarketRegime::BEAR_HIGH_VOL :
                                MarketRegime::BEAR_LOW_VOL;
        }
    }

    // Adjust risk limits based on regime
    struct RegimeAdjustments {
        double position_limit_multiplier;
        double var_limit_multiplier;
        bool enable_additional_checks;
    };

    static RegimeAdjustments getRegimeAdjustments(MarketRegime regime) {
        RegimeAdjustments adj;

        switch (regime) {
            case MarketRegime::CRISIS:
                adj.position_limit_multiplier = 0.3;
                adj.var_limit_multiplier = 0.5;
                adj.enable_additional_checks = true;
                break;

            case MarketRegime::BEAR_HIGH_VOL:
                adj.position_limit_multiplier = 0.5;
                adj.var_limit_multiplier = 0.7;
                adj.enable_additional_checks = true;
                break;

            case MarketRegime::BULL_LOW_VOL:
                adj.position_limit_multiplier = 1.2;
                adj.var_limit_multiplier = 1.0;
                adj.enable_additional_checks = false;
                break;

            default:
                adj.position_limit_multiplier = 1.0;
                adj.var_limit_multiplier = 1.0;
                adj.enable_additional_checks = false;
        }

        return adj;
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
6. CONFIGURATION
================================================================================

```json
{
  "market_risk": {
    "volatility_monitoring": {
      "enabled": true,
      "calculation_frequency_seconds": 60,
      "vol_spike_threshold_multiplier": 2.0,
      "vol_regime_lookback_days": 60,
      "alert_on_extreme_vol": true
    },

    "liquidity_monitoring": {
      "enabled": true,
      "min_liquidity_score": 50,
      "max_spread_bps": 50,
      "min_depth_dollars": 100000,
      "max_participation_rate": 0.10,
      "alert_on_illiquidity": true
    },

    "correlation_monitoring": {
      "enabled": true,
      "correlation_lookback_days": 60,
      "breakdown_threshold": 0.3,
      "crisis_correlation_threshold": 0.7
    },

    "market_impact_limits": {
      "max_impact_bps": 10.0,
      "reduce_size_on_high_impact": true
    }
  }
}
```

================================================================================
END OF MARKET RISK DOCUMENTATION
================================================================================
