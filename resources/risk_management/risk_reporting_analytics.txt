================================================================================
RISK REPORTING AND ANALYTICS - HFT RISK MANAGEMENT SYSTEM
================================================================================
Version: 2.1.0
Last Updated: 2025-11-25
Author: HFT Risk Management Team
Purpose: Comprehensive risk reporting, analytics, and visualization framework

================================================================================
1. RISK REPORTING FRAMEWORK
================================================================================

1.1 Report Types and Frequency
-------------------------------

Real-Time Reports (Continuous):
- Position summary
- P&L snapshot
- Risk limit utilization
- Active alerts dashboard
- System health status

Intraday Reports (Every 15 minutes):
- VaR breakdown
- Exposure analysis
- Slippage report
- Best execution analysis

End-of-Day Reports:
- Daily P&L report
- Risk metrics summary
- Limit breach report
- Trade analysis
- Performance attribution

Weekly Reports:
- Risk-adjusted performance
- Volatility analysis
- Correlation changes
- Drawdown analysis

Monthly Reports:
- Comprehensive risk review
- Strategy performance
- Backtesting validation
- Model performance
- Operational metrics

Regulatory Reports (As Required):
- Position reports
- Large trader reports
- Best execution reports
- Audit trail reports

================================================================================
2. C++ RISK REPORTING ENGINE
================================================================================

2.1 Core Report Generator
--------------------------

```cpp
// risk_report_generator.hpp
#ifndef RISK_REPORT_GENERATOR_HPP
#define RISK_REPORT_GENERATOR_HPP

#include <string>
#include <vector>
#include <unordered_map>
#include <chrono>
#include <memory>
#include <fstream>

namespace hft {
namespace risk {

// Report format
enum class ReportFormat {
    JSON,
    CSV,
    HTML,
    PDF,
    XML
};

// Report type
enum class ReportType {
    POSITION_SUMMARY,
    PNL_REPORT,
    RISK_METRICS,
    VAR_REPORT,
    EXPOSURE_ANALYSIS,
    LIMIT_UTILIZATION,
    TRADE_ANALYSIS,
    SLIPPAGE_REPORT,
    COUNTERPARTY_REPORT,
    REGULATORY_REPORT,
    PERFORMANCE_ATTRIBUTION,
    OPERATIONAL_METRICS
};

// Report configuration
struct ReportConfig {
    std::string report_name;
    ReportType type;
    ReportFormat format;

    // Scope
    std::vector<std::string> strategies;
    std::vector<std::string> symbols;
    std::chrono::system_clock::time_point start_time;
    std::chrono::system_clock::time_point end_time;

    // Options
    bool include_charts;
    bool include_detailed_breakdown;
    bool include_historical_comparison;
    int decimal_places;

    // Distribution
    std::vector<std::string> recipients;
    bool auto_distribute;
};

// Position summary report
struct PositionSummaryReport {
    std::chrono::system_clock::time_point report_time;

    struct PositionEntry {
        std::string symbol;
        std::string strategy;
        int64_t quantity;
        double average_price;
        double market_price;
        double market_value;
        double unrealized_pnl;
        double realized_pnl_today;
        double pnl_pct;
    };

    std::vector<PositionEntry> positions;

    // Summary totals
    double total_long_exposure;
    double total_short_exposure;
    double total_gross_exposure;
    double total_net_exposure;
    double total_unrealized_pnl;
    double total_realized_pnl;
    double gross_leverage;
    double net_leverage;

    int num_long_positions;
    int num_short_positions;
    int total_positions;
};

// P&L report
struct PnLReport {
    std::chrono::system_clock::time_point report_time;
    std::string period;  // "today", "week", "month", "year"

    // P&L breakdown
    double trading_pnl;
    double realized_pnl;
    double unrealized_pnl;
    double commission_costs;
    double fee_costs;
    double slippage_costs;
    double funding_costs;
    double total_pnl;

    // By strategy
    std::unordered_map<std::string, double> pnl_by_strategy;

    // By symbol
    std::unordered_map<std::string, double> pnl_by_symbol;

    // By venue
    std::unordered_map<std::string, double> pnl_by_venue;

    // Time series
    std::vector<std::pair<std::chrono::system_clock::time_point, double>> pnl_timeseries;

    // Statistics
    double sharpe_ratio;
    double sortino_ratio;
    double max_drawdown_pct;
    double win_rate;
    int winning_days;
    int losing_days;
};

// Risk metrics report
struct RiskMetricsReport {
    std::chrono::system_clock::time_point report_time;

    // VaR metrics
    double var_95_dollars;
    double var_99_dollars;
    double var_99_9_dollars;
    double expected_shortfall_99;

    // Greeks (if applicable)
    double total_delta;
    double total_gamma;
    double total_vega;
    double total_theta;

    // Volatility metrics
    double portfolio_volatility;
    double avg_position_volatility;
    double max_position_volatility;

    // Correlation metrics
    double avg_correlation;
    double max_correlation;
    double diversification_ratio;

    // Concentration metrics
    double herfindahl_index;
    double top_5_concentration_pct;
    double max_single_position_pct;

    // Factor exposures
    std::unordered_map<std::string, double> factor_exposures;
};

// Trade analysis report
struct TradeAnalysisReport {
    std::chrono::system_clock::time_point report_time;
    std::chrono::system_clock::time_point period_start;
    std::chrono::system_clock::time_point period_end;

    // Trade statistics
    uint64_t total_trades;
    uint64_t buy_trades;
    uint64_t sell_trades;
    int64_t total_volume;
    double total_notional;

    // Execution quality
    double avg_fill_price;
    double avg_slippage_bps;
    double avg_market_impact_bps;
    std::chrono::microseconds avg_execution_latency;

    // Performance
    double total_realized_pnl;
    double avg_pnl_per_trade;
    double win_rate;
    uint64_t winning_trades;
    uint64_t losing_trades;

    // By symbol
    struct SymbolTradeStats {
        std::string symbol;
        uint64_t num_trades;
        int64_t net_quantity;
        double total_pnl;
        double avg_slippage_bps;
    };
    std::vector<SymbolTradeStats> stats_by_symbol;

    // By venue
    struct VenueTradeStats {
        std::string venue;
        uint64_t num_trades;
        double fill_rate;
        double avg_slippage_bps;
        std::chrono::microseconds avg_latency;
    };
    std::vector<VenueTradeStats> stats_by_venue;
};

class RiskReportGenerator {
public:
    RiskReportGenerator();
    ~RiskReportGenerator();

    // Generate reports
    std::string generatePositionSummary(const ReportConfig& config);

    std::string generatePnLReport(const ReportConfig& config);

    std::string generateRiskMetricsReport(const ReportConfig& config);

    std::string generateTradeAnalysisReport(const ReportConfig& config);

    std::string generateExposureReport(const ReportConfig& config);

    std::string generateLimitUtilizationReport(const ReportConfig& config);

    std::string generateCounterpartyReport(const ReportConfig& config);

    // Generic report generation
    std::string generateReport(const ReportConfig& config);

    // Format conversion
    std::string formatAsJSON(const PositionSummaryReport& report) const;

    std::string formatAsCSV(const PositionSummaryReport& report) const;

    std::string formatAsHTML(const PositionSummaryReport& report) const;

    // Distribution
    void distributeReport(const std::string& report_content,
                         const ReportConfig& config);

    void emailReport(const std::string& report_content,
                    const std::vector<std::string>& recipients,
                    const std::string& subject);

    void saveReport(const std::string& report_content,
                   const std::string& filepath);

    // Scheduled reporting
    void scheduleReport(const ReportConfig& config,
                       std::chrono::minutes interval);

    void cancelScheduledReport(const std::string& report_name);

    // Report history
    std::vector<std::string> getReportHistory(
        const std::string& report_type,
        int max_count = 30) const;

private:
    // Data sources
    class PositionManager* position_manager_;
    class PnLCalculator* pnl_calculator_;
    class RiskCalculator* risk_calculator_;
    class TradeAnalyzer* trade_analyzer_;

    // Report storage
    std::string report_directory_;

    // Formatting helpers
    std::string formatNumber(double value, int decimal_places) const;
    std::string formatPercentage(double value, int decimal_places) const;
    std::string formatTimestamp(std::chrono::system_clock::time_point time) const;

    // Chart generation
    std::string generateChart(const std::vector<std::pair<double, double>>& data,
                             const std::string& chart_type) const;
};

// Implementation
inline std::string RiskReportGenerator::formatAsJSON(
    const PositionSummaryReport& report) const {

    std::ostringstream json;
    json << "{\n";
    json << "  \"report_time\": \"" << formatTimestamp(report.report_time) << "\",\n";
    json << "  \"positions\": [\n";

    for (size_t i = 0; i < report.positions.size(); i++) {
        const auto& pos = report.positions[i];
        json << "    {\n";
        json << "      \"symbol\": \"" << pos.symbol << "\",\n";
        json << "      \"strategy\": \"" << pos.strategy << "\",\n";
        json << "      \"quantity\": " << pos.quantity << ",\n";
        json << "      \"average_price\": " << formatNumber(pos.average_price, 2) << ",\n";
        json << "      \"market_price\": " << formatNumber(pos.market_price, 2) << ",\n";
        json << "      \"market_value\": " << formatNumber(pos.market_value, 2) << ",\n";
        json << "      \"unrealized_pnl\": " << formatNumber(pos.unrealized_pnl, 2) << ",\n";
        json << "      \"realized_pnl_today\": " << formatNumber(pos.realized_pnl_today, 2) << "\n";
        json << "    }";
        if (i < report.positions.size() - 1) json << ",";
        json << "\n";
    }

    json << "  ],\n";
    json << "  \"summary\": {\n";
    json << "    \"total_gross_exposure\": " << formatNumber(report.total_gross_exposure, 2) << ",\n";
    json << "    \"total_net_exposure\": " << formatNumber(report.total_net_exposure, 2) << ",\n";
    json << "    \"total_unrealized_pnl\": " << formatNumber(report.total_unrealized_pnl, 2) << ",\n";
    json << "    \"gross_leverage\": " << formatNumber(report.gross_leverage, 2) << ",\n";
    json << "    \"total_positions\": " << report.total_positions << "\n";
    json << "  }\n";
    json << "}\n";

    return json.str();
}

inline std::string RiskReportGenerator::formatAsCSV(
    const PositionSummaryReport& report) const {

    std::ostringstream csv;

    // Header
    csv << "Symbol,Strategy,Quantity,Average Price,Market Price,Market Value,"
        << "Unrealized PnL,Realized PnL Today,PnL %\n";

    // Data rows
    for (const auto& pos : report.positions) {
        csv << pos.symbol << ","
            << pos.strategy << ","
            << pos.quantity << ","
            << formatNumber(pos.average_price, 2) << ","
            << formatNumber(pos.market_price, 2) << ","
            << formatNumber(pos.market_value, 2) << ","
            << formatNumber(pos.unrealized_pnl, 2) << ","
            << formatNumber(pos.realized_pnl_today, 2) << ","
            << formatPercentage(pos.pnl_pct, 2) << "\n";
    }

    // Summary
    csv << "\nSummary\n";
    csv << "Total Gross Exposure," << formatNumber(report.total_gross_exposure, 2) << "\n";
    csv << "Total Net Exposure," << formatNumber(report.total_net_exposure, 2) << "\n";
    csv << "Total Unrealized PnL," << formatNumber(report.total_unrealized_pnl, 2) << "\n";
    csv << "Gross Leverage," << formatNumber(report.gross_leverage, 2) << "\n";
    csv << "Total Positions," << report.total_positions << "\n";

    return csv.str();
}

inline std::string RiskReportGenerator::formatAsHTML(
    const PositionSummaryReport& report) const {

    std::ostringstream html;

    html << "<!DOCTYPE html>\n";
    html << "<html>\n<head>\n";
    html << "<title>Position Summary Report</title>\n";
    html << "<style>\n";
    html << "body { font-family: Arial, sans-serif; margin: 20px; }\n";
    html << "h1 { color: #333; }\n";
    html << "table { border-collapse: collapse; width: 100%; margin-top: 20px; }\n";
    html << "th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }\n";
    html << "th { background-color: #4CAF50; color: white; }\n";
    html << "tr:nth-child(even) { background-color: #f2f2f2; }\n";
    html << ".positive { color: green; }\n";
    html << ".negative { color: red; }\n";
    html << ".summary { background-color: #e8f5e9; font-weight: bold; }\n";
    html << "</style>\n";
    html << "</head>\n<body>\n";

    html << "<h1>Position Summary Report</h1>\n";
    html << "<p>Generated: " << formatTimestamp(report.report_time) << "</p>\n";

    html << "<table>\n";
    html << "<tr>\n";
    html << "<th>Symbol</th><th>Strategy</th><th>Quantity</th>";
    html << "<th>Avg Price</th><th>Market Price</th><th>Market Value</th>";
    html << "<th>Unrealized PnL</th><th>Realized PnL Today</th><th>PnL %</th>\n";
    html << "</tr>\n";

    for (const auto& pos : report.positions) {
        std::string pnl_class = (pos.unrealized_pnl >= 0) ? "positive" : "negative";
        html << "<tr>\n";
        html << "<td>" << pos.symbol << "</td>";
        html << "<td>" << pos.strategy << "</td>";
        html << "<td>" << pos.quantity << "</td>";
        html << "<td>" << formatNumber(pos.average_price, 2) << "</td>";
        html << "<td>" << formatNumber(pos.market_price, 2) << "</td>";
        html << "<td>" << formatNumber(pos.market_value, 2) << "</td>";
        html << "<td class=\"" << pnl_class << "\">" << formatNumber(pos.unrealized_pnl, 2) << "</td>";
        html << "<td class=\"" << pnl_class << "\">" << formatNumber(pos.realized_pnl_today, 2) << "</td>";
        html << "<td class=\"" << pnl_class << "\">" << formatPercentage(pos.pnl_pct, 2) << "%</td>\n";
        html << "</tr>\n";
    }

    html << "</table>\n";

    // Summary section
    html << "<h2>Summary</h2>\n";
    html << "<table style=\"width: 50%;\">\n";
    html << "<tr class=\"summary\"><td>Total Gross Exposure</td><td>"
         << formatNumber(report.total_gross_exposure, 2) << "</td></tr>\n";
    html << "<tr class=\"summary\"><td>Total Net Exposure</td><td>"
         << formatNumber(report.total_net_exposure, 2) << "</td></tr>\n";
    html << "<tr class=\"summary\"><td>Total Unrealized PnL</td><td>"
         << formatNumber(report.total_unrealized_pnl, 2) << "</td></tr>\n";
    html << "<tr class=\"summary\"><td>Gross Leverage</td><td>"
         << formatNumber(report.gross_leverage, 2) << "x</td></tr>\n";
    html << "<tr class=\"summary\"><td>Total Positions</td><td>"
         << report.total_positions << "</td></tr>\n";
    html << "</table>\n";

    html << "</body>\n</html>\n";

    return html.str();
}

} // namespace risk
} // namespace hft

#endif // RISK_REPORT_GENERATOR_HPP
```

================================================================================
3. RISK ANALYTICS ENGINE
================================================================================

3.1 Advanced Analytics
-----------------------

```cpp
// risk_analytics.hpp

namespace hft {
namespace risk {

class RiskAnalytics {
public:
    // Performance attribution
    struct AttributionAnalysis {
        // Alpha/Beta decomposition
        double total_return;
        double alpha_return;
        double beta_return;
        double market_timing_return;
        double stock_selection_return;

        // Factor attribution
        std::unordered_map<std::string, double> factor_returns;

        // Interaction effects
        double diversification_return;
    };

    AttributionAnalysis performAttributionAnalysis(
        const std::string& strategy_id,
        const std::chrono::system_clock::time_point& start_date,
        const std::chrono::system_clock::time_point& end_date);

    // Risk-adjusted performance metrics
    struct PerformanceMetrics {
        double sharpe_ratio;
        double sortino_ratio;
        double calmar_ratio;
        double omega_ratio;
        double information_ratio;
        double treynor_ratio;
        double max_drawdown;
        double var_adjusted_return;
    };

    PerformanceMetrics calculatePerformanceMetrics(
        const std::vector<double>& returns,
        double risk_free_rate = 0.03);

    // Scenario analysis
    struct ScenarioResult {
        std::string scenario_name;
        double expected_pnl;
        double pnl_std_dev;
        double var_99;
        double expected_shortfall;
        std::unordered_map<std::string, double> position_impacts;
    };

    std::vector<ScenarioResult> runScenarioAnalysis(
        const std::vector<std::string>& scenario_names);

    // Stress testing
    struct StressTestResult {
        std::string test_name;
        double portfolio_value_before;
        double portfolio_value_after;
        double loss_pct;
        bool breaches_limits;
        std::vector<std::string> breached_limits;
    };

    std::vector<StressTestResult> runStressTests();

    // Rolling risk metrics
    struct RollingMetrics {
        std::vector<std::chrono::system_clock::time_point> dates;
        std::vector<double> rolling_sharpe;
        std::vector<double> rolling_vol;
        std::vector<double> rolling_var;
        std::vector<double> rolling_beta;
    };

    RollingMetrics calculateRollingMetrics(
        const std::string& strategy_id,
        int window_days = 60);

    // Correlation dynamics
    struct CorrelationDynamics {
        Eigen::MatrixXd current_correlation;
        Eigen::MatrixXd avg_correlation;
        Eigen::MatrixXd correlation_change;
        std::vector<std::pair<std::string, std::string>> high_correlation_pairs;
        double avg_pairwise_correlation;
    };

    CorrelationDynamics analyzeCorrelationDynamics();

    // Tail risk analysis
    struct TailRiskMetrics {
        double skewness;
        double kurtosis;
        double left_tail_index;
        double right_tail_index;
        std::vector<double> extreme_losses;
        double conditional_var;
    };

    TailRiskMetrics analyzeTailRisk(const std::vector<double>& returns);

private:
    double calculateSharpeRatio(const std::vector<double>& returns,
                               double risk_free_rate) const;

    double calculateSortinoRatio(const std::vector<double>& returns,
                                double risk_free_rate) const;

    double calculateMaxDrawdown(const std::vector<double>& cumulative_returns) const;
};

} // namespace risk
} // namespace hft
```

================================================================================
4. REAL-TIME DASHBOARD DATA
================================================================================

4.1 Dashboard Data Provider
----------------------------

```cpp
// dashboard_data_provider.hpp

namespace hft {
namespace risk {

class DashboardDataProvider {
public:
    // Real-time risk dashboard data
    struct DashboardData {
        // Overall status
        std::string system_status;  // "HEALTHY", "WARNING", "CRITICAL"
        int active_alerts;
        int critical_alerts;

        // Position metrics
        double gross_exposure;
        double net_exposure;
        double gross_leverage;
        int num_positions;

        // P&L metrics
        double pnl_today;
        double pnl_mtd;
        double pnl_ytd;
        double pnl_today_pct;

        // Risk metrics
        double var_95;
        double var_99;
        double current_drawdown_pct;
        double max_drawdown_pct;

        // Limit utilization
        double position_limit_util_pct;
        double var_limit_util_pct;
        double exposure_limit_util_pct;

        // Recent activity
        uint64_t orders_today;
        uint64_t trades_today;
        uint64_t cancels_today;
        uint64_t rejects_today;

        // Performance
        double sharpe_ratio_ytd;
        double win_rate_today;
        double avg_trade_pnl;

        std::chrono::system_clock::time_point last_update;
    };

    DashboardData getDashboardData() const;

    // Time series data for charts
    std::vector<std::pair<int64_t, double>> getPnLTimeSeries(
        std::chrono::hours lookback) const;

    std::vector<std::pair<int64_t, double>> getVaRTimeSeries(
        std::chrono::hours lookback) const;

    std::vector<std::pair<int64_t, double>> getExposureTimeSeries(
        std::chrono::hours lookback) const;

    // Top positions
    struct TopPosition {
        std::string symbol;
        double market_value;
        double pnl;
        double pnl_pct;
    };

    std::vector<TopPosition> getTopPositions(int count = 10) const;

    // Recent trades
    struct RecentTrade {
        std::string symbol;
        char side;
        int64_t quantity;
        double price;
        double pnl;
        std::chrono::system_clock::time_point time;
    };

    std::vector<RecentTrade> getRecentTrades(int count = 20) const;

    // Active alerts
    std::vector<std::string> getActiveAlerts() const;
};

} // namespace risk
} // namespace hft
```

================================================================================
5. REPORT SCHEDULING
================================================================================

5.1 Automated Report Generation
--------------------------------

```json
{
  "scheduled_reports": [
    {
      "name": "intraday_risk_snapshot",
      "type": "RISK_METRICS",
      "format": "JSON",
      "frequency": "15_MINUTES",
      "recipients": ["risk@firm.com"],
      "enabled": true
    },
    {
      "name": "eod_pnl_report",
      "type": "PNL_REPORT",
      "format": "HTML",
      "frequency": "DAILY",
      "time": "16:00",
      "recipients": ["trading@firm.com", "risk@firm.com"],
      "enabled": true
    },
    {
      "name": "weekly_performance",
      "type": "PERFORMANCE_ATTRIBUTION",
      "format": "PDF",
      "frequency": "WEEKLY",
      "day": "FRIDAY",
      "time": "17:00",
      "recipients": ["management@firm.com"],
      "enabled": true
    }
  ]
}
```

================================================================================
6. REGULATORY REPORTING
================================================================================

6.1 Regulatory Report Templates
--------------------------------

```cpp
// regulatory_reporting.hpp

namespace hft {
namespace risk {

class RegulatoryReporter {
public:
    // CFTC Large Trader Report
    std::string generateCFTCLargeTraderReport(
        const std::chrono::system_clock::time_point& date);

    // SEC Rule 15c3-5 (Market Access Rule)
    std::string generateMarketAccessReport();

    // MiFID II Transaction Reporting
    std::string generateMiFIDIIReport(
        const std::chrono::system_clock::time_point& start_date,
        const std::chrono::system_clock::time_point& end_date);

    // Best Execution Report (MiFID II / Reg NMS)
    std::string generateBestExecutionReport();

    // Position Limit Report
    std::string generatePositionLimitReport();

private:
    std::string formatForRegulator(const std::string& content,
                                  const std::string& regulator);
};

} // namespace risk
} // namespace hft
```

================================================================================
7. VISUALIZATION AND CHARTING
================================================================================

7.1 Chart Generation
---------------------

Chart Types Supported:

1. Line Charts
   - P&L time series
   - VaR evolution
   - Exposure trends

2. Bar Charts
   - Position breakdown
   - P&L by strategy
   - Volume by venue

3. Heatmaps
   - Correlation matrix
   - Risk concentration
   - Intraday activity

4. Scatter Plots
   - Risk-return analysis
   - Alpha vs beta
   - Volatility vs returns

5. Histograms
   - Return distribution
   - P&L distribution
   - Trade size distribution

================================================================================
END OF RISK REPORTING AND ANALYTICS DOCUMENTATION
================================================================================
