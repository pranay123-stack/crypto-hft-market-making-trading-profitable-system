================================================================================
DRAWDOWN MANAGEMENT AND CIRCUIT BREAKERS - HFT RISK MANAGEMENT
================================================================================
Version: 2.1.0
Last Updated: 2025-11-25
Author: HFT Risk Management Team
Purpose: Real-time drawdown monitoring and automated circuit breaker mechanisms

================================================================================
1. DRAWDOWN MANAGEMENT FRAMEWORK
================================================================================

1.1 Drawdown Types and Definitions
-----------------------------------

Type 1: Absolute Drawdown
  - Decline from initial capital
  - Formula: DD_abs = (Initial_Capital - Current_Capital) / Initial_Capital
  - Trigger: Absolute loss threshold (e.g., 2% of starting capital)

Type 2: Relative Drawdown (Peak-to-Trough)
  - Decline from highest equity peak
  - Formula: DD_rel = (Peak_Equity - Current_Equity) / Peak_Equity
  - Trigger: Most common in HFT systems (e.g., 5% from peak)

Type 3: Daily Drawdown
  - Maximum intraday loss
  - Formula: DD_daily = (Day_Start_Equity - Current_Equity) / Day_Start_Equity
  - Trigger: Daily loss limit (e.g., 1% per day)

Type 4: Strategy Drawdown
  - Per-strategy loss tracking
  - Independent drawdown limits per strategy
  - Allows isolation of problematic strategies

Type 5: Velocity-Adjusted Drawdown
  - Considers rate of loss
  - Rapid losses trigger earlier intervention
  - Formula: Weighted by loss velocity

================================================================================
2. C++ DRAWDOWN MONITORING ENGINE
================================================================================

2.1 Core Drawdown Monitor Implementation
-----------------------------------------

```cpp
// drawdown_monitor.hpp
#ifndef DRAWDOWN_MONITOR_HPP
#define DRAWDOWN_MONITOR_HPP

#include <string>
#include <unordered_map>
#include <mutex>
#include <shared_mutex>
#include <atomic>
#include <chrono>
#include <vector>
#include <deque>
#include <optional>
#include <cmath>

namespace hft {
namespace risk {

// Drawdown event severity
enum class DrawdownSeverity {
    NORMAL,              // Within acceptable range
    WARNING,             // Approaching threshold
    CRITICAL,            // At threshold
    EMERGENCY,           // Exceeded threshold
    CATASTROPHIC         // Far exceeded - emergency shutdown
};

// Circuit breaker action
enum class CircuitBreakerAction {
    NONE,                // No action
    ALERT_ONLY,          // Send alert, continue trading
    REDUCE_POSITION,     // Scale down positions by %
    HALT_NEW_TRADES,     // Stop new trades, allow exits
    FLATTEN_POSITIONS,   // Close all positions
    KILL_SWITCH          // Complete shutdown
};

// Drawdown configuration
struct DrawdownConfig {
    std::string strategy_id;

    // Absolute drawdown thresholds
    double abs_warning_threshold_pct;     // 1.0 = 1%
    double abs_critical_threshold_pct;    // 2.0 = 2%
    double abs_emergency_threshold_pct;   // 3.0 = 3%

    // Relative drawdown thresholds
    double rel_warning_threshold_pct;     // 3.0 = 3%
    double rel_critical_threshold_pct;    // 5.0 = 5%
    double rel_emergency_threshold_pct;   // 7.0 = 7%

    // Daily drawdown thresholds
    double daily_warning_threshold_pct;   // 0.5 = 0.5%
    double daily_critical_threshold_pct;  // 1.0 = 1%
    double daily_emergency_threshold_pct; // 1.5 = 1.5%

    // Velocity-based thresholds
    double max_loss_per_minute;           // Maximum $ loss per minute
    double max_loss_per_hour;             // Maximum $ loss per hour
    bool enable_velocity_checks;

    // Recovery settings
    double recovery_threshold_pct;        // Must recover X% to reset
    std::chrono::minutes recovery_period; // Time window for recovery

    // Actions per severity
    CircuitBreakerAction warning_action;
    CircuitBreakerAction critical_action;
    CircuitBreakerAction emergency_action;

    // Auto-recovery settings
    bool auto_resume_after_recovery;
    std::chrono::minutes min_halt_duration;
};

// Drawdown state
struct DrawdownState {
    std::string strategy_id;

    // Capital tracking
    double initial_capital;
    double peak_equity;
    double current_equity;
    double day_start_equity;

    // Drawdown metrics
    double absolute_drawdown_pct;
    double relative_drawdown_pct;
    double daily_drawdown_pct;
    double max_drawdown_ever_pct;

    // Dollar values
    double absolute_drawdown_dollars;
    double relative_drawdown_dollars;
    double daily_drawdown_dollars;

    // Velocity metrics
    double loss_rate_per_minute;
    double loss_rate_per_hour;
    std::deque<std::pair<std::chrono::system_clock::time_point, double>> loss_history;

    // Status
    DrawdownSeverity current_severity;
    bool circuit_breaker_active;
    CircuitBreakerAction active_action;

    // Timestamps
    std::chrono::system_clock::time_point peak_equity_time;
    std::chrono::system_clock::time_point last_update_time;
    std::chrono::system_clock::time_point circuit_breaker_trigger_time;

    // Recovery tracking
    double lowest_equity_in_drawdown;
    double recovery_from_low_pct;
    bool in_recovery_phase;
};

// Circuit breaker event
struct CircuitBreakerEvent {
    std::string event_id;
    std::string strategy_id;

    CircuitBreakerAction action;
    DrawdownSeverity severity;

    std::string trigger_reason;
    double drawdown_pct;
    double equity_at_trigger;

    std::chrono::system_clock::time_point trigger_time;
    std::chrono::system_clock::time_point resume_time;
    bool is_active;

    std::string resolution_note;
};

class DrawdownMonitor {
public:
    DrawdownMonitor();
    ~DrawdownMonitor();

    // Configuration
    void setConfig(const std::string& strategy_id,
                   const DrawdownConfig& config);

    DrawdownConfig getConfig(const std::string& strategy_id) const;

    // Initialize strategy tracking
    void initializeStrategy(const std::string& strategy_id,
                           double initial_capital);

    void resetStrategy(const std::string& strategy_id);

    // Real-time equity updates
    void updateEquity(const std::string& strategy_id,
                     double current_equity);

    void updatePnL(const std::string& strategy_id,
                   double pnl_change);

    // Drawdown calculations
    DrawdownState getDrawdownState(const std::string& strategy_id) const;

    double calculateAbsoluteDrawdown(const std::string& strategy_id) const;
    double calculateRelativeDrawdown(const std::string& strategy_id) const;
    double calculateDailyDrawdown(const std::string& strategy_id) const;

    // Velocity calculations
    double calculateLossVelocity(const std::string& strategy_id,
                                std::chrono::minutes window) const;

    // Circuit breaker checks
    DrawdownSeverity checkDrawdown(const std::string& strategy_id);

    bool isCircuitBreakerActive(const std::string& strategy_id) const;

    CircuitBreakerAction getActiveAction(const std::string& strategy_id) const;

    // Circuit breaker control
    void triggerCircuitBreaker(const std::string& strategy_id,
                              CircuitBreakerAction action,
                              const std::string& reason);

    bool attemptResume(const std::string& strategy_id,
                      const std::string& authorized_user);

    void manualOverride(const std::string& strategy_id,
                       const std::string& authorized_user,
                       const std::string& reason);

    // Recovery monitoring
    bool checkRecoveryConditions(const std::string& strategy_id) const;

    void startRecoveryPhase(const std::string& strategy_id);

    // Session management
    void startNewDay();
    void endDay();

    // Statistics and reporting
    struct DrawdownStatistics {
        std::string strategy_id;
        double avg_drawdown_pct;
        double max_drawdown_pct;
        double current_drawdown_pct;
        int circuit_breaker_triggers_today;
        int circuit_breaker_triggers_total;
        std::chrono::minutes total_halt_time_today;
        double total_losses_today;
    };

    DrawdownStatistics getStatistics(const std::string& strategy_id) const;

    std::vector<CircuitBreakerEvent> getCircuitBreakerHistory(
        const std::string& strategy_id,
        size_t max_count = 100) const;

    // Global kill switch
    void engageGlobalKillSwitch(const std::string& reason);
    void disengageGlobalKillSwitch(const std::string& authorized_user);
    bool isGlobalKillSwitchActive() const { return global_kill_switch_.load(); }

private:
    // Internal calculation helpers
    void calculateDrawdowns(DrawdownState& state) const;

    void updateLossVelocity(DrawdownState& state,
                           double equity_change);

    DrawdownSeverity determineSeverity(const DrawdownState& state,
                                      const DrawdownConfig& config) const;

    CircuitBreakerAction determineAction(DrawdownSeverity severity,
                                        const DrawdownConfig& config) const;

    void executeCircuitBreakerAction(const std::string& strategy_id,
                                    CircuitBreakerAction action);

    void recordCircuitBreakerEvent(const CircuitBreakerEvent& event);

    void sendAlert(const std::string& strategy_id,
                  DrawdownSeverity severity,
                  const std::string& message);

    // Data structures
    mutable std::shared_mutex config_mutex_;
    std::unordered_map<std::string, DrawdownConfig> configs_;

    mutable std::shared_mutex state_mutex_;
    std::unordered_map<std::string, DrawdownState> states_;

    mutable std::shared_mutex events_mutex_;
    std::vector<CircuitBreakerEvent> event_history_;

    // Global state
    std::atomic<bool> global_kill_switch_{false};
    std::chrono::system_clock::time_point day_start_time_;

    // Statistics
    std::atomic<uint64_t> total_circuit_breaker_triggers_{0};
    std::atomic<uint64_t> total_checks_{0};
};

// Implementation
inline void DrawdownMonitor::initializeStrategy(
    const std::string& strategy_id,
    double initial_capital) {

    std::unique_lock<std::shared_mutex> lock(state_mutex_);

    DrawdownState state{};
    state.strategy_id = strategy_id;
    state.initial_capital = initial_capital;
    state.peak_equity = initial_capital;
    state.current_equity = initial_capital;
    state.day_start_equity = initial_capital;
    state.current_severity = DrawdownSeverity::NORMAL;
    state.circuit_breaker_active = false;
    state.peak_equity_time = std::chrono::system_clock::now();
    state.last_update_time = std::chrono::system_clock::now();

    states_[strategy_id] = state;
}

inline void DrawdownMonitor::updateEquity(
    const std::string& strategy_id,
    double current_equity) {

    std::unique_lock<std::shared_mutex> lock(state_mutex_);

    auto it = states_.find(strategy_id);
    if (it == states_.end()) {
        return;
    }

    auto& state = it->second;
    double equity_change = current_equity - state.current_equity;

    // Update equity
    state.current_equity = current_equity;

    // Update peak if new high
    if (current_equity > state.peak_equity) {
        state.peak_equity = current_equity;
        state.peak_equity_time = std::chrono::system_clock::now();
        state.in_recovery_phase = false;
    }

    // Update loss velocity
    updateLossVelocity(state, equity_change);

    // Recalculate drawdowns
    calculateDrawdowns(state);

    state.last_update_time = std::chrono::system_clock::now();
}

inline void DrawdownMonitor::calculateDrawdowns(DrawdownState& state) const {
    // Absolute drawdown
    state.absolute_drawdown_dollars = state.initial_capital - state.current_equity;
    state.absolute_drawdown_pct = (state.absolute_drawdown_dollars /
                                   state.initial_capital) * 100.0;

    // Relative drawdown (peak to trough)
    state.relative_drawdown_dollars = state.peak_equity - state.current_equity;
    state.relative_drawdown_pct = (state.relative_drawdown_dollars /
                                   state.peak_equity) * 100.0;

    // Daily drawdown
    state.daily_drawdown_dollars = state.day_start_equity - state.current_equity;
    state.daily_drawdown_pct = (state.daily_drawdown_dollars /
                               state.day_start_equity) * 100.0;

    // Update max drawdown ever
    state.max_drawdown_ever_pct = std::max(state.max_drawdown_ever_pct,
                                           state.relative_drawdown_pct);

    // Track lowest equity in current drawdown
    if (state.relative_drawdown_pct > 0) {
        state.lowest_equity_in_drawdown = std::min(
            state.lowest_equity_in_drawdown == 0 ? state.current_equity :
                                                   state.lowest_equity_in_drawdown,
            state.current_equity
        );
    }

    // Calculate recovery percentage
    if (state.lowest_equity_in_drawdown > 0) {
        state.recovery_from_low_pct =
            ((state.current_equity - state.lowest_equity_in_drawdown) /
             state.lowest_equity_in_drawdown) * 100.0;
    }
}

inline void DrawdownMonitor::updateLossVelocity(
    DrawdownState& state,
    double equity_change) {

    auto now = std::chrono::system_clock::now();

    // Add to history if it's a loss
    if (equity_change < 0) {
        state.loss_history.push_back({now, equity_change});
    }

    // Remove old entries (older than 1 hour)
    auto cutoff_time = now - std::chrono::hours(1);
    while (!state.loss_history.empty() &&
           state.loss_history.front().first < cutoff_time) {
        state.loss_history.pop_front();
    }

    // Calculate loss rates
    double loss_last_minute = 0.0;
    double loss_last_hour = 0.0;

    auto one_min_ago = now - std::chrono::minutes(1);
    auto one_hour_ago = now - std::chrono::hours(1);

    for (const auto& [timestamp, loss] : state.loss_history) {
        if (timestamp >= one_min_ago) {
            loss_last_minute += std::abs(loss);
        }
        if (timestamp >= one_hour_ago) {
            loss_last_hour += std::abs(loss);
        }
    }

    state.loss_rate_per_minute = loss_last_minute;
    state.loss_rate_per_hour = loss_last_hour;
}

inline DrawdownSeverity DrawdownMonitor::checkDrawdown(
    const std::string& strategy_id) {

    total_checks_.fetch_add(1, std::memory_order_relaxed);

    std::shared_lock<std::shared_mutex> state_lock(state_mutex_);
    std::shared_lock<std::shared_mutex> config_lock(config_mutex_);

    auto state_it = states_.find(strategy_id);
    auto config_it = configs_.find(strategy_id);

    if (state_it == states_.end() || config_it == configs_.end()) {
        return DrawdownSeverity::NORMAL;
    }

    const auto& state = state_it->second;
    const auto& config = config_it->second;

    state_lock.unlock();
    config_lock.unlock();

    // Determine severity based on thresholds
    auto severity = determineSeverity(state, config);

    // Update state with new severity
    {
        std::unique_lock<std::shared_mutex> lock(state_mutex_);
        states_[strategy_id].current_severity = severity;
    }

    // Trigger circuit breaker if needed
    if (severity >= DrawdownSeverity::CRITICAL) {
        auto action = determineAction(severity, config);
        if (action != CircuitBreakerAction::NONE) {
            triggerCircuitBreaker(strategy_id, action,
                                "Drawdown threshold exceeded");
        }
    }

    return severity;
}

inline DrawdownSeverity DrawdownMonitor::determineSeverity(
    const DrawdownState& state,
    const DrawdownConfig& config) const {

    // Check emergency thresholds first
    if (state.absolute_drawdown_pct >= config.abs_emergency_threshold_pct ||
        state.relative_drawdown_pct >= config.rel_emergency_threshold_pct ||
        state.daily_drawdown_pct >= config.daily_emergency_threshold_pct) {
        return DrawdownSeverity::EMERGENCY;
    }

    // Check critical thresholds
    if (state.absolute_drawdown_pct >= config.abs_critical_threshold_pct ||
        state.relative_drawdown_pct >= config.rel_critical_threshold_pct ||
        state.daily_drawdown_pct >= config.daily_critical_threshold_pct) {
        return DrawdownSeverity::CRITICAL;
    }

    // Check warning thresholds
    if (state.absolute_drawdown_pct >= config.abs_warning_threshold_pct ||
        state.relative_drawdown_pct >= config.rel_warning_threshold_pct ||
        state.daily_drawdown_pct >= config.daily_warning_threshold_pct) {
        return DrawdownSeverity::WARNING;
    }

    // Check velocity thresholds
    if (config.enable_velocity_checks) {
        if (state.loss_rate_per_minute > config.max_loss_per_minute) {
            return DrawdownSeverity::CRITICAL;
        }
        if (state.loss_rate_per_hour > config.max_loss_per_hour) {
            return DrawdownSeverity::WARNING;
        }
    }

    return DrawdownSeverity::NORMAL;
}

inline CircuitBreakerAction DrawdownMonitor::determineAction(
    DrawdownSeverity severity,
    const DrawdownConfig& config) const {

    switch (severity) {
        case DrawdownSeverity::WARNING:
            return config.warning_action;
        case DrawdownSeverity::CRITICAL:
            return config.critical_action;
        case DrawdownSeverity::EMERGENCY:
        case DrawdownSeverity::CATASTROPHIC:
            return config.emergency_action;
        default:
            return CircuitBreakerAction::NONE;
    }
}

inline void DrawdownMonitor::triggerCircuitBreaker(
    const std::string& strategy_id,
    CircuitBreakerAction action,
    const std::string& reason) {

    std::unique_lock<std::shared_mutex> lock(state_mutex_);

    auto it = states_.find(strategy_id);
    if (it == states_.end()) {
        return;
    }

    auto& state = it->second;

    // Don't re-trigger if already active
    if (state.circuit_breaker_active) {
        return;
    }

    // Update state
    state.circuit_breaker_active = true;
    state.active_action = action;
    state.circuit_breaker_trigger_time = std::chrono::system_clock::now();

    // Create event
    CircuitBreakerEvent event;
    event.event_id = "CB_" + std::to_string(
        total_circuit_breaker_triggers_.fetch_add(1));
    event.strategy_id = strategy_id;
    event.action = action;
    event.severity = state.current_severity;
    event.trigger_reason = reason;
    event.drawdown_pct = state.relative_drawdown_pct;
    event.equity_at_trigger = state.current_equity;
    event.trigger_time = state.circuit_breaker_trigger_time;
    event.is_active = true;

    lock.unlock();

    // Record event
    recordCircuitBreakerEvent(event);

    // Execute action
    executeCircuitBreakerAction(strategy_id, action);

    // Send alerts
    sendAlert(strategy_id, state.current_severity,
             "Circuit breaker triggered: " + reason);
}

inline void DrawdownMonitor::executeCircuitBreakerAction(
    const std::string& strategy_id,
    CircuitBreakerAction action) {

    switch (action) {
        case CircuitBreakerAction::ALERT_ONLY:
            // Already sent alert
            break;

        case CircuitBreakerAction::REDUCE_POSITION:
            // Reduce positions by 50%
            // Implementation: Call position manager to reduce
            break;

        case CircuitBreakerAction::HALT_NEW_TRADES:
            // Stop accepting new orders
            // Implementation: Set trading flag to false
            break;

        case CircuitBreakerAction::FLATTEN_POSITIONS:
            // Close all positions
            // Implementation: Call position manager to flatten
            break;

        case CircuitBreakerAction::KILL_SWITCH:
            // Complete system shutdown
            engageGlobalKillSwitch("Circuit breaker triggered for " + strategy_id);
            break;

        default:
            break;
    }
}

} // namespace risk
} // namespace hft

#endif // DRAWDOWN_MONITOR_HPP
```

================================================================================
3. CIRCUIT BREAKER ALGORITHMS
================================================================================

3.1 Adaptive Circuit Breaker Thresholds
----------------------------------------

```cpp
// adaptive_circuit_breaker.hpp

namespace hft {
namespace risk {

class AdaptiveCircuitBreaker {
public:
    // Adjust thresholds based on market volatility
    static DrawdownConfig adjustForVolatility(
        const DrawdownConfig& base_config,
        double current_volatility,
        double normal_volatility) {

        DrawdownConfig adjusted = base_config;

        if (current_volatility <= 0 || normal_volatility <= 0) {
            return adjusted;
        }

        // Tighten thresholds in high volatility
        double vol_ratio = current_volatility / normal_volatility;

        if (vol_ratio > 1.5) {  // High volatility
            adjusted.rel_warning_threshold_pct *= 0.8;
            adjusted.rel_critical_threshold_pct *= 0.8;
            adjusted.daily_critical_threshold_pct *= 0.8;
        } else if (vol_ratio < 0.7) {  // Low volatility
            adjusted.rel_warning_threshold_pct *= 1.2;
            adjusted.rel_critical_threshold_pct *= 1.2;
        }

        return adjusted;
    }

    // Time-of-day based thresholds
    static DrawdownConfig adjustForTimeOfDay(
        const DrawdownConfig& base_config,
        std::chrono::hours time_of_day) {

        DrawdownConfig adjusted = base_config;

        // Tighter limits during illiquid times
        if (time_of_day.count() < 9 || time_of_day.count() > 16) {
            // Pre-market or after-hours
            adjusted.daily_critical_threshold_pct *= 0.7;
            adjusted.max_loss_per_minute *= 0.5;
        }

        return adjusted;
    }

    // Strategy performance based adjustment
    static DrawdownConfig adjustForPerformance(
        const DrawdownConfig& base_config,
        double sharpe_ratio,
        int consecutive_loss_days) {

        DrawdownConfig adjusted = base_config;

        // Tighten limits for underperforming strategies
        if (sharpe_ratio < 1.0 || consecutive_loss_days > 3) {
            adjusted.rel_critical_threshold_pct *= 0.7;
            adjusted.daily_critical_threshold_pct *= 0.7;
        }

        // Loosen limits for high-performing strategies
        if (sharpe_ratio > 2.0 && consecutive_loss_days == 0) {
            adjusted.rel_critical_threshold_pct *= 1.2;
        }

        return adjusted;
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
4. RECOVERY MECHANISMS
================================================================================

4.1 Automated Recovery System
------------------------------

```cpp
// recovery_manager.hpp

namespace hft {
namespace risk {

struct RecoveryConfig {
    // Recovery thresholds
    double min_recovery_pct;              // Must recover X% from low
    std::chrono::minutes recovery_period; // Time window to observe

    // Gradual resumption
    bool enable_gradual_resumption;
    std::vector<double> position_scale_steps;  // e.g., [0.25, 0.5, 0.75, 1.0]
    std::chrono::minutes time_between_steps;

    // Validation requirements
    int min_profitable_trades;            // Before full resumption
    double min_win_rate_pct;              // Required win rate
    bool require_manual_approval;         // For emergency situations
};

class RecoveryManager {
public:
    RecoveryManager(const RecoveryConfig& config)
        : config_(config) {}

    // Check if strategy can resume
    bool canResume(const std::string& strategy_id,
                   const DrawdownState& state) const {

        // Check recovery percentage
        if (state.recovery_from_low_pct < config_.min_recovery_pct) {
            return false;
        }

        // Check time since trigger
        auto time_since_trigger = std::chrono::system_clock::now() -
                                 state.circuit_breaker_trigger_time;

        if (time_since_trigger < config_.recovery_period) {
            return false;
        }

        // Check if still in drawdown
        if (state.relative_drawdown_pct > state.max_drawdown_ever_pct * 0.5) {
            return false;
        }

        return true;
    }

    // Get current position scaling factor
    double getPositionScaleFactor(const std::string& strategy_id,
                                 std::chrono::minutes time_since_resume) const {

        if (!config_.enable_gradual_resumption) {
            return 1.0;
        }

        size_t step = time_since_resume.count() / config_.time_between_steps.count();
        step = std::min(step, config_.position_scale_steps.size() - 1);

        return config_.position_scale_steps[step];
    }

private:
    RecoveryConfig config_;
};

} // namespace risk
} // namespace hft
```

================================================================================
5. CIRCUIT BREAKER TYPES
================================================================================

5.1 Multiple Circuit Breaker Strategies
----------------------------------------

Strategy 1: Static Threshold Circuit Breaker
- Fixed percentage thresholds
- Simple to implement and understand
- Best for stable market conditions

Strategy 2: Dynamic Threshold Circuit Breaker
- Adjusts based on market volatility
- Adapts to changing conditions
- More sophisticated but complex

Strategy 3: Velocity-Based Circuit Breaker
- Triggers on rate of loss
- Catches rapid deterioration
- Prevents flash crashes

Strategy 4: Correlation-Based Circuit Breaker
- Monitors correlation breakdown
- Triggers when strategies become correlated
- Prevents systemic risk

Strategy 5: Multi-Factor Circuit Breaker
- Combines multiple signals
- Most comprehensive approach
- Used in production systems

Implementation Example:

```cpp
class MultiFact orCircuitBreaker {
public:
    struct TriggerSignals {
        bool drawdown_exceeded;
        bool velocity_exceeded;
        bool correlation_spike;
        bool volatility_spike;
        bool liquidity_drought;
    };

    bool shouldTrigger(const TriggerSignals& signals) const {
        // Require at least 2 signals
        int signal_count = 0;
        signal_count += signals.drawdown_exceeded ? 1 : 0;
        signal_count += signals.velocity_exceeded ? 1 : 0;
        signal_count += signals.correlation_spike ? 1 : 0;
        signal_count += signals.volatility_spike ? 1 : 0;
        signal_count += signals.liquidity_drought ? 1 : 0;

        // Or any single critical signal
        if (signals.drawdown_exceeded || signals.velocity_exceeded) {
            return true;
        }

        return signal_count >= 2;
    }
};
```

================================================================================
6. CONFIGURATION EXAMPLES
================================================================================

6.1 Production Drawdown Configuration
--------------------------------------

```json
{
  "drawdown_management": {
    "global_settings": {
      "enable_drawdown_monitoring": true,
      "check_frequency_ms": 100,
      "enable_global_kill_switch": true
    },

    "strategy_configs": [
      {
        "strategy_id": "MM_EQUITY_001",

        "absolute_thresholds": {
          "warning_pct": 1.0,
          "critical_pct": 2.0,
          "emergency_pct": 3.0
        },

        "relative_thresholds": {
          "warning_pct": 3.0,
          "critical_pct": 5.0,
          "emergency_pct": 7.0
        },

        "daily_thresholds": {
          "warning_pct": 0.5,
          "critical_pct": 1.0,
          "emergency_pct": 1.5
        },

        "velocity_thresholds": {
          "enable": true,
          "max_loss_per_minute": 10000.0,
          "max_loss_per_hour": 50000.0
        },

        "circuit_breaker_actions": {
          "warning": "ALERT_ONLY",
          "critical": "HALT_NEW_TRADES",
          "emergency": "FLATTEN_POSITIONS"
        },

        "recovery_settings": {
          "recovery_threshold_pct": 50.0,
          "recovery_period_minutes": 30,
          "auto_resume": false,
          "min_halt_duration_minutes": 15
        }
      }
    ],

    "adaptive_settings": {
      "enable_volatility_adjustment": true,
      "enable_time_of_day_adjustment": true,
      "enable_performance_adjustment": true
    }
  }
}
```

================================================================================
7. REAL-TIME DASHBOARDS
================================================================================

7.1 Drawdown Monitoring Dashboard
----------------------------------

Dashboard Components:

1. Equity Curve
   - Real-time equity line
   - High water mark
   - Drawdown shading
   - Circuit breaker triggers marked

2. Drawdown Metrics Panel
   - Current absolute DD%
   - Current relative DD%
   - Daily DD%
   - Max DD ever

3. Circuit Breaker Status
   - Active/Inactive status
   - Time since last trigger
   - Current action level
   - Auto-recovery timer

4. Loss Velocity Gauge
   - Current loss rate
   - Threshold indicators
   - Trend arrow

5. Recovery Progress
   - Recovery percentage
   - Time in recovery
   - Next action level

6. Alert Log
   - Recent circuit breaker events
   - Resolution status
   - Performance impact

```cpp
struct DashboardData {
    // Current state
    double current_equity;
    double peak_equity;
    double drawdown_pct;

    // Velocity
    double loss_rate_1min;
    double loss_rate_1hour;

    // Circuit breaker
    bool cb_active;
    std::string cb_action;
    std::chrono::seconds time_since_trigger;

    // Recovery
    bool in_recovery;
    double recovery_progress_pct;

    // Historical data for charts
    std::vector<std::pair<int64_t, double>> equity_timeseries;
    std::vector<CircuitBreakerEvent> recent_events;
};
```

================================================================================
8. TESTING FRAMEWORK
================================================================================

8.1 Circuit Breaker Testing
----------------------------

```cpp
// Test drawdown detection
TEST(DrawdownMonitorTest, DetectsRelativeDrawdown) {
    DrawdownMonitor monitor;

    DrawdownConfig config;
    config.rel_warning_threshold_pct = 3.0;
    config.rel_critical_threshold_pct = 5.0;
    config.warning_action = CircuitBreakerAction::ALERT_ONLY;

    monitor.setConfig("TEST_STRAT", config);
    monitor.initializeStrategy("TEST_STRAT", 1000000.0);

    // Simulate profit to new peak
    monitor.updateEquity("TEST_STRAT", 1100000.0);

    // Simulate drawdown
    monitor.updateEquity("TEST_STRAT", 1045000.0);  // 5% drawdown

    auto severity = monitor.checkDrawdown("TEST_STRAT");
    EXPECT_EQ(severity, DrawdownSeverity::CRITICAL);
    EXPECT_TRUE(monitor.isCircuitBreakerActive("TEST_STRAT"));
}

// Test velocity-based circuit breaker
TEST(DrawdownMonitorTest, VelocityBasedTrigger) {
    DrawdownMonitor monitor;

    DrawdownConfig config;
    config.enable_velocity_checks = true;
    config.max_loss_per_minute = 5000.0;
    config.critical_action = CircuitBreakerAction::HALT_NEW_TRADES;

    monitor.setConfig("TEST_STRAT", config);
    monitor.initializeStrategy("TEST_STRAT", 1000000.0);

    // Simulate rapid losses
    for (int i = 0; i < 10; i++) {
        monitor.updateEquity("TEST_STRAT", 1000000.0 - (i + 1) * 1000);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    auto severity = monitor.checkDrawdown("TEST_STRAT");
    EXPECT_GE(severity, DrawdownSeverity::WARNING);
}

// Test recovery mechanism
TEST(DrawdownMonitorTest, RecoveryProcess) {
    DrawdownMonitor monitor;

    DrawdownConfig config;
    config.rel_critical_threshold_pct = 5.0;
    config.recovery_threshold_pct = 50.0;
    config.auto_resume_after_recovery = true;

    monitor.setConfig("TEST_STRAT", config);
    monitor.initializeStrategy("TEST_STRAT", 1000000.0);

    // Trigger circuit breaker
    monitor.updateEquity("TEST_STRAT", 950000.0);  // 5% loss
    EXPECT_TRUE(monitor.isCircuitBreakerActive("TEST_STRAT"));

    // Recover 50%
    monitor.updateEquity("TEST_STRAT", 975000.0);  // 2.5% loss

    bool can_recover = monitor.checkRecoveryConditions("TEST_STRAT");
    EXPECT_TRUE(can_recover);
}
```

================================================================================
9. ADVANCED FEATURES
================================================================================

9.1 Machine Learning Enhanced Circuit Breakers
-----------------------------------------------

```cpp
// ml_circuit_breaker.hpp

namespace hft {
namespace risk {

class MLCircuitBreaker {
public:
    // Predict probability of further drawdown
    double predictDrawdownProbability(
        const DrawdownState& state,
        const std::vector<double>& market_features) {

        // Features: current DD, velocity, volatility, correlation, etc.
        // Returns probability [0, 1] of exceeding next threshold

        // Simple example using weighted features
        double score = 0.0;
        score += state.relative_drawdown_pct * 0.3;
        score += state.loss_rate_per_minute / 10000.0 * 0.3;
        score += market_features[0] * 0.2;  // Volatility
        score += market_features[1] * 0.2;  // Correlation

        return std::min(1.0, std::max(0.0, score / 10.0));
    }

    // Predictive circuit breaker trigger
    bool shouldPreemptivelyTrigger(double probability_threshold = 0.7) const {
        // Trigger before actual breach based on ML prediction
        return predictedProbability_ > probability_threshold;
    }

private:
    double predictedProbability_ = 0.0;
};

} // namespace risk
} // namespace hft
```

9.2 Coordinated Multi-Strategy Circuit Breakers
------------------------------------------------

```cpp
// portfolio_circuit_breaker.hpp

namespace hft {
namespace risk {

class PortfolioCircuitBreaker {
public:
    // Check if multiple strategies are in drawdown simultaneously
    bool checkCorrelatedDrawdowns(
        const std::vector<std::string>& strategy_ids,
        const DrawdownMonitor& monitor) {

        int strategies_in_drawdown = 0;
        double total_drawdown = 0.0;

        for (const auto& strategy_id : strategy_ids) {
            auto state = monitor.getDrawdownState(strategy_id);
            if (state.relative_drawdown_pct > 2.0) {
                strategies_in_drawdown++;
                total_drawdown += state.relative_drawdown_pct;
            }
        }

        // Trigger if >50% of strategies in drawdown
        double pct_in_drawdown = (double)strategies_in_drawdown /
                                strategy_ids.size();

        return pct_in_drawdown > 0.5 || total_drawdown > 15.0;
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
10. OPERATIONAL PROCEDURES
================================================================================

10.1 Circuit Breaker Response Procedures
-----------------------------------------

When Circuit Breaker Triggers:

1. Immediate Actions (Automated)
   - Stop new order entry
   - Cancel pending orders (if configured)
   - Flatten positions (if configured)
   - Log event with full context

2. Notification (Within 1 minute)
   - Email alerts to risk team
   - SMS to head trader
   - Dashboard red alert
   - Slack/Teams notification

3. Investigation (Within 5 minutes)
   - Review trigger cause
   - Check system health
   - Verify data integrity
   - Assess market conditions

4. Resolution (Within 15 minutes)
   - Determine root cause
   - Fix if system issue
   - Wait if market issue
   - Document findings

5. Resumption (Gradual)
   - Get approval from risk manager
   - Start with reduced position size
   - Monitor closely for 30 minutes
   - Gradually increase to normal

10.2 False Trigger Handling
----------------------------

Common causes of false triggers:
- Data feed glitches
- Quote outliers
- Connectivity issues
- Calculation errors

Mitigation strategies:
- Multi-source data validation
- Outlier detection before trigger
- Manual override capability
- Post-trigger data review

================================================================================
END OF DRAWDOWN MANAGEMENT AND CIRCUIT BREAKERS DOCUMENTATION
================================================================================
