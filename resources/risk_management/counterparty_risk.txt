================================================================================
COUNTERPARTY RISK MANAGEMENT - HFT RISK MANAGEMENT SYSTEM
================================================================================
Version: 2.1.0
Last Updated: 2025-11-25
Author: HFT Risk Management Team
Purpose: Counterparty credit risk, exposure limits, and collateral management

================================================================================
1. COUNTERPARTY RISK FRAMEWORK
================================================================================

1.1 Counterparty Risk Components
---------------------------------

Primary Risk Areas:

1. Credit Risk
   - Default probability
   - Loss given default (LGD)
   - Expected loss calculation
   - Credit VaR

2. Settlement Risk
   - Delivery vs Payment (DvP)
   - Settlement fails
   - Pre-settlement exposure
   - Settlement timing risk

3. Replacement Cost Risk
   - Mark-to-market exposure
   - Potential future exposure (PFE)
   - Expected positive exposure (EPE)
   - Credit valuation adjustment (CVA)

4. Concentration Risk
   - Single counterparty limits
   - Sector concentration
   - Geographic concentration
   - Systemic risk exposure

5. Collateral Management
   - Initial margin requirements
   - Variation margin
   - Collateral eligibility
   - Rehypothecation risk

================================================================================
2. C++ COUNTERPARTY RISK ENGINE
================================================================================

2.1 Core Counterparty Risk Manager
-----------------------------------

```cpp
// counterparty_risk_manager.hpp
#ifndef COUNTERPARTY_RISK_MANAGER_HPP
#define COUNTERPARTY_RISK_MANAGER_HPP

#include <string>
#include <unordered_map>
#include <vector>
#include <memory>
#include <chrono>
#include <atomic>
#include <mutex>
#include <shared_mutex>

namespace hft {
namespace risk {

// Credit rating enum
enum class CreditRating {
    AAA, AA_PLUS, AA, AA_MINUS,
    A_PLUS, A, A_MINUS,
    BBB_PLUS, BBB, BBB_MINUS,
    BB_PLUS, BB, BB_MINUS,
    B_PLUS, B, B_MINUS,
    CCC_PLUS, CCC, CCC_MINUS,
    CC, C, D, NR
};

// Counterparty type
enum class CounterpartyType {
    BROKER_DEALER,
    BANK,
    HEDGE_FUND,
    ASSET_MANAGER,
    PROPRIETARY_TRADING_FIRM,
    EXCHANGE,
    CLEARING_HOUSE,
    PRIME_BROKER,
    CORPORATE,
    SOVEREIGN
};

// Counterparty information
struct CounterpartyInfo {
    std::string counterparty_id;
    std::string name;
    CounterpartyType type;
    CreditRating rating;

    // Credit metrics
    double probability_of_default;      // PD (0-1)
    double loss_given_default;          // LGD (0-1)
    double expected_loss;               // EL = PD * LGD * EAD

    // Limits
    double credit_limit;
    double collateral_requirement_pct;
    bool requires_collateral;

    // Geographic and sector
    std::string country;
    std::string sector;

    // Operational
    bool is_active;
    bool is_approved;
    std::chrono::system_clock::time_point approval_date;
    std::chrono::system_clock::time_point review_date;
};

// Exposure record
struct CounterpartyExposure {
    std::string counterparty_id;
    std::string instrument_type;

    // Current exposure
    double current_exposure;            // Mark-to-market
    double notional_exposure;
    int64_t num_trades;

    // Forward-looking exposure
    double potential_future_exposure;   // PFE
    double expected_positive_exposure;  // EPE
    double effective_expected_positive_exposure;  // EEPE

    // Netted exposure
    double gross_exposure;
    double netted_exposure;
    double collateral_held;
    double net_credit_exposure;         // After netting & collateral

    // Time breakdown
    std::unordered_map<std::string, double> exposure_by_maturity;

    // Risk metrics
    double credit_var_95;
    double credit_var_99;
    double cva_charge;                  // Credit valuation adjustment
    double dva_charge;                  // Debit valuation adjustment

    std::chrono::system_clock::time_point calculation_time;
};

// Collateral record
struct CollateralRecord {
    std::string collateral_id;
    std::string counterparty_id;
    std::string collateral_type;

    // Collateral details
    double amount;
    double market_value;
    double haircut_pct;
    double adjusted_value;              // After haircut

    // Status
    bool is_eligible;
    bool is_segregated;
    std::string custodian;

    std::chrono::system_clock::time_point received_date;
    std::chrono::system_clock::time_point valuation_date;
};

// Margin call
struct MarginCall {
    std::string call_id;
    std::string counterparty_id;

    // Amounts
    double current_collateral;
    double required_collateral;
    double margin_deficit;
    double call_amount;

    // Timing
    std::chrono::system_clock::time_point call_time;
    std::chrono::system_clock::time_point due_time;

    // Status
    enum class Status {
        PENDING,
        ACKNOWLEDGED,
        DISPUTED,
        SATISFIED,
        DEFAULTED
    };
    Status status;

    std::string notes;
};

class CounterpartyRiskManager {
public:
    CounterpartyRiskManager();
    ~CounterpartyRiskManager();

    // Counterparty management
    void addCounterparty(const CounterpartyInfo& counterparty);
    void updateCounterparty(const CounterpartyInfo& counterparty);
    bool isCounterpartyApproved(const std::string& counterparty_id) const;

    // Exposure calculation
    void updateTrade(const std::string& counterparty_id,
                    const std::string& trade_id,
                    double notional,
                    double mark_to_market,
                    const std::string& instrument_type);

    CounterpartyExposure calculateExposure(
        const std::string& counterparty_id) const;

    std::vector<CounterpartyExposure> calculateAllExposures() const;

    // Potential future exposure
    double calculatePFE(const std::string& counterparty_id,
                       double confidence_level = 0.95,
                       int horizon_days = 10) const;

    double calculateEPE(const std::string& counterparty_id) const;

    // Credit risk metrics
    double calculateCreditVaR(const std::string& counterparty_id,
                             double confidence_level = 0.99) const;

    double calculateExpectedLoss(const std::string& counterparty_id) const;

    double calculateCVA(const std::string& counterparty_id) const;

    // Limit checking
    bool checkCreditLimit(const std::string& counterparty_id,
                         double additional_exposure,
                         std::string& rejection_reason) const;

    std::vector<CounterpartyExposure> getCounterpartiesNearLimit(
        double threshold_pct = 80.0) const;

    std::vector<CounterpartyExposure> getCounterpartiesOverLimit() const;

    // Netting
    void setNettingAgreement(const std::string& counterparty_id,
                           bool has_netting,
                           const std::string& agreement_type);

    double calculateNettedExposure(
        const std::string& counterparty_id) const;

    // Collateral management
    void addCollateral(const CollateralRecord& collateral);
    void updateCollateral(const CollateralRecord& collateral);
    void removeCollateral(const std::string& collateral_id);

    std::vector<CollateralRecord> getCollateral(
        const std::string& counterparty_id) const;

    double calculateCollateralCoverage(
        const std::string& counterparty_id) const;

    // Margin calls
    MarginCall generateMarginCall(const std::string& counterparty_id);
    void updateMarginCallStatus(const std::string& call_id,
                               MarginCall::Status status);

    std::vector<MarginCall> getPendingMarginCalls() const;
    std::vector<MarginCall> getOverdueMarginCalls() const;

    // Concentration analysis
    struct ConcentrationAnalysis {
        std::unordered_map<std::string, double> exposure_by_rating;
        std::unordered_map<std::string, double> exposure_by_country;
        std::unordered_map<std::string, double> exposure_by_sector;
        double top_10_concentration_pct;
        std::string largest_exposure_counterparty;
        double largest_exposure_amount;
    };

    ConcentrationAnalysis analyzeConcentration() const;

    // Settlement risk
    double calculateSettlementRisk(
        const std::string& counterparty_id,
        const std::chrono::system_clock::time_point& settlement_date) const;

    // Stress testing
    struct StressScenario {
        std::string name;
        double default_rate_multiplier;
        double lgd_multiplier;
        double exposure_multiplier;
    };

    double stressTestCounterparty(
        const std::string& counterparty_id,
        const StressScenario& scenario) const;

    // Reports
    struct CounterpartyRiskReport {
        std::string counterparty_id;
        CounterpartyInfo info;
        CounterpartyExposure exposure;
        double collateral_coverage_ratio;
        double credit_utilization_pct;
        std::vector<MarginCall> active_margin_calls;
    };

    CounterpartyRiskReport generateReport(
        const std::string& counterparty_id) const;

    std::vector<CounterpartyRiskReport> generateAllReports() const;

private:
    // Helper methods
    double calculatePD(CreditRating rating) const;
    double calculateLGD(CounterpartyType type) const;
    double calculateHaircut(const std::string& collateral_type) const;
    bool isCollateralEligible(const std::string& collateral_type) const;

    // Data structures
    mutable std::shared_mutex counterparties_mutex_;
    std::unordered_map<std::string, CounterpartyInfo> counterparties_;

    mutable std::shared_mutex trades_mutex_;
    struct TradeRecord {
        std::string trade_id;
        std::string counterparty_id;
        double notional;
        double mark_to_market;
        std::string instrument_type;
        std::chrono::system_clock::time_point trade_date;
    };
    std::unordered_map<std::string, std::vector<TradeRecord>> trades_by_counterparty_;

    mutable std::shared_mutex collateral_mutex_;
    std::unordered_map<std::string, std::vector<CollateralRecord>> collateral_by_counterparty_;

    mutable std::shared_mutex margin_calls_mutex_;
    std::vector<MarginCall> margin_calls_;

    // Netting agreements
    mutable std::shared_mutex netting_mutex_;
    std::unordered_map<std::string, bool> has_netting_agreement_;

    // Statistics
    std::atomic<uint64_t> total_margin_calls_{0};
    std::atomic<uint64_t> total_defaults_{0};
};

// Implementation
inline double CounterpartyRiskManager::calculatePD(CreditRating rating) const {
    // Historical default probabilities by rating
    static const std::unordered_map<CreditRating, double> pd_map = {
        {CreditRating::AAA, 0.0001},
        {CreditRating::AA_PLUS, 0.0002},
        {CreditRating::AA, 0.0003},
        {CreditRating::AA_MINUS, 0.0005},
        {CreditRating::A_PLUS, 0.0008},
        {CreditRating::A, 0.0012},
        {CreditRating::A_MINUS, 0.0018},
        {CreditRating::BBB_PLUS, 0.0030},
        {CreditRating::BBB, 0.0045},
        {CreditRating::BBB_MINUS, 0.0070},
        {CreditRating::BB_PLUS, 0.0120},
        {CreditRating::BB, 0.0200},
        {CreditRating::BB_MINUS, 0.0350},
        {CreditRating::B_PLUS, 0.0600},
        {CreditRating::B, 0.1000},
        {CreditRating::B_MINUS, 0.1500},
        {CreditRating::CCC_PLUS, 0.2500},
        {CreditRating::CCC, 0.3500},
        {CreditRating::CC, 0.5000},
        {CreditRating::C, 0.7000},
        {CreditRating::D, 1.0000},
        {CreditRating::NR, 0.0500}
    };

    auto it = pd_map.find(rating);
    return (it != pd_map.end()) ? it->second : 0.05;
}

inline double CounterpartyRiskManager::calculateLGD(
    CounterpartyType type) const {

    // Typical LGD by counterparty type
    switch (type) {
        case CounterpartyType::BANK:
        case CounterpartyType::EXCHANGE:
        case CounterpartyType::CLEARING_HOUSE:
            return 0.30;  // 30% LGD (high recovery)

        case CounterpartyType::BROKER_DEALER:
        case CounterpartyType::PRIME_BROKER:
            return 0.40;  // 40% LGD

        case CounterpartyType::HEDGE_FUND:
        case CounterpartyType::PROPRIETARY_TRADING_FIRM:
            return 0.60;  // 60% LGD (lower recovery)

        case CounterpartyType::ASSET_MANAGER:
        case CounterpartyType::CORPORATE:
            return 0.50;  // 50% LGD

        case CounterpartyType::SOVEREIGN:
            return 0.20;  // 20% LGD (high recovery for sovereigns)

        default:
            return 0.45;  // Default LGD
    }
}

inline CounterpartyExposure CounterpartyRiskManager::calculateExposure(
    const std::string& counterparty_id) const {

    CounterpartyExposure exposure;
    exposure.counterparty_id = counterparty_id;
    exposure.current_exposure = 0.0;
    exposure.notional_exposure = 0.0;
    exposure.num_trades = 0;
    exposure.gross_exposure = 0.0;

    std::shared_lock<std::shared_mutex> lock(trades_mutex_);

    auto it = trades_by_counterparty_.find(counterparty_id);
    if (it != trades_by_counterparty_.end()) {
        const auto& trades = it->second;

        for (const auto& trade : trades) {
            exposure.notional_exposure += std::abs(trade.notional);
            exposure.current_exposure += trade.mark_to_market;
            exposure.gross_exposure += std::abs(trade.mark_to_market);
            exposure.num_trades++;
        }
    }

    lock.unlock();

    // Calculate netted exposure
    exposure.netted_exposure = exposure.current_exposure;

    // Apply netting if agreement exists
    std::shared_lock<std::shared_mutex> netting_lock(netting_mutex_);
    auto netting_it = has_netting_agreement_.find(counterparty_id);
    if (netting_it != has_netting_agreement_.end() && netting_it->second) {
        // With netting, only net positive exposure counts
        exposure.netted_exposure = std::max(0.0, exposure.current_exposure);
    } else {
        // Without netting, take gross exposure
        exposure.netted_exposure = exposure.gross_exposure;
    }
    netting_lock.unlock();

    // Subtract collateral
    exposure.collateral_held = 0.0;
    std::shared_lock<std::shared_mutex> collateral_lock(collateral_mutex_);
    auto coll_it = collateral_by_counterparty_.find(counterparty_id);
    if (coll_it != collateral_by_counterparty_.end()) {
        for (const auto& coll : coll_it->second) {
            exposure.collateral_held += coll.adjusted_value;
        }
    }
    collateral_lock.unlock();

    // Net credit exposure
    exposure.net_credit_exposure = std::max(0.0,
        exposure.netted_exposure - exposure.collateral_held);

    // Calculate PFE and EPE
    exposure.potential_future_exposure = calculatePFE(counterparty_id);
    exposure.expected_positive_exposure = calculateEPE(counterparty_id);

    // Calculate CVA
    exposure.cva_charge = calculateCVA(counterparty_id);

    exposure.calculation_time = std::chrono::system_clock::now();

    return exposure;
}

inline double CounterpartyRiskManager::calculatePFE(
    const std::string& counterparty_id,
    double confidence_level,
    int horizon_days) const {

    // Simplified PFE calculation
    // In production, use Monte Carlo simulation

    auto exposure = calculateExposure(counterparty_id);
    double current_exposure = exposure.current_exposure;

    // Assume volatility of 20% per year
    double annual_vol = 0.20;
    double time_factor = std::sqrt(horizon_days / 252.0);

    // Z-score for confidence level
    double z_score = (confidence_level >= 0.99) ? 2.33 :
                     (confidence_level >= 0.95) ? 1.645 : 1.28;

    // PFE = Current + (Current * Vol * Z * sqrt(T))
    double pfe = current_exposure + (std::abs(current_exposure) *
                                    annual_vol * z_score * time_factor);

    return std::max(0.0, pfe);
}

inline double CounterpartyRiskManager::calculateEPE(
    const std::string& counterparty_id) const {

    // Expected Positive Exposure
    // Simplified: assume 40% of PFE
    double pfe = calculatePFE(counterparty_id);
    return pfe * 0.4;
}

inline double CounterpartyRiskManager::calculateExpectedLoss(
    const std::string& counterparty_id) const {

    std::shared_lock<std::shared_mutex> lock(counterparties_mutex_);
    auto it = counterparties_.find(counterparty_id);
    if (it == counterparties_.end()) {
        return 0.0;
    }

    const auto& cp = it->second;
    lock.unlock();

    // Get exposure
    auto exposure = calculateExposure(counterparty_id);

    // EL = PD * LGD * EAD
    double pd = cp.probability_of_default > 0 ? cp.probability_of_default :
                calculatePD(cp.rating);
    double lgd = cp.loss_given_default > 0 ? cp.loss_given_default :
                 calculateLGD(cp.type);
    double ead = exposure.net_credit_exposure;  // Exposure at default

    return pd * lgd * ead;
}

inline double CounterpartyRiskManager::calculateCVA(
    const std::string& counterparty_id) const {

    // Credit Valuation Adjustment
    // CVA = LGD * sum(EE_i * PD_i * DF_i)

    std::shared_lock<std::shared_mutex> lock(counterparties_mutex_);
    auto it = counterparties_.find(counterparty_id);
    if (it == counterparties_.end()) {
        return 0.0;
    }

    const auto& cp = it->second;
    lock.unlock();

    double pd = cp.probability_of_default > 0 ? cp.probability_of_default :
                calculatePD(cp.rating);
    double lgd = cp.loss_given_default > 0 ? cp.loss_given_default :
                 calculateLGD(cp.type);

    // Simplified CVA
    double epe = calculateEPE(counterparty_id);
    double risk_free_rate = 0.03;  // 3% discount rate
    double discount_factor = std::exp(-risk_free_rate);

    double cva = lgd * epe * pd * discount_factor;

    return cva;
}

inline bool CounterpartyRiskManager::checkCreditLimit(
    const std::string& counterparty_id,
    double additional_exposure,
    std::string& rejection_reason) const {

    std::shared_lock<std::shared_mutex> lock(counterparties_mutex_);
    auto it = counterparties_.find(counterparty_id);
    if (it == counterparties_.end()) {
        rejection_reason = "Unknown counterparty: " + counterparty_id;
        return false;
    }

    const auto& cp = it->second;

    if (!cp.is_active || !cp.is_approved) {
        rejection_reason = "Counterparty not approved for trading";
        return false;
    }

    double credit_limit = cp.credit_limit;
    lock.unlock();

    // Get current exposure
    auto current_exposure = calculateExposure(counterparty_id);
    double projected_exposure = current_exposure.net_credit_exposure +
                               additional_exposure;

    if (projected_exposure > credit_limit) {
        rejection_reason = "Projected exposure " +
                          std::to_string(projected_exposure) +
                          " exceeds credit limit " +
                          std::to_string(credit_limit);
        return false;
    }

    return true;
}

inline MarginCall CounterpartyRiskManager::generateMarginCall(
    const std::string& counterparty_id) {

    auto exposure = calculateExposure(counterparty_id);

    std::shared_lock<std::shared_mutex> lock(counterparties_mutex_);
    auto it = counterparties_.find(counterparty_id);
    if (it == counterparties_.end()) {
        return MarginCall{};
    }

    const auto& cp = it->second;
    lock.unlock();

    // Calculate required collateral
    double required_collateral = exposure.net_credit_exposure *
                                cp.collateral_requirement_pct;

    double margin_deficit = required_collateral - exposure.collateral_held;

    if (margin_deficit > 0) {
        MarginCall call;
        call.call_id = "MC_" + std::to_string(total_margin_calls_.fetch_add(1));
        call.counterparty_id = counterparty_id;
        call.current_collateral = exposure.collateral_held;
        call.required_collateral = required_collateral;
        call.margin_deficit = margin_deficit;
        call.call_amount = margin_deficit;
        call.call_time = std::chrono::system_clock::now();
        call.due_time = call.call_time + std::chrono::hours(24);
        call.status = MarginCall::Status::PENDING;

        // Store margin call
        std::unique_lock<std::shared_mutex> mc_lock(margin_calls_mutex_);
        margin_calls_.push_back(call);

        return call;
    }

    return MarginCall{};
}

} // namespace risk
} // namespace hft

#endif // COUNTERPARTY_RISK_MANAGER_HPP
```

================================================================================
3. COLLATERAL MANAGEMENT SYSTEM
================================================================================

3.1 Collateral Optimization
----------------------------

```cpp
// collateral_optimizer.hpp

namespace hft {
namespace risk {

class CollateralOptimizer {
public:
    struct CollateralAsset {
        std::string asset_type;
        double amount;
        double market_value;
        double haircut_pct;
        double funding_cost_pct;
        int liquidity_score;  // 1-10
    };

    // Optimize collateral basket
    static std::vector<CollateralAsset> optimizeCollateral(
        double required_amount,
        const std::vector<CollateralAsset>& available_assets) {

        std::vector<CollateralAsset> optimal_basket;
        double remaining_requirement = required_amount;

        // Sort by efficiency (low haircut, low cost, high liquidity)
        auto sorted_assets = available_assets;
        std::sort(sorted_assets.begin(), sorted_assets.end(),
            [](const auto& a, const auto& b) {
                double score_a = a.liquidity_score - a.haircut_pct -
                               a.funding_cost_pct * 10;
                double score_b = b.liquidity_score - b.haircut_pct -
                               b.funding_cost_pct * 10;
                return score_a > score_b;
            });

        // Allocate optimal assets
        for (const auto& asset : sorted_assets) {
            if (remaining_requirement <= 0) break;

            double adjusted_value = asset.market_value *
                                   (1.0 - asset.haircut_pct / 100.0);
            double amount_to_use = std::min(adjusted_value,
                                          remaining_requirement);

            CollateralAsset allocated_asset = asset;
            allocated_asset.amount = amount_to_use;
            optimal_basket.push_back(allocated_asset);

            remaining_requirement -= amount_to_use;
        }

        return optimal_basket;
    }
};

} // namespace risk
} // namespace hft
```

================================================================================
4. CONFIGURATION
================================================================================

```json
{
  "counterparty_risk": {
    "credit_limits": {
      "default_limit": 10000000,
      "minimum_rating": "BBB",
      "require_approval_below": "BBB_MINUS"
    },

    "collateral_requirements": {
      "default_requirement_pct": 10.0,
      "min_collateral_amount": 100000,
      "margin_call_threshold": 50000,
      "eligible_collateral": [
        {"type": "cash_usd", "haircut": 0.0},
        {"type": "us_treasury", "haircut": 2.0},
        {"type": "investment_grade_bond", "haircut": 5.0},
        {"type": "equity_sp500", "haircut": 15.0},
        {"type": "gold", "haircut": 10.0}
      ]
    },

    "concentration_limits": {
      "max_single_counterparty_pct": 10.0,
      "max_rating_category_pct": 25.0,
      "max_country_pct": 30.0
    }
  }
}
```

================================================================================
END OF COUNTERPARTY RISK DOCUMENTATION
================================================================================
