================================================================================
STATE MANAGEMENT ARCHITECTURE FOR RECOVERY
================================================================================

Comprehensive architecture for persisting and recovering HFT system state.
Critical for safe system restarts after crashes, maintenance, or updates.

================================================================================
OVERVIEW - STATE MANAGEMENT PRINCIPLES
================================================================================

**Key Principles:**
1. **Durability**: State survives crashes and power failures
2. **Consistency**: State is always valid (ACID properties)
3. **Performance**: State persistence doesn't add significant latency
4. **Completeness**: All critical state is captured
5. **Recoverability**: State can be restored quickly and correctly

**State Types:**
- **Transient State**: Lost on restart (acceptable for caches, temporary data)
- **Persistent State**: Must survive restart (positions, orders, config)
- **Recoverable State**: Can be reconstructed from other sources (market data)

================================================================================
CRITICAL STATE COMPONENTS
================================================================================

**1. Trading State**

```cpp
struct TradingState {
    // Positions
    std::unordered_map<Symbol, Position> positions;

    // Orders
    std::unordered_map<OrderID, Order> open_orders;
    std::vector<OrderID> pending_orders;  // Submitted but not acked

    // Recent fills (last 1 hour for reconciliation)
    std::vector<Fill> recent_fills;

    // Account balances per exchange
    std::unordered_map<Exchange, AccountBalance> balances;

    // Risk state
    RiskState risk_state;

    // P&L
    double realized_pnl;
    std::unordered_map<Symbol, double> unrealized_pnl;

    // Timestamp of last update
    uint64_t last_update_timestamp;

    // Checksum for validation
    uint64_t checksum;
};

struct Position {
    Symbol symbol;
    Exchange exchange;
    double quantity;  // Positive = long, negative = short
    double avg_price;
    uint64_t last_updated;
};

struct Order {
    OrderID id;
    ClientOrderID client_id;
    Symbol symbol;
    Exchange exchange;
    Side side;
    OrderType type;
    double price;
    double quantity;
    double filled_quantity;
    OrderStatus status;
    uint64_t submitted_time;
    uint64_t last_updated;
};

struct RiskState {
    // Current exposure
    double gross_exposure;
    double net_exposure;

    // Loss tracking
    double daily_realized_pnl;
    double daily_unrealized_pnl;
    double max_drawdown_today;

    // Limit utilization
    std::unordered_map<Symbol, double> position_limit_usage;

    // Circuit breaker state
    bool trading_halted;
    std::string halt_reason;
    uint64_t halt_timestamp;
};
```

**2. Strategy State**

```cpp
struct StrategyState {
    std::string strategy_id;
    std::string strategy_name;

    // Strategy parameters
    std::unordered_map<std::string, double> parameters;

    // Strategy-specific state
    std::vector<uint8_t> custom_state;  // Serialized

    // Active/inactive
    bool is_active;

    // Last signal time
    uint64_t last_signal_time;

    // Strategy P&L
    double strategy_pnl;

    // Checksum
    uint64_t checksum;
};
```

**3. Configuration State**

```cpp
struct ConfigurationState {
    // System configuration
    SystemConfig system_config;

    // Exchange configurations
    std::unordered_map<Exchange, ExchangeConfig> exchange_configs;

    // Risk limits
    RiskLimits risk_limits;

    // Strategy configurations
    std::vector<StrategyConfig> strategy_configs;

    // Version
    uint32_t version;
    uint64_t last_modified;
};
```

**4. Market Data State (Optional)**

```cpp
struct MarketDataState {
    // Recent order books (last 5 minutes for each symbol)
    std::unordered_map<Symbol, OrderBook> order_books;

    // Recent trades
    std::vector<Trade> recent_trades;

    // Market status
    std::unordered_map<Symbol, MarketStatus> market_status;

    // Last update timestamps
    std::unordered_map<Symbol, uint64_t> last_updates;
};
```

================================================================================
PERSISTENCE MECHANISMS
================================================================================

**1. Synchronous Persistence (Critical State)**

For position updates, order submissions:

```cpp
class SynchronousPersistence {
public:
    // Write state and wait for durability
    void SaveState(const TradingState& state) {
        // Serialize state
        std::vector<uint8_t> serialized = Serialize(state);

        // Write to persistent storage
        file_.write(serialized.data(), serialized.size());

        // Force flush to disk (fsync)
        file_.flush();
        ::fsync(file_.native_handle());

        // Latency: ~100 microseconds (SSD)
    }

private:
    std::ofstream file_;
};
```

**Pros:**
- Zero data loss (RPO = 0)
- Simple to implement
- Easy to reason about

**Cons:**
- Adds latency (~100μs per write)
- Can't be used in ultra-hot path

**Use Cases:**
- Order submissions (before sending to exchange)
- Fill processing (after receiving fill)
- Position updates
- Critical configuration changes

**2. Asynchronous Persistence (Non-Critical State)**

For logs, analytics, non-critical data:

```cpp
class AsynchronousPersistence {
public:
    void SaveStateAsync(const TradingState& state) {
        // Copy state (avoid race conditions)
        auto state_copy = std::make_shared<TradingState>(state);

        // Queue for background thread
        write_queue_.push(state_copy);

        // Returns immediately (no blocking)
    }

private:
    void BackgroundWriter() {
        while (running_) {
            auto state = write_queue_.pop();
            WriteStateToDisk(state);
        }
    }

    LockFreeQueue<std::shared_ptr<TradingState>> write_queue_;
    std::thread writer_thread_;
    std::atomic<bool> running_;
};
```

**Pros:**
- No latency impact on hot path
- High throughput

**Cons:**
- Data loss possible on crash (RPO > 0)
- More complex (concurrency, queuing)

**Use Cases:**
- Logs
- Analytics data
- Historical market data
- Performance metrics

**3. Memory-Mapped Files**

For high-frequency checkpoints:

```cpp
class MemoryMappedPersistence {
public:
    MemoryMappedPersistence(const std::string& file_path, size_t size) {
        // Open/create file
        fd_ = open(file_path.c_str(), O_RDWR | O_CREAT, 0644);
        ftruncate(fd_, size);

        // Memory-map the file
        mapped_region_ = mmap(nullptr, size, PROT_READ | PROT_WRITE,
                              MAP_SHARED, fd_, 0);

        // Use huge pages for performance
        madvise(mapped_region_, size, MADV_HUGEPAGE);
    }

    void SaveState(const TradingState& state) {
        // Write directly to mapped memory
        memcpy(mapped_region_, &state, sizeof(state));

        // Optional: Force flush
        msync(mapped_region_, sizeof(state), MS_SYNC);

        // Latency: ~10 microseconds (without sync)
        //          ~100 microseconds (with sync)
    }

    TradingState LoadState() {
        TradingState state;
        memcpy(&state, mapped_region_, sizeof(state));
        return state;
    }

private:
    int fd_;
    void* mapped_region_;
};
```

**Pros:**
- Very low latency (<10μs without sync)
- Direct memory access
- OS handles flushing

**Cons:**
- Fixed size
- Complex error handling
- Possible data corruption on crash (if no sync)

**Use Cases:**
- High-frequency state checkpoints
- Shared memory between processes
- Ring buffers for IPC

**4. Write-Ahead Log (WAL)**

For transactional state changes:

```cpp
class WriteAheadLog {
public:
    void LogOperation(const Operation& op) {
        // Serialize operation
        auto serialized = Serialize(op);

        // Append to log
        log_file_.append(serialized);

        // Flush to disk
        log_file_.flush();

        // Update in-memory state
        ApplyOperation(op);
    }

    void Recover() {
        // Start with empty state
        TradingState state;

        // Replay all operations from log
        for (const auto& op : ReadAllOperations()) {
            ApplyOperation(op, state);
        }

        return state;
    }

private:
    std::ofstream log_file_;
};

enum class OperationType {
    ORDER_SUBMIT,
    ORDER_CANCEL,
    FILL_RECEIVED,
    POSITION_UPDATE,
    CONFIG_CHANGE
};

struct Operation {
    OperationType type;
    uint64_t timestamp;
    uint64_t sequence_number;
    std::vector<uint8_t> data;
    uint64_t checksum;
};
```

**Pros:**
- Atomic operations
- Point-in-time recovery
- Complete audit trail
- Can replay to any point in time

**Cons:**
- Log grows over time (need truncation)
- Slower recovery (replay all ops)
- More complex implementation

**Use Cases:**
- Order management (complete order lifecycle)
- Audit trail
- Debugging (replay historical state)
- Compliance requirements

**5. Database Persistence**

For complex state and queries:

```cpp
class DatabasePersistence {
public:
    void SavePosition(const Position& pos) {
        // SQL query
        db_.execute(
            "INSERT INTO positions (symbol, exchange, quantity, avg_price, "
            "last_updated) VALUES (?, ?, ?, ?, ?) "
            "ON CONFLICT (symbol, exchange) DO UPDATE SET "
            "quantity = ?, avg_price = ?, last_updated = ?",
            pos.symbol, pos.exchange, pos.quantity, pos.avg_price,
            pos.last_updated, pos.quantity, pos.avg_price, pos.last_updated
        );
    }

    std::vector<Position> LoadAllPositions() {
        auto result = db_.query("SELECT * FROM positions");
        return ParsePositions(result);
    }

private:
    Database db_;  // PostgreSQL, SQLite, etc.
};
```

**Pros:**
- ACID guarantees
- Complex queries
- Transactions
- Mature tooling

**Cons:**
- Higher latency (milliseconds)
- Network overhead (if remote DB)
- Overkill for simple state

**Use Cases:**
- Historical data storage
- Complex analytics
- Configuration management
- Non-time-critical state

================================================================================
CHECKPOINT STRATEGY
================================================================================

**Multi-Level Checkpointing:**

```
Level 1: Ultra-Fast (Memory-Mapped)
- Frequency: Every 100ms
- Latency: <10μs
- Data: Critical trading state only
- Survives: Clean shutdown, not crash

Level 2: Fast (Synchronous Write)
- Frequency: Every 1 second
- Latency: ~100μs
- Data: Full trading state
- Survives: Most crashes

Level 3: Complete (WAL + Snapshot)
- Frequency: Every 5 minutes
- Latency: ~10ms
- Data: Everything (state + config + history)
- Survives: All failures

Level 4: Archive (Database)
- Frequency: Every 1 hour
- Latency: Seconds
- Data: Historical snapshot
- Survives: Long-term storage, disaster recovery
```

**Implementation:**

```cpp
class MultiLevelCheckpointer {
public:
    void Run() {
        while (running_) {
            auto now = GetCurrentTimeNanos();

            // Level 1: Every 100ms
            if (now - last_l1_ >= 100'000'000) {
                CheckpointLevel1();
                last_l1_ = now;
            }

            // Level 2: Every 1 second
            if (now - last_l2_ >= 1'000'000'000) {
                CheckpointLevel2();
                last_l2_ = now;
            }

            // Level 3: Every 5 minutes
            if (now - last_l3_ >= 300'000'000'000) {
                CheckpointLevel3();
                last_l3_ = now;
            }

            // Level 4: Every 1 hour
            if (now - last_l4_ >= 3600'000'000'000) {
                CheckpointLevel4();
                last_l4_ = now;
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    }

private:
    void CheckpointLevel1() {
        // Memory-mapped (ultra-fast)
        mmap_persistence_.SaveState(state_);
    }

    void CheckpointLevel2() {
        // Synchronous write (fast)
        sync_persistence_.SaveState(state_);
    }

    void CheckpointLevel3() {
        // WAL + full snapshot
        wal_.CreateSnapshot(state_);
    }

    void CheckpointLevel4() {
        // Database archive
        db_.SaveSnapshot(state_);
    }

    TradingState state_;
    uint64_t last_l1_, last_l2_, last_l3_, last_l4_;

    MemoryMappedPersistence mmap_persistence_;
    SynchronousPersistence sync_persistence_;
    WriteAheadLog wal_;
    DatabasePersistence db_;

    std::atomic<bool> running_;
};
```

================================================================================
STATE VALIDATION & CHECKSUMS
================================================================================

**Checksum Calculation:**

```cpp
uint64_t CalculateChecksum(const TradingState& state) {
    // Use CRC64 or xxHash for speed
    XXH64_state_t hash_state;
    XXH64_reset(&hash_state, 0);

    // Hash all fields
    XXH64_update(&hash_state, &state.positions, sizeof(state.positions));
    XXH64_update(&hash_state, &state.open_orders, sizeof(state.open_orders));
    // ... hash all fields

    return XXH64_digest(&hash_state);
}

bool ValidateState(const TradingState& state) {
    // Recalculate checksum
    uint64_t calculated = CalculateChecksum(state);

    // Compare with stored checksum
    if (calculated != state.checksum) {
        LOG_ERROR("State checksum mismatch! Corruption detected.");
        return false;
    }

    // Additional validation
    if (state.positions.empty() && state.gross_exposure > 0) {
        LOG_ERROR("Inconsistent state: No positions but non-zero exposure");
        return false;
    }

    // Validate timestamps
    if (state.last_update_timestamp > GetCurrentTimeNanos()) {
        LOG_ERROR("State timestamp is in the future!");
        return false;
    }

    return true;
}
```

================================================================================
STATE RECOVERY PROCESS
================================================================================

**Recovery Sequence:**

```cpp
class StateRecovery {
public:
    TradingState Recover() {
        LOG_INFO("Starting state recovery...");

        // Try levels from fastest to slowest
        TradingState state;

        // Try Level 1 (memory-mapped, recent)
        if (TryRecoverLevel1(state)) {
            LOG_INFO("Recovered from Level 1 (memory-mapped)");
            if (ValidateState(state)) {
                return state;
            }
        }

        // Try Level 2 (synchronous file, recent)
        if (TryRecoverLevel2(state)) {
            LOG_INFO("Recovered from Level 2 (file)");
            if (ValidateState(state)) {
                return state;
            }
        }

        // Try Level 3 (WAL + snapshot)
        if (TryRecoverLevel3(state)) {
            LOG_INFO("Recovered from Level 3 (WAL)");
            if (ValidateState(state)) {
                return state;
            }
        }

        // Try Level 4 (database, older)
        if (TryRecoverLevel4(state)) {
            LOG_INFO("Recovered from Level 4 (database)");
            if (ValidateState(state)) {
                return state;
            }
        }

        // All recovery methods failed
        LOG_ERROR("All recovery methods failed!");

        // Last resort: Reconstruct from exchanges
        return ReconstructFromExchanges();
    }

private:
    TradingState ReconstructFromExchanges() {
        LOG_WARN("Reconstructing state from exchanges (slow)...");

        TradingState state;

        // Query each exchange for positions
        for (auto exchange : exchanges_) {
            auto positions = exchange.GetAllPositions();
            for (const auto& pos : positions) {
                state.positions[pos.symbol] = pos;
            }

            // Query open orders
            auto orders = exchange.GetOpenOrders();
            for (const auto& order : orders) {
                state.open_orders[order.id] = order;
            }

            // Query account balances
            state.balances[exchange.name()] = exchange.GetBalance();
        }

        // Recalculate derived state
        RecalculateDerivedState(state);

        return state;
    }
};
```

================================================================================
BEST PRACTICES
================================================================================

**1. Separate Hot and Cold State**
- Hot state: Frequently updated, needs fast persistence
- Cold state: Rarely updated, can use slower persistence

**2. Version Your State**
- Include version number in state structure
- Handle migration when loading old state
- Test loading state from previous versions

**3. Test Recovery Regularly**
- Monthly: Simulate crash and recover
- Measure RTO (recovery time objective)
- Validate recovered state

**4. Monitor State Size**
- Checkpoint size should be bounded
- Prune old data (e.g., fills older than 24 hours)
- Alert if state size grows unexpectedly

**5. Use Atomic Writes**
- Write to temporary file, then atomic rename
- Prevents partial writes on crash
```cpp
void AtomicWrite(const std::string& path, const Data& data) {
    std::string temp_path = path + ".tmp";
    WriteToFile(temp_path, data);
    std::filesystem::rename(temp_path, path);  // Atomic on POSIX
}
```

**6. Compress Large State**
- Use compression for Level 3+ checkpoints
- LZ4 (very fast), Zstd (good ratio), or Gzip (small)
- Trade-off: CPU vs disk I/O

**7. Replicate State**
- Keep state on multiple machines
- Synchronous replication for critical state
- Asynchronous for non-critical

================================================================================
PERFORMANCE CONSIDERATIONS
================================================================================

**Latency Budget:**
- Memory-mapped write: <10μs
- Synchronous file write: ~100μs
- Database write: ~1-10ms

**Throughput:**
- Memory-mapped: >100K writes/sec
- Synchronous file: ~10K writes/sec
- Database: ~1K writes/sec

**Optimization Techniques:**
- Batch writes (trade latency for throughput)
- Use SPDK/DPDK for ultra-low latency storage
- Use NVMe SSDs (latency <100μs)
- Use battery-backed RAID (cache)
- Disable write barriers (if safe)

================================================================================
