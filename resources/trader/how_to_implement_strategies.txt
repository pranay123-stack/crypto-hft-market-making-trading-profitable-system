================================================================================
                   HOW TO IMPLEMENT TRADING STRATEGIES
                        Step-by-Step Implementation Guide
================================================================================
Last Updated: 2025-11-25
Version: 1.0
Target Audience: All Traders
Document Size: ~28KB

================================================================================
                              TABLE OF CONTENTS
================================================================================

1. INTRODUCTION
   1.1 Purpose of This Guide
   1.2 Prerequisites
   1.3 Strategy Lifecycle Overview

2. STRATEGY ARCHITECTURE
   2.1 Core Components
   2.2 Strategy Framework
   2.3 Integration Points
   2.4 Data Flow

3. PRE-IMPLEMENTATION PHASE
   3.1 Strategy Specification
   3.2 Backtesting Requirements
   3.3 Risk Assessment
   3.4 Approval Process

4. IMPLEMENTATION WORKFLOW
   4.1 Development Environment Setup
   4.2 Strategy Coding Standards
   4.3 Parameter Configuration
   4.4 Signal Generation Logic
   4.5 Order Management Integration
   4.6 Risk Controls Implementation

5. TESTING PROCEDURES
   5.1 Unit Testing
   5.2 Integration Testing
   5.3 Paper Trading
   5.4 Simulation Testing
   5.5 Performance Validation

6. DEPLOYMENT PROCESS
   6.1 Pre-Deployment Checklist
   6.2 Staged Rollout
   6.3 Production Deployment
   6.4 Post-Deployment Monitoring

7. MONITORING AND MAINTENANCE
   7.1 Real-Time Monitoring
   7.2 Performance Metrics
   7.3 Strategy Tuning
   7.4 Debugging Procedures

8. TROUBLESHOOTING
   8.1 Common Issues
   8.2 Diagnostic Procedures
   8.3 Resolution Workflows

9. ADVANCED TOPICS
   9.1 Multi-Strategy Coordination
   9.2 Dynamic Parameter Adjustment
   9.3 Machine Learning Integration

10. APPENDICES
    A. Code Templates
    B. Configuration Examples
    C. Checklist Summary

================================================================================
                            1. INTRODUCTION
================================================================================

1.1 PURPOSE OF THIS GUIDE
-------------------------
This comprehensive guide walks traders through the complete process of
implementing trading strategies on the HFT platform. It covers everything
from initial concept to production deployment and ongoing maintenance.

Key Objectives:
- Ensure consistent implementation methodology
- Maintain high code quality and safety standards
- Minimize production incidents
- Optimize strategy performance
- Enable rapid yet safe deployment

Who Should Use This Guide:
- Traders implementing new strategies
- Strategy developers
- Quantitative analysts
- Risk managers overseeing strategy deployment

1.2 PREREQUISITES
----------------
Before implementing a strategy, ensure you have:

Technical Skills:
[ ] Proficiency in C++ (primary language)
[ ] Understanding of Python (for rapid prototyping)
[ ] Knowledge of trading concepts and market microstructure
[ ] Familiarity with the HFT platform architecture
[ ] Experience with version control (Git)

System Access:
[ ] Development environment credentials
[ ] Testing environment access
[ ] Strategy repository permissions
[ ] Risk dashboard access
[ ] Production deployment authorization (if applicable)

Documentation:
[ ] Strategy specification document
[ ] Backtest results and analysis
[ ] Risk assessment approval
[ ] Compliance review completion

Training:
[ ] Platform training module completed
[ ] Risk management certification
[ ] Code review process training
[ ] Incident response training

1.3 STRATEGY LIFECYCLE OVERVIEW
-------------------------------
The complete strategy lifecycle consists of:

Phase 1: CONCEPT (Duration: 1-2 weeks)
- Strategy ideation and research
- Initial backtesting
- Preliminary risk assessment

Phase 2: DEVELOPMENT (Duration: 2-4 weeks)
- Detailed specification
- Implementation in development environment
- Comprehensive testing
- Code review

Phase 3: VALIDATION (Duration: 1-2 weeks)
- Paper trading
- Performance validation
- Risk validation
- Final approvals

Phase 4: DEPLOYMENT (Duration: 1-3 days)
- Staged rollout
- Production deployment
- Initial monitoring period

Phase 5: PRODUCTION (Ongoing)
- Active trading
- Performance monitoring
- Periodic review and optimization
- Maintenance and updates

Phase 6: RETIREMENT (When needed)
- Graceful shutdown
- Performance post-mortem
- Knowledge capture

================================================================================
                        2. STRATEGY ARCHITECTURE
================================================================================

2.1 CORE COMPONENTS
------------------
Every trading strategy consists of these essential components:

Component 1: MARKET DATA HANDLER
--------------------------------
Purpose: Process incoming market data
Responsibilities:
- Subscribe to relevant market data feeds
- Parse and normalize data
- Handle data quality issues
- Maintain order book state
- Calculate derived metrics (VWAP, spreads, etc.)

Key Interfaces:
- OnMarketData(const MarketData& data)
- OnOrderBookUpdate(const OrderBook& book)
- OnTrade(const Trade& trade)

Component 2: SIGNAL GENERATOR
-----------------------------
Purpose: Generate trading signals
Responsibilities:
- Analyze market conditions
- Apply strategy logic
- Generate buy/sell signals
- Calculate signal confidence
- Determine position sizing

Key Interfaces:
- GenerateSignal() -> Signal
- EvaluateConditions() -> bool
- CalculatePositionSize() -> double

Component 3: RISK MANAGER
-------------------------
Purpose: Enforce risk controls
Responsibilities:
- Pre-trade risk checks
- Position limit enforcement
- P&L monitoring
- Exposure calculation
- Dynamic limit adjustment

Key Interfaces:
- PreTradeCheck(const Order& order) -> bool
- UpdateRiskMetrics()
- CheckLimits() -> bool
- GetRemainingCapacity() -> RiskCapacity

Component 4: ORDER MANAGER
--------------------------
Purpose: Execute and manage orders
Responsibilities:
- Order creation and submission
- Order lifecycle management
- Execution monitoring
- Fill processing
- Order cancellation

Key Interfaces:
- SubmitOrder(const Order& order) -> OrderID
- CancelOrder(OrderID id) -> bool
- OnFill(const Fill& fill)
- GetOrderStatus(OrderID id) -> Status

Component 5: POSITION MANAGER
-----------------------------
Purpose: Track and manage positions
Responsibilities:
- Position tracking
- P&L calculation
- Inventory management
- Position reconciliation
- Risk exposure calculation

Key Interfaces:
- UpdatePosition(const Fill& fill)
- GetPosition(const Symbol& symbol) -> Position
- CalculatePnL() -> double
- GetExposure() -> Exposure

Component 6: PERFORMANCE TRACKER
--------------------------------
Purpose: Monitor strategy performance
Responsibilities:
- Track key metrics
- Calculate statistics
- Generate reports
- Alert on anomalies
- Log decisions and outcomes

Key Interfaces:
- UpdateMetrics()
- GetPerformance() -> PerformanceStats
- LogDecision(const Decision& decision)
- GenerateReport() -> Report

2.2 STRATEGY FRAMEWORK
---------------------
The platform provides a base strategy framework:

class Strategy {
public:
    // Lifecycle methods
    virtual bool Initialize(const Config& config) = 0;
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Shutdown() = 0;

    // Core trading logic
    virtual void OnMarketData(const MarketData& data) = 0;
    virtual void OnOrderUpdate(const OrderUpdate& update) = 0;
    virtual void OnTimer(TimerID id) = 0;

    // Risk management
    virtual bool PreTradeCheck(const Order& order) = 0;
    virtual void OnRiskBreach(const RiskEvent& event) = 0;

    // Configuration
    virtual void UpdateParameters(const Parameters& params) = 0;
    virtual Parameters GetParameters() const = 0;

    // Status and reporting
    virtual StrategyStatus GetStatus() const = 0;
    virtual PerformanceMetrics GetMetrics() const = 0;

protected:
    // Helper utilities provided by framework
    void SubscribeMarketData(const Symbol& symbol);
    void SetTimer(TimerID id, Duration interval);
    void LogInfo(const std::string& message);
    void LogWarning(const std::string& message);
    void LogError(const std::string& message);

    // Access to core services
    RiskManager* risk_manager_;
    OrderManager* order_manager_;
    PositionManager* position_manager_;
    MarketDataService* market_data_;
};

2.3 INTEGRATION POINTS
---------------------
Strategies integrate with the platform through:

Integration Point 1: MARKET DATA SERVICE
---------------------------------------
Connection: High-speed market data feed
Protocol: FIX 4.4 / Binary proprietary
Latency: <100 microseconds
Reliability: Redundant feeds with automatic failover

Integration Point 2: ORDER ROUTING SERVICE
-----------------------------------------
Connection: Direct market access (DMA)
Protocol: FIX 4.4 / Exchange-specific
Latency: <500 microseconds to exchange
Features: Smart order routing, TWAP, VWAP, Iceberg

Integration Point 3: RISK MANAGEMENT SERVICE
-------------------------------------------
Connection: In-process / Low-latency IPC
Checks: Pre-trade, post-trade, continuous monitoring
Latency: <10 microseconds
Response: Block, warn, or throttle

Integration Point 4: POSITION MANAGEMENT SERVICE
-----------------------------------------------
Connection: Shared memory / Real-time database
Updates: Immediate on fills
Reconciliation: Every 5 minutes and end-of-day
Accuracy: 100% required

Integration Point 5: LOGGING AND MONITORING
------------------------------------------
Connection: Async logging infrastructure
Protocols: Structured logging, metrics, alerts
Storage: Long-term archival (7 years)
Accessibility: Real-time dashboards, historical queries

2.4 DATA FLOW
------------
Typical data flow in a strategy:

Market Data Flow:
[Exchange] -> [Market Data Service] -> [Strategy.OnMarketData()]
           -> [Signal Generator] -> [Risk Check] -> [Order Manager]
           -> [Order Routing] -> [Exchange]

Fill Flow:
[Exchange] -> [Order Routing] -> [Order Manager] -> [Strategy.OnOrderUpdate()]
           -> [Position Manager] -> [P&L Calculation] -> [Risk Update]

Risk Monitoring Flow:
[Position Manager] -> [Risk Service] -> [Continuous Monitoring]
                   -> [Alert Generation] -> [Dashboard / Trader]

================================================================================
                      3. PRE-IMPLEMENTATION PHASE
================================================================================

3.1 STRATEGY SPECIFICATION
--------------------------
Before coding, create a detailed specification:

SPECIFICATION TEMPLATE:
----------------------

Strategy Name: [Descriptive name]
Strategy Type: [Market Making / Arbitrage / Momentum / Mean Reversion / etc.]
Version: [x.y.z]
Author: [Name]
Date: [YYYY-MM-DD]

EXECUTIVE SUMMARY:
-----------------
[2-3 paragraph description of strategy concept and rationale]

MARKET HYPOTHESIS:
-----------------
- What market inefficiency does this exploit?
- Why should this strategy be profitable?
- What are the economic underpinnings?
- What market conditions favor this strategy?
- What conditions are unfavorable?

STRATEGY LOGIC:
--------------
Signal Generation:
- Entry conditions (be specific with formulas)
- Exit conditions
- Position sizing rules
- Timing considerations

Example:
Entry: When (bid_volume / ask_volume) > 1.5 AND spread < 0.02% AND RSI < 30
Exit: When profit > 0.1% OR loss > 0.05% OR time > 300 seconds
Size: min(1000 shares, 5% of daily volume, risk_capacity / price)

PARAMETERS:
----------
List all configurable parameters:
- Parameter name
- Type (integer, float, boolean, etc.)
- Default value
- Valid range
- Description
- Sensitivity (how much performance changes with this parameter)

Example:
volume_ratio_threshold: float, default=1.5, range=[1.2, 2.0]
  Description: Minimum bid/ask volume ratio for entry signal
  Sensitivity: High - small changes significantly affect signal frequency

MARKET COVERAGE:
---------------
- Asset classes: [Equities / Futures / Options / Crypto / FX]
- Specific instruments or universe definition
- Market hours: [Pre-market / Regular / After-hours]
- Minimum liquidity requirements
- Exchange preferences

RISK PARAMETERS:
---------------
- Maximum position size per symbol
- Maximum portfolio exposure
- Daily loss limit
- Maximum leverage
- Concentration limits
- Correlation considerations

EXPECTED PERFORMANCE:
--------------------
Based on backtesting:
- Expected Sharpe ratio: [x.xx]
- Average daily P&L: [$xx,xxx]
- Win rate: [xx%]
- Average win: [$xxx]
- Average loss: [$xxx]
- Maximum drawdown: [$xx,xxx]
- Recovery time: [x days]
- Capital requirements: [$xxx,xxx]

BACKTESTING SUMMARY:
-------------------
- Historical period tested: [Start date] to [End date]
- Number of trades: [x,xxx]
- Data quality: [Description]
- Assumptions made
- Known limitations
- Slippage model used
- Commission model used

DEPENDENCIES:
------------
- Required market data feeds
- External data sources
- Other strategies (if any coordination needed)
- Infrastructure requirements
- Third-party services

RISKS AND LIMITATIONS:
---------------------
- Known failure modes
- Market conditions to avoid
- Operational risks
- Technology risks
- Regulatory considerations
- Potential for adverse selection

MONITORING PLAN:
---------------
- Key metrics to track
- Alert thresholds
- Review frequency
- Success criteria
- Failure criteria (when to shut down)

3.2 BACKTESTING REQUIREMENTS
----------------------------
Comprehensive backtesting is mandatory:

MINIMUM BACKTEST REQUIREMENTS:
-----------------------------

Duration:
- At least 2 years of historical data
- Must include different market regimes
- Must include major market events

Data Quality:
- Tick-by-tick data for primary instruments
- Complete order book depth
- Accurate timestamps (microsecond precision)
- Handled data gaps and anomalies properly

Realism:
- Accurate transaction costs
- Realistic slippage model
- Market impact model
- Latency simulation (at least 500us)
- Exchange rules and constraints
- Capacity constraints

Statistical Rigor:
- Walk-forward analysis
- Out-of-sample testing
- Monte Carlo simulation
- Parameter sensitivity analysis
- Robustness testing

BACKTEST REPORT MUST INCLUDE:
-----------------------------
1. Summary Statistics
   - Total P&L
   - Sharpe ratio
   - Maximum drawdown
   - Win rate
   - Profit factor
   - Number of trades

2. Time Series Analysis
   - Equity curve
   - Daily P&L distribution
   - Drawdown periods
   - Rolling Sharpe ratio

3. Trade Analysis
   - Trade duration distribution
   - P&L per trade distribution
   - Time of day analysis
   - Day of week analysis
   - Win/loss streaks

4. Parameter Sensitivity
   - Performance vs. each parameter
   - Optimal parameter regions
   - Robustness assessment

5. Risk Analysis
   - VaR calculations (95%, 99%)
   - Expected shortfall
   - Tail risk analysis
   - Correlation with market indices

6. Capacity Analysis
   - Expected daily volume traded
   - Market impact estimates
   - Scalability assessment

3.3 RISK ASSESSMENT
------------------
Complete risk assessment required:

RISK ASSESSMENT CHECKLIST:
--------------------------

Market Risk:
[ ] Directional exposure quantified
[ ] Volatility sensitivity analyzed
[ ] Liquidity risk assessed
[ ] Concentration risk evaluated
[ ] Correlation risk considered

Operational Risk:
[ ] System failure scenarios identified
[ ] Data quality issues addressed
[ ] Latency sensitivity tested
[ ] Recovery procedures defined
[ ] Manual intervention procedures documented

Model Risk:
[ ] Parameter stability verified
[ ] Overfitting risk assessed
[ ] Regime change sensitivity tested
[ ] Model degradation monitoring plan created

Regulatory Risk:
[ ] Compliance review completed
[ ] Market manipulation risk assessed
[ ] Reporting requirements identified
[ ] Audit trail adequacy verified

Counterparty Risk:
[ ] Exchange risk evaluated
[ ] Clearing risk assessed
[ ] Credit risk considered

3.4 APPROVAL PROCESS
-------------------
Multi-level approval required:

APPROVAL WORKFLOW:
-----------------

Level 1: PEER REVIEW
--------------------
Reviewers: 2 senior traders or quants
Focus:
- Strategy logic soundness
- Backtest quality
- Code quality (if available)
- Documentation completeness
Criteria: Both reviewers must approve
Timeline: 3-5 business days

Level 2: RISK REVIEW
--------------------
Reviewers: Risk management team
Focus:
- Risk parameters appropriateness
- Limit setting
- Potential for large losses
- Correlation with existing strategies
- Stress testing results
Criteria: Risk officer approval required
Timeline: 3-5 business days

Level 3: COMPLIANCE REVIEW
--------------------------
Reviewers: Compliance officer
Focus:
- Regulatory compliance
- Market abuse prevention
- Documentation adequacy
- Audit trail completeness
Criteria: Compliance officer approval required
Timeline: 2-3 business days

Level 4: TECHNOLOGY REVIEW
--------------------------
Reviewers: Platform architecture team
Focus:
- System stability impact
- Resource requirements
- Integration quality
- Performance impact on other strategies
Criteria: Tech lead approval required
Timeline: 2-3 business days

Level 5: FINAL APPROVAL
-----------------------
Approver: Head of Trading or CIO
Focus:
- Business case
- Alignment with firm strategy
- Resource allocation
- Overall risk/reward
Criteria: Executive approval required
Timeline: 1-2 business days

TOTAL APPROVAL TIMELINE: 2-3 WEEKS

================================================================================
                      4. IMPLEMENTATION WORKFLOW
================================================================================

4.1 DEVELOPMENT ENVIRONMENT SETUP
---------------------------------
Set up your development environment:

STEP 1: REPOSITORY ACCESS
-------------------------
git clone git@github.com:hft-trading/strategy-dev.git
cd strategy-dev
git checkout -b strategy/[your-strategy-name]

STEP 2: ENVIRONMENT CONFIGURATION
---------------------------------
# Copy template configuration
cp config/strategy_template.yaml config/[your_strategy].yaml

# Set up virtual environment for Python tools
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt

# Install C++ dependencies
./scripts/install_dependencies.sh

STEP 3: IDE SETUP
----------------
Recommended: CLion or VS Code with C++ extensions

Configure linter and formatter:
- ClangFormat for code formatting
- Clang-Tidy for static analysis
- Google Test for unit testing

STEP 4: BUILD SYSTEM
-------------------
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Debug ..
make -j8

STEP 5: DATABASE SETUP
---------------------
# Create development database
./scripts/setup_dev_db.sh

# Populate with test data
./scripts/load_test_data.sh --days 30

4.2 STRATEGY CODING STANDARDS
-----------------------------
Follow these coding standards strictly:

NAMING CONVENTIONS:
------------------
- Classes: PascalCase (e.g., MarketMakingStrategy)
- Functions: camelCase (e.g., calculateSignal)
- Variables: snake_case (e.g., bid_price)
- Constants: UPPER_SNAKE_CASE (e.g., MAX_POSITION_SIZE)
- Private members: trailing underscore (e.g., risk_manager_)

FILE ORGANIZATION:
-----------------
src/strategies/[strategy_name]/
  ├── strategy.h          # Main strategy header
  ├── strategy.cpp        # Main strategy implementation
  ├── signal_generator.h  # Signal generation logic
  ├── signal_generator.cpp
  ├── config.h            # Configuration structures
  └── README.md           # Strategy-specific documentation

HEADER FILE TEMPLATE:
--------------------
#ifndef HFT_STRATEGIES_[STRATEGY_NAME]_H_
#define HFT_STRATEGIES_[STRATEGY_NAME]_H_

#include "strategy_framework/base_strategy.h"
#include <memory>
#include <string>

namespace hft {
namespace strategies {

class [StrategyName] : public BaseStrategy {
public:
    explicit [StrategyName](const Config& config);
    ~[StrategyName]() override;

    // Prevent copying
    [StrategyName](const [StrategyName]&) = delete;
    [StrategyName]& operator=(const [StrategyName]&) = delete;

    // BaseStrategy interface implementation
    bool Initialize() override;
    void Start() override;
    void Stop() override;
    void Shutdown() override;

    void OnMarketData(const MarketData& data) override;
    void OnOrderUpdate(const OrderUpdate& update) override;

private:
    // Private helper methods
    void processSignal(const Signal& signal);
    bool shouldTrade() const;

    // Member variables
    std::unique_ptr<SignalGenerator> signal_generator_;
    StrategyConfig config_;
};

}  // namespace strategies
}  // namespace hft

#endif  // HFT_STRATEGIES_[STRATEGY_NAME]_H_

ERROR HANDLING:
--------------
- Use exceptions for exceptional situations only
- Return error codes for expected errors
- Always check return values
- Log all errors with context
- Never silently swallow exceptions

Example:
try {
    auto order = createOrder(signal);
    if (!risk_manager_->PreTradeCheck(order)) {
        LogWarning("PreTradeCheck failed for order: " + order.ToString());
        return;
    }

    auto result = order_manager_->SubmitOrder(order);
    if (!result.success) {
        LogError("Failed to submit order: " + result.error_message);
        handleOrderSubmissionFailure(order, result);
        return;
    }
} catch (const std::exception& e) {
    LogError("Exception in order submission: " + std::string(e.what()));
    handleCriticalError();
}

LOGGING:
-------
Use structured logging:

LogInfo("Signal generated", {
    {"symbol", symbol},
    {"signal_type", "BUY"},
    {"confidence", confidence},
    {"reason", reason}
});

Log levels:
- DEBUG: Detailed diagnostic information
- INFO: Normal operational messages
- WARNING: Warning messages for recoverable issues
- ERROR: Error messages for failures
- CRITICAL: Critical failures requiring immediate attention

COMMENTS AND DOCUMENTATION:
--------------------------
- Document WHY, not WHAT
- Use Doxygen-style comments for public APIs
- Explain complex algorithms
- Note assumptions and limitations
- Reference research papers or sources

Example:
/**
 * Calculates the optimal position size based on signal strength and risk capacity.
 *
 * Uses Kelly Criterion with half-Kelly sizing for conservative risk management.
 * The formula accounts for current volatility and adjusts for portfolio heat.
 *
 * @param signal The trading signal with confidence score [0, 1]
 * @param risk_capacity Remaining risk capacity in dollars
 * @return Optimal position size in shares, or 0 if conditions not favorable
 *
 * @note This assumes normally distributed returns, which may not hold during
 *       extreme market conditions. Position sizing is capped at 5% of ADV.
 */
int calculatePositionSize(const Signal& signal, double risk_capacity);

4.3 PARAMETER CONFIGURATION
---------------------------
Design flexible, configurable strategies:

CONFIGURATION FILE FORMAT (YAML):
---------------------------------
strategy:
  name: "MeanReversionStrategy"
  version: "1.0.0"
  enabled: true

  parameters:
    # Signal generation
    lookback_period: 20
    entry_threshold: 2.0  # Standard deviations
    exit_threshold: 0.5

    # Position sizing
    base_size: 1000  # shares
    max_size: 10000
    sizing_method: "volatility_adjusted"

    # Risk management
    max_position_value: 1000000  # dollars
    daily_loss_limit: -50000
    max_leverage: 2.0

    # Timing
    min_hold_time: 60  # seconds
    max_hold_time: 3600

  instruments:
    - symbol: "AAPL"
      exchange: "NASDAQ"
      enabled: true
      size_multiplier: 1.0
    - symbol: "MSFT"
      exchange: "NASDAQ"
      enabled: true
      size_multiplier: 0.8

  risk_limits:
    per_symbol_limit: 500000
    concentration_limit: 0.3  # 30% max in single position
    sector_limit: 2000000

  market_hours:
    start_time: "09:35:00"  # After opening volatility
    end_time: "15:45:00"    # Before closing auction
    trade_close_auction: false

PARAMETER VALIDATION:
--------------------
Always validate parameters on startup:

bool [StrategyName]::validateConfig(const Config& config) {
    if (config.lookback_period < 5 || config.lookback_period > 100) {
        LogError("lookback_period must be between 5 and 100");
        return false;
    }

    if (config.entry_threshold <= config.exit_threshold) {
        LogError("entry_threshold must be > exit_threshold");
        return false;
    }

    if (config.daily_loss_limit >= 0) {
        LogError("daily_loss_limit must be negative");
        return false;
    }

    // Validate all parameters...

    return true;
}

DYNAMIC PARAMETER UPDATES:
-------------------------
Support runtime parameter updates where safe:

void [StrategyName]::UpdateParameters(const Parameters& params) {
    std::lock_guard<std::mutex> lock(config_mutex_);

    // Only allow safe updates (not structural changes)
    if (params.has("entry_threshold")) {
        config_.entry_threshold = params.get<double>("entry_threshold");
        LogInfo("Updated entry_threshold to " +
                std::to_string(config_.entry_threshold));
    }

    // Don't allow changing fundamental parameters while running
    if (params.has("lookback_period")) {
        LogWarning("Cannot update lookback_period while strategy is running");
    }
}

4.4 SIGNAL GENERATION LOGIC
---------------------------
Implement clean, testable signal generation:

SIGNAL STRUCTURE:
----------------
struct Signal {
    enum class Type { NONE, BUY, SELL };
    enum class Confidence { LOW, MEDIUM, HIGH };

    Type type;
    Confidence confidence;
    double strength;  // [0, 1]
    std::string symbol;
    double target_price;
    double stop_loss;
    double take_profit;
    std::string reason;
    Timestamp generated_at;

    // Metadata for analysis
    std::map<std::string, double> factors;
};

SIGNAL GENERATOR IMPLEMENTATION:
-------------------------------
class SignalGenerator {
public:
    explicit SignalGenerator(const Config& config);

    Signal Generate(const MarketData& data);

private:
    bool checkEntryConditions(const MarketData& data);
    bool checkExitConditions(const Position& position, const MarketData& data);
    double calculateSignalStrength(const MarketData& data);

    Config config_;
    IndicatorCalculator indicators_;
};

Signal SignalGenerator::Generate(const MarketData& data) {
    Signal signal;
    signal.symbol = data.symbol;
    signal.generated_at = data.timestamp;
    signal.type = Signal::Type::NONE;

    // Calculate technical indicators
    double sma = indicators_.SMA(data.close_prices, config_.lookback_period);
    double std_dev = indicators_.StdDev(data.close_prices, config_.lookback_period);
    double z_score = (data.last_price - sma) / std_dev;

    // Store factors for later analysis
    signal.factors["sma"] = sma;
    signal.factors["std_dev"] = std_dev;
    signal.factors["z_score"] = z_score;

    // Check entry conditions
    if (z_score < -config_.entry_threshold) {
        // Price is significantly below mean - potential buy
        signal.type = Signal::Type::BUY;
        signal.strength = std::min(1.0, std::abs(z_score) / config_.entry_threshold);
        signal.target_price = sma;
        signal.stop_loss = data.last_price * 0.99;  // 1% stop
        signal.reason = "Mean reversion: z-score=" + std::to_string(z_score);

        if (signal.strength > 0.8) {
            signal.confidence = Signal::Confidence::HIGH;
        } else if (signal.strength > 0.5) {
            signal.confidence = Signal::Confidence::MEDIUM;
        } else {
            signal.confidence = Signal::Confidence::LOW;
        }
    }
    else if (z_score > config_.entry_threshold) {
        // Price is significantly above mean - potential sell
        signal.type = Signal::Type::SELL;
        signal.strength = std::min(1.0, std::abs(z_score) / config_.entry_threshold);
        signal.target_price = sma;
        signal.stop_loss = data.last_price * 1.01;  // 1% stop
        signal.reason = "Mean reversion: z-score=" + std::to_string(z_score);

        if (signal.strength > 0.8) {
            signal.confidence = Signal::Confidence::HIGH;
        } else if (signal.strength > 0.5) {
            signal.confidence = Signal::Confidence::MEDIUM;
        } else {
            signal.confidence = Signal::Confidence::LOW;
        }
    }

    return signal;
}

4.5 ORDER MANAGEMENT INTEGRATION
--------------------------------
Integrate with the order management system:

ORDER CREATION:
--------------
Order createOrder(const Signal& signal, const Position& current_position) {
    Order order;
    order.symbol = signal.symbol;
    order.timestamp = Clock::now();

    // Determine order side
    if (signal.type == Signal::Type::BUY) {
        order.side = OrderSide::BUY;
    } else {
        order.side = OrderSide::SELL;
    }

    // Calculate order quantity
    int quantity = calculateOrderQuantity(signal, current_position);
    order.quantity = quantity;

    // Set order type and pricing
    order.type = OrderType::LIMIT;  // Start with limit orders
    order.price = calculateLimitPrice(signal);
    order.time_in_force = TimeInForce::DAY;

    // Set order tags for tracking
    order.tags["strategy"] = strategy_name_;
    order.tags["signal_strength"] = std::to_string(signal.strength);
    order.tags["signal_reason"] = signal.reason;

    return order;
}

ORDER SUBMISSION WITH ERROR HANDLING:
------------------------------------
bool submitOrder(const Order& order) {
    // Pre-submission validation
    if (!validateOrder(order)) {
        LogError("Order validation failed: " + order.ToString());
        return false;
    }

    // Risk check
    auto risk_result = risk_manager_->PreTradeCheck(order);
    if (!risk_result.approved) {
        LogWarning("Order blocked by risk check: " + risk_result.reason);
        metrics_.IncrementCounter("orders_blocked_by_risk");
        return false;
    }

    // Submit to order manager
    auto result = order_manager_->SubmitOrder(order);
    if (!result.success) {
        LogError("Order submission failed: " + result.error_message);
        metrics_.IncrementCounter("order_submission_failures");
        handleSubmissionFailure(order, result);
        return false;
    }

    // Track pending order
    pending_orders_[result.order_id] = order;

    LogInfo("Order submitted successfully", {
        {"order_id", result.order_id},
        {"symbol", order.symbol},
        {"side", order.side},
        {"quantity", order.quantity},
        {"price", order.price}
    });

    metrics_.IncrementCounter("orders_submitted");
    return true;
}

ORDER UPDATE HANDLING:
---------------------
void [StrategyName]::OnOrderUpdate(const OrderUpdate& update) {
    LogDebug("Received order update", {
        {"order_id", update.order_id},
        {"status", update.status},
        {"filled_quantity", update.filled_quantity}
    });

    switch (update.status) {
        case OrderStatus::FILLED:
            handleFill(update);
            break;

        case OrderStatus::PARTIALLY_FILLED:
            handlePartialFill(update);
            break;

        case OrderStatus::CANCELLED:
            handleCancellation(update);
            break;

        case OrderStatus::REJECTED:
            handleRejection(update);
            break;

        default:
            // Intermediate statuses (PENDING, SUBMITTED, ACKNOWLEDGED)
            updatePendingOrderStatus(update);
            break;
    }
}

void handleFill(const OrderUpdate& update) {
    // Update position
    position_manager_->UpdatePosition(update);

    // Calculate execution quality
    double slippage = calculateSlippage(update);
    metrics_.RecordValue("slippage", slippage);

    // Remove from pending orders
    pending_orders_.erase(update.order_id);

    // Log fill
    LogInfo("Order filled", {
        {"order_id", update.order_id},
        {"symbol", update.symbol},
        {"side", update.side},
        {"quantity", update.filled_quantity},
        {"price", update.fill_price},
        {"slippage", slippage}
    });

    // Update strategy state
    updateStrategyState(update);
}

4.6 RISK CONTROLS IMPLEMENTATION
--------------------------------
Implement comprehensive risk controls:

PRE-TRADE RISK CHECKS:
---------------------
bool [StrategyName]::PreTradeCheck(const Order& order) {
    // Check 1: Position limit
    auto current_position = position_manager_->GetPosition(order.symbol);
    auto new_position = simulatePosition(current_position, order);

    if (std::abs(new_position.quantity * new_position.avg_price) >
        config_.max_position_value) {
        LogWarning("Order would exceed position limit");
        return false;
    }

    // Check 2: Daily loss limit
    double current_pnl = position_manager_->GetDailyPnL();
    if (current_pnl <= config_.daily_loss_limit) {
        LogWarning("Daily loss limit reached: " + std::to_string(current_pnl));
        Stop();  // Auto-stop strategy
        return false;
    }

    // Check 3: Leverage limit
    double total_exposure = position_manager_->GetTotalExposure();
    double capital = risk_manager_->GetAvailableCapital();
    double current_leverage = total_exposure / capital;

    if (current_leverage > config_.max_leverage) {
        LogWarning("Leverage limit exceeded: " + std::to_string(current_leverage));
        return false;
    }

    // Check 4: Concentration limit
    double symbol_exposure = std::abs(new_position.quantity * new_position.avg_price);
    if (symbol_exposure / total_exposure > config_.concentration_limit) {
        LogWarning("Concentration limit exceeded for " + order.symbol);
        return false;
    }

    // Check 5: Market hours
    if (!isWithinTradingHours()) {
        LogWarning("Outside allowed trading hours");
        return false;
    }

    // Check 6: Strategy-specific checks
    if (!strategySpecificRiskCheck(order)) {
        return false;
    }

    return true;
}

CONTINUOUS RISK MONITORING:
--------------------------
void [StrategyName]::monitorRisk() {
    // Called periodically (e.g., every second)

    RiskMetrics metrics;

    // Calculate current metrics
    metrics.total_exposure = position_manager_->GetTotalExposure();
    metrics.daily_pnl = position_manager_->GetDailyPnL();
    metrics.unrealized_pnl = position_manager_->GetUnrealizedPnL();
    metrics.leverage = calculateCurrentLeverage();
    metrics.var_95 = calculateVaR(0.95);
    metrics.largest_position = getLargestPosition();

    // Check for breaches
    if (metrics.daily_pnl <= config_.daily_loss_limit * 0.9) {
        // Approaching daily loss limit
        sendAlert("Approaching daily loss limit", AlertLevel::HIGH);
        reducePositions(0.5);  // Reduce positions by 50%
    }

    if (metrics.leverage > config_.max_leverage * 0.95) {
        // Approaching leverage limit
        sendAlert("Approaching leverage limit", AlertLevel::MEDIUM);
        stopNewPositions();
    }

    // Update risk dashboard
    risk_manager_->UpdateMetrics(metrics);

    // Log metrics
    LogDebug("Risk metrics", {
        {"exposure", metrics.total_exposure},
        {"daily_pnl", metrics.daily_pnl},
        {"leverage", metrics.leverage},
        {"var_95", metrics.var_95}
    });
}

POSITION REDUCTION LOGIC:
------------------------
void reducePositions(double target_reduction) {
    auto positions = position_manager_->GetAllPositions();

    // Sort by unrealized P&L (close losers first)
    std::sort(positions.begin(), positions.end(),
              [](const Position& a, const Position& b) {
                  return a.unrealized_pnl < b.unrealized_pnl;
              });

    double total_exposure = position_manager_->GetTotalExposure();
    double target_exposure = total_exposure * (1.0 - target_reduction);
    double current_exposure = total_exposure;

    for (const auto& position : positions) {
        if (current_exposure <= target_exposure) {
            break;
        }

        // Create closing order
        Order close_order;
        close_order.symbol = position.symbol;
        close_order.side = (position.quantity > 0) ? OrderSide::SELL : OrderSide::BUY;
        close_order.quantity = std::abs(position.quantity);
        close_order.type = OrderType::MARKET;  // Use market orders for urgency
        close_order.time_in_force = TimeInForce::IOC;  // Immediate or cancel

        if (submitOrder(close_order)) {
            current_exposure -= std::abs(position.quantity * position.avg_price);
            LogInfo("Closing position for risk reduction", {
                {"symbol", position.symbol},
                {"quantity", position.quantity}
            });
        }
    }
}

================================================================================
                        5. TESTING PROCEDURES
================================================================================

5.1 UNIT TESTING
---------------
Write comprehensive unit tests:

TEST STRUCTURE:
--------------
#include <gtest/gtest.h>
#include "strategies/mean_reversion/strategy.h"
#include "test_utils/mock_market_data.h"
#include "test_utils/mock_order_manager.h"

class MeanReversionStrategyTest : public ::testing::Test {
protected:
    void SetUp() override {
        config_ = createTestConfig();
        strategy_ = std::make_unique<MeanReversionStrategy>(config_);
        mock_market_data_ = std::make_shared<MockMarketData>();
        mock_order_manager_ = std::make_shared<MockOrderManager>();

        strategy_->SetMarketData(mock_market_data_);
        strategy_->SetOrderManager(mock_order_manager_);

        ASSERT_TRUE(strategy_->Initialize());
    }

    Config config_;
    std::unique_ptr<MeanReversionStrategy> strategy_;
    std::shared_ptr<MockMarketData> mock_market_data_;
    std::shared_ptr<MockOrderManager> mock_order_manager_;
};

EXAMPLE UNIT TESTS:
------------------
TEST_F(MeanReversionStrategyTest, GeneratesBuySignalWhenPriceBelowMean) {
    // Arrange
    auto market_data = createMarketDataBelowMean();

    // Act
    strategy_->OnMarketData(market_data);

    // Assert
    EXPECT_EQ(mock_order_manager_->GetOrderCount(), 1);
    auto order = mock_order_manager_->GetLastOrder();
    EXPECT_EQ(order.side, OrderSide::BUY);
    EXPECT_GT(order.quantity, 0);
}

TEST_F(MeanReversionStrategyTest, RespectsDailyLossLimit) {
    // Arrange
    setCurrentPnL(-49000);  // Just below $50k limit
    auto market_data = createMarketDataWithBuySignal();

    // Act
    strategy_->OnMarketData(market_data);

    // Assert - should still trade
    EXPECT_EQ(mock_order_manager_->GetOrderCount(), 1);

    // Now exceed limit
    setCurrentPnL(-50001);
    mock_order_manager_->Clear();

    // Act
    strategy_->OnMarketData(market_data);

    // Assert - should not trade
    EXPECT_EQ(mock_order_manager_->GetOrderCount(), 0);
    EXPECT_FALSE(strategy_->IsRunning());
}

TEST_F(MeanReversionStrategyTest, HandlesPartialFills) {
    // Arrange
    auto market_data = createMarketDataWithBuySignal();
    strategy_->OnMarketData(market_data);
    auto order = mock_order_manager_->GetLastOrder();

    // Act - simulate partial fill
    OrderUpdate update;
    update.order_id = order.id;
    update.status = OrderStatus::PARTIALLY_FILLED;
    update.filled_quantity = order.quantity / 2;
    update.fill_price = order.price;

    strategy_->OnOrderUpdate(update);

    // Assert
    auto position = strategy_->GetPosition(order.symbol);
    EXPECT_EQ(position.quantity, order.quantity / 2);
}

TEST_F(MeanReversionStrategyTest, CalculatesPositionSizeCorrectly) {
    // Arrange
    Signal signal;
    signal.type = Signal::Type::BUY;
    signal.strength = 0.8;
    signal.symbol = "AAPL";

    double price = 150.0;
    double risk_capacity = 100000.0;

    // Act
    int size = strategy_->CalculatePositionSize(signal, price, risk_capacity);

    // Assert
    double position_value = size * price;
    EXPECT_LE(position_value, config_.max_position_value);
    EXPECT_LE(position_value, risk_capacity);
    EXPECT_GT(size, 0);
}

RUN UNIT TESTS:
--------------
cd build
./tests/strategy_tests --gtest_filter=MeanReversionStrategy*

COVERAGE REQUIREMENTS:
---------------------
Minimum code coverage: 80%
Critical path coverage: 100%

Generate coverage report:
cmake -DCMAKE_BUILD_TYPE=Coverage ..
make coverage
# Report available at coverage/index.html

5.2 INTEGRATION TESTING
-----------------------
Test integration with platform services:

INTEGRATION TEST SETUP:
----------------------
class IntegrationTestEnvironment {
public:
    void SetUp() {
        // Start test database
        test_db_ = startTestDatabase();

        // Start mock exchange
        mock_exchange_ = startMockExchange();

        // Start platform services
        market_data_service_ = startMarketDataService();
        order_manager_ = startOrderManager();
        risk_manager_ = startRiskManager();
        position_manager_ = startPositionManager();

        // Wait for services to be ready
        waitForServicesReady();
    }

    void TearDown() {
        // Shutdown in reverse order
        position_manager_->Shutdown();
        risk_manager_->Shutdown();
        order_manager_->Shutdown();
        market_data_service_->Shutdown();
        mock_exchange_->Shutdown();
        test_db_->Shutdown();
    }
};

INTEGRATION TEST EXAMPLES:
-------------------------
TEST(IntegrationTest, EndToEndTradeFlow) {
    // Arrange
    IntegrationTestEnvironment env;
    auto strategy = createStrategy(env);
    strategy->Start();

    // Act - send market data that should trigger trade
    auto market_data = createSignalTriggeringData();
    env.SendMarketData(market_data);

    // Wait for order to be submitted and filled
    waitForCondition([&]() {
        return env.GetMockExchange()->GetFillCount() > 0;
    }, 5s);

    // Assert
    EXPECT_EQ(env.GetMockExchange()->GetOrderCount(), 1);
    EXPECT_EQ(env.GetMockExchange()->GetFillCount(), 1);

    auto position = env.GetPositionManager()->GetPosition("AAPL");
    EXPECT_NE(position.quantity, 0);

    auto metrics = strategy->GetMetrics();
    EXPECT_GT(metrics.trades_count, 0);
}

TEST(IntegrationTest, RiskLimitEnforcement) {
    // Arrange
    IntegrationTestEnvironment env;
    auto strategy = createStrategy(env);

    // Set position close to limit
    env.GetPositionManager()->SetPosition("AAPL",
        Position{9000, 100.0});  // $900k position

    strategy->Start();

    // Act - try to add more position (would exceed $1M limit)
    auto market_data = createSignalTriggeringData();
    env.SendMarketData(market_data);

    // Wait briefly
    std::this_thread::sleep_for(100ms);

    // Assert - order should be blocked
    EXPECT_EQ(env.GetMockExchange()->GetOrderCount(), 0);

    auto alerts = env.GetAlerts();
    EXPECT_TRUE(containsAlert(alerts, "position limit"));
}

5.3 PAPER TRADING
----------------
Test with live data but simulated execution:

PAPER TRADING SETUP:
-------------------
# Deploy to paper trading environment
./scripts/deploy_paper.sh --strategy mean_reversion --config paper_config.yaml

# Monitor paper trading
./scripts/monitor_paper.sh --strategy mean_reversion

PAPER TRADING CONFIGURATION:
---------------------------
environment: paper_trading
strategy: mean_reversion_v1
start_date: 2025-11-25
duration_days: 10

paper_trading_config:
  initial_capital: 1000000
  use_live_market_data: true
  simulate_fills: true
  fill_simulation:
    model: realistic  # basic, realistic, or pessimistic
    latency_ms: 500
    slippage_bps: 2
    fill_probability: 0.95

  logging:
    log_all_signals: true
    log_all_decisions: true
    record_market_data: true

monitoring:
  real_time_dashboard: true
  daily_reports: true
  alert_on_anomalies: true

PAPER TRADING DURATION:
----------------------
Minimum duration: 5 trading days
Recommended: 10-20 trading days
Extended testing: 1-3 months for complex strategies

SUCCESS CRITERIA:
----------------
1. Performance within 20% of backtest expectations
2. No system errors or crashes
3. Risk limits never breached
4. Sharpe ratio > 1.0 (or as specified)
5. Maximum drawdown within expectations

5.4 SIMULATION TESTING
---------------------
Test under various market conditions:

SIMULATION SCENARIOS:
--------------------
1. Normal Market Conditions
   - Typical volatility
   - Normal volume
   - Gradual price movements

2. High Volatility
   - VIX > 30
   - Large price swings
   - News-driven moves

3. Low Liquidity
   - Thin order books
   - Wide spreads
   - Difficult fills

4. Trending Markets
   - Strong directional moves
   - Momentum conditions
   - Potential for mean reversion failure

5. Choppy/Sideways Markets
   - No clear direction
   - Frequent reversals
   - Whipsaw potential

6. Market Stress
   - Flash crash scenarios
   - Circuit breakers
   - Exchange outages

7. Gap Events
   - Overnight gaps
   - Earnings announcements
   - Major news events

RUN SIMULATION SUITE:
--------------------
./scripts/run_simulation_suite.sh \
    --strategy mean_reversion \
    --scenarios all \
    --output simulation_results/

ANALYZE SIMULATION RESULTS:
--------------------------
python3 tools/analyze_simulations.py \
    --results simulation_results/ \
    --report simulation_report.pdf

5.5 PERFORMANCE VALIDATION
-------------------------
Validate strategy meets performance criteria:

VALIDATION CHECKLIST:
--------------------
[ ] Sharpe ratio meets or exceeds target
[ ] Win rate within expected range
[ ] Average trade P&L matches expectations
[ ] Maximum drawdown acceptable
[ ] Recovery time reasonable
[ ] Capacity sufficient for allocated capital
[ ] Slippage and transaction costs realistic
[ ] Latency sensitivity acceptable
[ ] Correlation with other strategies acceptable
[ ] Performance stable across different market conditions

PERFORMANCE REPORT MUST INCLUDE:
-------------------------------
1. Overall Statistics
   - Total P&L
   - Number of trades
   - Win rate
   - Profit factor
   - Sharpe ratio
   - Sortino ratio
   - Maximum drawdown
   - Recovery time

2. Comparison to Backtest
   - Backtest vs. paper trading performance
   - Explanation of differences
   - Degradation analysis

3. Risk Analysis
   - VaR and CVaR
   - Tail risk events
   - Largest losing trade
   - Losing streaks

4. Execution Quality
   - Fill rates
   - Average slippage
   - Impact cost
   - Order cancellation rate

5. Operational Metrics
   - System uptime
   - Latency statistics
   - Error rates
   - Alert frequency

APPROVAL TO PROCEED:
-------------------
Performance validation must be approved by:
- Strategy developer
- Senior trader or quant
- Risk manager

Only after approval can strategy proceed to production deployment.

================================================================================
                        6. DEPLOYMENT PROCESS
================================================================================

6.1 PRE-DEPLOYMENT CHECKLIST
----------------------------
Complete this checklist before deployment:

TECHNICAL READINESS:
[ ] All unit tests passing (100%)
[ ] All integration tests passing (100%)
[ ] Code review completed and approved
[ ] Documentation complete and up-to-date
[ ] Configuration files validated
[ ] Deployment scripts tested
[ ] Rollback procedure defined and tested
[ ] Monitoring dashboards configured
[ ] Alert rules configured
[ ] Log aggregation configured

PERFORMANCE VALIDATION:
[ ] Paper trading completed successfully
[ ] Performance metrics meet targets
[ ] Simulation testing completed
[ ] Performance report approved
[ ] Execution quality acceptable
[ ] Capacity analysis completed

RISK MANAGEMENT:
[ ] Risk parameters defined and approved
[ ] Position limits configured
[ ] Daily loss limit configured
[ ] Leverage limit configured
[ ] Risk monitoring operational
[ ] Emergency stop procedures tested
[ ] Escalation procedures defined

OPERATIONAL READINESS:
[ ] Trading desk briefed
[ ] Risk team briefed
[ ] IT operations briefed
[ ] Runbook created
[ ] On-call schedule defined
[ ] Support contacts documented
[ ] Training completed (if needed)

COMPLIANCE AND GOVERNANCE:
[ ] Compliance review approved
[ ] Regulatory requirements met
[ ] Audit trail verified
[ ] Documentation filed
[ ] Change management ticket created
[ ] Management approval obtained

6.2 STAGED ROLLOUT
-----------------
Deploy in stages to minimize risk:

STAGE 1: DARK DEPLOYMENT (Day 1)
--------------------------------
Deploy strategy in "dark" mode (observational only)
- Strategy runs but doesn't submit real orders
- Monitors market data and generates signals
- Logs what orders it would have submitted
- Validates system integration

Success Criteria:
- No system errors
- Signal generation as expected
- Performance monitoring working
- Risk checks functioning

Duration: 1 trading day

STAGE 2: LIMITED CAPITAL (Days 2-3)
-----------------------------------
Deploy with 10% of target capital
- Real orders submitted
- Reduced position limits
- Enhanced monitoring
- Quick shutdown capability

Example limits:
- Position limit: $100k (vs $1M target)
- Daily loss limit: -$5k (vs -$50k target)
- Max 2 positions simultaneously

Success Criteria:
- Clean execution
- No risk breaches
- Performance tracking correctly
- No operational issues

Duration: 2 trading days

STAGE 3: MEDIUM CAPITAL (Days 4-6)
----------------------------------
Increase to 50% of target capital
- Increase position limits proportionally
- Continue enhanced monitoring
- Expand to more instruments (if applicable)

Example limits:
- Position limit: $500k
- Daily loss limit: -$25k
- Normal operational procedures

Success Criteria:
- Consistent performance
- Scaling behaves as expected
- No new issues emerge

Duration: 3 trading days

STAGE 4: FULL DEPLOYMENT (Day 7+)
---------------------------------
Deploy with full target capital
- Full position limits
- Full instrument universe
- Standard monitoring
- Normal operational mode

Success Criteria:
- Performance meets expectations
- Operations running smoothly
- Team comfortable with strategy

ROLLBACK TRIGGERS:
-----------------
Immediate rollback if:
- Critical system error
- Risk limit breached
- Performance significantly worse than expected
- Operational issues prevent proper monitoring
- Compliance concern raised

6.3 PRODUCTION DEPLOYMENT
------------------------
Formal deployment procedure:

DEPLOYMENT DAY TIMELINE:
-----------------------
T-1 Day:
- Final approvals confirmed
- Team briefed
- Communication sent
- Emergency contacts on standby

T-0 07:00: Pre-Market Preparation
- System health check
- Deploy strategy code
- Validate configuration
- Test connectivity
- Verify monitoring

T-0 09:00: Pre-Market Validation
- Run strategy in dark mode
- Validate signal generation
- Check risk integration
- Verify logging

T-0 09:25: Final Go/No-Go Decision
- Review checklist
- Confirm team ready
- Get final approval
- Prepare to enable

T-0 09:30: Market Open
- Keep strategy in dark mode
- Observe market open volatility
- Monitor for any issues

T-0 09:35: Strategy Activation
- Enable strategy (Stage 1 capital)
- Begin active monitoring
- Trading desk and risk team watching

T-0 10:00: First Check-in
- Review first 25 minutes
- Check any trades executed
- Verify system behavior
- Confirm no issues

T-0 12:00: Midday Review
- Performance assessment
- Risk metrics review
- Any adjustments needed

T-0 16:00: Market Close
- End-of-day review
- Performance analysis
- Incident review (if any)
- Go/No-Go for next day

T-0 17:00: Day 1 Report
- Formal report to management
- Performance summary
- Issues and resolutions
- Plan for Day 2

DEPLOYMENT COMMANDS:
-------------------
# Deploy strategy
./scripts/deploy_production.sh \
    --strategy mean_reversion \
    --config prod_config.yaml \
    --stage dark \
    --validate

# Enable trading (move from dark to live)
./scripts/enable_strategy.sh \
    --strategy mean_reversion \
    --stage limited \
    --confirm

# Monitor deployment
./scripts/monitor_deployment.sh \
    --strategy mean_reversion \
    --realtime

# Emergency stop (if needed)
./scripts/emergency_stop.sh \
    --strategy mean_reversion \
    --reason "description" \
    --confirm

6.4 POST-DEPLOYMENT MONITORING
------------------------------
Enhanced monitoring after deployment:

FIRST WEEK MONITORING:
---------------------
- Real-time dashboard watching (especially first day)
- Detailed review of every trade
- Daily performance reports
- Daily team check-ins
- Enhanced logging
- Incident tracking

Key Metrics to Monitor:
- Trade count per day
- Fill rates
- Slippage
- P&L vs. expectations
- Risk utilization
- Error rates
- System latency

FIRST MONTH MONITORING:
----------------------
- Daily performance tracking
- Weekly performance reviews
- Weekly team meetings
- Parameter tuning as needed
- Documentation updates

Success Criteria After 1 Month:
- Performance within 20% of expectations
- No major incidents
- Team confident in strategy
- Ready to transition to standard monitoring

================================================================================
                    7. MONITORING AND MAINTENANCE
================================================================================

7.1 REAL-TIME MONITORING
-----------------------
Continuous monitoring during trading hours:

MONITORING DASHBOARD:
--------------------
Key Panels:
1. Strategy Health
   - Status (Running / Stopped / Error)
   - Uptime
   - Last heartbeat
   - Error count

2. Performance Metrics
   - Daily P&L
   - Number of trades today
   - Win rate today
   - Current positions
   - Largest position

3. Risk Metrics
   - Total exposure
   - Leverage ratio
   - P&L vs. daily limit
   - VaR utilization
   - Risk score

4. Execution Quality
   - Recent fills
   - Average slippage
   - Fill rate
   - Order cancel rate
   - Average latency

5. Market Conditions
   - Instruments trading
   - Market volatility
   - Spread levels
   - Volume levels

6. Alerts
   - Recent alerts
   - Alert severity
   - Alert frequency

REAL-TIME ALERTS:
----------------
Configure alerts for:

Critical (Immediate Response):
- Strategy crash or error
- Risk limit breach
- Daily loss limit reached
- System connectivity loss
- Data feed failure

High (Within 5 minutes):
- Approaching risk limits (>90%)
- Unusual P&L movement
- Fill rate degradation
- Slippage spike
- Latency spike

Medium (Within 15 minutes):
- Performance deviation
- Position concentration
- Low liquidity conditions
- Parameter adjustment needed

Low (Daily Review):
- Daily performance summary
- Trading statistics
- Maintenance reminders

ALERT DELIVERY:
--------------
- Critical: SMS + Phone call + Dashboard
- High: SMS + Email + Dashboard
- Medium: Email + Dashboard
- Low: Email + Dashboard

ON-CALL ROTATION:
----------------
Primary: Trader who owns strategy
Secondary: Senior trader
Tertiary: Strategy development team
Escalation: Head of Trading / CRO

7.2 PERFORMANCE METRICS
-----------------------
Track comprehensive performance metrics:

DAILY METRICS:
-------------
- Total P&L
- Number of trades
- Win rate
- Average win / Average loss
- Largest win / Largest loss
- Sharpe ratio (rolling)
- Maximum intraday drawdown
- Total commissions paid
- Total slippage cost
- Risk-adjusted return

WEEKLY METRICS:
--------------
- Weekly P&L
- Cumulative P&L
- Weekly Sharpe ratio
- Win rate trend
- Average trade duration
- Position turnover
- Capacity utilization
- Strategy correlation (vs. other strategies)

MONTHLY METRICS:
---------------
- Monthly P&L
- Sharpe ratio
- Sortino ratio
- Maximum drawdown
- Recovery time
- Information ratio
- Calmar ratio
- Trade frequency
- Capital efficiency

EXECUTION METRICS:
-----------------
- Fill rate
- Average fill time
- Slippage (bps)
- Market impact
- Price improvement rate
- Order cancellation rate
- Order rejection rate
- Adverse selection cost

RISK METRICS:
------------
- VaR (95%, 99%)
- Expected Shortfall
- Maximum position size
- Average position size
- Leverage utilization
- Concentration risk
- Tail risk exposure

OPERATIONAL METRICS:
-------------------
- Uptime percentage
- Error count
- Alert count
- Average latency
- Market data delays
- Order routing latency
- System resource usage

GENERATE REPORTS:
----------------
# Daily report
./scripts/generate_report.sh \
    --strategy mean_reversion \
    --period daily \
    --date 2025-11-25

# Weekly report
./scripts/generate_report.sh \
    --strategy mean_reversion \
    --period weekly \
    --week 47

# Monthly report
./scripts/generate_report.sh \
    --strategy mean_reversion \
    --period monthly \
    --month 2025-11

7.3 STRATEGY TUNING
------------------
Periodic optimization of strategy parameters:

WHEN TO TUNE:
-------------
- After first month of live trading
- Quarterly reviews
- After significant market regime change
- When performance degrades
- When new data/research suggests improvements

TUNING PROCESS:
--------------
1. Analyze Current Performance
   - Gather recent performance data
   - Identify areas for improvement
   - Understand current market conditions

2. Identify Parameters to Tune
   - Focus on high-sensitivity parameters
   - Consider recent market changes
   - Review parameter stability

3. Backtest Parameter Changes
   - Use recent data (last 3-6 months)
   - Test parameter variations
   - Validate improvements

4. Paper Trade New Parameters
   - Deploy with new parameters in paper mode
   - Compare to live strategy
   - Validate improvements persist

5. Gradual Rollout
   - Stage deployment of new parameters
   - Monitor closely
   - Roll back if issues

6. Document Changes
   - Record parameter changes
   - Document rationale
   - Update configuration

PARAMETER CHANGE APPROVAL:
-------------------------
Minor changes (<10% parameter adjustment):
- Trader approval sufficient
- Document and monitor

Major changes (>10% or structural):
- Risk manager approval required
- Re-testing required
- Formal change management process

AVOID OVER-OPTIMIZATION:
-----------------------
Warning signs:
- Frequent parameter changes (>monthly)
- Large parameter swings
- Parameters at boundary values
- Increasing complexity
- Declining performance despite tuning

Best Practices:
- Tune conservatively
- Focus on robust parameters
- Maintain parameter stability
- Prefer simple adjustments
- Document all changes
- Monitor post-change performance

7.4 DEBUGGING PROCEDURES
-----------------------
Systematic approach to troubleshooting:

COMMON ISSUES AND SOLUTIONS:
---------------------------

Issue: No Signals Generated
Symptoms: Strategy running but no trades
Diagnostics:
[ ] Check market data feed connectivity
[ ] Verify instruments are trading
[ ] Review signal generation logic
[ ] Check if parameters too restrictive
[ ] Verify time-of-day filters
Solution:
- Fix data connectivity if needed
- Adjust parameters if too conservative
- Review and update signal logic

Issue: Poor Fill Rate
Symptoms: Many orders unfilled or cancelled
Diagnostics:
[ ] Check order prices vs. market
[ ] Review order type (limit vs. market)
[ ] Analyze time-in-force settings
[ ] Check for fast-moving markets
[ ] Review exchange connectivity
Solution:
- Adjust limit prices (more aggressive)
- Consider market orders or IOC
- Improve order timing
- Check for latency issues

Issue: Excessive Slippage
Symptoms: Fill prices much worse than expected
Diagnostics:
[ ] Analyze market conditions (volatility, liquidity)
[ ] Review order sizes vs. market depth
[ ] Check order timing
[ ] Analyze latency issues
[ ] Review exchange selection
Solution:
- Reduce order sizes
- Improve timing (avoid momentum)
- Consider different order types
- Optimize routing

Issue: Performance Degradation
Symptoms: Strategy profitable but declining
Diagnostics:
[ ] Compare recent vs. historical performance
[ ] Analyze market regime changes
[ ] Check for increased competition
[ ] Review parameter stability
[ ] Analyze trade characteristics
Solution:
- Adapt to market conditions
- Tune parameters
- Consider strategy enhancement
- May need to retire strategy

Issue: Risk Limit Breaches
Symptoms: Frequently hitting risk limits
Diagnostics:
[ ] Review position sizing logic
[ ] Analyze volatility changes
[ ] Check for correlated positions
[ ] Review limit appropriateness
Solution:
- Adjust position sizing
- Update limits if market conditions changed
- Improve risk calculations
- Consider volatility-adjusted sizing

DEBUG LOGGING:
-------------
Enable detailed logging when debugging:

# Enable debug logging
./scripts/set_log_level.sh \
    --strategy mean_reversion \
    --level debug

# Tail logs in real-time
tail -f logs/mean_reversion_$(date +%Y%m%d).log

# Search logs for errors
grep -i error logs/mean_reversion_*.log

# Analyze specific time window
./scripts/analyze_logs.sh \
    --strategy mean_reversion \
    --start "2025-11-25 10:00:00" \
    --end "2025-11-25 10:30:00"

PERFORMANCE PROFILING:
---------------------
If latency is suspected:

# Enable profiling
./scripts/enable_profiling.sh --strategy mean_reversion

# Run for brief period (impacts performance)
# ... let it run ...

# Analyze profile
./scripts/analyze_profile.sh \
    --strategy mean_reversion \
    --report profile_report.html

REPRODUCE ISSUES:
----------------
Use replay capability:

# Replay market data from specific date/time
./scripts/replay.sh \
    --strategy mean_reversion \
    --date 2025-11-25 \
    --start-time "10:00:00" \
    --duration 3600 \
    --mode debug

This replays historical market data through the strategy
to reproduce and debug issues.

================================================================================
                          8. TROUBLESHOOTING
================================================================================

8.1 COMMON ISSUES
----------------

ISSUE CATEGORY: Connectivity
---------------------------
Problem: Market data feed disconnected
Symptoms: No data updates, stale prices
Impact: Cannot trade safely
Resolution:
1. Check network connectivity
2. Restart market data service
3. Verify exchange status
4. Switch to backup feed if primary down
5. If cannot resolve: Stop strategy

Problem: Order routing failure
Symptoms: Orders not reaching exchange
Impact: Cannot execute trades
Resolution:
1. Check order routing service status
2. Verify exchange connectivity
3. Check for exchange issues
4. Try alternate routing path
5. If cannot resolve: Stop strategy and notify

ISSUE CATEGORY: Performance
---------------------------
Problem: High latency
Symptoms: Delays in data processing or order submission
Impact: Increased slippage, missed opportunities
Resolution:
1. Check system resource usage (CPU, memory, network)
2. Review logs for bottlenecks
3. Profile code if needed
4. Scale resources if insufficient
5. Optimize code if systematic issue

Problem: Memory leak
Symptoms: Increasing memory usage over time
Impact: Eventually system crash
Resolution:
1. Monitor memory usage
2. Use memory profiler to identify leak
3. Fix leak in code
4. Deploy fix
5. Restart strategy with fixed version

ISSUE CATEGORY: Logic
---------------------
Problem: Unexpected signals
Symptoms: Signals don't match expectations
Impact: Poor performance, potential losses
Resolution:
1. Review recent market data
2. Check parameter values
3. Trace signal generation logic
4. Verify indicator calculations
5. Update logic or parameters as needed

Problem: Position reconciliation mismatch
Symptoms: Position in system != position at exchange
Impact: Risk miscalculation, potential large loss
Resolution:
1. STOP STRATEGY IMMEDIATELY
2. Manually reconcile positions
3. Identify cause of mismatch
4. Fix underlying issue
5. Verify reconciliation correct
6. Only restart after confirmed accurate

ISSUE CATEGORY: Risk
--------------------
Problem: Unexpected loss spike
Symptoms: Large loss in short time
Impact: Risk limit breach, potential further losses
Resolution:
1. Assess current situation
2. Stop strategy if limit breached
3. Close positions if appropriate
4. Investigate root cause
5. Determine if strategy error or market event
6. Document incident
7. Implement safeguards against recurrence

Problem: Correlation risk materialized
Symptoms: Multiple positions moving against you simultaneously
Impact: Larger than expected loss
Resolution:
1. Reduce positions across correlated instruments
2. Review correlation assumptions
3. Adjust position sizing to account for correlation
4. Update risk model
5. Consider position limits per sector/theme

8.2 DIAGNOSTIC PROCEDURES
-------------------------

SYSTEMATIC DIAGNOSTIC APPROACH:
------------------------------

STEP 1: GATHER INFORMATION
--------------------------
[ ] What is the symptom/problem?
[ ] When did it start?
[ ] What changed recently?
[ ] Is it consistent or intermittent?
[ ] What is the impact?
[ ] Are other strategies affected?

STEP 2: CHECK BASICS
--------------------
[ ] Is strategy running?
[ ] Are services healthy?
[ ] Is market data flowing?
[ ] Can orders be submitted?
[ ] Are positions accurate?
[ ] Are risk limits correct?

STEP 3: REVIEW LOGS
-------------------
[ ] Check error logs
[ ] Check warning logs
[ ] Review recent decisions
[ ] Check performance logs
[ ] Review system logs

STEP 4: ANALYZE DATA
--------------------
[ ] Review recent trades
[ ] Analyze P&L
[ ] Check positions
[ ] Review orders (filled, cancelled, rejected)
[ ] Analyze market conditions

STEP 5: FORM HYPOTHESIS
-----------------------
Based on information gathered, what is likely cause?
- System issue (connectivity, performance, bug)
- Logic issue (parameter problem, logic error)
- Market condition issue (regime change, unusual event)
- External issue (exchange problem, data issue)

STEP 6: TEST HYPOTHESIS
-----------------------
[ ] Does evidence support hypothesis?
[ ] Can you reproduce the issue?
[ ] Does fix address the issue?
[ ] Are there side effects?

STEP 7: IMPLEMENT SOLUTION
--------------------------
[ ] Apply fix
[ ] Test thoroughly
[ ] Deploy carefully
[ ] Monitor closely

STEP 8: DOCUMENT
----------------
[ ] Record problem and solution
[ ] Update runbook
[ ] Share learnings with team
[ ] Implement preventive measures

DIAGNOSTIC COMMANDS:
-------------------
# Check strategy status
./scripts/status.sh --strategy mean_reversion

# View recent performance
./scripts/performance.sh \
    --strategy mean_reversion \
    --period 1h

# Check current positions
./scripts/positions.sh --strategy mean_reversion

# Review recent orders
./scripts/orders.sh \
    --strategy mean_reversion \
    --count 100

# Analyze logs
./scripts/log_analyzer.sh \
    --strategy mean_reversion \
    --severity error \
    --period 1h

# Check system health
./scripts/health_check.sh --all

8.3 RESOLUTION WORKFLOWS
-----------------------

WORKFLOW: Production Issue
--------------------------
1. DETECT
   - Alert triggers or manual detection
   - Assess severity

2. TRIAGE
   - Critical: Immediate action required
   - High: Action within 5 minutes
   - Medium: Action within 15 minutes
   - Low: Can wait for scheduled maintenance

3. STABILIZE
   - Stop trading if necessary
   - Prevent further losses
   - Secure systems

4. INVESTIGATE
   - Gather information
   - Diagnose root cause
   - Determine fix

5. RESOLVE
   - Implement fix
   - Test fix
   - Deploy fix

6. VERIFY
   - Confirm issue resolved
   - Monitor for recurrence
   - Check for side effects

7. RESUME
   - Restart strategy (if stopped)
   - Return to normal operations
   - Continue enhanced monitoring

8. POST-MORTEM
   - Document incident
   - Analyze root cause
   - Identify preventive measures
   - Update procedures
   - Share learnings

ESCALATION PATHS:
----------------

LEVEL 1: Trader / Strategy Owner
- Initial response
- Basic troubleshooting
- Minor issues resolution

LEVEL 2: Senior Trader / Technical Lead
- Complex issues
- Requires deeper expertise
- Architecture decisions

LEVEL 3: Platform Team / Risk Management
- Platform-wide issues
- Risk limit changes
- System modifications

LEVEL 4: Management
- Major incidents
- Policy decisions
- External communication

ESCALATE IF:
- Cannot resolve within expected timeframe
- Issue impacts other strategies or traders
- Potential for significant loss
- Requires expertise beyond your level
- Requires authority beyond your level

INCIDENT DOCUMENTATION:
----------------------
For every significant incident, complete:

INCIDENT REPORT TEMPLATE:
------------------------
Incident ID: [YYYYMMDD-NNN]
Date/Time: [Timestamp]
Strategy: [Strategy name]
Severity: [Critical / High / Medium / Low]
Reporter: [Name]

SUMMARY:
[Brief description of incident]

TIMELINE:
[Chronological sequence of events]

IMPACT:
- Financial impact: [$XXX loss/gain]
- Trading interruption: [XX minutes]
- Other impacts: [Description]

ROOT CAUSE:
[Technical explanation of what went wrong]

RESOLUTION:
[What was done to fix the issue]

PREVENTIVE MEASURES:
[What will be done to prevent recurrence]

LESSONS LEARNED:
[Key takeaways]

FOLLOW-UP ACTIONS:
[ ] Action item 1 - Owner: [Name] - Due: [Date]
[ ] Action item 2 - Owner: [Name] - Due: [Date]

================================================================================
                          9. ADVANCED TOPICS
================================================================================

9.1 MULTI-STRATEGY COORDINATION
-------------------------------
Coordinate multiple strategies effectively:

COORDINATION SCENARIOS:
----------------------

Scenario 1: Shared Risk Budget
Multiple strategies share same risk limits
Solution: Centralized risk management service
- Tracks aggregate exposure
- Allocates capacity dynamically
- Enforces global limits

Scenario 2: Position Conflicts
Two strategies want to trade same instrument opposite directions
Solution: Position conflict resolution
- Higher priority strategy wins
- Or: Net positions and trade remainder
- Or: Coordinate timing to avoid conflict

Scenario 3: Market Impact
Multiple strategies trading same instrument
Solution: Order coordination
- Aggregate orders when possible
- Sequence orders to minimize impact
- Use shared execution algorithms

IMPLEMENTATION:
--------------
class StrategyCoordinator {
public:
    // Register strategy
    void RegisterStrategy(Strategy* strategy, int priority);

    // Check if trade allowed (considers all strategies)
    bool ApproveTradeall(const Order& order, StrategyID strategy_id);

    // Coordinate orders across strategies
    std::vector<Order> CoordinateOrders(
        const std::vector<Order>& orders);

    // Allocate risk capacity
    RiskCapacity AllocateCapacity(StrategyID strategy_id);

private:
    std::map<StrategyID, Strategy*> strategies_;
    std::map<StrategyID, int> priorities_;
    RiskManager* risk_manager_;
};

9.2 DYNAMIC PARAMETER ADJUSTMENT
--------------------------------
Automatically adjust parameters based on conditions:

ADAPTIVE PARAMETERS:
-------------------
Parameters that adjust based on:
- Market volatility
- Liquidity conditions
- Time of day
- Recent performance
- Market regime

Example: Volatility-Adjusted Position Sizing
-------------------------------------------
double calculateAdaptivePositionSize(
    const Signal& signal,
    const MarketConditions& conditions) {

    // Base size from signal
    double base_size = signal.strength * config_.base_position_size;

    // Adjust for volatility
    double vol_adjustment = target_volatility_ / conditions.current_volatility;
    vol_adjustment = std::clamp(vol_adjustment, 0.5, 2.0);  // Limit adjustment

    // Adjust for liquidity
    double liquidity_factor = std::min(1.0,
        conditions.avg_volume / config_.min_volume);

    // Adjust for time of day
    double time_factor = getTimeOfDayFactor(conditions.time);

    // Adjust for recent performance
    double performance_factor = getPerformanceFactor();

    // Combine adjustments
    double adjusted_size = base_size
        * vol_adjustment
        * liquidity_factor
        * time_factor
        * performance_factor;

    return std::round(adjusted_size);
}

REGIME DETECTION:
----------------
Detect market regime changes:

enum class MarketRegime {
    TRENDING_UP,
    TRENDING_DOWN,
    RANGE_BOUND,
    HIGH_VOLATILITY,
    LOW_VOLATILITY,
    UNCERTAIN
};

MarketRegime detectRegime(const MarketData& data) {
    // Calculate regime indicators
    double trend_strength = calculateTrendStrength(data);
    double volatility = calculateVolatility(data);
    double range_ratio = calculateRangeRatio(data);

    // Classify regime
    if (volatility > high_vol_threshold_) {
        return MarketRegime::HIGH_VOLATILITY;
    } else if (volatility < low_vol_threshold_) {
        return MarketRegime::LOW_VOLATILITY;
    } else if (trend_strength > trend_threshold_) {
        if (data.price_change > 0) {
            return MarketRegime::TRENDING_UP;
        } else {
            return MarketRegime::TRENDING_DOWN;
        }
    } else if (range_ratio < range_threshold_) {
        return MarketRegime::RANGE_BOUND;
    }

    return MarketRegime::UNCERTAIN;
}

REGIME-BASED STRATEGY ADJUSTMENT:
---------------------------------
void adjustForRegime(MarketRegime regime) {
    switch (regime) {
        case MarketRegime::TRENDING_UP:
        case MarketRegime::TRENDING_DOWN:
            // Reduce mean reversion trading in trends
            config_.entry_threshold *= 1.5;
            config_.position_size *= 0.7;
            break;

        case MarketRegime::RANGE_BOUND:
            // Optimal for mean reversion
            config_.entry_threshold = config_.default_entry_threshold;
            config_.position_size = config_.default_position_size;
            break;

        case MarketRegime::HIGH_VOLATILITY:
            // Reduce size in high vol
            config_.position_size *= 0.5;
            config_.stop_loss *= 1.5;  // Wider stops
            break;

        case MarketRegime::LOW_VOLATILITY:
            // Can use tighter stops in low vol
            config_.stop_loss *= 0.8;
            break;

        case MarketRegime::UNCERTAIN:
            // Conservative approach
            config_.position_size *= 0.8;
            break;
    }

    LogInfo("Adjusted parameters for regime: " + toString(regime));
}

9.3 MACHINE LEARNING INTEGRATION
--------------------------------
Integrate ML models into strategy:

ML MODEL TYPES:
--------------
1. Signal Enhancement
   - Improve signal quality
   - Filter false signals
   - Adjust signal strength

2. Parameter Optimization
   - Continuously optimize parameters
   - Adapt to changing conditions
   - Learn from outcomes

3. Market Prediction
   - Predict short-term price movements
   - Forecast volatility
   - Estimate liquidity

4. Execution Optimization
   - Optimal order sizing
   - Timing optimization
   - Routing optimization

INTEGRATION PATTERN:
-------------------
class MLEnhancedStrategy : public BaseStrategy {
public:
    MLEnhancedStrategy(const Config& config);

    void OnMarketData(const MarketData& data) override {
        // Traditional signal
        Signal base_signal = signal_generator_.Generate(data);

        if (base_signal.type != Signal::Type::NONE) {
            // Enhance with ML
            auto features = extractFeatures(data, base_signal);
            double ml_score = ml_model_->Predict(features);

            // Combine traditional and ML signals
            Signal enhanced_signal = combineSignals(base_signal, ml_score);

            if (shouldTrade(enhanced_signal)) {
                auto order = createOrder(enhanced_signal);
                if (PreTradeCheck(order)) {
                    submitOrder(order);
                }
            }
        }
    }

private:
    std::unique_ptr<MLModel> ml_model_;
    SignalGenerator signal_generator_;
};

FEATURE EXTRACTION:
------------------
Features extractFeatures(const MarketData& data, const Signal& signal) {
    Features features;

    // Price-based features
    features.push_back(data.close / data.open - 1.0);  // Intraday return
    features.push_back(data.high / data.low - 1.0);    // Intraday range
    features.push_back(calculateRSI(data));
    features.push_back(calculateMACD(data));

    // Volume-based features
    features.push_back(data.volume / data.avg_volume);
    features.push_back(data.buy_volume / data.sell_volume);

    // Order book features
    features.push_back(data.bid_ask_spread);
    features.push_back(data.order_book_imbalance);
    features.push_back(data.order_book_depth);

    // Signal features
    features.push_back(signal.strength);
    features.push_back(static_cast<double>(signal.confidence));

    // Time-based features
    features.push_back(getTimeOfDayFeature(data.timestamp));
    features.push_back(getDayOfWeekFeature(data.timestamp));

    // Historical features
    features.push_back(calculate Returns(data, 5));    // 5-period return
    features.push_back(calculateVolatility(data, 20)); // 20-period vol

    return features;
}

ML MODEL DEPLOYMENT:
-------------------
# Train model offline
python3 ml/train_model.py \
    --data historical_data/ \
    --config ml_config.yaml \
    --output models/signal_enhancer_v1.model

# Validate model
python3 ml/validate_model.py \
    --model models/signal_enhancer_v1.model \
    --test-data test_data/ \
    --report validation_report.pdf

# Export for production
python3 ml/export_model.py \
    --model models/signal_enhancer_v1.model \
    --format cpp \
    --output src/models/signal_enhancer_v1.h

# Integrate into strategy
# (Include generated header and use in code)

ML MODEL MONITORING:
-------------------
- Track model prediction accuracy
- Monitor for model degradation
- A/B test model versions
- Retrain periodically
- Version control models

Warning Signs:
- Decreasing accuracy over time
- Predictions consistently wrong in certain conditions
- Model confidence vs. actual outcomes diverging

Model Refresh Cadence:
- Retrain monthly or quarterly
- Validate on recent data
- A/B test new version vs. current
- Gradual rollout of new model

================================================================================
                            10. APPENDICES
================================================================================

APPENDIX A: CODE TEMPLATES
--------------------------

See repository:
- templates/strategy_template.h
- templates/strategy_template.cpp
- templates/config_template.yaml
- templates/test_template.cpp

APPENDIX B: CONFIGURATION EXAMPLES
----------------------------------

See repository:
- examples/market_making_config.yaml
- examples/arbitrage_config.yaml
- examples/mean_reversion_config.yaml
- examples/momentum_config.yaml

APPENDIX C: CHECKLIST SUMMARY
-----------------------------

PRE-IMPLEMENTATION:
[ ] Strategy specification complete
[ ] Backtesting done
[ ] Risk assessment approved
[ ] All approvals obtained

IMPLEMENTATION:
[ ] Code complete and reviewed
[ ] Unit tests passing
[ ] Integration tests passing
[ ] Documentation complete

TESTING:
[ ] Paper trading successful
[ ] Simulation testing complete
[ ] Performance validated
[ ] Ready for deployment

DEPLOYMENT:
[ ] Pre-deployment checklist complete
[ ] Deployment plan approved
[ ] Team briefed
[ ] Monitoring configured

POST-DEPLOYMENT:
[ ] Performing as expected
[ ] No major issues
[ ] Team comfortable
[ ] Standard monitoring established

================================================================================
                              END OF GUIDE
================================================================================

For questions or support:
- Strategy Development: strategydev@hft.trading.system
- Technical Support: itops@hft.trading.system
- Documentation: documentation@hft.trading.system

Version: 1.0
Last Updated: 2025-11-25
