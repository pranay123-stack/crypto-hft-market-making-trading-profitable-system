================================================================================
HFT SYSTEM API DOCUMENTATION
================================================================================

VERSION: 1.0
LAST UPDATED: 2025-11-25
OWNER: Platform Engineering Team
CLASSIFICATION: Internal Use Only

================================================================================
TABLE OF CONTENTS
================================================================================

1. API OVERVIEW
2. REST API DOCUMENTATION
3. WEBSOCKET API DOCUMENTATION
4. INTERNAL C++ API DOCUMENTATION
5. EXCHANGE-SPECIFIC API DETAILS
6. AUTHENTICATION & AUTHORIZATION
7. RATE LIMITING
8. ERROR HANDLING
9. DATA MODELS
10. CODE EXAMPLES
11. API TESTING
12. TROUBLESHOOTING

================================================================================
1. API OVERVIEW
================================================================================

1.1 API TYPES
-------------

The HFT system provides three types of APIs:

A) REST API (Management & Control)
   - Purpose: System control, configuration, queries
   - Protocol: HTTP/HTTPS
   - Format: JSON
   - Port: 8080 (HTTP), 8443 (HTTPS)
   - Authentication: API key + HMAC signature

B) WebSocket API (Real-time Data)
   - Purpose: Market data streaming, order updates
   - Protocol: WebSocket (ws/wss)
   - Format: JSON
   - Port: 8081 (WS), 8444 (WSS)
   - Authentication: Token-based

C) Internal C++ API (Component Integration)
   - Purpose: Internal component communication
   - Language: C++20
   - Format: Native objects
   - Interface: Abstract base classes

1.2 API DESIGN PRINCIPLES
--------------------------

- RESTful: REST API follows RESTful principles
- Versioned: All APIs versioned (v1, v2, etc.)
- Idempotent: Safe to retry most operations
- Asynchronous: Non-blocking where possible
- Observable: Comprehensive logging and metrics
- Secure: HTTPS/WSS in production, authentication required

================================================================================
2. REST API DOCUMENTATION
================================================================================

2.1 BASE URL
------------

Development:  http://localhost:8080/api/v1
Production:   https://hft-prod-01.company.com:8443/api/v1

2.2 AUTHENTICATION
------------------

All REST API requests require authentication via API key and signature.

Headers:
  X-API-KEY: <your-api-key>
  X-TIMESTAMP: <unix-timestamp-milliseconds>
  X-SIGNATURE: <hmac-sha256-signature>

Signature Calculation:
  message = timestamp + method + path + body
  signature = HMAC-SHA256(message, api_secret)

Example (Python):
  import hmac
  import hashlib
  import time

  timestamp = str(int(time.time() * 1000))
  message = timestamp + "GET" + "/api/v1/positions" + ""
  signature = hmac.new(
      api_secret.encode(),
      message.encode(),
      hashlib.sha256
  ).hexdigest()

2.3 SYSTEM ENDPOINTS
--------------------

GET /health
Description: Health check endpoint
Response:
{
  "status": "healthy",
  "timestamp": "2025-11-25T10:30:45.123Z",
  "uptime_seconds": 86400,
  "version": "1.0.0"
}

GET /status
Description: Detailed system status
Response:
{
  "status": "running",
  "node_id": "hft-prod-01",
  "role": "primary",
  "trading_enabled": true,
  "exchanges": {
    "binance": {"status": "connected", "latency_ms": 12.5},
    "coinbase": {"status": "connected", "latency_ms": 18.3},
    "kraken": {"status": "connected", "latency_ms": 22.1}
  },
  "strategies": {
    "market_maker_btc": {"status": "running", "pnl_usd": 1234.56},
    "arbitrage_eth": {"status": "running", "pnl_usd": 567.89}
  },
  "risk": {
    "daily_pnl_usd": 1802.45,
    "daily_loss_limit_usd": 10000.00,
    "total_exposure_usd": 50000.00,
    "position_limit_usd": 100000.00
  }
}

POST /shutdown
Description: Graceful system shutdown
Request:
{
  "cancel_orders": true,
  "reason": "planned maintenance"
}
Response:
{
  "status": "shutting_down",
  "message": "System will shutdown in 10 seconds"
}

POST /killswitch
Description: Emergency stop all trading
Request:
{
  "reason": "market anomaly detected"
}
Response:
{
  "status": "killed",
  "orders_cancelled": 42,
  "message": "All trading stopped immediately"
}

2.4 TRADING ENDPOINTS
---------------------

GET /positions
Description: Get current positions
Query Parameters:
  - exchange: Filter by exchange (optional)
  - symbol: Filter by symbol (optional)
Response:
{
  "positions": [
    {
      "symbol": "BTC-USDT",
      "exchange": "binance",
      "side": "long",
      "quantity": 0.5,
      "avg_entry_price": 50000.00,
      "current_price": 50500.00,
      "unrealized_pnl_usd": 250.00,
      "realized_pnl_usd": 0.00,
      "last_updated": "2025-11-25T10:30:45.123Z"
    }
  ],
  "total_unrealized_pnl_usd": 250.00,
  "total_realized_pnl_usd": 1802.45
}

GET /orders
Description: Get order history
Query Parameters:
  - exchange: Filter by exchange (optional)
  - symbol: Filter by symbol (optional)
  - status: Filter by status (open, filled, cancelled)
  - limit: Number of results (default 100, max 1000)
  - offset: Pagination offset
Response:
{
  "orders": [
    {
      "order_id": "abc123",
      "exchange_order_id": "12345678",
      "exchange": "binance",
      "symbol": "BTC-USDT",
      "side": "buy",
      "type": "limit",
      "quantity": 0.1,
      "price": 50000.00,
      "filled_quantity": 0.1,
      "average_fill_price": 50000.00,
      "status": "filled",
      "created_at": "2025-11-25T10:30:00.000Z",
      "updated_at": "2025-11-25T10:30:05.123Z",
      "fills": [
        {
          "fill_id": "fill_001",
          "quantity": 0.1,
          "price": 50000.00,
          "fee": 5.00,
          "fee_currency": "USDT",
          "timestamp": "2025-11-25T10:30:05.000Z"
        }
      ]
    }
  ],
  "total": 1,
  "limit": 100,
  "offset": 0
}

POST /orders
Description: Submit new order
Request:
{
  "exchange": "binance",
  "symbol": "BTC-USDT",
  "side": "buy",
  "type": "limit",
  "quantity": 0.1,
  "price": 50000.00,
  "time_in_force": "GTC",
  "client_order_id": "my_order_001"
}
Response:
{
  "order_id": "abc123",
  "status": "pending",
  "message": "Order submitted successfully",
  "timestamp": "2025-11-25T10:30:45.123Z"
}

DELETE /orders/{order_id}
Description: Cancel order
Response:
{
  "order_id": "abc123",
  "status": "cancelled",
  "message": "Order cancelled successfully",
  "timestamp": "2025-11-25T10:30:45.123Z"
}

2.5 STRATEGY ENDPOINTS
----------------------

GET /strategies
Description: List all strategies
Response:
{
  "strategies": [
    {
      "strategy_id": "market_maker_btc",
      "name": "BTC Market Maker",
      "type": "market_making",
      "status": "running",
      "enabled": true,
      "symbols": ["BTC-USDT", "BTC-USDC"],
      "exchanges": ["binance", "coinbase"],
      "config": {
        "spread_bps": 5,
        "order_size": 0.1,
        "max_position": 2.0
      },
      "performance": {
        "total_pnl_usd": 5432.10,
        "daily_pnl_usd": 123.45,
        "sharpe_ratio": 2.3,
        "win_rate": 0.62,
        "total_trades": 1234
      }
    }
  ]
}

POST /strategies/{strategy_id}/start
Description: Start strategy
Response:
{
  "strategy_id": "market_maker_btc",
  "status": "running",
  "message": "Strategy started successfully"
}

POST /strategies/{strategy_id}/stop
Description: Stop strategy
Request:
{
  "cancel_orders": true
}
Response:
{
  "strategy_id": "market_maker_btc",
  "status": "stopped",
  "orders_cancelled": 10,
  "message": "Strategy stopped successfully"
}

PUT /strategies/{strategy_id}/config
Description: Update strategy configuration
Request:
{
  "config": {
    "spread_bps": 10,
    "order_size": 0.2
  }
}
Response:
{
  "strategy_id": "market_maker_btc",
  "status": "updated",
  "message": "Configuration updated successfully"
}

2.6 MARKET DATA ENDPOINTS
--------------------------

GET /marketdata/ticker/{exchange}/{symbol}
Description: Get current ticker
Response:
{
  "exchange": "binance",
  "symbol": "BTC-USDT",
  "last_price": 50500.00,
  "bid": 50499.00,
  "ask": 50501.00,
  "volume_24h": 12345.67,
  "high_24h": 51000.00,
  "low_24h": 49500.00,
  "timestamp": "2025-11-25T10:30:45.123Z"
}

GET /marketdata/orderbook/{exchange}/{symbol}
Description: Get current order book
Query Parameters:
  - depth: Number of levels (default 20, max 100)
Response:
{
  "exchange": "binance",
  "symbol": "BTC-USDT",
  "bids": [
    {"price": 50499.00, "quantity": 1.5},
    {"price": 50498.00, "quantity": 2.3}
  ],
  "asks": [
    {"price": 50501.00, "quantity": 1.2},
    {"price": 50502.00, "quantity": 3.1}
  ],
  "timestamp": "2025-11-25T10:30:45.123Z"
}

GET /marketdata/trades/{exchange}/{symbol}
Description: Get recent trades
Query Parameters:
  - limit: Number of trades (default 100, max 1000)
Response:
{
  "exchange": "binance",
  "symbol": "BTC-USDT",
  "trades": [
    {
      "trade_id": "123456",
      "price": 50500.00,
      "quantity": 0.5,
      "side": "buy",
      "timestamp": "2025-11-25T10:30:45.123Z"
    }
  ]
}

2.7 RISK ENDPOINTS
------------------

GET /risk/summary
Description: Get risk summary
Response:
{
  "daily_pnl_usd": 1802.45,
  "daily_loss_limit_usd": 10000.00,
  "limit_utilization_pct": 18.02,
  "total_exposure_usd": 50000.00,
  "position_limit_usd": 100000.00,
  "var_95_usd": 2500.00,
  "positions_count": 12,
  "orders_count": 8,
  "circuit_breaker_active": false
}

GET /risk/violations
Description: Get recent risk violations
Query Parameters:
  - limit: Number of results (default 100)
Response:
{
  "violations": [
    {
      "violation_id": "viol_001",
      "type": "position_limit",
      "severity": "warning",
      "symbol": "BTC-USDT",
      "message": "Position approaching limit (85%)",
      "timestamp": "2025-11-25T10:15:00.000Z",
      "resolved": true
    }
  ]
}

POST /risk/limits
Description: Update risk limits
Request:
{
  "daily_loss_limit_usd": 15000.00,
  "position_limit_usd": 150000.00,
  "max_order_size_usd": 10000.00
}
Response:
{
  "status": "updated",
  "message": "Risk limits updated successfully"
}

2.8 CONFIGURATION ENDPOINTS
----------------------------

GET /config
Description: Get system configuration
Response:
{
  "trading_enabled": true,
  "exchanges": {
    "binance": {
      "enabled": true,
      "market_data": true,
      "trading": true,
      "rate_limit_orders_per_second": 50
    }
  },
  "logging": {
    "level": "INFO",
    "console": true,
    "file": true
  },
  "performance": {
    "market_data_threads": 10,
    "order_threads": 4,
    "queue_size": 100000
  }
}

PUT /config
Description: Update system configuration
Request:
{
  "logging": {
    "level": "DEBUG"
  }
}
Response:
{
  "status": "updated",
  "message": "Configuration updated successfully",
  "requires_restart": false
}

GET /config/reload
Description: Reload configuration from disk
Response:
{
  "status": "reloaded",
  "message": "Configuration reloaded successfully"
}

================================================================================
3. WEBSOCKET API DOCUMENTATION
================================================================================

3.1 CONNECTION
--------------

URL: ws://localhost:8081/ws (dev) or wss://hft-prod-01.company.com:8444/ws

Authentication:
  1. Connect to WebSocket endpoint
  2. Send authentication message within 5 seconds
  3. Receive authentication response
  4. Start receiving data

Authentication Message:
{
  "type": "auth",
  "api_key": "your-api-key",
  "timestamp": 1700000000000,
  "signature": "hmac-sha256-signature"
}

Authentication Response:
{
  "type": "auth_response",
  "status": "success",
  "session_id": "session_abc123",
  "message": "Authentication successful"
}

3.2 SUBSCRIPTION MANAGEMENT
----------------------------

Subscribe to Market Data:
{
  "type": "subscribe",
  "channel": "market_data",
  "exchange": "binance",
  "symbols": ["BTC-USDT", "ETH-USDT"],
  "data_types": ["ticker", "orderbook", "trades"]
}

Subscribe Response:
{
  "type": "subscribe_response",
  "channel": "market_data",
  "status": "success",
  "subscriptions": ["binance:BTC-USDT:ticker", "binance:BTC-USDT:orderbook"]
}

Unsubscribe:
{
  "type": "unsubscribe",
  "channel": "market_data",
  "exchange": "binance",
  "symbols": ["BTC-USDT"]
}

3.3 MARKET DATA MESSAGES
------------------------

Ticker Update:
{
  "type": "ticker",
  "exchange": "binance",
  "symbol": "BTC-USDT",
  "last_price": 50500.00,
  "bid": 50499.00,
  "ask": 50501.00,
  "volume_24h": 12345.67,
  "timestamp": 1700000000000,
  "latency_us": 123
}

Order Book Update:
{
  "type": "orderbook",
  "exchange": "binance",
  "symbol": "BTC-USDT",
  "bids": [
    [50499.00, 1.5],
    [50498.00, 2.3]
  ],
  "asks": [
    [50501.00, 1.2],
    [50502.00, 3.1]
  ],
  "timestamp": 1700000000000,
  "latency_us": 156
}

Trade Update:
{
  "type": "trade",
  "exchange": "binance",
  "symbol": "BTC-USDT",
  "trade_id": "123456",
  "price": 50500.00,
  "quantity": 0.5,
  "side": "buy",
  "timestamp": 1700000000000,
  "latency_us": 89
}

3.4 ORDER UPDATE MESSAGES
--------------------------

Order Status Update:
{
  "type": "order_update",
  "order_id": "abc123",
  "exchange_order_id": "12345678",
  "exchange": "binance",
  "symbol": "BTC-USDT",
  "status": "filled",
  "filled_quantity": 0.1,
  "average_fill_price": 50000.00,
  "timestamp": 1700000000000
}

Fill Update:
{
  "type": "fill",
  "order_id": "abc123",
  "fill_id": "fill_001",
  "exchange": "binance",
  "symbol": "BTC-USDT",
  "side": "buy",
  "quantity": 0.1,
  "price": 50000.00,
  "fee": 5.00,
  "fee_currency": "USDT",
  "timestamp": 1700000000000
}

3.5 SYSTEM MESSAGES
-------------------

Heartbeat:
{
  "type": "heartbeat",
  "timestamp": 1700000000000
}

Error Message:
{
  "type": "error",
  "code": "RATE_LIMIT_EXCEEDED",
  "message": "Too many requests, please slow down",
  "timestamp": 1700000000000
}

System Status:
{
  "type": "system_status",
  "status": "running",
  "trading_enabled": true,
  "timestamp": 1700000000000
}

3.6 WEBSOCKET BEST PRACTICES
-----------------------------

1. Heartbeat: Send ping every 30 seconds, expect pong response
2. Reconnection: Implement exponential backoff (1s, 2s, 4s, 8s, max 60s)
3. Message Queue: Buffer messages during disconnection
4. Error Handling: Parse all error messages, log appropriately
5. Subscription Recovery: Re-subscribe after reconnection
6. Rate Limiting: Max 10 subscription requests per second

================================================================================
4. INTERNAL C++ API DOCUMENTATION
================================================================================

4.1 ORDER MANAGER API
---------------------

Class: OrderManager
Header: include/order_manager.h

// Submit new order
OrderResult submitOrder(const OrderRequest& request);

// Cancel existing order
CancelResult cancelOrder(const std::string& order_id);

// Modify existing order
ModifyResult modifyOrder(const std::string& order_id,
                         const OrderModification& modification);

// Get order by ID
std::optional<Order> getOrder(const std::string& order_id);

// Get all orders for symbol
std::vector<Order> getOrders(const std::string& symbol,
                              OrderStatus status = OrderStatus::ALL);

Example Usage:
```cpp
OrderManager order_manager;

// Create order request
OrderRequest request;
request.exchange = "binance";
request.symbol = "BTC-USDT";
request.side = OrderSide::BUY;
request.type = OrderType::LIMIT;
request.quantity = 0.1;
request.price = 50000.0;
request.time_in_force = TimeInForce::GTC;

// Submit order
auto result = order_manager.submitOrder(request);
if (result.success) {
    std::cout << "Order submitted: " << result.order_id << std::endl;
} else {
    std::cerr << "Order failed: " << result.error_message << std::endl;
}
```

4.2 MARKET DATA HANDLER API
----------------------------

Class: MarketDataHandler
Header: include/market_data_handler.h

// Subscribe to market data
void subscribe(const std::string& exchange,
               const std::string& symbol,
               MarketDataType type);

// Unsubscribe from market data
void unsubscribe(const std::string& exchange,
                 const std::string& symbol,
                 MarketDataType type);

// Register callback for market data updates
void registerCallback(MarketDataCallback callback);

// Get latest ticker
std::optional<Ticker> getTicker(const std::string& exchange,
                                const std::string& symbol);

// Get order book snapshot
std::optional<OrderBook> getOrderBook(const std::string& exchange,
                                      const std::string& symbol);

Example Usage:
```cpp
MarketDataHandler md_handler;

// Subscribe to BTC-USDT on Binance
md_handler.subscribe("binance", "BTC-USDT", MarketDataType::TICKER);
md_handler.subscribe("binance", "BTC-USDT", MarketDataType::ORDER_BOOK);

// Register callback
md_handler.registerCallback([](const MarketDataUpdate& update) {
    if (update.type == MarketDataType::TICKER) {
        std::cout << "Ticker: " << update.ticker.last_price << std::endl;
    }
});
```

4.3 RISK MANAGER API
--------------------

Class: RiskManager
Header: include/risk_manager.h

// Check if order passes pre-trade risk checks
RiskCheckResult checkOrder(const OrderRequest& request);

// Update position after fill
void updatePosition(const Fill& fill);

// Get current position for symbol
std::optional<Position> getPosition(const std::string& symbol);

// Get total exposure across all positions
double getTotalExposure();

// Enable/disable trading (kill switch)
void setTradingEnabled(bool enabled);

// Set risk limits
void setRiskLimits(const RiskLimits& limits);

Example Usage:
```cpp
RiskManager risk_manager;

// Set risk limits
RiskLimits limits;
limits.daily_loss_limit_usd = 10000.0;
limits.position_limit_usd = 100000.0;
limits.max_order_size_usd = 10000.0;
risk_manager.setRiskLimits(limits);

// Check order before submission
auto risk_result = risk_manager.checkOrder(order_request);
if (risk_result.passed) {
    // Submit order
} else {
    std::cerr << "Risk check failed: " << risk_result.reason << std::endl;
}
```

4.4 POSITION MANAGER API
-------------------------

Class: PositionManager
Header: include/position_manager.h

// Get position for symbol
Position getPosition(const std::string& symbol,
                     const std::string& exchange = "");

// Get all positions
std::vector<Position> getAllPositions();

// Calculate P&L for position
double calculatePnL(const Position& position, double current_price);

// Get unrealized P&L
double getUnrealizedPnL();

// Get realized P&L
double getRealizedPnL();

Example Usage:
```cpp
PositionManager position_manager;

// Get BTC position
auto btc_position = position_manager.getPosition("BTC-USDT");
std::cout << "BTC Position: " << btc_position.quantity << std::endl;
std::cout << "Avg Entry: " << btc_position.avg_entry_price << std::endl;

// Calculate P&L
double current_price = 50500.0;
double pnl = position_manager.calculatePnL(btc_position, current_price);
std::cout << "Unrealized P&L: $" << pnl << std::endl;
```

4.5 STRATEGY INTERFACE
----------------------

Class: Strategy (Abstract Base Class)
Header: include/strategy.h

class Strategy {
public:
    virtual ~Strategy() = default;

    // Initialize strategy
    virtual void initialize() = 0;

    // Start strategy execution
    virtual void start() = 0;

    // Stop strategy execution
    virtual void stop() = 0;

    // On market data update
    virtual void onMarketData(const MarketDataUpdate& update) = 0;

    // On order update
    virtual void onOrderUpdate(const OrderUpdate& update) = 0;

    // On timer event
    virtual void onTimer(uint64_t timer_id) = 0;

    // Get strategy status
    virtual StrategyStatus getStatus() const = 0;

    // Get strategy performance
    virtual StrategyPerformance getPerformance() const = 0;
};

Example Implementation:
```cpp
class SimpleMarketMaker : public Strategy {
private:
    OrderManager& order_manager_;
    RiskManager& risk_manager_;
    double spread_bps_;

public:
    void onMarketData(const MarketDataUpdate& update) override {
        if (update.type == MarketDataType::ORDER_BOOK) {
            // Get best bid/ask
            double best_bid = update.order_book.bids[0].price;
            double best_ask = update.order_book.asks[0].price;

            // Calculate our quotes
            double our_bid = best_bid + (best_bid * spread_bps_ / 10000.0);
            double our_ask = best_ask - (best_ask * spread_bps_ / 10000.0);

            // Submit orders
            submitQuotes(our_bid, our_ask);
        }
    }
};
```

================================================================================
5. EXCHANGE-SPECIFIC API DETAILS
================================================================================

5.1 BINANCE API
---------------

WebSocket Endpoints:
- Market Data: wss://stream.binance.com:9443/ws
- User Data: wss://stream.binance.com:9443/ws/<listenKey>

REST Endpoints:
- Base URL: https://api.binance.com
- Order Submission: POST /api/v3/order
- Order Cancellation: DELETE /api/v3/order
- Account Info: GET /api/v3/account

Rate Limits:
- Orders: 50 per second per account
- Market Data: 1200 requests per minute
- WebSocket: 5 connections per IP

Authentication:
- Method: HMAC-SHA256
- Header: X-MBX-APIKEY
- Query Param: signature

5.2 COINBASE API
----------------

WebSocket Endpoints:
- Market Data: wss://ws-feed.pro.coinbase.com

REST Endpoints:
- Base URL: https://api.pro.coinbase.com
- Order Submission: POST /orders
- Order Cancellation: DELETE /orders/<order-id>
- Account Info: GET /accounts

Rate Limits:
- Public: 10 requests per second
- Private: 15 requests per second

Authentication:
- Method: HMAC-SHA256
- Headers: CB-ACCESS-KEY, CB-ACCESS-SIGN, CB-ACCESS-TIMESTAMP, CB-ACCESS-PASSPHRASE

5.3 KRAKEN API
--------------

WebSocket Endpoints:
- Market Data: wss://ws.kraken.com
- Private: wss://ws-auth.kraken.com

REST Endpoints:
- Base URL: https://api.kraken.com
- Order Submission: POST /0/private/AddOrder
- Order Cancellation: POST /0/private/CancelOrder
- Account Info: POST /0/private/Balance

Rate Limits:
- Public: 1 per second
- Private: Counter-based system (starts at 15, decreases by request cost)

Authentication:
- Method: HMAC-SHA512
- Header: API-Key, API-Sign

[Similar sections for OKX, Bybit, Huobi, KuCoin, Bitfinex, Deribit...]

================================================================================
6. AUTHENTICATION & AUTHORIZATION
================================================================================

6.1 API KEY MANAGEMENT
----------------------

Generation:
1. Navigate to /admin/api-keys
2. Click "Generate New API Key"
3. Set permissions (read, trade, admin)
4. Save API key and secret (shown once)

Storage:
- API keys encrypted in database (AES-256)
- Secrets never stored in plaintext
- Hashed for comparison

Permissions:
- READ: Query positions, orders, market data
- TRADE: Submit/cancel orders
- ADMIN: System configuration, risk limits

6.2 SIGNATURE VERIFICATION
---------------------------

Server-side verification process:
1. Receive request with headers
2. Extract timestamp, verify not too old (< 5 seconds)
3. Reconstruct message: timestamp + method + path + body
4. Calculate expected signature using stored secret
5. Compare signatures (constant-time comparison)
6. Allow or reject request

Prevention:
- Replay attacks: Timestamp validation
- Man-in-the-middle: HTTPS/WSS required
- Brute force: Rate limiting

================================================================================
7. RATE LIMITING
================================================================================

7.1 SYSTEM RATE LIMITS
----------------------

REST API:
- Per API Key: 100 requests per second
- Per IP: 200 requests per second
- Burst: 150% of limit for 5 seconds

WebSocket:
- Subscriptions: 10 per second
- Messages: 50 per second
- Connections: 5 per IP

Response Headers:
- X-RateLimit-Limit: 100
- X-RateLimit-Remaining: 95
- X-RateLimit-Reset: 1700000000 (Unix timestamp)

7.2 EXCHANGE RATE LIMITS
-------------------------

The system enforces exchange-specific rate limits:

Binance:
- Order limit: 50/second
- Request limit: 1200/minute
- Weight-based system

Coinbase:
- Public: 10/second
- Private: 15/second

Implementation:
```cpp
class RateLimiter {
    bool checkLimit(const std::string& key) {
        auto now = std::chrono::steady_clock::now();
        auto& bucket = buckets_[key];

        // Token bucket algorithm
        auto elapsed = now - bucket.last_refill;
        bucket.tokens += elapsed.count() * refill_rate_;
        bucket.tokens = std::min(bucket.tokens, max_tokens_);
        bucket.last_refill = now;

        if (bucket.tokens >= 1.0) {
            bucket.tokens -= 1.0;
            return true;  // Request allowed
        }
        return false;  // Rate limit exceeded
    }
};
```

================================================================================
8. ERROR HANDLING
================================================================================

8.1 ERROR RESPONSE FORMAT
--------------------------

{
  "error": {
    "code": "ORDER_REJECTED",
    "message": "Insufficient balance",
    "details": {
      "symbol": "BTC-USDT",
      "required_balance": 5000.00,
      "available_balance": 4500.00
    },
    "timestamp": "2025-11-25T10:30:45.123Z",
    "request_id": "req_abc123"
  }
}

8.2 ERROR CODES
---------------

System Errors (1xxx):
- 1000: INTERNAL_SERVER_ERROR
- 1001: SERVICE_UNAVAILABLE
- 1002: TIMEOUT
- 1003: CONFIGURATION_ERROR

Authentication Errors (2xxx):
- 2000: UNAUTHORIZED
- 2001: INVALID_API_KEY
- 2002: INVALID_SIGNATURE
- 2003: EXPIRED_TIMESTAMP
- 2004: PERMISSION_DENIED

Request Errors (3xxx):
- 3000: BAD_REQUEST
- 3001: INVALID_PARAMETER
- 3002: MISSING_PARAMETER
- 3003: RATE_LIMIT_EXCEEDED

Trading Errors (4xxx):
- 4000: ORDER_REJECTED
- 4001: INSUFFICIENT_BALANCE
- 4002: POSITION_LIMIT_EXCEEDED
- 4003: RISK_CHECK_FAILED
- 4004: SYMBOL_NOT_FOUND
- 4005: EXCHANGE_ERROR

8.3 RETRY STRATEGY
------------------

Retryable Errors:
- 1002: TIMEOUT
- 1001: SERVICE_UNAVAILABLE
- 3003: RATE_LIMIT_EXCEEDED (after backoff)

Non-Retryable Errors:
- 2xxx: Authentication errors
- 4001: INSUFFICIENT_BALANCE
- 4002: POSITION_LIMIT_EXCEEDED

Retry Logic:
```cpp
RetryResult retryWithBackoff(std::function<Result()> operation,
                            int max_retries = 3) {
    for (int attempt = 0; attempt < max_retries; ++attempt) {
        auto result = operation();

        if (result.success || !result.retryable) {
            return result;
        }

        // Exponential backoff: 100ms, 200ms, 400ms
        auto delay_ms = 100 * (1 << attempt);
        std::this_thread::sleep_for(std::chrono::milliseconds(delay_ms));
    }

    return RetryResult{false, "Max retries exceeded"};
}
```

================================================================================
9. DATA MODELS
================================================================================

9.1 ORDER MODEL
---------------

```cpp
struct Order {
    std::string order_id;              // Internal order ID
    std::string exchange_order_id;     // Exchange-specific ID
    std::string exchange;              // Exchange name
    std::string symbol;                // Trading pair
    OrderSide side;                    // BUY or SELL
    OrderType type;                    // LIMIT, MARKET, STOP_LOSS
    double quantity;                   // Order quantity
    double price;                      // Limit price (0 for market)
    double filled_quantity;            // Filled quantity
    double average_fill_price;         // Average fill price
    OrderStatus status;                // NEW, PENDING, FILLED, etc.
    TimeInForce time_in_force;         // GTC, IOC, FOK
    std::string client_order_id;       // Optional client ID
    uint64_t created_at;               // Unix timestamp (ms)
    uint64_t updated_at;               // Unix timestamp (ms)
    std::vector<Fill> fills;           // List of fills
};

enum class OrderSide { BUY, SELL };
enum class OrderType { LIMIT, MARKET, STOP_LOSS, STOP_LIMIT };
enum class OrderStatus { NEW, PENDING, ACKNOWLEDGED, PARTIALLY_FILLED, FILLED, CANCELLED, REJECTED };
enum class TimeInForce { GTC, IOC, FOK };
```

9.2 POSITION MODEL
------------------

```cpp
struct Position {
    std::string symbol;                // Trading pair
    std::string exchange;              // Exchange name
    PositionSide side;                 // LONG, SHORT, or FLAT
    double quantity;                   // Position size (abs value)
    double avg_entry_price;            // Average entry price
    double unrealized_pnl;             // Unrealized P&L (USD)
    double realized_pnl;               // Realized P&L (USD)
    uint64_t last_updated;             // Unix timestamp (ms)
};

enum class PositionSide { LONG, SHORT, FLAT };
```

9.3 MARKET DATA MODELS
----------------------

```cpp
struct Ticker {
    std::string exchange;
    std::string symbol;
    double last_price;
    double bid;
    double ask;
    double volume_24h;
    double high_24h;
    double low_24h;
    uint64_t timestamp;
};

struct OrderBook {
    std::string exchange;
    std::string symbol;
    std::vector<Level> bids;      // Sorted by price desc
    std::vector<Level> asks;      // Sorted by price asc
    uint64_t timestamp;
    uint64_t sequence_number;
};

struct Level {
    double price;
    double quantity;
};

struct Trade {
    std::string trade_id;
    std::string exchange;
    std::string symbol;
    double price;
    double quantity;
    TradeSide side;
    uint64_t timestamp;
};
```

================================================================================
10. CODE EXAMPLES
================================================================================

10.1 SUBMITTING AN ORDER (C++)
-------------------------------

```cpp
#include "trading_system.h"

int main() {
    // Initialize system
    TradingSystem system;
    system.initialize("config.json");

    // Get managers
    auto& order_mgr = system.getOrderManager();
    auto& risk_mgr = system.getRiskManager();

    // Create order request
    OrderRequest request;
    request.exchange = "binance";
    request.symbol = "BTC-USDT";
    request.side = OrderSide::BUY;
    request.type = OrderType::LIMIT;
    request.quantity = 0.1;
    request.price = 50000.0;
    request.time_in_force = TimeInForce::GTC;

    // Check risk
    auto risk_check = risk_mgr.checkOrder(request);
    if (!risk_check.passed) {
        std::cerr << "Risk check failed: " << risk_check.reason << std::endl;
        return 1;
    }

    // Submit order
    auto result = order_mgr.submitOrder(request);
    if (result.success) {
        std::cout << "Order submitted: " << result.order_id << std::endl;

        // Wait for fill
        auto order = order_mgr.waitForFill(result.order_id,
                                          std::chrono::seconds(30));
        if (order && order->status == OrderStatus::FILLED) {
            std::cout << "Order filled at " << order->average_fill_price << std::endl;
        }
    } else {
        std::cerr << "Order failed: " << result.error_message << std::endl;
    }

    return 0;
}
```

10.2 MARKET DATA SUBSCRIPTION (C++)
------------------------------------

```cpp
#include "market_data_handler.h"

class MyStrategy {
private:
    MarketDataHandler& md_handler_;

public:
    void initialize() {
        // Subscribe to BTC-USDT
        md_handler_.subscribe("binance", "BTC-USDT",
                             MarketDataType::ORDER_BOOK);

        // Register callback
        md_handler_.registerCallback([this](const MarketDataUpdate& update) {
            this->onMarketData(update);
        });
    }

    void onMarketData(const MarketDataUpdate& update) {
        if (update.type == MarketDataType::ORDER_BOOK) {
            double mid_price = (update.order_book.bids[0].price +
                               update.order_book.asks[0].price) / 2.0;

            std::cout << "Mid price: " << mid_price << std::endl;

            // Check for arbitrage opportunity
            checkArbitrage(update);
        }
    }
};
```

10.3 REST API CLIENT (Python)
------------------------------

```python
import requests
import hmac
import hashlib
import time

class HFTClient:
    def __init__(self, api_key, api_secret, base_url):
        self.api_key = api_key
        self.api_secret = api_secret
        self.base_url = base_url

    def _sign_request(self, method, path, body=""):
        timestamp = str(int(time.time() * 1000))
        message = timestamp + method + path + body
        signature = hmac.new(
            self.api_secret.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        return timestamp, signature

    def get_positions(self):
        method = "GET"
        path = "/api/v1/positions"
        timestamp, signature = self._sign_request(method, path)

        headers = {
            "X-API-KEY": self.api_key,
            "X-TIMESTAMP": timestamp,
            "X-SIGNATURE": signature
        }

        response = requests.get(self.base_url + path, headers=headers)
        return response.json()

    def submit_order(self, exchange, symbol, side, quantity, price):
        method = "POST"
        path = "/api/v1/orders"
        body = {
            "exchange": exchange,
            "symbol": symbol,
            "side": side,
            "type": "limit",
            "quantity": quantity,
            "price": price
        }
        import json
        body_str = json.dumps(body)

        timestamp, signature = self._sign_request(method, path, body_str)

        headers = {
            "X-API-KEY": self.api_key,
            "X-TIMESTAMP": timestamp,
            "X-SIGNATURE": signature,
            "Content-Type": "application/json"
        }

        response = requests.post(self.base_url + path,
                                headers=headers,
                                data=body_str)
        return response.json()

# Usage
client = HFTClient("your-api-key", "your-api-secret",
                   "https://hft-prod-01.company.com:8443")
positions = client.get_positions()
print(positions)

order = client.submit_order("binance", "BTC-USDT", "buy", 0.1, 50000.0)
print(order)
```

================================================================================
11. API TESTING
================================================================================

11.1 TESTING TOOLS
------------------

Recommended Tools:
- Postman: REST API testing
- websocat: WebSocket testing
- curl: Command-line REST testing
- Python requests: Automated testing

11.2 EXAMPLE TESTS
------------------

Test 1: Health Check
```bash
curl http://localhost:8080/api/v1/health
```

Test 2: Get Positions (with authentication)
```bash
#!/bin/bash
API_KEY="your-api-key"
API_SECRET="your-api-secret"
TIMESTAMP=$(date +%s%3N)
METHOD="GET"
PATH="/api/v1/positions"
MESSAGE="${TIMESTAMP}${METHOD}${PATH}"
SIGNATURE=$(echo -n "$MESSAGE" | openssl dgst -sha256 -hmac "$API_SECRET" | cut -d' ' -f2)

curl -H "X-API-KEY: $API_KEY" \
     -H "X-TIMESTAMP: $TIMESTAMP" \
     -H "X-SIGNATURE: $SIGNATURE" \
     http://localhost:8080/api/v1/positions
```

Test 3: WebSocket Connection
```bash
websocat ws://localhost:8081/ws
# Then send authentication message
{"type":"auth","api_key":"your-key","timestamp":1700000000000,"signature":"sig"}
```

================================================================================
12. TROUBLESHOOTING
================================================================================

12.1 COMMON ISSUES
------------------

Issue: "Invalid signature" error
Solution:
- Verify API secret is correct
- Ensure message construction matches exactly: timestamp + method + path + body
- Check timestamp is in milliseconds
- Verify no extra whitespace in body

Issue: "Rate limit exceeded" error
Solution:
- Check X-RateLimit-Remaining header
- Wait for X-RateLimit-Reset time
- Implement exponential backoff
- Consider requesting rate limit increase

Issue: WebSocket disconnects frequently
Solution:
- Implement ping/pong heartbeat (every 30 seconds)
- Check network stability
- Verify firewall not timing out connections
- Implement automatic reconnection logic

12.2 DEBUGGING TIPS
-------------------

1. Enable DEBUG logging to see detailed request/response
2. Use network monitoring tools (Wireshark, tcpdump)
3. Check system metrics (CPU, memory, network)
4. Verify exchange connectivity separately
5. Test with minimal example first, then add complexity

12.3 SUPPORT CONTACTS
---------------------

API Issues: api-support@company.com
Technical Support: tech-support@company.com
Emergency: oncall@company.com (+1-555-0100)

================================================================================
END OF DOCUMENT
================================================================================
