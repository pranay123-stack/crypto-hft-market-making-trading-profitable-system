ANOMALY DETECTION FOR HFT SYSTEMS
==================================

TABLE OF CONTENTS
-----------------
1. Overview & Anomaly Detection Strategy
2. Statistical Anomaly Detection
3. Machine Learning Based Detection
4. Time-Series Anomaly Detection
5. Latency Spike Detection
6. Volume Anomaly Detection
7. Pattern Recognition
8. Real-Time Anomaly Alerts
9. False Positive Reduction
10. Production Implementation
11. Automated Response Actions

============================================
1. OVERVIEW & ANOMALY DETECTION STRATEGY
============================================

Anomaly Detection Architecture:
--------------------------------
┌────────────────────────────────────────────────────────────┐
│                    Data Collection Layer                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │   Metrics    │  │     Logs     │  │    Traces    │    │
│  │  (Latency,   │  │   (Errors,   │  │  (Request    │    │
│  │  Throughput) │  │   Events)    │  │   Flows)     │    │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘    │
└─────────┼──────────────────┼──────────────────┼────────────┘
          │                  │                  │
          └──────────────────┼──────────────────┘
                             │
                    ┌────────▼────────┐
                    │  Feature        │
                    │  Extraction     │
                    └────────┬────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
   ┌────▼─────┐      ┌──────▼──────┐     ┌──────▼──────┐
   │Statistical│      │  Machine    │     │  Pattern    │
   │  Methods  │      │  Learning   │     │  Matching   │
   │  (Z-score,│      │  (Isolation │     │  (Regex,    │
   │   IQR)    │      │   Forest)   │     │   Rules)    │
   └────┬─────┘      └──────┬──────┘     └──────┬──────┘
        │                   │                    │
        └───────────────────┼────────────────────┘
                            │
                     ┌──────▼──────┐
                     │  Anomaly    │
                     │  Classifier │
                     └──────┬──────┘
                            │
                     ┌──────▼──────┐
                     │   Alert &   │
                     │   Response  │
                     └─────────────┘

Types of Anomalies in HFT:
---------------------------
1. POINT ANOMALIES
   - Single outlier data points
   - Example: Sudden latency spike

2. CONTEXTUAL ANOMALIES
   - Normal in one context, abnormal in another
   - Example: High latency during market open vs close

3. COLLECTIVE ANOMALIES
   - Group of points forming anomalous pattern
   - Example: Gradual performance degradation

4. BEHAVIORAL ANOMALIES
   - Deviation from expected behavior
   - Example: Fill rate drop, rejection rate increase

Detection Approaches:
---------------------
1. Statistical: Z-score, IQR, moving average
2. Machine Learning: Isolation Forest, Autoencoders
3. Time-Series: ARIMA, Prophet, STL decomposition
4. Threshold-based: Static and dynamic thresholds
5. Pattern-based: Regular expressions, state machines

============================================
2. STATISTICAL ANOMALY DETECTION
============================================

Z-Score Based Detector:
------------------------
#include <vector>
#include <cmath>
#include <deque>
#include <algorithm>

class ZScoreAnomalyDetector {
private:
    std::deque<double> window_;
    size_t window_size_;
    double threshold_;  // Number of standard deviations

public:
    ZScoreAnomalyDetector(size_t window_size = 100, double threshold = 3.0)
        : window_size_(window_size), threshold_(threshold) {}

    struct Detection {
        bool is_anomaly;
        double value;
        double zscore;
        double mean;
        double stddev;
    };

    Detection detect(double value) {
        // Add to window
        window_.push_back(value);
        if (window_.size() > window_size_) {
            window_.pop_front();
        }

        // Need sufficient data points
        if (window_.size() < 30) {
            return {false, value, 0.0, value, 0.0};
        }

        // Calculate mean
        double sum = 0.0;
        for (double v : window_) {
            sum += v;
        }
        double mean = sum / window_.size();

        // Calculate standard deviation
        double variance = 0.0;
        for (double v : window_) {
            variance += (v - mean) * (v - mean);
        }
        double stddev = std::sqrt(variance / window_.size());

        // Calculate z-score
        double zscore = stddev > 0 ? std::abs((value - mean) / stddev) : 0.0;

        // Detect anomaly
        bool is_anomaly = zscore > threshold_;

        return {is_anomaly, value, zscore, mean, stddev};
    }

    void reset() {
        window_.clear();
    }
};

Interquartile Range (IQR) Detector:
------------------------------------
class IQRAnomalyDetector {
private:
    std::deque<double> window_;
    size_t window_size_;
    double iqr_multiplier_;  // Typically 1.5 or 3.0

public:
    IQRAnomalyDetector(size_t window_size = 100, double iqr_multiplier = 1.5)
        : window_size_(window_size), iqr_multiplier_(iqr_multiplier) {}

    struct Detection {
        bool is_anomaly;
        double value;
        double q1;
        double q3;
        double iqr;
        double lower_bound;
        double upper_bound;
    };

    Detection detect(double value) {
        window_.push_back(value);
        if (window_.size() > window_size_) {
            window_.pop_front();
        }

        if (window_.size() < 30) {
            return {false, value, 0, 0, 0, 0, 0};
        }

        // Sort for percentile calculation
        std::vector<double> sorted(window_.begin(), window_.end());
        std::sort(sorted.begin(), sorted.end());

        // Calculate Q1 (25th percentile) and Q3 (75th percentile)
        size_t q1_idx = sorted.size() / 4;
        size_t q3_idx = (sorted.size() * 3) / 4;

        double q1 = sorted[q1_idx];
        double q3 = sorted[q3_idx];
        double iqr = q3 - q1;

        // Calculate bounds
        double lower_bound = q1 - (iqr_multiplier_ * iqr);
        double upper_bound = q3 + (iqr_multiplier_ * iqr);

        // Detect anomaly
        bool is_anomaly = value < lower_bound || value > upper_bound;

        return {is_anomaly, value, q1, q3, iqr, lower_bound, upper_bound};
    }
};

Moving Average Detector:
-------------------------
class MovingAverageAnomalyDetector {
private:
    std::deque<double> window_;
    size_t window_size_;
    double deviation_threshold_;  // Percentage deviation from MA

public:
    MovingAverageAnomalyDetector(size_t window_size = 50,
                                 double deviation_threshold = 20.0)
        : window_size_(window_size),
          deviation_threshold_(deviation_threshold) {}

    struct Detection {
        bool is_anomaly;
        double value;
        double moving_average;
        double deviation_percentage;
    };

    Detection detect(double value) {
        window_.push_back(value);
        if (window_.size() > window_size_) {
            window_.pop_front();
        }

        if (window_.size() < 10) {
            return {false, value, value, 0.0};
        }

        // Calculate moving average
        double sum = 0.0;
        for (double v : window_) {
            sum += v;
        }
        double ma = sum / window_.size();

        // Calculate deviation percentage
        double deviation = ma > 0 ?
            std::abs((value - ma) / ma) * 100.0 : 0.0;

        // Detect anomaly
        bool is_anomaly = deviation > deviation_threshold_;

        return {is_anomaly, value, ma, deviation};
    }
};

Exponential Weighted Moving Average (EWMA):
--------------------------------------------
class EWMAAnomalyDetector {
private:
    double alpha_;  // Smoothing factor (0-1)
    double ewma_;
    double ewma_variance_;
    bool initialized_;
    double threshold_;  // Number of standard deviations

public:
    EWMAAnomalyDetector(double alpha = 0.1, double threshold = 3.0)
        : alpha_(alpha),
          ewma_(0.0),
          ewma_variance_(0.0),
          initialized_(false),
          threshold_(threshold) {}

    struct Detection {
        bool is_anomaly;
        double value;
        double ewma;
        double ewma_stddev;
        double zscore;
    };

    Detection detect(double value) {
        if (!initialized_) {
            ewma_ = value;
            ewma_variance_ = 0.0;
            initialized_ = true;
            return {false, value, ewma_, 0.0, 0.0};
        }

        // Update EWMA
        double previous_ewma = ewma_;
        ewma_ = alpha_ * value + (1.0 - alpha_) * ewma_;

        // Update EWMA variance
        double diff = value - previous_ewma;
        ewma_variance_ = (1.0 - alpha_) * (ewma_variance_ + alpha_ * diff * diff);

        // Calculate standard deviation
        double ewma_stddev = std::sqrt(ewma_variance_);

        // Calculate z-score
        double zscore = ewma_stddev > 0 ?
            std::abs((value - ewma_) / ewma_stddev) : 0.0;

        // Detect anomaly
        bool is_anomaly = zscore > threshold_;

        return {is_anomaly, value, ewma_, ewma_stddev, zscore};
    }

    void reset() {
        initialized_ = false;
        ewma_ = 0.0;
        ewma_variance_ = 0.0;
    }
};

============================================
3. TIME-SERIES ANOMALY DETECTION
============================================

Seasonal Decomposition Detector:
---------------------------------
class SeasonalAnomalyDetector {
private:
    size_t seasonal_period_;  // e.g., 288 for 5-min buckets in a day
    std::vector<double> seasonal_component_;
    std::vector<double> trend_component_;
    std::deque<double> residuals_;

    double residual_threshold_;

public:
    SeasonalAnomalyDetector(size_t seasonal_period,
                           double residual_threshold = 3.0)
        : seasonal_period_(seasonal_period),
          residual_threshold_(residual_threshold) {

        seasonal_component_.resize(seasonal_period, 0.0);
        trend_component_.resize(seasonal_period, 0.0);
    }

    struct Detection {
        bool is_anomaly;
        double value;
        double seasonal;
        double trend;
        double residual;
        double residual_zscore;
    };

    Detection detect(double value, size_t time_index) {
        size_t seasonal_idx = time_index % seasonal_period_;

        // Simple seasonal decomposition
        // (In production, use STL decomposition or similar)

        // Get seasonal component
        double seasonal = seasonal_component_[seasonal_idx];

        // Get trend component
        double trend = trend_component_[seasonal_idx];

        // Calculate residual
        double residual = value - (seasonal + trend);

        // Update seasonal component (exponential smoothing)
        double alpha_seasonal = 0.01;
        seasonal_component_[seasonal_idx] =
            alpha_seasonal * (value - trend) +
            (1.0 - alpha_seasonal) * seasonal_component_[seasonal_idx];

        // Update trend component
        double alpha_trend = 0.05;
        trend_component_[seasonal_idx] =
            alpha_trend * value +
            (1.0 - alpha_trend) * trend_component_[seasonal_idx];

        // Track residuals
        residuals_.push_back(residual);
        if (residuals_.size() > 1000) {
            residuals_.pop_front();
        }

        // Calculate residual z-score
        double residual_mean = 0.0;
        double residual_variance = 0.0;

        if (residuals_.size() >= 30) {
            for (double r : residuals_) {
                residual_mean += r;
            }
            residual_mean /= residuals_.size();

            for (double r : residuals_) {
                residual_variance += (r - residual_mean) * (r - residual_mean);
            }
            residual_variance /= residuals_.size();
        }

        double residual_stddev = std::sqrt(residual_variance);
        double residual_zscore = residual_stddev > 0 ?
            std::abs((residual - residual_mean) / residual_stddev) : 0.0;

        // Detect anomaly
        bool is_anomaly = residual_zscore > residual_threshold_;

        return {is_anomaly, value, seasonal, trend, residual, residual_zscore};
    }
};

Change Point Detection:
-----------------------
class ChangePointDetector {
private:
    std::deque<double> window_;
    size_t window_size_;
    double threshold_;  // Threshold for change detection

public:
    ChangePointDetector(size_t window_size = 100, double threshold = 0.5)
        : window_size_(window_size), threshold_(threshold) {}

    struct Detection {
        bool is_change_point;
        double value;
        double cusum;
        double mean_before;
        double mean_after;
    };

    Detection detect(double value) {
        window_.push_back(value);
        if (window_.size() > window_size_) {
            window_.pop_front();
        }

        if (window_.size() < window_size_) {
            return {false, value, 0.0, 0.0, 0.0};
        }

        // Use CUSUM (Cumulative Sum) algorithm
        double overall_mean = 0.0;
        for (double v : window_) {
            overall_mean += v;
        }
        overall_mean /= window_.size();

        // Find potential change point
        double max_cusum = 0.0;
        size_t change_point_idx = 0;
        double cusum = 0.0;

        for (size_t i = 0; i < window_.size(); ++i) {
            cusum += window_[i] - overall_mean;

            if (std::abs(cusum) > max_cusum) {
                max_cusum = std::abs(cusum);
                change_point_idx = i;
            }
        }

        // Calculate means before and after change point
        double mean_before = 0.0;
        double mean_after = 0.0;

        for (size_t i = 0; i <= change_point_idx; ++i) {
            mean_before += window_[i];
        }
        mean_before /= (change_point_idx + 1);

        for (size_t i = change_point_idx + 1; i < window_.size(); ++i) {
            mean_after += window_[i];
        }
        mean_after /= (window_.size() - change_point_idx - 1);

        // Detect change point
        double change_magnitude = std::abs(mean_after - mean_before);
        double relative_change = overall_mean > 0 ?
            change_magnitude / overall_mean : 0.0;

        bool is_change_point = relative_change > threshold_;

        return {is_change_point, value, max_cusum, mean_before, mean_after};
    }
};

============================================
4. LATENCY SPIKE DETECTION
============================================

Latency Anomaly Detector:
--------------------------
class LatencyAnomalyDetector {
private:
    ZScoreAnomalyDetector zscore_detector_;
    IQRAnomalyDetector iqr_detector_;
    EWMAAnomalyDetector ewma_detector_;

    // Thresholds
    double absolute_threshold_us_;  // Hard limit
    double percentile_multiplier_;  // Multiple of p99

    std::deque<double> latencies_;
    size_t window_size_;

public:
    LatencyAnomalyDetector(double absolute_threshold_us = 100000.0,  // 100ms
                          double percentile_multiplier = 5.0,
                          size_t window_size = 1000)
        : zscore_detector_(window_size, 3.0),
          iqr_detector_(window_size, 3.0),
          ewma_detector_(0.1, 3.0),
          absolute_threshold_us_(absolute_threshold_us),
          percentile_multiplier_(percentile_multiplier),
          window_size_(window_size) {}

    struct LatencyAnomaly {
        bool is_anomaly;
        double latency_us;
        std::string reason;
        double severity;  // 0-1 scale

        // Individual detector results
        bool zscore_anomaly;
        bool iqr_anomaly;
        bool ewma_anomaly;
        bool absolute_anomaly;
        bool percentile_anomaly;
    };

    LatencyAnomaly detect(double latency_us) {
        LatencyAnomaly result;
        result.latency_us = latency_us;
        result.is_anomaly = false;
        result.severity = 0.0;

        // Track latencies for percentile calculation
        latencies_.push_back(latency_us);
        if (latencies_.size() > window_size_) {
            latencies_.pop_front();
        }

        // 1. Absolute threshold check
        result.absolute_anomaly = latency_us > absolute_threshold_us_;

        // 2. Z-score detection
        auto zscore_result = zscore_detector_.detect(latency_us);
        result.zscore_anomaly = zscore_result.is_anomaly;

        // 3. IQR detection
        auto iqr_result = iqr_detector_.detect(latency_us);
        result.iqr_anomaly = iqr_result.is_anomaly;

        // 4. EWMA detection
        auto ewma_result = ewma_detector_.detect(latency_us);
        result.ewma_anomaly = ewma_result.is_anomaly;

        // 5. Percentile-based detection
        result.percentile_anomaly = false;
        if (latencies_.size() >= 100) {
            std::vector<double> sorted(latencies_.begin(), latencies_.end());
            std::sort(sorted.begin(), sorted.end());

            size_t p99_idx = static_cast<size_t>(sorted.size() * 0.99);
            double p99 = sorted[p99_idx];

            result.percentile_anomaly = latency_us > (p99 * percentile_multiplier_);
        }

        // Aggregate detection
        int anomaly_count = 0;
        if (result.absolute_anomaly) anomaly_count++;
        if (result.zscore_anomaly) anomaly_count++;
        if (result.iqr_anomaly) anomaly_count++;
        if (result.ewma_anomaly) anomaly_count++;
        if (result.percentile_anomaly) anomaly_count++;

        // Require at least 2 detectors to agree
        result.is_anomaly = anomaly_count >= 2;

        // Calculate severity
        result.severity = std::min(1.0, anomaly_count / 5.0);

        // Generate reason
        if (result.is_anomaly) {
            std::ostringstream oss;
            oss << "Latency spike: " << latency_us << "us (";

            if (result.absolute_anomaly) oss << "absolute, ";
            if (result.zscore_anomaly) oss << "z-score, ";
            if (result.iqr_anomaly) oss << "IQR, ";
            if (result.ewma_anomaly) oss << "EWMA, ";
            if (result.percentile_anomaly) oss << "percentile, ";

            result.reason = oss.str();
            result.reason.pop_back();  // Remove trailing comma
            result.reason.pop_back();
            result.reason += ")";
        }

        return result;
    }
};

============================================
5. VOLUME ANOMALY DETECTION
============================================

Volume Anomaly Detector:
-------------------------
class VolumeAnomalyDetector {
private:
    size_t time_window_seconds_;
    std::deque<std::pair<uint64_t, double>> volume_history_;  // timestamp, volume

    ZScoreAnomalyDetector zscore_detector_;
    double drop_threshold_;  // Percentage drop to trigger alert

public:
    VolumeAnomalyDetector(size_t time_window_seconds = 3600,
                         double drop_threshold = 50.0)
        : time_window_seconds_(time_window_seconds),
          zscore_detector_(100, 3.0),
          drop_threshold_(drop_threshold) {}

    struct VolumeAnomaly {
        bool is_anomaly;
        double volume;
        std::string type;  // "spike" or "drop"
        double severity;
        double expected_volume;
        double deviation_percentage;
    };

    VolumeAnomaly detect(double volume) {
        auto now = std::chrono::system_clock::now();
        auto timestamp = std::chrono::duration_cast<std::chrono::seconds>(
            now.time_since_epoch()).count();

        // Add to history
        volume_history_.push_back({timestamp, volume});

        // Remove old entries
        while (!volume_history_.empty() &&
               volume_history_.front().first < timestamp - time_window_seconds_) {
            volume_history_.pop_front();
        }

        VolumeAnomaly result;
        result.volume = volume;
        result.is_anomaly = false;
        result.severity = 0.0;

        // Need sufficient history
        if (volume_history_.size() < 30) {
            return result;
        }

        // Calculate expected volume (moving average)
        double sum = 0.0;
        for (const auto& [ts, vol] : volume_history_) {
            sum += vol;
        }
        double expected = sum / volume_history_.size();
        result.expected_volume = expected;

        // Calculate deviation
        result.deviation_percentage = expected > 0 ?
            ((volume - expected) / expected) * 100.0 : 0.0;

        // Check for volume spike using z-score
        auto zscore_result = zscore_detector_.detect(volume);

        if (zscore_result.is_anomaly) {
            if (volume > expected) {
                result.type = "spike";
                result.is_anomaly = true;
                result.severity = std::min(1.0, zscore_result.zscore / 10.0);
            } else {
                result.type = "drop";
                double drop_percentage = ((expected - volume) / expected) * 100.0;

                if (drop_percentage > drop_threshold_) {
                    result.is_anomaly = true;
                    result.severity = std::min(1.0, drop_percentage / 100.0);
                }
            }
        }

        return result;
    }
};

============================================
6. COMPOSITE ANOMALY DETECTOR
============================================

Multi-Metric Anomaly Detector:
-------------------------------
class CompositeAnomalyDetector {
private:
    std::unique_ptr<LatencyAnomalyDetector> latency_detector_;
    std::unique_ptr<VolumeAnomalyDetector> volume_detector_;
    std::unique_ptr<ZScoreAnomalyDetector> error_rate_detector_;

    std::function<void(const std::string&, double)> alert_callback_;

public:
    CompositeAnomalyDetector() {
        latency_detector_ = std::make_unique<LatencyAnomalyDetector>(
            100000.0, 5.0, 1000);

        volume_detector_ = std::make_unique<VolumeAnomalyDetector>(
            3600, 50.0);

        error_rate_detector_ = std::make_unique<ZScoreAnomalyDetector>(
            100, 3.0);
    }

    void setAlertCallback(
        std::function<void(const std::string&, double)> callback) {
        alert_callback_ = callback;
    }

    struct SystemAnomaly {
        bool has_anomaly;
        std::vector<std::string> anomalies;
        double overall_severity;
    };

    SystemAnomaly detectSystemAnomaly(double latency_us,
                                     double volume,
                                     double error_rate) {
        SystemAnomaly result;
        result.has_anomaly = false;
        result.overall_severity = 0.0;

        // Check latency
        auto latency_anomaly = latency_detector_->detect(latency_us);
        if (latency_anomaly.is_anomaly) {
            result.has_anomaly = true;
            result.anomalies.push_back(latency_anomaly.reason);
            result.overall_severity = std::max(result.overall_severity,
                                              latency_anomaly.severity);
        }

        // Check volume
        auto volume_anomaly = volume_detector_->detect(volume);
        if (volume_anomaly.is_anomaly) {
            result.has_anomaly = true;

            std::ostringstream oss;
            oss << "Volume " << volume_anomaly.type << ": "
                << volume << " (expected: " << volume_anomaly.expected_volume
                << ", deviation: " << volume_anomaly.deviation_percentage << "%)";

            result.anomalies.push_back(oss.str());
            result.overall_severity = std::max(result.overall_severity,
                                              volume_anomaly.severity);
        }

        // Check error rate
        auto error_anomaly = error_rate_detector_->detect(error_rate);
        if (error_anomaly.is_anomaly) {
            result.has_anomaly = true;

            std::ostringstream oss;
            oss << "Error rate spike: " << error_rate
                << "% (z-score: " << error_anomaly.zscore << ")";

            result.anomalies.push_back(oss.str());

            double error_severity = std::min(1.0, error_anomaly.zscore / 10.0);
            result.overall_severity = std::max(result.overall_severity,
                                              error_severity);
        }

        // Send alert if anomaly detected
        if (result.has_anomaly && alert_callback_) {
            for (const auto& anomaly : result.anomalies) {
                alert_callback_(anomaly, result.overall_severity);
            }
        }

        return result;
    }
};

Usage in Trading Engine:
-------------------------
class TradingEngineWithAnomalyDetection {
private:
    CompositeAnomalyDetector anomaly_detector_;

    std::atomic<uint64_t> total_orders_{0};
    std::atomic<uint64_t> failed_orders_{0};

public:
    TradingEngineWithAnomalyDetection() {
        anomaly_detector_.setAlertCallback(
            [](const std::string& message, double severity) {
                std::cerr << "ANOMALY DETECTED [severity: " << severity
                         << "]: " << message << "\n";

                // Send to monitoring system
                sendAlert("Anomaly", message, severity);
            }
        );

        // Start monitoring thread
        std::thread([this]() {
            while (true) {
                std::this_thread::sleep_for(std::chrono::seconds(60));
                checkAnomalies();
            }
        }).detach();
    }

    void processOrder(const Order& order) {
        auto start = std::chrono::high_resolution_clock::now();

        bool success = executeOrder(order);

        auto end = std::chrono::high_resolution_clock::now();
        auto latency_us = std::chrono::duration_cast<std::chrono::microseconds>(
            end - start).count();

        total_orders_.fetch_add(1, std::memory_order_relaxed);
        if (!success) {
            failed_orders_.fetch_add(1, std::memory_order_relaxed);
        }

        // Check for latency anomalies in real-time
        auto latency_anomaly = checkLatencyAnomaly(latency_us);
        if (latency_anomaly.is_anomaly) {
            handleLatencyAnomaly(latency_anomaly);
        }
    }

private:
    void checkAnomalies() {
        // Calculate current metrics
        uint64_t total = total_orders_.load(std::memory_order_acquire);
        uint64_t failed = failed_orders_.load(std::memory_order_acquire);

        double error_rate = total > 0 ?
            (static_cast<double>(failed) / total) * 100.0 : 0.0;

        double orders_per_minute = getOrdersPerMinute();
        double avg_latency = getAverageLatency();

        // Detect system anomalies
        auto anomaly = anomaly_detector_.detectSystemAnomaly(
            avg_latency,
            orders_per_minute,
            error_rate
        );

        if (anomaly.has_anomaly && anomaly.overall_severity > 0.7) {
            // High severity - take action
            handleCriticalAnomaly(anomaly);
        }
    }

    void handleLatencyAnomaly(const LatencyAnomalyDetector::LatencyAnomaly& anomaly) {
        // Log anomaly
        logAnomaly("latency", anomaly.reason, anomaly.severity);

        // If severe, trigger investigation
        if (anomaly.severity > 0.8) {
            // Collect diagnostics
            collectDiagnostics();
        }
    }

    void handleCriticalAnomaly(const CompositeAnomalyDetector::SystemAnomaly& anomaly) {
        // Take protective actions
        // e.g., reduce order rate, pause trading, etc.
    }

    bool executeOrder(const Order& order) { return true; }
    double getOrdersPerMinute() { return 1000.0; }
    double getAverageLatency() { return 5000.0; }
    void sendAlert(const std::string& type, const std::string& msg, double severity) {}
    void logAnomaly(const std::string& type, const std::string& msg, double severity) {}
    void collectDiagnostics() {}

    LatencyAnomalyDetector::LatencyAnomaly checkLatencyAnomaly(double latency_us) {
        static LatencyAnomalyDetector detector;
        return detector.detect(latency_us);
    }
};

Production Configuration:
--------------------------
# anomaly_detection_config.yaml
anomaly_detection:
  latency:
    enabled: true
    absolute_threshold_us: 100000  # 100ms
    percentile_multiplier: 5.0
    window_size: 1000

  volume:
    enabled: true
    time_window_seconds: 3600
    drop_threshold_percentage: 50.0

  error_rate:
    enabled: true
    zscore_threshold: 3.0
    window_size: 100

  alerts:
    severity_threshold: 0.7  # Only alert on high-severity anomalies
    cooldown_seconds: 300    # Don't re-alert within 5 minutes

echo "Anomaly detection configured"
