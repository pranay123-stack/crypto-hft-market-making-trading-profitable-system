================================================================================
                         REPLAY SCENARIOS
                   Testing Different Market Conditions
================================================================================

PURPOSE: Define and execute different replay scenarios to validate strategy
robustness under various market conditions.

================================================================================
                         TABLE OF CONTENTS
================================================================================

1. Scenario Types Overview
2. Normal Market Scenarios
3. Stress Scenarios
4. Crash/Recovery Scenarios
5. Multi-Exchange Scenarios
6. Custom Scenario Creation
7. Scenario Library Management

================================================================================
                     1. SCENARIO TYPES OVERVIEW
================================================================================

SCENARIO CLASSIFICATION:
------------------------

┌─────────────────────────────────────────────────────────────────────────────┐
│                      REPLAY SCENARIO MATRIX                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Market        │ Normal    │ Volatile  │ Stress    │ Crisis               │
│  Condition     │           │           │           │                       │
│  ─────────────────────────────────────────────────────────────────────────│
│  Volatility    │ 10-20%    │ 30-50%    │ 50-100%   │ >100%                │
│  Spread        │ Tight     │ Widening  │ Wide      │ Very Wide            │
│  Liquidity     │ Normal    │ Reduced   │ Low       │ Dried Up             │
│  Latency       │ Normal    │ Elevated  │ Spikes    │ Timeouts             │
│                │           │           │           │                       │
│  TESTING:      │ Daily     │ Weekly    │ Monthly   │ Quarterly            │
│  PRIORITY:     │ High      │ High      │ Critical  │ Critical             │
└─────────────────────────────────────────────────────────────────────────────┘

SCENARIO CONFIGURATION:
-----------------------

```cpp
struct ReplayScenario {
    std::string name;
    std::string description;
    ScenarioType type;

    // Time range
    Timestamp start_time;
    Timestamp end_time;

    // Market conditions
    double expected_volatility;
    double expected_spread_bps;
    double expected_volume_ratio;  // vs normal

    // System conditions
    double latency_multiplier;
    double packet_loss_rate;
    bool simulate_disconnects;

    // Validation criteria
    double max_drawdown_pct;
    double min_sharpe;
    int max_rejected_orders;
};

enum class ScenarioType {
    NORMAL,
    VOLATILE,
    STRESS,
    CRASH,
    RECOVERY,
    MULTI_EXCHANGE,
    CUSTOM
};
```

================================================================================
                     2. NORMAL MARKET SCENARIOS
================================================================================

SCENARIO: TYPICAL_TRADING_DAY
-----------------------------

Description: Standard trading day with normal market conditions
Frequency: Run daily
Duration: Full trading session

```cpp
ReplayScenario create_typical_day_scenario(const Date& date) {
    return ReplayScenario{
        .name = "TYPICAL_DAY_" + date.to_string(),
        .description = "Normal market conditions, standard volatility",
        .type = ScenarioType::NORMAL,

        .start_time = date.at("09:30:00"),
        .end_time = date.at("16:00:00"),

        .expected_volatility = 0.15,        // 15% annualized
        .expected_spread_bps = 1.0,
        .expected_volume_ratio = 1.0,

        .latency_multiplier = 1.0,
        .packet_loss_rate = 0.0001,         // 0.01%
        .simulate_disconnects = false,

        .max_drawdown_pct = 0.05,           // 5%
        .min_sharpe = 1.5,
        .max_rejected_orders = 10
    };
}
```

SCENARIO: LOW_VOLATILITY
------------------------

Description: Quiet market with tight spreads
Purpose: Verify strategy doesn't overtrade in low-vol environment

```cpp
ReplayScenario create_low_vol_scenario() {
    return ReplayScenario{
        .name = "LOW_VOLATILITY",
        .description = "Low volatility, tight spreads, low volume",
        .type = ScenarioType::NORMAL,

        .expected_volatility = 0.08,        // 8% annualized
        .expected_spread_bps = 0.5,
        .expected_volume_ratio = 0.6,

        .latency_multiplier = 1.0,
        .packet_loss_rate = 0.0001,
        .simulate_disconnects = false,

        // Adjusted expectations for low vol
        .max_drawdown_pct = 0.02,
        .min_sharpe = 1.0,                  // Lower expectation
        .max_rejected_orders = 5
    };
}
```

SCENARIO: HIGH_VOLUME
---------------------

Description: High volume day (earnings, macro events)
Purpose: Verify system handles high message rates

```cpp
ReplayScenario create_high_volume_scenario() {
    return ReplayScenario{
        .name = "HIGH_VOLUME",
        .description = "2-3x normal volume, elevated volatility",
        .type = ScenarioType::NORMAL,

        .expected_volatility = 0.25,
        .expected_spread_bps = 1.5,
        .expected_volume_ratio = 2.5,

        .latency_multiplier = 1.2,          // Slight latency increase
        .packet_loss_rate = 0.001,
        .simulate_disconnects = false,

        .max_drawdown_pct = 0.08,
        .min_sharpe = 1.2,
        .max_rejected_orders = 20
    };
}
```

================================================================================
                     3. STRESS SCENARIOS
================================================================================

SCENARIO: FLASH_CRASH
---------------------

Description: Rapid market decline and recovery (2010-style)
Purpose: Verify circuit breakers and risk controls

```cpp
ReplayScenario create_flash_crash_scenario() {
    return ReplayScenario{
        .name = "FLASH_CRASH",
        .description = "5-10% drop in minutes, rapid recovery",
        .type = ScenarioType::STRESS,

        // Use historical flash crash data
        .start_time = Timestamp("2010-05-06 14:30:00"),
        .end_time = Timestamp("2010-05-06 15:30:00"),

        .expected_volatility = 1.5,         // 150% annualized during event
        .expected_spread_bps = 50.0,        // Spreads blow out
        .expected_volume_ratio = 5.0,

        .latency_multiplier = 3.0,          // System under stress
        .packet_loss_rate = 0.01,           // 1%
        .simulate_disconnects = true,

        // Survival mode - just don't blow up
        .max_drawdown_pct = 0.25,
        .min_sharpe = 0.0,                  // Not worried about Sharpe
        .max_rejected_orders = 100
    };
}
```

SCENARIO: LIQUIDITY_DROUGHT
---------------------------

Description: Order book depth disappears
Purpose: Test behavior when can't exit positions

```cpp
ReplayScenario create_liquidity_drought_scenario() {
    return ReplayScenario{
        .name = "LIQUIDITY_DROUGHT",
        .description = "Order book depth drops 80%, wide spreads",
        .type = ScenarioType::STRESS,

        .expected_volatility = 0.50,
        .expected_spread_bps = 20.0,
        .expected_volume_ratio = 0.2,       // 80% less volume

        .latency_multiplier = 2.0,
        .packet_loss_rate = 0.005,
        .simulate_disconnects = false,

        .max_drawdown_pct = 0.15,
        .min_sharpe = -0.5,                 // May be negative
        .max_rejected_orders = 50
    };
}
```

SCENARIO: EXCHANGE_DEGRADATION
------------------------------

Description: Exchange systems slow down
Purpose: Test handling of elevated latency

```cpp
ReplayScenario create_exchange_degradation_scenario() {
    return ReplayScenario{
        .name = "EXCHANGE_DEGRADATION",
        .description = "Exchange latency 5-10x normal, message drops",
        .type = ScenarioType::STRESS,

        .expected_volatility = 0.30,
        .expected_spread_bps = 5.0,
        .expected_volume_ratio = 0.8,

        .latency_multiplier = 7.0,          // 7x normal latency
        .packet_loss_rate = 0.05,           // 5% packet loss
        .simulate_disconnects = true,

        .max_drawdown_pct = 0.10,
        .min_sharpe = 0.5,
        .max_rejected_orders = 100
    };
}
```

================================================================================
                     4. CRASH/RECOVERY SCENARIOS
================================================================================

SCENARIO: SYSTEM_CRASH_RECOVERY
-------------------------------

Description: Simulate system crash during active trading
Purpose: Verify state recovery and position reconciliation

```cpp
ReplayScenario create_crash_recovery_scenario() {
    return ReplayScenario{
        .name = "CRASH_RECOVERY",
        .description = "System crash at random point, restart and recover",
        .type = ScenarioType::CRASH,

        // Normal market conditions
        .expected_volatility = 0.20,
        .expected_spread_bps = 1.0,
        .expected_volume_ratio = 1.0,

        // Inject crash
        .inject_crash = true,
        .crash_time = RandomTime(),         // Random time during replay
        .crash_duration_ms = 5000,          // 5 second outage

        // Recovery validation
        .validate_position_recovery = true,
        .validate_order_sync = true,
        .max_position_discrepancy = 0,      // Must match exactly
        .max_order_discrepancy = 0
    };
}
```

SCENARIO: NETWORK_PARTITION
---------------------------

Description: Temporary network disconnect from exchange
Purpose: Verify reconnection and state sync

```cpp
ReplayScenario create_network_partition_scenario() {
    return ReplayScenario{
        .name = "NETWORK_PARTITION",
        .description = "30-second network disconnect, reconnect",
        .type = ScenarioType::CRASH,

        .expected_volatility = 0.20,
        .expected_spread_bps = 1.0,
        .expected_volume_ratio = 1.0,

        // Network partition simulation
        .inject_disconnect = true,
        .disconnect_duration_ms = 30000,    // 30 seconds
        .disconnect_count = 3,              // 3 disconnects during session

        .max_drawdown_pct = 0.10,
        .validate_reconnection = true,
        .max_reconnect_time_ms = 5000
    };
}
```

SCENARIO: DATA_CENTER_FAILOVER
------------------------------

Description: Primary site fails, failover to backup
Purpose: Verify DR procedures work correctly

```cpp
ReplayScenario create_dc_failover_scenario() {
    return ReplayScenario{
        .name = "DC_FAILOVER",
        .description = "Primary DC failure, failover to secondary",
        .type = ScenarioType::CRASH,

        .expected_volatility = 0.25,
        .expected_spread_bps = 2.0,
        .expected_volume_ratio = 1.0,

        // Failover simulation
        .simulate_dc_failure = true,
        .failover_delay_ms = 10000,         // 10 seconds to failover
        .data_gap_ms = 5000,                // 5 seconds of missed data

        .max_drawdown_pct = 0.15,
        .validate_position_sync = true,
        .max_missed_fills = 5
    };
}
```

================================================================================
                     5. MULTI-EXCHANGE SCENARIOS
================================================================================

SCENARIO: CROSS_EXCHANGE_ARB
----------------------------

Description: Test cross-exchange arbitrage during replay
Purpose: Verify multi-venue execution timing

```cpp
ReplayScenario create_cross_exchange_scenario() {
    return ReplayScenario{
        .name = "CROSS_EXCHANGE_ARB",
        .description = "Replay from multiple exchanges simultaneously",
        .type = ScenarioType::MULTI_EXCHANGE,

        .exchanges = {"BINANCE", "COINBASE", "KRAKEN"},

        // Per-exchange conditions
        .exchange_configs = {
            {"BINANCE", {
                .latency_us = 50,
                .spread_bps = 0.5
            }},
            {"COINBASE", {
                .latency_us = 100,
                .spread_bps = 1.0
            }},
            {"KRAKEN", {
                .latency_us = 150,
                .spread_bps = 1.5
            }}
        },

        // Validation
        .validate_arb_detection = true,
        .min_arb_capture_rate = 0.70        // Capture 70% of arbs
    };
}
```

SCENARIO: EXCHANGE_OUTAGE
-------------------------

Description: One exchange goes down during multi-exchange trading
Purpose: Verify graceful handling of partial outage

```cpp
ReplayScenario create_exchange_outage_scenario() {
    return ReplayScenario{
        .name = "EXCHANGE_OUTAGE",
        .description = "Single exchange outage during trading",
        .type = ScenarioType::MULTI_EXCHANGE,

        .exchanges = {"BINANCE", "COINBASE", "KRAKEN"},

        // Simulate Binance outage
        .failed_exchange = "BINANCE",
        .outage_start = "10:30:00",
        .outage_duration_min = 15,

        // Remaining exchanges
        .continue_on_remaining = true,

        .max_drawdown_pct = 0.10,
        .validate_order_cancellation = true
    };
}
```

================================================================================
                     6. CUSTOM SCENARIO CREATION
================================================================================

SCENARIO BUILDER:
-----------------

```cpp
class ScenarioBuilder {
public:
    ScenarioBuilder& name(const std::string& n) {
        scenario_.name = n;
        return *this;
    }

    ScenarioBuilder& time_range(const Timestamp& start, const Timestamp& end) {
        scenario_.start_time = start;
        scenario_.end_time = end;
        return *this;
    }

    ScenarioBuilder& volatility(double vol) {
        scenario_.expected_volatility = vol;
        return *this;
    }

    ScenarioBuilder& spread(double spread_bps) {
        scenario_.expected_spread_bps = spread_bps;
        return *this;
    }

    ScenarioBuilder& latency_multiplier(double mult) {
        scenario_.latency_multiplier = mult;
        return *this;
    }

    ScenarioBuilder& inject_event(const Event& event) {
        scenario_.injected_events.push_back(event);
        return *this;
    }

    ScenarioBuilder& validation(const ValidationCriteria& criteria) {
        scenario_.validation = criteria;
        return *this;
    }

    ReplayScenario build() {
        validate_scenario(scenario_);
        return scenario_;
    }

private:
    ReplayScenario scenario_;
};

// Usage example
ReplayScenario custom = ScenarioBuilder()
    .name("CUSTOM_STRESS_TEST")
    .time_range("2025-11-26 09:30:00", "2025-11-26 16:00:00")
    .volatility(0.40)
    .spread(5.0)
    .latency_multiplier(2.5)
    .inject_event(Event::disconnect_at("10:00:00"))
    .inject_event(Event::spread_spike_at("11:30:00", 20.0))
    .validation(ValidationCriteria{
        .max_drawdown = 0.15,
        .min_sharpe = 0.5
    })
    .build();
```

CREATING SYNTHETIC SCENARIOS:
-----------------------------

```cpp
class SyntheticScenarioGenerator {
public:
    // Generate scenario from historical extreme events
    ReplayScenario from_historical_extreme(
        const Date& date,
        ExtremeType type
    ) {
        switch (type) {
            case ExtremeType::MAX_VOLATILITY:
                return find_highest_vol_day(date.year());
            case ExtremeType::MAX_SPREAD:
                return find_widest_spread_day(date.year());
            case ExtremeType::MAX_VOLUME:
                return find_highest_volume_day(date.year());
            case ExtremeType::MAX_DRAWDOWN:
                return find_worst_drawdown_day(date.year());
        }
    }

    // Generate Monte Carlo stress scenarios
    std::vector<ReplayScenario> monte_carlo_stress(
        int num_scenarios,
        const StressParams& params
    ) {
        std::vector<ReplayScenario> scenarios;

        for (int i = 0; i < num_scenarios; i++) {
            scenarios.push_back(generate_random_stress(params));
        }

        return scenarios;
    }

private:
    ReplayScenario generate_random_stress(const StressParams& params) {
        // Random volatility within stress range
        double vol = uniform_random(params.min_vol, params.max_vol);
        double spread = uniform_random(params.min_spread, params.max_spread);
        double latency = uniform_random(params.min_latency_mult,
                                       params.max_latency_mult);

        return ScenarioBuilder()
            .name("MONTE_CARLO_" + std::to_string(rand()))
            .volatility(vol)
            .spread(spread)
            .latency_multiplier(latency)
            .build();
    }
};
```

================================================================================
                     7. SCENARIO LIBRARY MANAGEMENT
================================================================================

SCENARIO REGISTRY:
------------------

```cpp
class ScenarioRegistry {
public:
    static ScenarioRegistry& instance() {
        static ScenarioRegistry registry;
        return registry;
    }

    void register_scenario(const ReplayScenario& scenario) {
        scenarios_[scenario.name] = scenario;
    }

    ReplayScenario get(const std::string& name) const {
        return scenarios_.at(name);
    }

    std::vector<ReplayScenario> get_by_type(ScenarioType type) const {
        std::vector<ReplayScenario> result;
        for (const auto& [name, scenario] : scenarios_) {
            if (scenario.type == type) {
                result.push_back(scenario);
            }
        }
        return result;
    }

    // Get scenarios to run daily
    std::vector<ReplayScenario> get_daily_scenarios() const {
        return get_by_type(ScenarioType::NORMAL);
    }

    // Get scenarios for monthly stress test
    std::vector<ReplayScenario> get_stress_scenarios() const {
        auto stress = get_by_type(ScenarioType::STRESS);
        auto crash = get_by_type(ScenarioType::CRASH);
        stress.insert(stress.end(), crash.begin(), crash.end());
        return stress;
    }

private:
    std::map<std::string, ReplayScenario> scenarios_;
};

// Initialize standard scenarios
void initialize_scenario_library() {
    auto& registry = ScenarioRegistry::instance();

    // Normal scenarios
    registry.register_scenario(create_typical_day_scenario(Date::today()));
    registry.register_scenario(create_low_vol_scenario());
    registry.register_scenario(create_high_volume_scenario());

    // Stress scenarios
    registry.register_scenario(create_flash_crash_scenario());
    registry.register_scenario(create_liquidity_drought_scenario());
    registry.register_scenario(create_exchange_degradation_scenario());

    // Crash/recovery scenarios
    registry.register_scenario(create_crash_recovery_scenario());
    registry.register_scenario(create_network_partition_scenario());
    registry.register_scenario(create_dc_failover_scenario());

    // Multi-exchange scenarios
    registry.register_scenario(create_cross_exchange_scenario());
    registry.register_scenario(create_exchange_outage_scenario());
}
```

================================================================================
                         END OF DOCUMENT
================================================================================
