================================================================================
GPROF - CPU PROFILING & CALL GRAPH ANALYSIS FOR HFT C++
================================================================================

THEORY:
-------
gprof (GNU Profiler) is a compiler-based profiling tool that provides:
- Flat profile: Time spent in each function
- Call graph: Function call relationships and frequencies
- Annotated source listings

Unlike perf (sampling-based), gprof uses instrumentation added at compile
time. It's simpler but has higher overhead than perf.

HOW IT WORKS:
1. Compiler adds instrumentation code to function entry/exit
2. Program writes profiling data to gmon.out on exit
3. gprof analyzes gmon.out and generates reports

USE CASES IN HFT:
-----------------
1. Quick function-level profiling
2. Identify expensive function calls
3. Understand call relationships
4. Find unexpected function call frequencies
5. Portable profiling (works on any Linux/Unix)

ADVANTAGES:
- Simple to use
- No special permissions needed
- Portable across systems
- Shows call counts

DISADVANTAGES:
- High runtime overhead (10-30%)
- Only profiles user code (not kernel)
- Limited support for multi-threaded programs
- Requires recompilation

INSTALLATION:
-------------
# Usually included with GCC
gcc --version
gprof --version

PROCESS & COMMANDS:
-------------------

STEP 1: Compile with profiling enabled
g++ -pg -O2 -std=c++17 your_program.cpp -o your_program

Important flags:
-pg         : Enable gprof instrumentation
-O2         : Enable optimizations (but not -O3, may inline too much)
-g          : Add debug symbols for source code annotation
-no-pie     : Disable position independent code if issues occur

STEP 2: Run the program
./your_program

This generates gmon.out in the current directory

STEP 3: Generate profiling report
gprof your_program gmon.out > analysis.txt

Advanced options:
gprof -b your_program gmon.out > analysis.txt  # Brief, no verbose blurbs
gprof -p your_program gmon.out > flat.txt      # Only flat profile
gprof -q your_program gmon.out > callgraph.txt # Only call graph
gprof -A your_program gmon.out > annotated.txt # Annotated source
gprof -l your_program gmon.out                 # Line-by-line profiling

HFT C++ EXAMPLE:
----------------

// trading_engine.cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <chrono>

// Simulate order validation
bool validateOrder(double price, uint64_t quantity, double balance) {
    if (price <= 0 || quantity == 0) return false;
    if (price * quantity > balance) return false;

    // Simulate some computation
    volatile double temp = 0;
    for (int i = 0; i < 100; ++i) {
        temp += std::sqrt(price * quantity);
    }

    return true;
}

// Simulate risk calculation
double calculateRisk(double position, double volatility, double price) {
    // Expensive calculation
    double risk = 0;
    for (int i = 0; i < 1000; ++i) {
        risk += std::abs(position * volatility * std::sin(price + i * 0.01));
    }
    return risk / 1000.0;
}

// Process order book update
void processOrderBookUpdate(std::vector<double>& prices, std::vector<uint64_t>& quantities) {
    double total_value = 0;

    for (size_t i = 0; i < prices.size(); ++i) {
        // Validate each level
        if (validateOrder(prices[i], quantities[i], 1000000.0)) {
            total_value += prices[i] * quantities[i];
        }
    }
}

// Calculate portfolio metrics
void calculatePortfolioMetrics(const std::vector<double>& positions,
                                const std::vector<double>& prices,
                                const std::vector<double>& volatilities) {
    double total_risk = 0;

    for (size_t i = 0; i < positions.size(); ++i) {
        // This function is called frequently and may be expensive
        total_risk += calculateRisk(positions[i], volatilities[i], prices[i]);
    }

    std::cout << "Total risk: " << total_risk << std::endl;
}

// Main trading loop
void runTradingEngine(int num_iterations) {
    std::vector<double> prices(100);
    std::vector<uint64_t> quantities(100);
    std::vector<double> positions(50);
    std::vector<double> volatilities(50);

    // Initialize
    for (size_t i = 0; i < prices.size(); ++i) {
        prices[i] = 100.0 + i * 0.1;
        quantities[i] = 100;
    }

    for (size_t i = 0; i < positions.size(); ++i) {
        positions[i] = 1000.0 + i * 10;
        volatilities[i] = 0.2 + i * 0.01;
    }

    // Trading loop
    for (int iter = 0; iter < num_iterations; ++iter) {
        // Process order book (frequent, should be fast)
        processOrderBookUpdate(prices, quantities);

        // Calculate risk (less frequent, can be more expensive)
        if (iter % 10 == 0) {
            calculatePortfolioMetrics(positions, prices, volatilities);
        }
    }
}

int main() {
    std::cout << "Starting trading engine...\n";

    auto start = std::chrono::high_resolution_clock::now();

    runTradingEngine(1000);

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    std::cout << "Execution time: " << duration.count() << " ms\n";

    return 0;
}

COMPLETE WORKFLOW:
------------------

# Step 1: Compile with gprof instrumentation
g++ -pg -O2 -g -std=c++17 trading_engine.cpp -o trading_engine

# Step 2: Run the program (generates gmon.out)
./trading_engine

# Step 3: Generate profiling report
gprof trading_engine gmon.out > gprof_report.txt

# Step 4: View the report
less gprof_report.txt

# Alternative: Generate specific reports
gprof -b trading_engine gmon.out > brief_report.txt        # Brief
gprof -p trading_engine gmon.out > flat_profile.txt        # Flat only
gprof -q trading_engine gmon.out > call_graph.txt          # Call graph only
gprof -A -x trading_engine gmon.out > annotated.txt        # Annotated source

INTERPRETING RESULTS:
---------------------

FLAT PROFILE SECTION:
--------------------
Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
 45.00      0.45     0.45   100000     0.00     0.00  calculateRisk(double, double, double)
 30.00      0.75     0.30  1000000     0.00     0.00  validateOrder(double, unsigned long, double)
 15.00      0.90     0.15     1000     0.15     0.90  calculatePortfolioMetrics(...)
 10.00      1.00     0.10     1000     0.10     1.00  processOrderBookUpdate(...)

Interpretation:
- calculateRisk() takes 45% of total time - optimization target!
- validateOrder() called 1M times - consider optimization or reduction
- Time columns:
  - % time: Percentage of total execution time
  - cumulative: Running total of time
  - self: Time spent in function itself (not children)
  - calls: Number of times function was called
  - self ms/call: Time per call in function
  - total ms/call: Time per call including children

CALL GRAPH SECTION:
------------------
index % time    self  children    called     name
                                                 <spontaneous>
[1]    100.0    0.10    0.90                 main [1]
                0.15    0.75    1000/1000      runTradingEngine(int) [2]
-----------------------------------------------
                0.15    0.75    1000/1000      main [1]
[2]     90.0    0.15    0.75    1000         runTradingEngine(int) [2]
                0.30    0.00 1000000/1000000   processOrderBookUpdate(...) [3]
                0.15    0.30    100/100        calculatePortfolioMetrics(...) [4]
-----------------------------------------------
                0.30    0.00 1000000/1000000   runTradingEngine(int) [2]
[3]     30.0    0.30    0.00 1000000         processOrderBookUpdate(...) [3]
                0.00    0.00 10000000/10000000 validateOrder(...) [5]

Interpretation:
- Shows caller/callee relationships
- Identifies which call paths are expensive
- "self" = time in function, "children" = time in called functions

OPTIMIZATION STRATEGY BASED ON GPROF:
--------------------------------------

1. FIND HOT FUNCTIONS (Flat Profile)
   Look for functions with highest % time and/or call counts

2. ANALYZE CALL GRAPH
   Identify which call paths lead to expensive functions

3. OPTIMIZATION OPTIONS:

   a) High % time, low call count:
      - Optimize algorithm within function
      - Use better data structures
      - Apply SIMD optimizations

   b) High call count, moderate time per call:
      - Reduce number of calls
      - Inline function (if small)
      - Batch operations

   c) High call count, low time per call:
      - Consider inlining
      - May already be optimal

   d) Functions called through expensive paths:
      - Restructure code to reduce calls
      - Cache results if deterministic

HFT-SPECIFIC OPTIMIZATIONS:
---------------------------

Example optimization for calculateRisk():
// Before (45% of runtime)
double calculateRisk(double position, double volatility, double price) {
    double risk = 0;
    for (int i = 0; i < 1000; ++i) {
        risk += std::abs(position * volatility * std::sin(price + i * 0.01));
    }
    return risk / 1000.0;
}

// After - Optimizations:
// 1. Reduce iterations if precision allows
// 2. Pre-calculate common terms
// 3. Use lookup table for sin() if applicable
double calculateRisk(double position, double volatility, double price) {
    double base = position * volatility;
    double risk = 0;

    // Reduce iterations if acceptable
    for (int i = 0; i < 100; i += 10) {  // 10x fewer iterations
        risk += std::abs(base * std::sin(price + i * 0.1));
    }

    return risk / 100.0;
}

Example optimization for validateOrder():
// Before (called 1M times, 30% of runtime)
bool validateOrder(double price, uint64_t quantity, double balance) {
    if (price <= 0 || quantity == 0) return false;
    if (price * quantity > balance) return false;

    volatile double temp = 0;
    for (int i = 0; i < 100; ++i) {
        temp += std::sqrt(price * quantity);
    }
    return true;
}

// After - Inline and simplify
inline bool validateOrder(double price, uint64_t quantity, double balance) {
    // Fast path checks first
    if (price <= 0 || quantity == 0) return false;
    if (price * quantity > balance) return false;

    // Remove unnecessary computation in hot path
    return true;
}

MULTI-THREADED PROFILING:
-------------------------

gprof has limited multi-threading support. For each thread:

# Compile with -pg
g++ -pg -pthread -O2 your_mt_program.cpp -o mt_program

# Set environment to generate per-thread profiles
export GMON_OUT_PREFIX=gmon.out

# Run program (generates gmon.out.<pid> for each thread)
./mt_program

# Analyze each thread separately
gprof mt_program gmon.out.12345 > thread1_profile.txt
gprof mt_program gmon.out.12346 > thread2_profile.txt

# Or combine all profiles
gprof -s mt_program gmon.out.*
gprof mt_program gmon.sum > combined_profile.txt

COMPARISON: GPROF vs PERF:
--------------------------

GPROF:
+ Simple to use
+ No special permissions needed
+ Shows exact call counts
+ Portable
- High overhead (10-30%)
- Limited multi-threading support
- Only user-space profiling
- Requires recompilation

PERF:
+ Low overhead (<5%)
+ Excellent multi-threading support
+ Kernel + user space profiling
+ Hardware counter access
- Requires permissions or root
- Linux-specific
- More complex to use

RECOMMENDATION FOR HFT:
Use gprof for initial profiling and understanding code structure.
Use perf for production-like performance analysis and optimization.

BEST PRACTICES:
---------------
1. Profile with realistic workloads (market data rates, order volumes)
2. Run long enough for statistical significance (at least 1 second)
3. Compare before/after optimization
4. Focus on functions with high % time first
5. Consider both time per call and total calls
6. Don't over-optimize functions with <1% time
7. Verify optimizations don't hurt correctness or maintainability

TROUBLESHOOTING:
----------------
1. No gmon.out generated:
   - Ensure compiled with -pg
   - Ensure program exits normally (calls exit() or returns from main)
   - Check write permissions in directory

2. "gprof: file format not recognized":
   - Mismatch between binary and gmon.out
   - Recompile and regenerate gmon.out

3. Empty or minimal profile:
   - Program runs too quickly (<0.1 seconds)
   - Increase workload or iterations

4. Inaccurate results for small functions:
   - Compiler may inline aggressively with -O3
   - Use -O2 for profiling
   - Add __attribute__((noinline)) to prevent inlining if needed

ADVANCED USAGE:
---------------
# Profile specific sections using prof control
# In code, conditionally enable/disable profiling:

#include <sys/gmon.h>

int main() {
    moncontrol(0);  // Disable profiling

    // Setup code (not profiled)
    setupEnvironment();

    moncontrol(1);  // Enable profiling

    // Critical path (profiled)
    runTradingEngine(1000);

    moncontrol(0);  // Disable profiling

    // Cleanup (not profiled)
    cleanup();

    return 0;
}

This allows focusing profiling on specific code sections.
