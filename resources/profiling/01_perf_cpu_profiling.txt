================================================================================
PERF - CPU PROFILING FOR HFT C++
================================================================================

THEORY:
-------
perf is a Linux profiling tool with performance counters for CPU analysis.
It uses hardware performance monitoring units (PMUs) to collect low-overhead
statistics about CPU events like cache misses, branch mispredictions, and
instruction execution.

In HFT, CPU efficiency is critical - every CPU cycle counts. perf helps
identify hot spots, cache inefficiencies, and CPU stalls.

KEY CONCEPTS:
- Sampling: Periodically records program state (low overhead)
- Hardware counters: CPU-level event tracking
- Call graphs: Shows function call hierarchy and time spent
- Cache analysis: L1/L2/L3 cache hit/miss rates

USE CASES IN HFT:
-----------------
1. Identify hot code paths in order processing
2. Optimize critical trading algorithms
3. Reduce cache misses in market data handling
4. Analyze branch prediction efficiency
5. Find CPU-bound bottlenecks in tick processing

INSTALLATION:
-------------
sudo apt-get install linux-tools-common linux-tools-generic
sudo apt-get install linux-tools-$(uname -r)

PROCESS & COMMANDS:
-------------------

1. BASIC CPU PROFILING (Record & Report)
   perf record -g ./your_hft_app
   perf report

   Options:
   -g : Enable call-graph (stack trace) recording
   -F : Set sampling frequency (e.g., -F 99 for 99 Hz)
   --call-graph=dwarf : Better call graphs with DWARF info

2. RECORD WITH SPECIFIC EVENTS
   perf record -e cycles,instructions,cache-misses ./your_hft_app

   Common events for HFT:
   - cycles: CPU cycles
   - instructions: Instructions executed
   - cache-misses: Cache miss events
   - branch-misses: Branch mispredictions

3. CPU STATISTICS
   perf stat ./your_hft_app
   perf stat -e cycles,instructions,cache-references,cache-misses ./your_hft_app

4. LIVE MONITORING (top-like interface)
   perf top -g

   Options:
   -p PID : Monitor specific process
   -g : Enable call-graph

5. DETAILED CACHE ANALYSIS
   perf stat -e L1-dcache-loads,L1-dcache-load-misses,LLC-loads,LLC-load-misses ./your_hft_app

6. FLAMEGRAPH GENERATION (visualization)
   perf record -F 99 -g ./your_hft_app
   perf script | stackcollapse-perf.pl | flamegraph.pl > flamegraph.svg

HFT C++ EXAMPLE:
----------------

// sample_hft_orderbook.cpp
#include <iostream>
#include <vector>
#include <map>
#include <chrono>

struct Order {
    uint64_t id;
    double price;
    uint64_t quantity;
};

class OrderBook {
    std::map<double, std::vector<Order>> bids;
    std::map<double, std::vector<Order>> asks;

public:
    void addOrder(bool is_bid, double price, uint64_t qty, uint64_t id) {
        Order order{id, price, qty};
        if (is_bid) {
            bids[price].push_back(order);
        } else {
            asks[price].push_back(order);
        }
    }

    void processMarketData(int num_updates) {
        for (int i = 0; i < num_updates; ++i) {
            double price = 100.0 + (i % 100) * 0.01;
            addOrder(i % 2 == 0, price, 100, i);
        }
    }
};

int main() {
    OrderBook book;

    auto start = std::chrono::high_resolution_clock::now();

    // Simulate market data processing
    for (int round = 0; round < 10000; ++round) {
        book.processMarketData(1000);
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    std::cout << "Processing time: " << duration.count() << " us\n";

    return 0;
}

PROFILING WORKFLOW:
-------------------

# Compile with debug symbols and optimizations
g++ -O3 -g -std=c++17 sample_hft_orderbook.cpp -o orderbook

# 1. Get basic statistics
perf stat ./orderbook

# 2. Record CPU profile with call graphs
perf record -g -F 999 ./orderbook

# 3. View interactive report
perf report

# 4. Annotate source code (shows which lines are hot)
perf annotate

# 5. Cache analysis
perf stat -e cache-references,cache-misses,L1-dcache-loads,L1-dcache-load-misses ./orderbook

# 6. Branch prediction analysis
perf stat -e branches,branch-misses ./orderbook

INTERPRETING RESULTS:
---------------------

Key metrics for HFT:
- IPC (Instructions Per Cycle): >1.0 is good, >2.0 is excellent
- Cache miss rate: <3% for L1, <10% for LLC is good
- Branch miss rate: <5% is good
- CPU utilization: Should be high for critical paths

Example output interpretation:
  Performance counter stats for './orderbook':

      12,345.67 msec task-clock                #    0.999 CPUs utilized
      1,234,567,890      cycles                    #    2.500 GHz
      2,345,678,901      instructions              #    1.90  insn per cycle
         23,456,789      cache-misses              #    1.5% of all cache refs
      1,567,890,123      cache-references

Analysis: Good IPC (1.90), low cache miss rate (1.5%) - well optimized!

OPTIMIZATION TIPS FOR HFT:
--------------------------
1. If you see high cache-misses:
   - Reduce data structure sizes
   - Improve data locality
   - Use __builtin_prefetch() for predictable access patterns

2. If you see high branch-misses:
   - Use __builtin_expect() for hints
   - Reduce conditional logic in hot paths
   - Consider branchless programming techniques

3. Low IPC:
   - Check for dependency chains
   - Look for pipeline stalls
   - Consider loop unrolling

4. CPU bound hotspots:
   - Use SIMD instructions (AVX2/AVX-512)
   - Optimize algorithms
   - Reduce memory allocations

ADVANCED COMMANDS:
------------------
# Profile specific CPU cores
perf record -C 0,1 -g ./orderbook

# Record for specific duration
perf record -g sleep 10 &
PID=$!
./orderbook
kill $PID

# Kernel + userspace profiling
perf record -g -a ./orderbook

# Generate detailed report with percentages
perf report --stdio --show-total-period

COMMON ISSUES:
--------------
1. "perf command not found"
   Solution: Install linux-tools for your kernel version

2. "Access to performance monitoring denied"
   Solution: sudo sysctl -w kernel.perf_event_paranoid=-1
   Or run with sudo

3. Missing symbols in report
   Solution: Compile with -g flag, install debug symbols

BEST PRACTICES FOR HFT:
-----------------------
1. Profile on production-like hardware
2. Use representative workloads
3. Profile both latency and throughput scenarios
4. Compare before/after optimization
5. Focus on 99th percentile, not just averages
6. Profile with realistic market data volumes
