================================================================================
DISASTER RECOVERY - RECOVERY PROCEDURES
High-Frequency Trading System
RTO: 60 seconds | RPO: 0 seconds | SLA: 99.99% Uptime
================================================================================

TABLE OF CONTENTS
-----------------
1. Recovery Overview & Objectives
2. Recovery Time Objective (RTO) Framework
3. Recovery Point Objective (RPO) Framework
4. Critical System Recovery Procedures
5. Database Recovery Procedures
6. State Recovery & Reconciliation
7. Market Data Recovery
8. Position & Risk Recovery
9. Recovery Validation & Testing
10. Post-Recovery Procedures

================================================================================
1. RECOVERY OVERVIEW & OBJECTIVES
================================================================================

1.1 RECOVERY HIERARCHY
----------------------

┌─────────────────────────────────────────────────────────────────┐
│                  RECOVERY PRIORITY MATRIX                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Priority 1 (0-60 seconds)     CRITICAL                        │
│  ├── Trading Engine                                            │
│  ├── Order Management System                                   │
│  ├── Risk Management Engine                                    │
│  └── Market Data Feeds                                         │
│                                                                 │
│  Priority 2 (1-5 minutes)      ESSENTIAL                       │
│  ├── Position Management                                       │
│  ├── P&L Calculation                                           │
│  ├── Execution Management                                      │
│  └── Market Connectivity                                       │
│                                                                 │
│  Priority 3 (5-15 minutes)     IMPORTANT                       │
│  ├── Analytics Systems                                         │
│  ├── Monitoring & Alerting                                     │
│  ├── Reporting Systems                                         │
│  └── Historical Data Access                                    │
│                                                                 │
│  Priority 4 (15-60 minutes)    STANDARD                        │
│  ├── Back-office Systems                                       │
│  ├── Compliance Reporting                                      │
│  ├── Data Warehouse                                            │
│  └── Development Environments                                  │
└─────────────────────────────────────────────────────────────────┘

1.2 RECOVERY SLA TARGETS
-------------------------

SYSTEM-LEVEL TARGETS
--------------------

Trading Engine:
- RTO: 30 seconds
- RPO: 0 seconds (zero data loss)
- Availability: 99.995%
- Max Downtime/Year: 26.28 minutes

Order Management:
- RTO: 45 seconds
- RPO: 0 seconds
- Availability: 99.99%
- Max Downtime/Year: 52.56 minutes

Risk Management:
- RTO: 60 seconds
- RPO: 5 seconds
- Availability: 99.99%
- Max Downtime/Year: 52.56 minutes

Market Data Feeds:
- RTO: 15 seconds
- RPO: 0 seconds (real-time)
- Availability: 99.999%
- Max Downtime/Year: 5.26 minutes

1.3 RECOVERY DECISION MATRIX
-----------------------------

Decision Tree for Recovery Actions:

                    [System Failure Detected]
                             │
                             ▼
                    [Assess Failure Scope]
                             │
                ┌────────────┴────────────┐
                ▼                         ▼
        [Single Component]        [Multiple Systems]
                │                         │
                ▼                         ▼
        [Component Recovery]      [Full DR Activation]
        - Hot Failover            - Failover to DR Site
        - Service Restart         - State Recovery
        - Local Recovery          - System Validation
        RTO: 30-60s              RTO: 60-300s

================================================================================
2. RECOVERY TIME OBJECTIVE (RTO) FRAMEWORK
================================================================================

2.1 RTO TIER DEFINITIONS
-------------------------

TIER 1: ULTRA-FAST RECOVERY (0-60 seconds)
-------------------------------------------

Applicable Systems:
- Trading Engine Core
- Order Router
- Market Data Gateway
- Risk Checks (Pre-trade)

Recovery Method: Automatic Failover
Technology: Active-Active or Active-Passive Hot Standby
Trigger: Automated (health checks)
Manual Intervention: None required

Target RTO: 30-60 seconds
Acceptable Data Loss: None
Cost: High (24/7 hot standby)

Implementation:
```bash
# Automatic failover via heartbeat monitoring
# /opt/hft/scripts/auto_failover.sh

#!/bin/bash
PRIMARY_ENDPOINT="tcp://primary-trading:5555"
FAILOVER_ENDPOINT="tcp://failover-trading:5555"
HEALTHCHECK_INTERVAL=1  # seconds

while true; do
    if ! nc -zv primary-trading 5555 >/dev/null 2>&1; then
        echo "Primary down, activating failover..."
        # Update routing
        /opt/hft/scripts/activate_failover.sh
        # Update DNS/Load Balancer
        consul kv put service/trading/active "failover"
        break
    fi
    sleep $HEALTHCHECK_INTERVAL
done
```

TIER 2: RAPID RECOVERY (1-5 minutes)
-------------------------------------

Applicable Systems:
- Position Management
- P&L Engine
- Settlement Systems
- Execution Reporting

Recovery Method: Automated restart with state recovery
Technology: Warm standby with state synchronization
Trigger: Semi-automated (requires confirmation)
Manual Intervention: Minimal

Target RTO: 1-5 minutes
Acceptable Data Loss: <5 seconds
Cost: Medium (warm standby)

TIER 3: STANDARD RECOVERY (5-15 minutes)
-----------------------------------------

Applicable Systems:
- Analytics Platforms
- Monitoring Dashboards
- Historical Data Systems

Recovery Method: Service restart and data sync
Technology: Cold standby or clustered failover
Trigger: Manual
Manual Intervention: Required

Target RTO: 5-15 minutes
Acceptable Data Loss: <5 minutes
Cost: Low (on-demand)

2.2 RTO MEASUREMENT & TRACKING
-------------------------------

Recovery Time Components:

                    Total RTO
                       │
    ┌──────────────────┼──────────────────┐
    │                  │                  │
    ▼                  ▼                  ▼
Detection Time    Decision Time    Recovery Time
(1-10 sec)        (5-30 sec)       (20-240 sec)
    │                  │                  │
    ▼                  ▼                  ▼
- Monitoring      - Assess Impact   - Failover
- Alerting        - Choose Action   - State Recovery
- Escalation      - Authorization   - Validation

Script: /opt/hft/scripts/measure_rto.py

```python
#!/usr/bin/env python3
"""
RTO Measurement and Tracking
Records actual recovery times vs. targets
"""

import time
import json
from datetime import datetime
import logging

class RTOMeasurement:
    def __init__(self):
        self.events = []
        self.start_time = None

    def start_recovery(self, component, failure_type):
        """Mark start of recovery process"""
        self.start_time = time.time()
        event = {
            'component': component,
            'failure_type': failure_type,
            'detection_time': datetime.now().isoformat(),
            'stages': []
        }
        self.events.append(event)
        logging.info(f"Recovery started for {component}")

    def mark_stage(self, stage_name):
        """Record completion of recovery stage"""
        elapsed = time.time() - self.start_time
        stage = {
            'name': stage_name,
            'elapsed_seconds': elapsed,
            'timestamp': datetime.now().isoformat()
        }
        self.events[-1]['stages'].append(stage)
        logging.info(f"Stage '{stage_name}' completed in {elapsed:.2f}s")

    def complete_recovery(self):
        """Finalize recovery measurement"""
        total_time = time.time() - self.start_time
        self.events[-1]['total_recovery_time'] = total_time
        self.events[-1]['completion_time'] = datetime.now().isoformat()

        # Check against RTO target
        component = self.events[-1]['component']
        target_rto = self.get_rto_target(component)

        if total_time <= target_rto:
            status = "SUCCESS"
        else:
            status = "FAILED"
            self.send_rto_violation_alert(component, total_time, target_rto)

        self.events[-1]['rto_status'] = status

        logging.info(
            f"Recovery completed in {total_time:.2f}s (target: {target_rto}s) - {status}"
        )

        # Save to database
        self.save_metrics()

    def get_rto_target(self, component):
        """Get RTO target for component"""
        rto_targets = {
            'trading_engine': 30,
            'order_management': 45,
            'risk_engine': 60,
            'market_data': 15,
            'position_management': 120,
            'analytics': 300
        }
        return rto_targets.get(component, 300)

    def send_rto_violation_alert(self, component, actual, target):
        """Alert on RTO violation"""
        message = f"RTO VIOLATION: {component} recovered in {actual:.2f}s (target: {target}s)"
        # Send to monitoring system
        logging.critical(message)

    def save_metrics(self):
        """Save RTO metrics to database"""
        with open('/var/log/hft/rto_metrics.json', 'a') as f:
            json.dump(self.events[-1], f)
            f.write('\n')

# Usage example
if __name__ == '__main__':
    rto = RTOMeasurement()
    rto.start_recovery('trading_engine', 'primary_failure')
    time.sleep(2)  # Simulated detection
    rto.mark_stage('detection')
    time.sleep(5)  # Simulated decision
    rto.mark_stage('decision')
    time.sleep(20)  # Simulated recovery
    rto.mark_stage('failover_complete')
    time.sleep(3)  # Simulated validation
    rto.mark_stage('validation')
    rto.complete_recovery()
```

================================================================================
3. RECOVERY POINT OBJECTIVE (RPO) FRAMEWORK
================================================================================

3.1 RPO TIER DEFINITIONS
-------------------------

TIER 1: ZERO DATA LOSS (RPO = 0 seconds)
-----------------------------------------

Applicable Data:
- Active Orders
- Trade Executions
- Position Updates
- Account Balances
- Risk Limits

Implementation: Synchronous replication

PostgreSQL Configuration:
```conf
# Synchronous replication for zero data loss
synchronous_commit = remote_apply
synchronous_standby_names = 'standby1,standby2'
```

Redis Configuration:
```conf
# Wait for replication before acknowledging writes
wait-for-replicas 1
wait-for-replicas-timeout 1000
```

TIER 2: NEAR-ZERO DATA LOSS (RPO < 5 seconds)
----------------------------------------------

Applicable Data:
- Market Data Snapshots
- Performance Metrics
- Audit Logs

Implementation: Asynchronous replication with frequent checkpoints

TIER 3: MINIMAL DATA LOSS (RPO < 5 minutes)
--------------------------------------------

Applicable Data:
- Analytics Results
- Historical Reports
- System Logs

Implementation: Periodic snapshots

3.2 RPO VALIDATION SCRIPT
--------------------------

Script: /opt/hft/scripts/validate_rpo.sh

```bash
#!/bin/bash
# RPO Validation
# Verifies replication lag meets RPO targets

RPO_TARGET_MS=0  # Zero data loss target
ALERT_THRESHOLD_MS=100

# Check PostgreSQL replication lag
check_db_rpo() {
    echo "Checking database RPO..."

    # Query replication lag from standby
    LAG_MS=$(psql -h standby.hft.local -U monitoring -d trading -t -c "
        SELECT EXTRACT(EPOCH FROM (NOW() - pg_last_xact_replay_timestamp())) * 1000 AS lag_ms;
    " | tr -d ' ')

    echo "Current replication lag: ${LAG_MS}ms"

    if (( $(echo "$LAG_MS > $ALERT_THRESHOLD_MS" | bc -l) )); then
        echo "ALERT: Replication lag exceeds threshold!"
        echo "Current: ${LAG_MS}ms, Threshold: ${ALERT_THRESHOLD_MS}ms"

        # Send alert
        /opt/hft/scripts/send_alert.sh "RPO_VIOLATION" \
            "Database replication lag: ${LAG_MS}ms"

        return 1
    fi

    echo "RPO check PASSED"
    return 0
}

# Check Redis replication lag
check_redis_rpo() {
    echo "Checking Redis RPO..."

    REDIS_INFO=$(redis-cli -h replica.hft.local INFO replication)

    MASTER_OFFSET=$(echo "$REDIS_INFO" | grep "master_repl_offset" | cut -d: -f2 | tr -d '\r')
    SLAVE_OFFSET=$(echo "$REDIS_INFO" | grep "slave_repl_offset" | cut -d: -f2 | tr -d '\r')

    LAG=$((MASTER_OFFSET - SLAVE_OFFSET))

    echo "Redis replication lag: $LAG operations"

    if [ $LAG -gt 100 ]; then
        echo "ALERT: Redis replication lag too high!"
        /opt/hft/scripts/send_alert.sh "RPO_VIOLATION" \
            "Redis replication lag: ${LAG} operations"
        return 1
    fi

    echo "Redis RPO check PASSED"
    return 0
}

# Check last transaction time
check_last_transaction() {
    echo "Checking last transaction replication..."

    # Get last transaction ID from primary
    PRIMARY_TXN=$(psql -h primary.hft.local -U monitoring -d trading -t -c "
        SELECT MAX(txn_id) FROM trades WHERE created_at > NOW() - INTERVAL '1 minute';
    " | tr -d ' ')

    # Get last transaction ID from standby
    STANDBY_TXN=$(psql -h standby.hft.local -U monitoring -d trading -t -c "
        SELECT MAX(txn_id) FROM trades WHERE created_at > NOW() - INTERVAL '1 minute';
    " | tr -d ' ')

    DIFF=$((PRIMARY_TXN - STANDBY_TXN))

    echo "Transaction difference: $DIFF"

    if [ $DIFF -gt 0 ]; then
        echo "WARNING: Standby is $DIFF transactions behind"
        return 1
    fi

    echo "Transaction replication check PASSED"
    return 0
}

# Main execution
main() {
    echo "=== RPO Validation Check ==="
    echo "Target RPO: ${RPO_TARGET_MS}ms"
    echo "Alert Threshold: ${ALERT_THRESHOLD_MS}ms"
    echo ""

    CHECKS_PASSED=0
    CHECKS_FAILED=0

    if check_db_rpo; then
        ((CHECKS_PASSED++))
    else
        ((CHECKS_FAILED++))
    fi

    if check_redis_rpo; then
        ((CHECKS_PASSED++))
    else
        ((CHECKS_FAILED++))
    fi

    if check_last_transaction; then
        ((CHECKS_PASSED++))
    else
        ((CHECKS_FAILED++))
    fi

    echo ""
    echo "=== Summary ==="
    echo "Checks Passed: $CHECKS_PASSED"
    echo "Checks Failed: $CHECKS_FAILED"

    if [ $CHECKS_FAILED -gt 0 ]; then
        echo "STATUS: FAILED"
        exit 1
    else
        echo "STATUS: PASSED"
        exit 0
    fi
}

main
```

Cron Configuration:
```cron
# Check RPO every minute
* * * * * /opt/hft/scripts/validate_rpo.sh >> /var/log/hft/rpo_validation.log 2>&1
```

================================================================================
4. CRITICAL SYSTEM RECOVERY PROCEDURES
================================================================================

4.1 TRADING ENGINE RECOVERY
----------------------------

Procedure: RECOVER-TRADE-001
Priority: CRITICAL
RTO: 30 seconds
RPO: 0 seconds

STEP-BY-STEP RECOVERY
---------------------

Step 1: Detect Failure (0-5 seconds)
```bash
# Automated detection via health check
/opt/hft/scripts/healthcheck_trading_engine.sh

# Check process status
ps aux | grep trading_engine

# Check connectivity
nc -zv localhost 5555
```

Step 2: Initiate Failover (5-10 seconds)
```bash
#!/bin/bash
# /opt/hft/scripts/failover_trading_engine.sh

echo "$(date): Initiating trading engine failover"

# Stop primary (if still running)
systemctl stop hft-trading-engine

# Promote standby to primary
ssh standby.hft.local "systemctl start hft-trading-engine-primary"

# Update service discovery
consul kv put service/trading/endpoint "standby.hft.local:5555"

# Update load balancer
curl -X POST http://lb.hft.local/api/update \
    -d '{"service":"trading","endpoint":"standby.hft.local:5555"}'

echo "$(date): Failover initiated"
```

Step 3: Recover State (10-25 seconds)
```bash
#!/bin/bash
# /opt/hft/scripts/recover_trading_state.sh

echo "Recovering trading engine state..."

# Restore last checkpoint
LAST_CHECKPOINT=$(ls -t /var/lib/hft/checkpoints/trading_*.ckpt | head -1)
echo "Restoring from: $LAST_CHECKPOINT"

# Load checkpoint into new primary
/opt/hft/bin/trading_engine --restore $LAST_CHECKPOINT &

# Wait for initialization
sleep 5

# Replay WAL from checkpoint to current
/opt/hft/scripts/replay_wal.sh $LAST_CHECKPOINT

# Reconcile positions
/opt/hft/scripts/reconcile_positions.sh

echo "State recovery complete"
```

Step 4: Validate Recovery (25-30 seconds)
```bash
#!/bin/bash
# /opt/hft/scripts/validate_trading_recovery.sh

echo "Validating trading engine recovery..."

# Check health endpoint
HEALTH=$(curl -s http://standby.hft.local:8080/health)
if [[ $HEALTH != *"OK"* ]]; then
    echo "ERROR: Health check failed"
    exit 1
fi

# Verify position accuracy
/opt/hft/scripts/verify_positions.sh

# Test order submission
/opt/hft/scripts/test_order.sh

# Check market data connectivity
/opt/hft/scripts/check_market_data.sh

echo "Validation complete - Trading engine operational"
```

Complete Recovery Script:
```bash
#!/bin/bash
# /opt/hft/scripts/recover_trading_engine_complete.sh

set -e  # Exit on error

START_TIME=$(date +%s)

echo "=== TRADING ENGINE RECOVERY ==="
echo "Start time: $(date)"

# Step 1: Detection (already occurred)
echo "[Step 1/4] Failure detected"

# Step 2: Failover
echo "[Step 2/4] Initiating failover..."
/opt/hft/scripts/failover_trading_engine.sh

# Step 3: State Recovery
echo "[Step 3/4] Recovering state..."
/opt/hft/scripts/recover_trading_state.sh

# Step 4: Validation
echo "[Step 4/4] Validating recovery..."
/opt/hft/scripts/validate_trading_recovery.sh

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

echo "=== RECOVERY COMPLETE ==="
echo "End time: $(date)"
echo "Total duration: ${DURATION} seconds"

# Check RTO compliance
if [ $DURATION -le 30 ]; then
    echo "RTO MET (target: 30s, actual: ${DURATION}s)"
else
    echo "RTO VIOLATED (target: 30s, actual: ${DURATION}s)"
    /opt/hft/scripts/send_alert.sh "RTO_VIOLATION" \
        "Trading engine recovery took ${DURATION}s"
fi

# Log recovery event
echo "{\"timestamp\":\"$(date -Iseconds)\",\"component\":\"trading_engine\",\"duration\":${DURATION},\"status\":\"success\"}" >> /var/log/hft/recovery_events.json
```

4.2 ORDER MANAGEMENT RECOVERY
------------------------------

Procedure: RECOVER-OMS-001
Priority: CRITICAL
RTO: 45 seconds
RPO: 0 seconds

Recovery Script: /opt/hft/scripts/recover_oms.sh

```bash
#!/bin/bash
# Order Management System Recovery

echo "=== OMS RECOVERY INITIATED ==="

# 1. Stop all order processing
echo "Stopping order processing..."
redis-cli SET oms:accepting_orders false

# 2. Snapshot current orders
echo "Snapshotting current orders..."
psql -d trading -c "
    CREATE TABLE orders_recovery_$(date +%Y%m%d_%H%M%S) AS
    SELECT * FROM orders WHERE status IN ('PENDING', 'PARTIAL');
"

# 3. Reconcile with exchange
echo "Reconciling with exchange..."
/opt/hft/scripts/reconcile_exchange_orders.py

# 4. Restart OMS
echo "Restarting OMS..."
systemctl restart hft-oms

# Wait for startup
sleep 10

# 5. Reload active orders
echo "Reloading active orders..."
psql -d trading -c "
    SELECT load_active_orders();
"

# 6. Resume order processing
echo "Resuming order processing..."
redis-cli SET oms:accepting_orders true

# 7. Validate
echo "Validating OMS recovery..."
ORDER_COUNT=$(redis-cli GET oms:active_order_count)
echo "Active orders: $ORDER_COUNT"

if [ -z "$ORDER_COUNT" ]; then
    echo "ERROR: OMS validation failed"
    exit 1
fi

echo "=== OMS RECOVERY COMPLETE ==="
```

4.3 RISK ENGINE RECOVERY
-------------------------

Procedure: RECOVER-RISK-001
Priority: CRITICAL
RTO: 60 seconds
RPO: 5 seconds

Recovery Script: /opt/hft/scripts/recover_risk_engine.sh

```bash
#!/bin/bash
# Risk Management Engine Recovery

echo "=== RISK ENGINE RECOVERY ==="

# 1. Enable fail-safe mode (reject all orders)
echo "Enabling fail-safe mode..."
redis-cli SET risk:failsafe true
redis-cli SET risk:allow_trading false

# 2. Restore risk parameters
echo "Restoring risk parameters..."
/opt/hft/scripts/restore_risk_params.sh

# 3. Recalculate current positions
echo "Recalculating positions..."
python3 /opt/hft/scripts/calculate_positions.py

# 4. Recalculate exposures
echo "Recalculating exposures..."
python3 /opt/hft/scripts/calculate_exposures.py

# 5. Verify risk limits
echo "Verifying risk limits..."
/opt/hft/scripts/verify_risk_limits.sh

# 6. Restart risk engine
echo "Restarting risk engine..."
systemctl restart hft-risk-engine

sleep 5

# 7. Validate risk calculations
echo "Validating risk calculations..."
POSITION_DELTA=$(psql -d trading -t -c "
    SELECT SUM(ABS(calculated_position - actual_position))
    FROM position_reconciliation;
" | tr -d ' ')

if (( $(echo "$POSITION_DELTA > 0.01" | bc -l) )); then
    echo "ERROR: Position reconciliation failed (delta: $POSITION_DELTA)"
    exit 1
fi

# 8. Disable fail-safe mode
echo "Disabling fail-safe mode..."
redis-cli SET risk:failsafe false
redis-cli SET risk:allow_trading true

echo "=== RISK ENGINE RECOVERY COMPLETE ==="
```

================================================================================
5. DATABASE RECOVERY PROCEDURES
================================================================================

5.1 POSTGRESQL RECOVERY
------------------------

Scenario 1: Point-in-Time Recovery (PITR)
------------------------------------------

Script: /opt/hft/scripts/pitr_recovery.sh

```bash
#!/bin/bash
# PostgreSQL Point-in-Time Recovery

TARGET_TIME=$1  # Format: 2025-01-15 14:30:00

if [ -z "$TARGET_TIME" ]; then
    echo "Usage: $0 'YYYY-MM-DD HH:MM:SS'"
    exit 1
fi

echo "=== POSTGRESQL PITR RECOVERY ==="
echo "Target time: $TARGET_TIME"

# 1. Stop PostgreSQL
echo "Stopping PostgreSQL..."
systemctl stop postgresql

# 2. Backup current data directory
echo "Backing up current data..."
mv /var/lib/pgsql/data /var/lib/pgsql/data.backup.$(date +%s)

# 3. Restore base backup
echo "Restoring base backup..."
LATEST_BACKUP=$(ls -t /backup/postgres/base_* | head -1)
tar -xzf $LATEST_BACKUP -C /var/lib/pgsql/

# 4. Create recovery.conf
echo "Creating recovery configuration..."
cat > /var/lib/pgsql/data/recovery.conf <<EOF
restore_command = 'cp /backup/postgres/wal_archive/%f %p'
recovery_target_time = '$TARGET_TIME'
recovery_target_action = 'promote'
EOF

# 5. Start PostgreSQL in recovery mode
echo "Starting PostgreSQL in recovery mode..."
systemctl start postgresql

# 6. Monitor recovery
echo "Monitoring recovery progress..."
while true; do
    if psql -c "SELECT pg_is_in_recovery();" | grep -q "f"; then
        echo "Recovery complete - database promoted"
        break
    fi
    echo "Still recovering..."
    sleep 5
done

# 7. Validate data
echo "Validating recovered data..."
RECORD_COUNT=$(psql -d trading -t -c "SELECT COUNT(*) FROM trades WHERE created_at <= '$TARGET_TIME';")
echo "Records recovered: $RECORD_COUNT"

echo "=== PITR RECOVERY COMPLETE ==="
```

Scenario 2: Standby Promotion
------------------------------

Script: /opt/hft/scripts/promote_standby.sh

```bash
#!/bin/bash
# Promote PostgreSQL Standby to Primary

echo "=== PROMOTING STANDBY TO PRIMARY ==="

# 1. Verify standby status
echo "Verifying standby status..."
IS_STANDBY=$(psql -t -c "SELECT pg_is_in_recovery();")

if [[ $IS_STANDBY != *"t"* ]]; then
    echo "ERROR: This is not a standby server"
    exit 1
fi

# 2. Check replication lag
echo "Checking replication lag..."
LAG=$(psql -t -c "SELECT EXTRACT(EPOCH FROM (NOW() - pg_last_xact_replay_timestamp()));")
echo "Current lag: ${LAG} seconds"

if (( $(echo "$LAG > 5" | bc -l) )); then
    echo "WARNING: High replication lag (${LAG}s)"
    read -p "Continue with promotion? (yes/no) " CONFIRM
    if [[ $CONFIRM != "yes" ]]; then
        echo "Promotion cancelled"
        exit 1
    fi
fi

# 3. Trigger promotion
echo "Triggering promotion..."
pg_ctl promote -D /var/lib/pgsql/data

# Wait for promotion
sleep 5

# 4. Verify promotion
echo "Verifying promotion..."
IS_PRIMARY=$(psql -t -c "SELECT NOT pg_is_in_recovery();")

if [[ $IS_PRIMARY != *"t"* ]]; then
    echo "ERROR: Promotion failed"
    exit 1
fi

# 5. Update configuration
echo "Updating configuration..."
sed -i 's/hot_standby = on/hot_standby = off/' /var/lib/pgsql/data/postgresql.conf

# 6. Reload configuration
echo "Reloading configuration..."
psql -c "SELECT pg_reload_conf();"

# 7. Update service discovery
echo "Updating service discovery..."
consul kv put database/primary "$(hostname)"

echo "=== STANDBY PROMOTED TO PRIMARY ==="
```

5.2 REDIS RECOVERY
------------------

Script: /opt/hft/scripts/recover_redis.sh

```bash
#!/bin/bash
# Redis Recovery

echo "=== REDIS RECOVERY ==="

# 1. Stop Redis
echo "Stopping Redis..."
systemctl stop redis

# 2. Check data files
echo "Checking data files..."
if [ -f /var/lib/redis/dump.rdb ]; then
    echo "RDB file found: $(ls -lh /var/lib/redis/dump.rdb)"
    BACKUP_RDB="/var/lib/redis/dump.rdb.backup.$(date +%s)"
    cp /var/lib/redis/dump.rdb $BACKUP_RDB
fi

if [ -f /var/lib/redis/appendonly.aof ]; then
    echo "AOF file found: $(ls -lh /var/lib/redis/appendonly.aof)"

    # Check AOF integrity
    redis-check-aof --fix /var/lib/redis/appendonly.aof
fi

# 3. Restore from backup if needed
if [ ! -s /var/lib/redis/dump.rdb ] && [ ! -s /var/lib/redis/appendonly.aof ]; then
    echo "No data files found, restoring from backup..."
    LATEST_BACKUP=$(ls -t /backup/redis/dump.rdb.* | head -1)
    cp $LATEST_BACKUP /var/lib/redis/dump.rdb
fi

# 4. Start Redis
echo "Starting Redis..."
systemctl start redis

# Wait for startup
sleep 3

# 5. Validate recovery
echo "Validating recovery..."
KEY_COUNT=$(redis-cli DBSIZE | awk '{print $2}')
echo "Keys recovered: $KEY_COUNT"

if [ $KEY_COUNT -eq 0 ]; then
    echo "WARNING: No keys in database"
fi

# 6. Test basic operations
echo "Testing operations..."
redis-cli SET recovery_test "$(date)"
RESULT=$(redis-cli GET recovery_test)

if [ -z "$RESULT" ]; then
    echo "ERROR: Redis operations failing"
    exit 1
fi

redis-cli DEL recovery_test

echo "=== REDIS RECOVERY COMPLETE ==="
```

================================================================================
6. STATE RECOVERY & RECONCILIATION
================================================================================

6.1 POSITION RECONCILIATION
----------------------------

Script: /opt/hft/scripts/reconcile_positions.py

```python
#!/usr/bin/env python3
"""
Position Reconciliation
Reconciles internal positions with exchange positions
"""

import psycopg2
import redis
from datetime import datetime
import logging

class PositionReconciliation:
    def __init__(self):
        self.db = psycopg2.connect("dbname=trading user=hft")
        self.redis = redis.StrictRedis(host='localhost', port=6379, db=0)
        self.logger = logging.getLogger(__name__)

    def get_internal_positions(self):
        """Get positions from internal database"""
        cursor = self.db.cursor()
        cursor.execute("""
            SELECT symbol, SUM(quantity) as position
            FROM trades
            WHERE status = 'FILLED'
            GROUP BY symbol
        """)
        return {row[0]: row[1] for row in cursor.fetchall()}

    def get_exchange_positions(self):
        """Get positions from exchange APIs"""
        # Placeholder - implement actual exchange API calls
        positions = {}

        # Example: Query from exchange cache
        for key in self.redis.scan_iter("position:*"):
            symbol = key.decode().split(':')[1]
            position = float(self.redis.get(key))
            positions[symbol] = position

        return positions

    def reconcile(self):
        """Perform reconciliation"""
        self.logger.info("Starting position reconciliation")

        internal = self.get_internal_positions()
        exchange = self.get_exchange_positions()

        all_symbols = set(internal.keys()) | set(exchange.keys())
        discrepancies = []

        for symbol in all_symbols:
            internal_pos = internal.get(symbol, 0)
            exchange_pos = exchange.get(symbol, 0)
            diff = internal_pos - exchange_pos

            if abs(diff) > 0.001:  # Tolerance for floating point
                discrepancy = {
                    'symbol': symbol,
                    'internal': internal_pos,
                    'exchange': exchange_pos,
                    'difference': diff,
                    'timestamp': datetime.now().isoformat()
                }
                discrepancies.append(discrepancy)
                self.logger.warning(f"Position mismatch: {discrepancy}")

        if discrepancies:
            self.handle_discrepancies(discrepancies)
        else:
            self.logger.info("All positions reconciled successfully")

        return discrepancies

    def handle_discrepancies(self, discrepancies):
        """Handle position discrepancies"""
        cursor = self.db.cursor()

        for disc in discrepancies:
            # Log to reconciliation table
            cursor.execute("""
                INSERT INTO position_reconciliation
                (symbol, internal_position, exchange_position, difference, reconciliation_time)
                VALUES (%s, %s, %s, %s, NOW())
            """, (disc['symbol'], disc['internal'], disc['exchange'], disc['difference']))

            # Alert if difference is significant
            if abs(disc['difference']) > 100:  # Alert threshold
                self.send_alert(
                    f"CRITICAL: Large position discrepancy for {disc['symbol']}: "
                    f"{disc['difference']} shares"
                )

        self.db.commit()

    def send_alert(self, message):
        """Send alert for position discrepancy"""
        self.logger.critical(message)
        # Implement actual alerting (email, Slack, PagerDuty, etc.)

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    reconciler = PositionReconciliation()
    discrepancies = reconciler.reconcile()

    if discrepancies:
        print(f"Found {len(discrepancies)} position discrepancies")
        exit(1)
    else:
        print("Position reconciliation successful")
        exit(0)
```

================================================================================
7. RECOVERY VALIDATION & TESTING
================================================================================

7.1 POST-RECOVERY VALIDATION CHECKLIST
---------------------------------------

Script: /opt/hft/scripts/post_recovery_validation.sh

```bash
#!/bin/bash
# Post-Recovery Validation
# Comprehensive system validation after recovery

echo "=== POST-RECOVERY VALIDATION ==="
echo "Start time: $(date)"

VALIDATION_PASSED=0
VALIDATION_FAILED=0

# Function to run validation test
validate() {
    TEST_NAME=$1
    TEST_COMMAND=$2

    echo ""
    echo "Testing: $TEST_NAME"

    if eval $TEST_COMMAND; then
        echo "✓ PASSED: $TEST_NAME"
        ((VALIDATION_PASSED++))
    else
        echo "✗ FAILED: $TEST_NAME"
        ((VALIDATION_FAILED++))
    fi
}

# 1. Database Connectivity
validate "Database Connectivity" \
    "psql -d trading -c 'SELECT 1;' > /dev/null 2>&1"

# 2. Redis Connectivity
validate "Redis Connectivity" \
    "redis-cli PING | grep -q PONG"

# 3. Trading Engine Health
validate "Trading Engine Health" \
    "curl -sf http://localhost:8080/health | grep -q OK"

# 4. Market Data Feed
validate "Market Data Feed" \
    "redis-cli GET last_market_data_update | grep -q $(date +%Y-%m-%d)"

# 5. Order Management
validate "Order Management" \
    "curl -sf http://localhost:8081/health | grep -q OK"

# 6. Risk Engine
validate "Risk Engine" \
    "curl -sf http://localhost:8082/health | grep -q OK"

# 7. Position Accuracy
validate "Position Accuracy" \
    "/opt/hft/scripts/verify_positions.sh"

# 8. Data Integrity
validate "Data Integrity" \
    "psql -d trading -c 'SELECT check_data_integrity();' | grep -q OK"

# 9. Replication Status
validate "Replication Status" \
    "/opt/hft/scripts/check_replication.sh"

# 10. Network Connectivity
validate "Network Connectivity" \
    "ping -c 3 exchange.example.com > /dev/null 2>&1"

# Summary
echo ""
echo "=== VALIDATION SUMMARY ==="
echo "Tests Passed: $VALIDATION_PASSED"
echo "Tests Failed: $VALIDATION_FAILED"
echo "End time: $(date)"

if [ $VALIDATION_FAILED -gt 0 ]; then
    echo "STATUS: FAILED - System not ready for production"
    exit 1
else
    echo "STATUS: PASSED - System ready for production"
    exit 0
fi
```

================================================================================
8. EMERGENCY CONTACTS & ESCALATION
================================================================================

8.1 ESCALATION MATRIX
---------------------

Level 1 - Initial Response (0-5 minutes)
- On-Call Engineer
- Phone: +1-555-0100
- Email: oncall@trading.com

Level 2 - Technical Lead (5-15 minutes)
- Infrastructure Lead
- Phone: +1-555-0101
- Email: infra-lead@trading.com

Level 3 - Management (15-30 minutes)
- CTO
- Phone: +1-555-0200
- Email: cto@trading.com

Level 4 - Executive (30+ minutes)
- CEO / Risk Officer
- Phone: +1-555-0300

8.2 RECOVERY RUNBOOK REFERENCE
-------------------------------

Quick Reference:
- Trading Engine: RECOVER-TRADE-001
- Order Management: RECOVER-OMS-001
- Risk Engine: RECOVER-RISK-001
- Database: RECOVER-DB-001
- Market Data: RECOVER-MD-001

All runbooks located in: /opt/hft/runbooks/

================================================================================
END OF DOCUMENT
================================================================================
