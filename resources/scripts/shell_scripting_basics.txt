================================================================================
SHELL SCRIPTING BASICS FOR HFT SYSTEMS
================================================================================
Comprehensive Guide to Bash Scripting for High-Frequency Trading Infrastructure
Version: 1.0
Last Updated: 2025-11-25
================================================================================

TABLE OF CONTENTS
-----------------
1. Shell Scripting Fundamentals
2. Variables and Data Types
3. Control Structures
4. Functions and Modularity
5. Error Handling and Logging
6. File Operations
7. Process Management
8. Network Operations
9. String Manipulation
10. Advanced Techniques
11. HFT-Specific Examples

================================================================================
1. SHELL SCRIPTING FUNDAMENTALS
================================================================================

1.1 BASIC SCRIPT STRUCTURE
--------------------------

#!/bin/bash
################################################################################
# Script Name: basic_template.sh
# Description: Production-ready bash script template for HFT systems
# Author: HFT DevOps Team
# Version: 1.0
# Last Modified: 2025-11-25
################################################################################

# Enable strict error handling
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# set -x           # Uncomment for debug mode

# Script configuration
readonly SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_PID=$$
readonly TIMESTAMP="$(date +%Y%m%d_%H%M%S)"

# Global variables
LOG_FILE="/var/log/hft/${SCRIPT_NAME%.sh}_${TIMESTAMP}.log"
ERROR_COUNT=0
MAX_RETRIES=3

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Main execution
main() {
    setup
    execute_logic
    cleanup
}

# Setup function
setup() {
    log_info "Starting ${SCRIPT_NAME}"
    create_log_directory
    trap cleanup_on_error ERR
    trap cleanup_on_exit EXIT
}

# Execute main logic
execute_logic() {
    log_info "Executing main logic"
    # Your code here
}

# Cleanup function
cleanup() {
    log_info "Cleanup completed"
}

# Cleanup on error
cleanup_on_error() {
    log_error "Script failed at line $LINENO"
    cleanup
    exit 1
}

# Cleanup on exit
cleanup_on_exit() {
    log_info "Script exiting with status $?"
}

# Run main function
main "$@"

1.2 SHEBANG AND INTERPRETER SELECTION
-------------------------------------

# Standard bash
#!/bin/bash

# Portable shell (POSIX compliant)
#!/bin/sh

# Use env for better portability
#!/usr/bin/env bash

# Specific bash version requirement
#!/usr/bin/bash --version=4.0

# Python shebang for comparison
#!/usr/bin/env python3

1.3 SCRIPT PERMISSIONS AND EXECUTION
------------------------------------

# Make script executable
chmod +x script.sh

# Execute with explicit interpreter
bash script.sh

# Execute in current shell (source)
source script.sh
. script.sh

# Execute in subshell
(./script.sh)

# Execute with specific permissions
sudo -u hftuser ./script.sh

================================================================================
2. VARIABLES AND DATA TYPES
================================================================================

2.1 VARIABLE DECLARATION AND TYPES
----------------------------------

#!/bin/bash

# Simple variable assignment
SERVICE_NAME="market_data_feed"
PORT=8080
IS_PRODUCTION=true

# Read-only variables (constants)
readonly CONFIG_PATH="/etc/hft/config.conf"
readonly MAX_CONNECTIONS=10000

# Environment variables
export HFT_ENV="production"
export LOG_LEVEL="INFO"

# Command substitution
CURRENT_DATE=$(date +%Y-%m-%d)
HOSTNAME_VAR=$(hostname)
CPU_COUNT=$(nproc)

# Arithmetic operations
let "TOTAL = 100 + 50"
((COUNTER++))
((THREADS = CPU_COUNT * 2))

# Array declarations
declare -a EXCHANGES=("NYSE" "NASDAQ" "CME" "ICE")
declare -A LATENCIES  # Associative array

LATENCIES["NYSE"]=125
LATENCIES["NASDAQ"]=98
LATENCIES["CME"]=156

# Special variables
echo "Script name: $0"
echo "First argument: $1"
echo "All arguments: $@"
echo "Argument count: $#"
echo "Last exit status: $?"
echo "Current PID: $$"
echo "Background PID: $!"

2.2 VARIABLE SCOPE AND LIFETIME
-------------------------------

#!/bin/bash

# Global variable
GLOBAL_VAR="Available everywhere"

function_example() {
    # Local variable (function scope)
    local LOCAL_VAR="Only in function"

    # Access global variable
    echo "$GLOBAL_VAR"

    # Modify global variable
    GLOBAL_VAR="Modified in function"
}

# Export for child processes
export PARENT_VAR="Available to subprocesses"

2.3 PARAMETER EXPANSION AND MANIPULATION
----------------------------------------

#!/bin/bash

# Variable with default value
EXCHANGE="${EXCHANGE_NAME:-NYSE}"  # Use NYSE if EXCHANGE_NAME unset

# Variable with error on unset
REQUIRED_VAR="${API_KEY:?Error: API_KEY not set}"

# Alternative value
FALLBACK="${OPTIONAL_VAR:+Using alternative}"

# String length
MESSAGE="Market data received"
echo "Length: ${#MESSAGE}"

# Substring extraction
SYMBOL="AAPL.NASDAQ"
echo "${SYMBOL:0:4}"      # AAPL
echo "${SYMBOL:5}"        # NASDAQ

# Pattern removal
FILE="/path/to/data.csv"
echo "${FILE##*/}"        # data.csv (remove longest prefix)
echo "${FILE%.*}"         # /path/to/data (remove shortest suffix)
echo "${FILE%%.*}"        # /path/to/data (remove longest suffix)

# Pattern replacement
LOG_LINE="ERROR: Connection failed"
echo "${LOG_LINE/ERROR/WARNING}"           # Replace first
echo "${LOG_LINE//ERROR/CRITICAL}"         # Replace all
echo "${LOG_LINE/#ERROR/ALERT}"            # Replace at beginning
echo "${LOG_LINE/%failed/timeout}"         # Replace at end

# Case conversion (Bash 4+)
SYMBOL="aapl"
echo "${SYMBOL^^}"        # AAPL (uppercase)
echo "${SYMBOL,,}"        # aapl (lowercase)
echo "${SYMBOL^}"         # Aapl (capitalize first)

================================================================================
3. CONTROL STRUCTURES
================================================================================

3.1 CONDITIONAL STATEMENTS
--------------------------

#!/bin/bash

# Basic if-else
check_connection() {
    local host=$1
    local port=$2

    if timeout 2 bash -c "cat < /dev/null > /dev/tcp/${host}/${port}" 2>/dev/null; then
        echo "Connection to ${host}:${port} successful"
        return 0
    else
        echo "Connection to ${host}:${port} failed"
        return 1
    fi
}

# If-elif-else chain
check_market_status() {
    local hour=$(date +%H)

    if [ $hour -lt 9 ]; then
        echo "Pre-market"
    elif [ $hour -ge 9 ] && [ $hour -lt 16 ]; then
        echo "Market open"
    elif [ $hour -ge 16 ] && [ $hour -lt 20 ]; then
        echo "After-hours"
    else
        echo "Market closed"
    fi
}

# Test operators
test_operators() {
    local file=$1
    local num=$2

    # File tests
    [ -f "$file" ]      # File exists and is regular file
    [ -d "$file" ]      # Directory exists
    [ -r "$file" ]      # Readable
    [ -w "$file" ]      # Writable
    [ -x "$file" ]      # Executable
    [ -s "$file" ]      # File exists and not empty
    [ -L "$file" ]      # Symbolic link

    # Numeric comparisons
    [ $num -eq 100 ]    # Equal
    [ $num -ne 100 ]    # Not equal
    [ $num -gt 50 ]     # Greater than
    [ $num -lt 200 ]    # Less than
    [ $num -ge 100 ]    # Greater or equal
    [ $num -le 100 ]    # Less or equal

    # String comparisons
    [ -z "$str" ]       # String is empty
    [ -n "$str" ]       # String is not empty
    [ "$str1" = "$str2" ]   # Strings equal
    [ "$str1" != "$str2" ]  # Strings not equal
    [ "$str1" \< "$str2" ]  # Lexicographic less than

    # Logical operators
    [ $num -gt 50 ] && [ $num -lt 150 ]  # AND
    [ $num -lt 50 ] || [ $num -gt 150 ]  # OR
    [ ! -f "$file" ]                      # NOT
}

# Double bracket syntax (bash specific, more features)
advanced_tests() {
    # Pattern matching
    [[ "$SYMBOL" == AAPL* ]]

    # Regex matching
    [[ "$IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]

    # No word splitting or globbing
    [[ -f $file_with_spaces ]]
}

# Case statement
process_message_type() {
    local msg_type=$1

    case $msg_type in
        TRADE)
            process_trade_message
            ;;
        QUOTE)
            process_quote_message
            ;;
        ORDER_ACK|ORDER_FILL)
            process_order_response
            ;;
        HEARTBEAT)
            update_heartbeat_timestamp
            ;;
        *)
            log_error "Unknown message type: $msg_type"
            return 1
            ;;
    esac
}

3.2 LOOPS
---------

#!/bin/bash

# For loop - traditional syntax
for i in 1 2 3 4 5; do
    echo "Iteration $i"
done

# For loop - range
for i in {1..10}; do
    echo "Number $i"
done

# For loop - range with step
for i in {0..100..10}; do
    echo "Count: $i"
done

# For loop - C-style
for ((i=0; i<10; i++)); do
    echo "Index $i"
done

# For loop - array iteration
EXCHANGES=("NYSE" "NASDAQ" "CME" "ICE")
for exchange in "${EXCHANGES[@]}"; do
    echo "Processing $exchange"
done

# For loop - file iteration
for file in /var/log/hft/*.log; do
    if [ -f "$file" ]; then
        process_log_file "$file"
    fi
done

# While loop
while [ $counter -lt 100 ]; do
    echo "Counter: $counter"
    ((counter++))
done

# While loop - reading file
while IFS= read -r line; do
    echo "Processing: $line"
done < input.txt

# While loop - reading command output
netstat -an | while read proto recv send local foreign state; do
    if [[ "$state" == "ESTABLISHED" ]]; then
        echo "Active connection: $local -> $foreign"
    fi
done

# Until loop
retry_count=0
until ping -c 1 exchange.server.com &>/dev/null; do
    echo "Waiting for server to respond..."
    ((retry_count++))
    if [ $retry_count -ge $MAX_RETRIES ]; then
        log_error "Server unreachable after $MAX_RETRIES attempts"
        exit 1
    fi
    sleep 5
done

# Loop control
for file in *.dat; do
    if [ ! -f "$file" ]; then
        continue  # Skip to next iteration
    fi

    if grep -q "CRITICAL_ERROR" "$file"; then
        break  # Exit loop immediately
    fi

    process_file "$file"
done

# Nested loops
for exchange in "${EXCHANGES[@]}"; do
    for symbol in "${SYMBOLS[@]}"; do
        fetch_quote "$exchange" "$symbol"
    done
done

================================================================================
4. FUNCTIONS AND MODULARITY
================================================================================

4.1 FUNCTION DECLARATION AND USAGE
----------------------------------

#!/bin/bash

# Basic function declaration
function greet {
    echo "Hello, World!"
}

# Alternative syntax (POSIX compatible)
greet() {
    echo "Hello, World!"
}

# Function with parameters
connect_to_exchange() {
    local exchange=$1
    local port=$2
    local timeout=${3:-10}  # Default timeout of 10 seconds

    log_info "Connecting to $exchange on port $port"

    if timeout $timeout bash -c "cat < /dev/null > /dev/tcp/localhost/${port}"; then
        log_info "Successfully connected to $exchange"
        return 0
    else
        log_error "Failed to connect to $exchange"
        return 1
    fi
}

# Function with return value
calculate_latency() {
    local start_time=$1
    local end_time=$2

    local latency_us=$((end_time - start_time))
    echo $latency_us  # Return via stdout
}

# Function with multiple return values
get_market_stats() {
    local symbol=$1

    # Simulate fetching data
    local volume=1000000
    local price=150.50
    local change=2.5

    # Return multiple values as space-separated string
    echo "$volume $price $change"
}

# Using the function
read volume price change <<< $(get_market_stats "AAPL")
echo "Volume: $volume, Price: $price, Change: $change"

4.2 ADVANCED FUNCTION TECHNIQUES
--------------------------------

#!/bin/bash

# Function with named parameters
process_order() {
    # Parse named parameters
    while [[ $# -gt 0 ]]; do
        case $1 in
            --symbol)
                local symbol="$2"
                shift 2
                ;;
            --quantity)
                local quantity="$2"
                shift 2
                ;;
            --price)
                local price="$2"
                shift 2
                ;;
            --side)
                local side="$2"
                shift 2
                ;;
            *)
                log_error "Unknown parameter: $1"
                return 1
                ;;
        esac
    done

    # Validate required parameters
    if [ -z "$symbol" ] || [ -z "$quantity" ] || [ -z "$side" ]; then
        log_error "Missing required parameters"
        return 1
    fi

    log_info "Processing order: $side $quantity $symbol @ $price"
}

# Usage
process_order --symbol AAPL --quantity 100 --side BUY --price 150.00

# Recursive function
calculate_fibonacci() {
    local n=$1

    if [ $n -le 1 ]; then
        echo $n
    else
        local prev1=$(calculate_fibonacci $((n-1)))
        local prev2=$(calculate_fibonacci $((n-2)))
        echo $((prev1 + prev2))
    fi
}

# Function overriding and calling original
original_log() {
    echo "$1"
}

# Save original function
eval "$(echo "original_log_backup()"; declare -f original_log | tail -n +2)"

# Override with enhanced version
original_log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    original_log_backup "$1"
}

4.3 LIBRARY AND SOURCE FILES
----------------------------

# File: hft_lib.sh
#!/bin/bash

# Common library functions for HFT scripts

# Initialize library
init_hft_lib() {
    readonly HFT_LIB_VERSION="1.0"
    log_info "HFT Library v${HFT_LIB_VERSION} loaded"
}

# Logging functions
log_message() {
    local level=$1
    shift
    local message="$@"
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [$level] $message" | tee -a "$LOG_FILE"
}

log_info() { log_message "INFO" "$@"; }
log_warn() { log_message "WARN" "$@"; }
log_error() { log_message "ERROR" "$@"; }

# File: main_script.sh
#!/bin/bash

# Source the library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/hft_lib.sh"

# Initialize
init_hft_lib

# Use library functions
log_info "Starting main script"

================================================================================
5. ERROR HANDLING AND LOGGING
================================================================================

5.1 COMPREHENSIVE ERROR HANDLING
--------------------------------

#!/bin/bash

# Enable strict error handling
set -euo pipefail
IFS=$'\n\t'

# Error handling configuration
readonly ERROR_LOG="/var/log/hft/errors.log"
declare -i ERROR_COUNT=0
declare -i WARNING_COUNT=0

# Custom error handler
handle_error() {
    local exit_code=$?
    local line_number=$1
    local bash_lineno=$2
    local function_name=$3
    local command="$4"

    ((ERROR_COUNT++))

    log_error "Error occurred in function '${function_name}' at line ${line_number}"
    log_error "Exit code: ${exit_code}"
    log_error "Command: ${command}"
    log_error "Call stack: ${BASH_LINENO[*]}"

    # Send alert if critical
    if [ $ERROR_COUNT -ge 5 ]; then
        send_critical_alert "Multiple errors detected: $ERROR_COUNT errors"
    fi

    cleanup_on_error
    exit $exit_code
}

# Set error trap
trap 'handle_error ${LINENO} ${BASH_LINENO} "${FUNCNAME}" "$BASH_COMMAND"' ERR

# Retry mechanism
retry_with_backoff() {
    local max_attempts=$1
    shift
    local command=("$@")
    local attempt=1
    local delay=1

    while [ $attempt -le $max_attempts ]; do
        log_info "Attempt $attempt of $max_attempts: ${command[*]}"

        if "${command[@]}"; then
            log_info "Command succeeded on attempt $attempt"
            return 0
        else
            local exit_code=$?
            log_warn "Command failed with exit code $exit_code"

            if [ $attempt -eq $max_attempts ]; then
                log_error "All $max_attempts attempts failed"
                return $exit_code
            fi

            log_info "Waiting ${delay}s before retry..."
            sleep $delay
            ((attempt++))
            ((delay *= 2))  # Exponential backoff
        fi
    done
}

# Usage
retry_with_backoff 5 curl -f https://api.exchange.com/data

# Safe command execution
safe_execute() {
    local command="$@"
    local output
    local exit_code

    log_info "Executing: $command"

    if output=$($command 2>&1); then
        exit_code=$?
        log_info "Command succeeded: $command"
        echo "$output"
        return $exit_code
    else
        exit_code=$?
        log_error "Command failed: $command"
        log_error "Output: $output"
        return $exit_code
    fi
}

5.2 PRODUCTION-GRADE LOGGING
----------------------------

#!/bin/bash

# Logging configuration
readonly LOG_DIR="/var/log/hft"
readonly LOG_FILE="${LOG_DIR}/$(basename $0 .sh)_$(date +%Y%m%d).log"
readonly LOG_LEVEL="${LOG_LEVEL:-INFO}"  # DEBUG, INFO, WARN, ERROR

# Log levels
declare -A LOG_LEVELS=([DEBUG]=0 [INFO]=1 [WARN]=2 [ERROR]=3)

# Create log directory
mkdir -p "$LOG_DIR"

# Comprehensive logging function
log() {
    local level=$1
    shift
    local message="$@"

    # Check if log level is enabled
    if [ ${LOG_LEVELS[$level]} -ge ${LOG_LEVELS[$LOG_LEVEL]} ]; then
        local timestamp=$(date +'%Y-%m-%d %H:%M:%S.%3N')
        local caller="${BASH_SOURCE[2]##*/}:${BASH_LINENO[1]}"
        local pid=$$

        # Format: timestamp [LEVEL] [PID] [caller] message
        printf "%s [%5s] [%6d] [%s] %s\n" \
            "$timestamp" "$level" "$pid" "$caller" "$message" \
            | tee -a "$LOG_FILE"

        # Also log to syslog for critical errors
        if [ "$level" = "ERROR" ]; then
            logger -t "$(basename $0)" -p user.error "$message"
        fi
    fi
}

# Convenience functions
log_debug() { log "DEBUG" "$@"; }
log_info()  { log "INFO"  "$@"; }
log_warn()  { log "WARN"  "$@"; }
log_error() { log "ERROR" "$@"; }

# Log rotation
rotate_logs() {
    local max_size_mb=${1:-100}
    local max_files=${2:-10}

    if [ -f "$LOG_FILE" ]; then
        local size_mb=$(($(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE") / 1024 / 1024))

        if [ $size_mb -ge $max_size_mb ]; then
            log_info "Rotating log file (size: ${size_mb}MB)"

            # Rotate existing logs
            for i in $(seq $((max_files - 1)) -1 1); do
                if [ -f "${LOG_FILE}.$i" ]; then
                    mv "${LOG_FILE}.$i" "${LOG_FILE}.$((i + 1))"
                fi
            done

            # Move current log
            mv "$LOG_FILE" "${LOG_FILE}.1"

            # Compress old logs
            gzip -f "${LOG_FILE}.1"

            # Remove oldest logs
            find "$LOG_DIR" -name "$(basename $LOG_FILE).*" -type f | \
                sort -r | tail -n +$((max_files + 1)) | xargs rm -f
        fi
    fi
}

# Performance logging
log_performance() {
    local operation=$1
    local start_time=$2
    local end_time=${3:-$(date +%s%N)}

    local duration_ns=$((end_time - start_time))
    local duration_ms=$((duration_ns / 1000000))

    log_info "Performance: $operation completed in ${duration_ms}ms"

    # Log to performance metrics file
    echo "$(date +%s),$operation,$duration_ms" >> "${LOG_DIR}/performance_metrics.csv"
}

# Structured logging (JSON format)
log_json() {
    local level=$1
    local message=$2
    shift 2

    local json_data='{'
    json_data+="\"timestamp\":\"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\","
    json_data+="\"level\":\"$level\","
    json_data+="\"message\":\"$message\","
    json_data+="\"pid\":$$,"
    json_data+="\"hostname\":\"$(hostname)\","

    # Add custom fields
    while [[ $# -gt 0 ]]; do
        json_data+="\"$1\":\"$2\","
        shift 2
    done

    json_data="${json_data%,}}"

    echo "$json_data" >> "${LOG_DIR}/structured.log"
}

# Usage
log_json "INFO" "Order executed" \
    "symbol" "AAPL" \
    "quantity" "100" \
    "price" "150.50"

================================================================================
6. FILE OPERATIONS
================================================================================

6.1 READING FILES
-----------------

#!/bin/bash

# Read entire file into variable
content=$(cat file.txt)

# Read file line by line
while IFS= read -r line; do
    echo "Line: $line"
done < file.txt

# Read file with custom delimiter
while IFS=',' read -r symbol price volume; do
    echo "Symbol: $symbol, Price: $price, Volume: $volume"
done < market_data.csv

# Read specific lines
head -n 10 file.txt          # First 10 lines
tail -n 20 file.txt          # Last 20 lines
sed -n '50,100p' file.txt    # Lines 50 to 100

# Read file into array
mapfile -t lines < file.txt
# or
readarray -t lines < file.txt

# Process large files efficiently
process_large_file() {
    local file=$1
    local chunk_size=10000

    split -l $chunk_size "$file" chunk_

    for chunk in chunk_*; do
        process_chunk "$chunk" &
    done

    wait
    rm -f chunk_*
}

6.2 WRITING FILES
-----------------

#!/bin/bash

# Write to file (overwrite)
echo "New content" > file.txt

# Append to file
echo "Additional content" >> file.txt

# Write multiple lines
cat > config.txt <<EOF
server_address=192.168.1.100
server_port=8080
timeout=30
EOF

# Write with here-document and variable expansion
cat > output.txt <<EOF
Hostname: $(hostname)
Date: $(date)
User: $USER
EOF

# Write without variable expansion
cat > literal.txt <<'EOF'
This is $VARIABLE - will be literal
No expansion here
EOF

# Atomic write (safer for critical files)
atomic_write() {
    local target_file=$1
    local content="$2"
    local temp_file="${target_file}.tmp.$$"

    echo "$content" > "$temp_file"

    if [ $? -eq 0 ]; then
        mv "$temp_file" "$target_file"
        log_info "File written atomically: $target_file"
    else
        rm -f "$temp_file"
        log_error "Failed to write file: $target_file"
        return 1
    fi
}

# Bulk write with buffering
buffered_write() {
    local output_file=$1
    local buffer=""
    local buffer_size=0
    local max_buffer_size=1000

    while read -r line; do
        buffer+="$line\n"
        ((buffer_size++))

        if [ $buffer_size -ge $max_buffer_size ]; then
            echo -e "$buffer" >> "$output_file"
            buffer=""
            buffer_size=0
        fi
    done

    # Flush remaining buffer
    if [ $buffer_size -gt 0 ]; then
        echo -e "$buffer" >> "$output_file"
    fi
}

6.3 FILE MANIPULATION
--------------------

#!/bin/bash

# Check file existence and type
if [ -f "$file" ]; then echo "Regular file exists"; fi
if [ -d "$dir" ]; then echo "Directory exists"; fi
if [ -L "$link" ]; then echo "Symbolic link"; fi
if [ -e "$path" ]; then echo "Path exists"; fi

# File permissions
chmod 755 script.sh          # rwxr-xr-x
chmod u+x script.sh          # Add execute for user
chmod go-w file.txt          # Remove write for group and others
chown hftuser:hftgroup file  # Change ownership

# File information
stat file.txt                # Detailed file info
ls -lh file.txt             # Human-readable size
file file.txt               # File type
du -h file.txt              # Disk usage

# Copy, move, remove
cp -p source dest           # Preserve attributes
cp -r dir1 dir2             # Recursive copy
mv old new                  # Move/rename
rm -f file                  # Force remove
rm -rf dir                  # Recursive force remove

# Create files and directories
touch file.txt              # Create empty file
mkdir -p /path/to/dir       # Create with parents
mktemp                      # Create temp file
mktemp -d                   # Create temp directory

# Find and process files
find /var/log/hft -name "*.log" -mtime +7 -exec gzip {} \;
find . -type f -size +100M  # Files larger than 100MB
find . -name "*.tmp" -delete # Delete all .tmp files

# Advanced find with multiple conditions
find /data/market_data \
    -type f \
    \( -name "*.csv" -o -name "*.dat" \) \
    -mtime -1 \
    -size +1M \
    -exec process_file {} \;

# File locking
acquire_lock() {
    local lock_file=$1
    local timeout=${2:-30}
    local elapsed=0

    while [ $elapsed -lt $timeout ]; do
        if mkdir "$lock_file" 2>/dev/null; then
            trap "rm -rf $lock_file" EXIT
            return 0
        fi
        sleep 1
        ((elapsed++))
    done

    log_error "Failed to acquire lock: $lock_file"
    return 1
}

# Usage
if acquire_lock "/tmp/market_data.lock"; then
    process_market_data
fi

================================================================================
7. PROCESS MANAGEMENT
================================================================================

7.1 PROCESS CONTROL
-------------------

#!/bin/bash

# Start background process
command &
background_pid=$!

# Wait for background process
wait $background_pid

# Start multiple background processes
for i in {1..5}; do
    process_chunk $i &
    pids[i]=$!
done

# Wait for all background processes
for pid in ${pids[@]}; do
    wait $pid
done

# Process monitoring
monitor_process() {
    local pid=$1

    while kill -0 $pid 2>/dev/null; do
        echo "Process $pid is running"
        sleep 5
    done

    echo "Process $pid has terminated"
}

# Check if process is running
is_process_running() {
    local process_name=$1
    pgrep -x "$process_name" > /dev/null
}

# Kill process gracefully
kill_gracefully() {
    local pid=$1
    local timeout=30

    # Try SIGTERM first
    kill -TERM $pid 2>/dev/null || return 1

    # Wait for process to terminate
    local elapsed=0
    while kill -0 $pid 2>/dev/null && [ $elapsed -lt $timeout ]; do
        sleep 1
        ((elapsed++))
    done

    # Force kill if still running
    if kill -0 $pid 2>/dev/null; then
        log_warn "Process $pid did not terminate, sending SIGKILL"
        kill -KILL $pid
    fi
}

# Process resource limits
ulimit -n 65535              # Max open files
ulimit -u 4096               # Max user processes
ulimit -v unlimited          # Virtual memory

# Set nice priority
nice -n 10 cpu_intensive_task    # Lower priority
nice -n -10 critical_task        # Higher priority (requires root)

# CPU affinity
taskset -c 0,1 trading_engine    # Pin to CPU cores 0 and 1

7.2 PROCESS INFORMATION
-----------------------

#!/bin/bash

# Get process information
ps aux | grep trading_engine
pgrep -a trading_engine
pidof trading_engine

# Process tree
pstree -p $$

# Resource usage
top -b -n 1 -p $pid
htop -p $pid

# Memory usage
ps -o pid,user,%mem,rss,vsz -p $pid

# Open files
lsof -p $pid
ls -l /proc/$pid/fd

# Network connections
netstat -anp | grep $pid
ss -anp | grep $pid
lsof -i -P -n | grep $pid

# Get process stats
get_process_stats() {
    local pid=$1

    if [ ! -d "/proc/$pid" ]; then
        echo "Process $pid not found"
        return 1
    fi

    local comm=$(cat /proc/$pid/comm)
    local state=$(awk '{print $3}' /proc/$pid/stat)
    local mem_kb=$(awk '{print $2}' /proc/$pid/statm)
    local cpu_time=$(awk '{print $14 + $15}' /proc/$pid/stat)

    echo "Process: $comm"
    echo "PID: $pid"
    echo "State: $state"
    echo "Memory: $((mem_kb * 4))KB"
    echo "CPU Time: ${cpu_time} jiffies"
}

================================================================================
8. NETWORK OPERATIONS
================================================================================

8.1 NETWORK CONNECTIVITY
------------------------

#!/bin/bash

# Test network connectivity
ping -c 4 exchange.server.com

# TCP connection test
test_tcp_connection() {
    local host=$1
    local port=$2
    local timeout=${3:-5}

    if timeout $timeout bash -c "cat < /dev/null > /dev/tcp/${host}/${port}" 2>/dev/null; then
        echo "Connection to $host:$port successful"
        return 0
    else
        echo "Connection to $host:$port failed"
        return 1
    fi
}

# Network latency measurement
measure_latency() {
    local host=$1
    local count=${2:-10}

    ping -c $count $host | tail -1 | awk '{print $4}' | cut -d '/' -f 2
}

# HTTP request
http_get() {
    local url=$1
    curl -s -S "$url"
}

http_post() {
    local url=$1
    local data=$2
    curl -s -S -X POST -H "Content-Type: application/json" -d "$data" "$url"
}

# Download file
download_file() {
    local url=$1
    local output=$2
    local max_time=${3:-300}

    curl -L -o "$output" --max-time $max_time "$url"
}

# Check URL availability
check_url() {
    local url=$1
    local http_code=$(curl -s -o /dev/null -w "%{http_code}" "$url")

    if [ "$http_code" -eq 200 ]; then
        echo "URL available: $url"
        return 0
    else
        echo "URL returned code $http_code: $url"
        return 1
    fi
}

8.2 NETWORK INFORMATION
-----------------------

#!/bin/bash

# Get IP address
get_ip_address() {
    local interface=${1:-eth0}
    ip addr show $interface | grep "inet " | awk '{print $2}' | cut -d/ -f1
}

# Get MAC address
get_mac_address() {
    local interface=${1:-eth0}
    ip addr show $interface | grep "link/ether" | awk '{print $2}'
}

# Network interface stats
netstat -i
ip -s link

# Active connections
netstat -an | grep ESTABLISHED
ss -tan state established

# Listening ports
netstat -tln
ss -tln

# Network throughput test
test_throughput() {
    local host=$1
    local port=$2
    local duration=${3:-10}

    # Requires iperf
    iperf -c $host -p $port -t $duration
}

================================================================================
9. STRING MANIPULATION
================================================================================

9.1 STRING OPERATIONS
---------------------

#!/bin/bash

# Concatenation
str1="Hello"
str2="World"
combined="${str1} ${str2}"

# Length
echo ${#str1}

# Substring extraction
text="AAPL.NASDAQ.US"
echo ${text:0:4}              # AAPL
echo ${text:5:6}              # NASDAQ
echo ${text:(-2)}             # US (from end)

# String replacement
message="The price is 100.50"
echo ${message/100.50/200.75}     # Replace first
echo ${message//./,}              # Replace all dots with commas

# Pattern matching and removal
file="/path/to/data.csv.gz"
echo ${file##*/}              # data.csv.gz (basename)
echo ${file%.*}               # /path/to/data.csv (remove extension)
echo ${file%%.*}              # /path/to/data (remove all extensions)
echo ${file#*/}               # path/to/data.csv.gz (remove first /)

# Case conversion
symbol="aapl"
echo ${symbol^^}              # AAPL (to uppercase)
echo ${symbol,,}              # aapl (to lowercase)
echo ${symbol^}               # Aapl (capitalize first letter)

# String trimming
trim() {
    local var="$1"
    var="${var#"${var%%[![:space:]]*}"}"  # Remove leading whitespace
    var="${var%"${var##*[![:space:]]}"}"  # Remove trailing whitespace
    echo "$var"
}

# Split string into array
IFS=',' read -ra parts <<< "AAPL,GOOGL,MSFT"
for symbol in "${parts[@]}"; do
    echo "Symbol: $symbol"
done

# Join array into string
join_array() {
    local delimiter=$1
    shift
    local first=$1
    shift
    printf "%s" "$first" "${@/#/$delimiter}"
}

symbols=("AAPL" "GOOGL" "MSFT")
result=$(join_array "," "${symbols[@]}")
echo $result  # AAPL,GOOGL,MSFT

9.2 ADVANCED STRING PROCESSING
------------------------------

#!/bin/bash

# Regular expression matching
if [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
    echo "Valid email"
fi

# Extract IP address
log_line="Connection from 192.168.1.100:8080"
if [[ "$log_line" =~ ([0-9]{1,3}\.){3}[0-9]{1,3} ]]; then
    ip="${BASH_REMATCH[0]}"
    echo "IP: $ip"
fi

# Parse CSV with embedded commas
parse_csv_line() {
    local line="$1"
    local -a fields
    local field=""
    local in_quotes=false

    while IFS= read -r -n1 char; do
        if [ "$char" = '"' ]; then
            in_quotes=$( [ "$in_quotes" = true ] && echo false || echo true )
        elif [ "$char" = ',' ] && [ "$in_quotes" = false ]; then
            fields+=("$field")
            field=""
        else
            field+="$char"
        fi
    done <<< "$line"

    fields+=("$field")
    printf '%s\n' "${fields[@]}"
}

# URL encoding
url_encode() {
    local string="$1"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0; pos<strlen; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] )
                o="${c}"
                ;;
            * )
                printf -v o '%%%02x' "'$c"
                ;;
        esac
        encoded+="${o}"
    done

    echo "$encoded"
}

# Parse query string
parse_query_string() {
    local query="$1"
    declare -gA QUERY_PARAMS

    IFS='&' read -ra pairs <<< "$query"
    for pair in "${pairs[@]}"; do
        IFS='=' read -r key value <<< "$pair"
        QUERY_PARAMS[$key]=$value
    done
}

================================================================================
10. ADVANCED TECHNIQUES
================================================================================

10.1 COMMAND SUBSTITUTION AND SUBSHELLS
---------------------------------------

#!/bin/bash

# Command substitution (preferred method)
current_date=$(date +%Y-%m-%d)
file_count=$(ls -1 | wc -l)

# Backticks (old method, avoid)
current_date=`date +%Y-%m-%d`

# Process substitution
diff <(sort file1.txt) <(sort file2.txt)

# Compare outputs
comm -12 <(cut -d',' -f1 file1.csv | sort) <(cut -d',' -f1 file2.csv | sort)

# Subshell execution
(
    cd /tmp
    process_data
)
# Still in original directory

# Command grouping in current shell
{
    echo "Starting process"
    process_data
    echo "Process complete"
} >> logfile.txt

10.2 PARALLEL PROCESSING
-----------------------

#!/bin/bash

# GNU Parallel
parallel_process_files() {
    find /data -name "*.csv" | parallel -j 8 process_file {}
}

# Bash parallel using xargs
find /data -name "*.csv" | xargs -P 8 -I {} process_file {}

# Manual parallel processing
parallel_manual() {
    local max_jobs=8
    local job_count=0

    for file in *.csv; do
        process_file "$file" &
        ((job_count++))

        if [ $job_count -ge $max_jobs ]; then
            wait -n  # Wait for any job to finish
            ((job_count--))
        fi
    done

    wait  # Wait for all remaining jobs
}

# Parallel with named pipes
parallel_with_fifos() {
    local num_workers=8
    local fifo="/tmp/parallel_fifo_$$"

    mkfifo "$fifo"
    exec 3<>"$fifo"
    rm "$fifo"

    # Initialize workers
    for ((i=0; i<num_workers; i++)); do
        echo >&3
    done

    for item in "${items[@]}"; do
        read -u 3  # Wait for available worker
        {
            process_item "$item"
            echo >&3  # Signal completion
        } &
    done

    wait
    exec 3>&-
}

10.3 SIGNAL HANDLING
-------------------

#!/bin/bash

# Trap signals
cleanup() {
    echo "Cleaning up..."
    kill_child_processes
    remove_temp_files
    exit 0
}

trap cleanup SIGINT SIGTERM

# Ignore specific signals
trap '' SIGINT  # Ignore Ctrl+C

# Reset signal handler
trap - SIGINT

# Handle multiple signals
trap 'handle_error $? $LINENO' ERR
trap 'cleanup' EXIT
trap 'log_info "Received SIGHUP"' SIGHUP

# Send signals
kill -TERM $pid
kill -USR1 $pid

# Custom signal handlers for IPC
handle_sigusr1() {
    log_info "Received SIGUSR1 - reloading configuration"
    reload_config
}

trap handle_sigusr1 SIGUSR1

================================================================================
11. HFT-SPECIFIC EXAMPLES
================================================================================

11.1 MARKET DATA PROCESSING SCRIPT
----------------------------------

#!/bin/bash
set -euo pipefail

# Market data processor for HFT system
readonly DATA_DIR="/data/market"
readonly PROCESSED_DIR="/data/processed"
readonly LOG_FILE="/var/log/hft/data_processor.log"

# Configuration
readonly SYMBOLS=("AAPL" "GOOGL" "MSFT" "AMZN" "TSLA")
readonly EXCHANGES=("NYSE" "NASDAQ")
readonly BATCH_SIZE=10000

# Initialize
source "$(dirname $0)/hft_lib.sh"

# Process market data file
process_market_data() {
    local file=$1
    local start_time=$(date +%s%N)

    log_info "Processing market data file: $file"

    # Validate file
    if [ ! -f "$file" ]; then
        log_error "File not found: $file"
        return 1
    fi

    # Extract metadata from filename
    local basename=$(basename "$file")
    local exchange=$(echo "$basename" | cut -d'_' -f1)
    local date=$(echo "$basename" | cut -d'_' -f2)

    # Create output directory
    local output_dir="${PROCESSED_DIR}/${exchange}/${date}"
    mkdir -p "$output_dir"

    # Process each symbol
    for symbol in "${SYMBOLS[@]}"; do
        local output_file="${output_dir}/${symbol}.csv"

        # Extract and process symbol data
        grep "^${symbol}," "$file" | \
            awk -F',' '{
                if ($3 > 0 && $4 > 0) {  # Filter invalid prices
                    print $0
                }
            }' | \
            sort -t',' -k2 -n > "$output_file"

        local line_count=$(wc -l < "$output_file")
        log_info "Processed $line_count records for $symbol"
    done

    # Calculate processing time
    local end_time=$(date +%s%N)
    log_performance "process_market_data" $start_time $end_time

    # Archive original file
    gzip "$file"
    mv "${file}.gz" "${DATA_DIR}/archive/"
}

# Main processing loop
main() {
    log_info "Starting market data processor"

    # Process all pending files
    find "$DATA_DIR" -name "*.csv" -type f | while read file; do
        process_market_data "$file"
    done

    log_info "Market data processing complete"
}

main "$@"

11.2 SYSTEM HEALTH CHECK SCRIPT
-------------------------------

#!/bin/bash
set -euo pipefail

# HFT system health check
readonly HEALTH_LOG="/var/log/hft/health_check.log"
readonly ALERT_THRESHOLD=3

# Services to monitor
readonly SERVICES=(
    "trading_engine"
    "market_data_feed"
    "order_gateway"
    "risk_manager"
)

# Ports to check
declare -A SERVICE_PORTS=(
    [trading_engine]=8080
    [market_data_feed]=8081
    [order_gateway]=8082
    [risk_manager]=8083
)

# Health check results
declare -A HEALTH_STATUS
declare -i FAILED_CHECKS=0

# Check service process
check_service_process() {
    local service=$1

    if pgrep -x "$service" > /dev/null; then
        HEALTH_STATUS[$service]="OK"
        log_info "Service $service is running"
        return 0
    else
        HEALTH_STATUS[$service]="FAILED"
        log_error "Service $service is not running"
        ((FAILED_CHECKS++))
        return 1
    fi
}

# Check service port
check_service_port() {
    local service=$1
    local port=${SERVICE_PORTS[$service]}

    if timeout 2 bash -c "cat < /dev/null > /dev/tcp/localhost/${port}" 2>/dev/null; then
        log_info "Service $service port $port is responding"
        return 0
    else
        log_error "Service $service port $port is not responding"
        ((FAILED_CHECKS++))
        return 1
    fi
}

# Check system resources
check_system_resources() {
    # CPU usage
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    log_info "CPU usage: ${cpu_usage}%"

    # Memory usage
    local mem_usage=$(free | grep Mem | awk '{print int($3/$2 * 100)}')
    log_info "Memory usage: ${mem_usage}%"

    # Disk usage
    local disk_usage=$(df /data | tail -1 | awk '{print int($3/$2 * 100)}')
    log_info "Disk usage: ${disk_usage}%"

    # Alert on high usage
    if [ $(echo "$cpu_usage > 80" | bc -l) -eq 1 ]; then
        log_warn "High CPU usage detected"
    fi

    if [ $mem_usage -gt 90 ]; then
        log_warn "High memory usage detected"
    fi

    if [ $disk_usage -gt 85 ]; then
        log_warn "High disk usage detected"
    fi
}

# Main health check
main() {
    log_info "Starting health check"

    # Check all services
    for service in "${SERVICES[@]}"; do
        check_service_process "$service"
        check_service_port "$service"
    done

    # Check system resources
    check_system_resources

    # Summary
    if [ $FAILED_CHECKS -eq 0 ]; then
        log_info "All health checks passed"
    else
        log_error "$FAILED_CHECKS health checks failed"

        if [ $FAILED_CHECKS -ge $ALERT_THRESHOLD ]; then
            send_alert "CRITICAL: $FAILED_CHECKS health checks failed"
        fi
    fi
}

main "$@"

11.3 AUTOMATED TRADING ENGINE RESTART
-------------------------------------

#!/bin/bash
set -euo pipefail

# Trading engine restart script with safety checks
readonly ENGINE_NAME="trading_engine"
readonly ENGINE_PATH="/opt/hft/bin/trading_engine"
readonly CONFIG_PATH="/etc/hft/trading_engine.conf"
readonly PID_FILE="/var/run/hft/${ENGINE_NAME}.pid"
readonly LOG_FILE="/var/log/hft/${ENGINE_NAME}_restart.log"

# Safety checks
readonly MARKET_HOURS_START=9
readonly MARKET_HOURS_END=16

# Check if market is open
is_market_open() {
    local hour=$(date +%H)
    local day=$(date +%u)  # 1=Monday, 7=Sunday

    # Weekend check
    if [ $day -eq 6 ] || [ $day -eq 7 ]; then
        return 1
    fi

    # Market hours check
    if [ $hour -ge $MARKET_HOURS_START ] && [ $hour -lt $MARKET_HOURS_END ]; then
        return 0
    else
        return 1
    fi
}

# Stop trading engine gracefully
stop_engine() {
    log_info "Stopping trading engine"

    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")

        if kill -0 $pid 2>/dev/null; then
            # Send SIGTERM for graceful shutdown
            kill -TERM $pid

            # Wait for graceful shutdown
            local timeout=30
            local elapsed=0
            while kill -0 $pid 2>/dev/null && [ $elapsed -lt $timeout ]; do
                sleep 1
                ((elapsed++))
            done

            # Force kill if still running
            if kill -0 $pid 2>/dev/null; then
                log_warn "Graceful shutdown timeout, sending SIGKILL"
                kill -KILL $pid
            fi

            log_info "Trading engine stopped"
        fi
    fi

    rm -f "$PID_FILE"
}

# Start trading engine
start_engine() {
    log_info "Starting trading engine"

    # Validate configuration
    if [ ! -f "$CONFIG_PATH" ]; then
        log_error "Configuration file not found: $CONFIG_PATH"
        return 1
    fi

    # Start engine
    $ENGINE_PATH --config "$CONFIG_PATH" &
    local pid=$!

    # Wait for startup
    sleep 5

    # Verify running
    if kill -0 $pid 2>/dev/null; then
        echo $pid > "$PID_FILE"
        log_info "Trading engine started with PID $pid"
        return 0
    else
        log_error "Trading engine failed to start"
        return 1
    fi
}

# Main restart logic
main() {
    log_info "Trading engine restart requested"

    # Safety check for market hours
    if is_market_open; then
        log_warn "Market is currently open - restart requires manual approval"
        read -p "Are you sure you want to restart during market hours? (yes/no): " confirm
        if [ "$confirm" != "yes" ]; then
            log_info "Restart cancelled by user"
            exit 0
        fi
    fi

    # Stop engine
    stop_engine

    # Wait before restart
    sleep 2

    # Start engine
    if start_engine; then
        log_info "Trading engine restart successful"
    else
        log_error "Trading engine restart failed"
        send_alert "CRITICAL: Trading engine failed to restart"
        exit 1
    fi
}

main "$@"

================================================================================
END OF SHELL SCRIPTING BASICS
================================================================================

This comprehensive guide covers all fundamental bash scripting concepts needed
for HFT system automation. Refer to other scripts files for specialized topics:
- deployment_scripts.txt: Automated deployment
- monitoring_scripts.txt: System and application monitoring
- backup_scripts.txt: Data backup strategies
- log_analysis_scripts.txt: Log processing and analysis
- data_collection_scripts.txt: Market data collection
- system_setup_scripts.txt: Infrastructure setup
- performance_testing_scripts.txt: Benchmarking and testing
- python_utility_scripts.txt: Python automation
- cronjob_examples.txt: Scheduled task automation

All scripts are production-ready and can be adapted for your specific needs.
