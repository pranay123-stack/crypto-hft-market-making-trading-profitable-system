================================================================================
                    LINUX PROCESS MANAGEMENT COMMANDS
                    HFT Process Control and Optimization
================================================================================

TABLE OF CONTENTS
-----------------
1. Process Creation and Control
2. Process Scheduling and Priority
3. CPU Affinity and Isolation
4. Systemd Service Management
5. Process Resource Limits
6. Process Monitoring and Inspection
7. Process Signals and Control
8. Cgroups (Control Groups)
9. Process Debugging
10. HFT-Specific Process Management

================================================================================
1. PROCESS CREATION AND CONTROL
================================================================================

1.1 PROCESS EXECUTION
----------------------

# Run command in background
./trading_engine &

# Run with nohup (survive logout)
nohup ./trading_engine &

# Run and disown
./trading_engine & disown

# Run in background with specific output
nohup ./trading_engine > output.log 2>&1 &

# Run with timeout
timeout 3600 ./trading_engine  # Kill after 1 hour

# Run with specific environment
env VAR=value ./trading_engine

# Clear environment and run
env -i ./trading_engine

# Run with limited resources
ulimit -v 4194304 && ./trading_engine  # 4GB virtual memory limit

HFT USE CASE: Launch trading engine with controlled environment
EXAMPLE: nohup nice -n -20 ./trading_engine > /var/log/trading.log 2>&1 &


1.2 JOB CONTROL
---------------

# List jobs
jobs

# Bring job to foreground
fg %1

# Send job to background
bg %1

# Kill job
kill %1

# Suspend foreground job
Ctrl+Z

# List stopped jobs
jobs -s

# List running jobs
jobs -r

HFT USE CASE: Manage multiple market data handlers
ONE-LINER: jobs -l  # Show job IDs and PIDs


1.3 SCREEN / TMUX (Terminal Multiplexing)
------------------------------------------

# Start screen session
screen -S trading_session

# Detach from screen
Ctrl+A, D

# List sessions
screen -ls

# Reattach to session
screen -r trading_session

# Kill session
screen -X -S trading_session quit

# TMUX alternative
tmux new -s trading
tmux detach
tmux ls
tmux attach -t trading

# Split panes in tmux
Ctrl+B, %  # Vertical split
Ctrl+B, "  # Horizontal split

HFT USE CASE: Maintain persistent sessions for trading operations
BEST PRACTICE: Use tmux for better split-pane management


================================================================================
2. PROCESS SCHEDULING AND PRIORITY
================================================================================

2.1 NICE / RENICE (Priority Control)
-------------------------------------

# Run with nice value (-20 to 19, lower = higher priority)
nice -n -20 ./trading_engine

# Run with lowest priority
nice -n 19 ./backup_script

# Change priority of running process
renice -n -20 -p $(pidof trading_engine)

# Renice by user
renice -n 10 -u trading

# Renice by group
renice -n 5 -g trading_group

# Check current nice value
ps -eo pid,ni,comm | grep trading_engine

HFT USE CASE: Maximize trading engine priority
EXPECTED: Nice value of -20 for critical processes
NOTE: Requires CAP_SYS_NICE capability or root


2.2 CHRT (Real-Time Scheduling)
--------------------------------

# Show scheduling policy
chrt -p $(pidof trading_engine)

# Set FIFO real-time scheduling (priority 1-99)
chrt -f 99 ./trading_engine

# Set Round-Robin real-time scheduling
chrt -r 99 ./trading_engine

# Change scheduling of running process
chrt -f -p 99 $(pidof trading_engine)

# Set batch scheduling (for background tasks)
chrt -b -p 0 $(pidof backup_process)

# Set idle scheduling (lowest priority)
chrt -i -p 0 $(pidof cleanup_job)

# Show all real-time processes
ps -eo pid,cls,rtprio,pri,nice,cmd | grep -E 'FF|RR'

HFT USE CASE: Real-time priority for order execution thread
PERFORMANCE IMPACT: Reduces scheduling latency from 100μs to <10μs

SCHEDULING CLASSES:
  SCHED_FIFO (FF)   - Real-time FIFO (use for HFT)
  SCHED_RR (RR)     - Real-time round-robin
  SCHED_NORMAL      - Standard time-sharing
  SCHED_BATCH (B)   - Batch processing
  SCHED_IDLE        - Very low priority

SAFETY WARNING: RT priority can hang system if process loops


2.3 TASKSET (CPU Affinity)
---------------------------

# Show CPU affinity
taskset -p $(pidof trading_engine)

# Set CPU affinity (decimal mask)
taskset -p 0x4 $(pidof trading_engine)  # CPU 2

# Set CPU affinity (list format)
taskset -cp 2,3,4,5 $(pidof trading_engine)

# Run with specific CPU affinity
taskset -c 2 ./trading_engine

# Set affinity for all threads
for tid in $(ps -T -p $(pidof trading_engine) | awk 'NR>1{print $2}'); do
    taskset -cp 2 $tid
done

# Show CPU affinity in binary
taskset -p $(pidof trading_engine) | awk '{print $NF}' | \
    python3 -c "print(bin(int(input(), 16)))"

HFT USE CASE: Pin trading thread to isolated CPU core
PERFORMANCE IMPACT: Eliminates CPU migration overhead (~5-15μs)

ONE-LINER: Pin to CPU 2: taskset -cp 2 $(pidof app)


2.4 NUMACTL (NUMA Control)
---------------------------

# Show NUMA topology
numactl --hardware

# Run on specific NUMA node
numactl --cpunodebind=0 --membind=0 ./trading_engine

# Preferred NUMA node
numactl --preferred=0 ./trading_engine

# Interleave memory across nodes
numactl --interleave=all ./data_processor

# Show current policy
numactl --show

# Set policy for running process (via /proc)
echo 0 > /proc/$(pidof trading_engine)/numa_maps

HFT USE CASE: Bind process to same NUMA node as NIC
PERFORMANCE IMPACT: 20-40% memory latency reduction

BEST PRACTICE: Use lstopo to visualize NUMA topology


================================================================================
3. CPU ISOLATION AND DEDICATED CORES
================================================================================

3.1 ISOLCPUS (Kernel Boot Parameter)
-------------------------------------

# Add to /etc/default/grub
GRUB_CMDLINE_LINUX="isolcpus=2,3,4,5 nohz_full=2,3,4,5 rcu_nocbs=2,3,4,5"

# Update grub
update-grub

# Verify isolated CPUs after reboot
cat /sys/devices/system/cpu/isolated

# Check tickless CPUs
cat /sys/devices/system/cpu/nohz_full

# Verify RCU callbacks offloaded
cat /sys/devices/system/cpu/rcu_nocbs

HFT USE CASE: Reserve CPUs 2-5 for trading, 0-1 for OS
PERFORMANCE IMPACT: Near-zero OS interference on isolated cores

CONFIGURATION EXPLAINED:
  isolcpus     - Remove CPUs from scheduler load balancing
  nohz_full    - Disable timer ticks when single task running
  rcu_nocbs    - Offload RCU callbacks to housekeeping CPUs


3.2 CSET (CPU Sets)
-------------------

# Create CPU set
cset shield -c 2,3,4,5 -k on

# Show CPU sets
cset set -l

# Move process to shielded set
cset shield -s -p $(pidof trading_engine)

# Move process to unshielded set
cset shield -u -p $(pidof system_daemon)

# Execute in shielded set
cset shield -e -- ./trading_engine

# Reset CPU sets
cset shield --reset

HFT USE CASE: Dynamic CPU partitioning without reboot
ADVANTAGE: More flexible than isolcpus


3.3 IRQ AFFINITY
-----------------

# Show IRQ assignments
cat /proc/interrupts

# Show IRQ affinity for specific IRQ
cat /proc/irq/125/smp_affinity_list

# Set IRQ affinity
echo 2 > /proc/irq/125/smp_affinity_list

# Set IRQ affinity (bitmask)
echo 4 > /proc/irq/125/smp_affinity  # CPU 2 (binary 0100)

# Script to set all NIC IRQs to CPU 2
for irq in $(grep eth0 /proc/interrupts | awk -F: '{print $1}'); do
    echo 2 > /proc/irq/$irq/smp_affinity_list
done

# Disable irqbalance
systemctl stop irqbalance
systemctl disable irqbalance

HFT USE CASE: Colocate NIC IRQs with trading thread
PERFORMANCE IMPACT: Reduces interrupt latency by 3-8μs


================================================================================
4. SYSTEMD SERVICE MANAGEMENT
================================================================================

4.1 SERVICE CONTROL
-------------------

# Start service
systemctl start trading_engine.service

# Stop service
systemctl stop trading_engine.service

# Restart service
systemctl restart trading_engine.service

# Reload configuration
systemctl reload trading_engine.service

# Enable on boot
systemctl enable trading_engine.service

# Disable on boot
systemctl disable trading_engine.service

# Check status
systemctl status trading_engine.service

# Show service logs
journalctl -u trading_engine.service

# Follow logs
journalctl -u trading_engine.service -f

# Show recent failures
systemctl --failed

HFT USE CASE: Manage trading services with automatic restart


4.2 SYSTEMD UNIT FILE (HFT Optimized)
--------------------------------------

# /etc/systemd/system/trading_engine.service

[Unit]
Description=HFT Trading Engine
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=trading
Group=trading
WorkingDirectory=/opt/trading

# Resource Limits
LimitNOFILE=1048576
LimitMEMLOCK=infinity
LimitNICE=-20
LimitRTPRIO=99
LimitCORE=infinity

# CPU Affinity
CPUAffinity=2 3 4 5

# NUMA Policy
NUMAPolicy=bind
NUMAMask=0

# Real-time Scheduling
CPUSchedulingPolicy=fifo
CPUSchedulingPriority=99

# I/O Scheduling
IOSchedulingClass=realtime
IOSchedulingPriority=0

# OOM Score (prevent killing)
OOMScoreAdjust=-1000

# Execution
ExecStart=/opt/trading/bin/trading_engine --config /etc/trading/config.yaml
ExecReload=/bin/kill -HUP $MAINPID

# Restart Policy
Restart=always
RestartSec=5
StartLimitInterval=0

# Security
PrivateTmp=yes
NoNewPrivileges=true
CapabilityBoundingSet=CAP_IPC_LOCK CAP_SYS_NICE CAP_NET_RAW CAP_NET_ADMIN

# Environment
Environment="LD_LIBRARY_PATH=/opt/trading/lib"
Environment="CONFIG_FILE=/etc/trading/config.yaml"

[Install]
WantedBy=multi-user.target

# Reload systemd
systemctl daemon-reload

# Enable and start
systemctl enable trading_engine.service
systemctl start trading_engine.service

HFT USE CASE: Complete systemd configuration for trading service
FEATURES: Real-time scheduling, CPU pinning, NUMA binding, resource limits


4.3 SYSTEMD RESOURCE CONTROL
-----------------------------

# Set CPU quota (50% of one core)
systemctl set-property trading_engine.service CPUQuota=50%

# Set memory limit
systemctl set-property trading_engine.service MemoryMax=4G

# Set I/O weight
systemctl set-property trading_engine.service IOWeight=1000

# Show resource usage
systemd-cgtop

# Show service properties
systemctl show trading_engine.service

HFT USE CASE: Limit resource usage of non-critical services


================================================================================
5. PROCESS RESOURCE LIMITS
================================================================================

5.1 ULIMIT (User Limits)
-------------------------

# Show all limits
ulimit -a

# Show hard limits
ulimit -Ha

# Set file descriptor limit
ulimit -n 1048576

# Set max locked memory
ulimit -l unlimited

# Set core dump size
ulimit -c unlimited

# Set max processes
ulimit -u 32768

# Set stack size
ulimit -s 10240

# Persistent limits in /etc/security/limits.conf
trading  soft  nofile  1048576
trading  hard  nofile  1048576
trading  soft  memlock unlimited
trading  hard  memlock unlimited
trading  soft  rtprio  99
trading  hard  rtprio  99
trading  soft  nice    -20
trading  hard  nice    -20

HFT USE CASE: Allow trading process to lock memory and use RT priority
ONE-LINER: Check limits: cat /proc/$(pidof app)/limits


5.2 PRLIMIT (Process Resource Limits)
--------------------------------------

# Show limits for process
prlimit --pid $(pidof trading_engine)

# Set file descriptor limit
prlimit --pid $(pidof trading_engine) --nofile=1048576:1048576

# Set memory lock limit
prlimit --pid $(pidof trading_engine) --memlock=unlimited:unlimited

# Set CPU time limit
prlimit --pid $(pidof trading_engine) --cpu=unlimited:unlimited

# Set stack size
prlimit --pid $(pidof trading_engine) --stack=10485760:10485760

# Run with limits
prlimit --nofile=1048576 --memlock=unlimited ./trading_engine

HFT USE CASE: Dynamically adjust running process limits


5.3 CGROUPS V2 LIMITS
----------------------

# Create cgroup
mkdir -p /sys/fs/cgroup/trading

# Set memory limit
echo "4G" > /sys/fs/cgroup/trading/memory.max

# Set CPU weight
echo "1000" > /sys/fs/cgroup/trading/cpu.weight

# Add process to cgroup
echo $(pidof trading_engine) > /sys/fs/cgroup/trading/cgroup.procs

# Show cgroup stats
cat /sys/fs/cgroup/trading/memory.current
cat /sys/fs/cgroup/trading/cpu.stat

HFT USE CASE: Resource isolation for trading processes


================================================================================
6. PROCESS MONITORING AND INSPECTION
================================================================================

6.1 PS (Process Status)
------------------------

# Standard output
ps aux

# Custom format for HFT monitoring
ps -eo pid,ppid,tid,class,rtprio,ni,pri,psr,pcpu,pmem,vsz,rss,wchan,stat,comm

# Show threads
ps -eLf

# Process tree
ps auxf

# Sort by CPU
ps aux --sort=-%cpu | head -20

# Sort by memory
ps aux --sort=-%mem | head -20

# Show real-time processes
ps -eo pid,cls,rtprio,comm | grep -E 'FF|RR'

# Show CPU affinity
ps -o pid,psr,comm

HFT USE CASE: Monitor trading process scheduling
ONE-LINER: ps -eo pid,class,rtprio,ni,comm | grep trading


6.2 TOP (Interactive Process Viewer)
-------------------------------------

# Launch top
top

# Show threads
top -H

# Monitor specific process
top -p $(pidof trading_engine)

# Batch mode
top -b -n 1

# Custom columns
top -o %CPU  # Sort by CPU

# Key shortcuts:
#   1 - Show individual CPUs
#   P - Sort by CPU
#   M - Sort by memory
#   c - Show full command
#   H - Show threads
#   f - Select fields
#   k - Kill process

HFT USE CASE: Real-time monitoring of trading processes


6.3 PIDSTAT (Process Statistics)
---------------------------------

# CPU usage
pidstat 1

# Specific process
pidstat -p $(pidof trading_engine) 1

# Thread statistics
pidstat -t -p $(pidof trading_engine) 1

# Context switches
pidstat -w -p $(pidof trading_engine) 1

# Memory usage
pidstat -r -p $(pidof trading_engine) 1

# I/O statistics
pidstat -d -p $(pidof trading_engine) 1

# Page faults
pidstat -r -p $(pidof trading_engine) 1

HFT USE CASE: Per-thread performance analysis
ONE-LINER: pidstat -t -p $(pidof app) | sort -k 8 -rn


6.4 PROC FILESYSTEM
-------------------

# Process status
cat /proc/$(pidof trading_engine)/status

# Command line
cat /proc/$(pidof trading_engine)/cmdline | tr '\0' ' '

# Environment variables
cat /proc/$(pidof trading_engine)/environ | tr '\0' '\n'

# Memory maps
cat /proc/$(pidof trading_engine)/maps

# Scheduling info
cat /proc/$(pidof trading_engine)/sched

# CPU affinity
cat /proc/$(pidof trading_engine)/status | grep Cpus_allowed_list

# Limits
cat /proc/$(pidof trading_engine)/limits

# File descriptors
ls -l /proc/$(pidof trading_engine)/fd

# Open files
ls -l /proc/$(pidof trading_engine)/fd | wc -l

# NUMA maps
cat /proc/$(pidof trading_engine)/numa_maps

HFT USE CASE: Deep inspection of process configuration
ONE-LINER: Check RT priority: grep policy /proc/$(pidof app)/sched


================================================================================
7. PROCESS SIGNALS
================================================================================

7.1 KILL (Send Signals)
------------------------

# Terminate process
kill $(pidof trading_engine)

# Force kill
kill -9 $(pidof trading_engine)

# Send SIGHUP (reload config)
kill -HUP $(pidof trading_engine)

# Send SIGUSR1 (custom signal)
kill -USR1 $(pidof trading_engine)

# Kill by name
killall trading_engine

# Kill by pattern
pkill -f "trading.*engine"

# Send signal to process group
kill -TERM -$(ps -o pgid= -p $(pidof trading_engine))

COMMON SIGNALS:
  SIGTERM (15) - Graceful termination (default)
  SIGKILL (9)  - Force kill (cannot be caught)
  SIGHUP (1)   - Reload configuration
  SIGINT (2)   - Interrupt (Ctrl+C)
  SIGQUIT (3)  - Quit with core dump
  SIGUSR1 (10) - User-defined
  SIGUSR2 (12) - User-defined

HFT USE CASE: Graceful shutdown of trading engine
EXAMPLE: kill -TERM $(pidof trading_engine) && wait


7.2 TIMEOUT (Time-Limited Execution)
-------------------------------------

# Kill after timeout
timeout 60s ./trading_engine

# Send specific signal
timeout -s SIGTERM 60s ./trading_engine

# Kill signal after delay
timeout -k 10s 60s ./trading_engine

HFT USE CASE: Limit execution time of batch jobs


================================================================================
8. COMPLETE PROCESS MANAGEMENT SCRIPTS
================================================================================

8.1 HFT PROCESS LAUNCHER
-------------------------

#!/bin/bash
# Launch HFT trading engine with optimal settings

APP="/opt/trading/bin/trading_engine"
CONFIG="/etc/trading/config.yaml"
LOG="/var/log/trading/engine.log"
PID_FILE="/var/run/trading/engine.pid"
CPU_CORE=2
NUMA_NODE=0

# Check if already running
if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null; then
    echo "Trading engine already running"
    exit 1
fi

# Set resource limits
ulimit -n 1048576
ulimit -l unlimited
ulimit -c unlimited

# Set CPU governor
echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor

# Disable swap
sudo swapoff -a

# Launch with optimal settings
numactl --cpunodebind=$NUMA_NODE --membind=$NUMA_NODE \
    chrt -f 99 \
    taskset -c $CPU_CORE \
    nice -n -20 \
    $APP --config $CONFIG > $LOG 2>&1 &

PID=$!
echo $PID > $PID_FILE

# Wait for startup
sleep 2

# Verify process
if kill -0 $PID 2>/dev/null; then
    echo "Trading engine started successfully (PID: $PID)"
    echo "CPU Core: $CPU_CORE"
    echo "NUMA Node: $NUMA_NODE"
    echo "Scheduling: SCHED_FIFO, Priority: 99"

    # Show process info
    ps -eo pid,class,rtprio,ni,psr,comm | grep $PID
else
    echo "Failed to start trading engine"
    rm -f $PID_FILE
    exit 1
fi


8.2 PROCESS MONITORING SCRIPT
------------------------------

#!/bin/bash
# Monitor HFT process performance

PROCESS="trading_engine"
INTERVAL=1

while true; do
    PID=$(pidof $PROCESS)

    if [ -z "$PID" ]; then
        echo "$(date): Process not running"
        sleep $INTERVAL
        continue
    fi

    # CPU and scheduling
    CPU=$(ps -p $PID -o %cpu= | tr -d ' ')
    SCHED=$(chrt -p $PID 2>/dev/null | awk '{print $2, $4}')
    CORE=$(ps -p $PID -o psr= | tr -d ' ')

    # Memory
    RSS=$(ps -p $PID -o rss= | tr -d ' ')
    RSS_MB=$((RSS / 1024))

    # Context switches
    CTXT=$(grep ctxt_switches /proc/$PID/status | awk '{sum+=$2} END {print sum}')

    # Threads
    THREADS=$(ps -T -p $PID | wc -l)

    echo "$(date '+%Y-%m-%d %H:%M:%S') | CPU: ${CPU}% | Core: $CORE | Sched: $SCHED | RSS: ${RSS_MB}MB | CTXT: $CTXT | Threads: $THREADS"

    sleep $INTERVAL
done


8.3 GRACEFUL SHUTDOWN SCRIPT
-----------------------------

#!/bin/bash
# Gracefully shutdown trading engine

PID_FILE="/var/run/trading/engine.pid"
TIMEOUT=30

if [ ! -f "$PID_FILE" ]; then
    echo "PID file not found"
    exit 1
fi

PID=$(cat "$PID_FILE")

if ! kill -0 $PID 2>/dev/null; then
    echo "Process not running"
    rm -f "$PID_FILE"
    exit 0
fi

echo "Sending SIGTERM to process $PID..."
kill -TERM $PID

# Wait for graceful shutdown
COUNT=0
while kill -0 $PID 2>/dev/null; do
    sleep 1
    COUNT=$((COUNT + 1))

    if [ $COUNT -ge $TIMEOUT ]; then
        echo "Timeout reached, sending SIGKILL..."
        kill -9 $PID
        sleep 1
        break
    fi
done

if kill -0 $PID 2>/dev/null; then
    echo "Failed to stop process"
    exit 1
else
    echo "Process stopped successfully"
    rm -f "$PID_FILE"
fi


================================================================================
BEST PRACTICES FOR HFT PROCESS MANAGEMENT
================================================================================

1. Scheduling
   - Use SCHED_FIFO with priority 99 for critical threads
   - Pin critical threads to isolated CPU cores
   - Use NUMA binding for memory locality
   - Disable CPU frequency scaling

2. Resource Limits
   - Set unlimited memlock for mlockall()
   - Increase file descriptor limits
   - Allow real-time priority
   - Enable core dumps for debugging

3. CPU Isolation
   - Use isolcpus boot parameter
   - Enable nohz_full for tickless operation
   - Offload RCU callbacks
   - Pin interrupts away from trading cores

4. Monitoring
   - Track CPU usage and affinity
   - Monitor context switches
   - Watch for scheduling anomalies
   - Alert on priority changes

5. Deployment
   - Use systemd for service management
   - Implement proper startup/shutdown sequences
   - Test failover scenarios
   - Document CPU allocation

SAFETY WARNINGS
---------------
- Real-time priority can hang system if process loops
- CPU isolation requires careful system configuration
- mlockall() can cause OOM if too much memory requested
- Always test configuration changes in development first
- Maintain console access during testing
- Have rollback procedures ready

================================================================================
Last Updated: 2025-01-25
Version: 2.0
Maintainer: HFT Engineering Team
================================================================================
