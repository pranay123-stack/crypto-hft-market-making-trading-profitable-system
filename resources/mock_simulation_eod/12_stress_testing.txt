================================================================================
STRESS TESTING
System Stress Tests and Capacity Planning
================================================================================

VERSION: 1.0
DOCUMENT: Comprehensive Stress Testing Framework
LAST UPDATED: 2025-11-26

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. Load Testing
3. Volume Stress Testing
4. Latency Stress Testing
5. Resource Exhaustion Testing
6. Chaos Engineering
7. Capacity Planning
8. Complete Implementation

================================================================================
1. OVERVIEW
================================================================================

The Stress Testing Framework validates system behavior under extreme conditions
and helps determine capacity limits for production deployment.

KEY OBJECTIVES:
---------------
- Identify breaking points
- Validate scalability
- Test error handling
- Measure degradation curves
- Plan capacity requirements
- Validate recovery mechanisms
- Test concurrent load handling

STRESS TEST TYPES:
------------------
1. Load Testing: Sustained high load
2. Spike Testing: Sudden traffic surges
3. Volume Testing: Large data sets
4. Soak Testing: Extended duration
5. Isolation Testing: Resource constraints
6. Chaos Testing: Failure injection

================================================================================
2. LOAD TESTING
================================================================================

2.1 LOAD TEST CONFIGURATION
----------------------------

struct LoadTestConfig {
    // Load profile
    size_t initial_load;           // Starting load (events/sec)
    size_t target_load;            // Maximum load to test
    size_t load_increment;         // Increase per step
    uint64_t ramp_up_duration_ms;  // Time to reach next level
    uint64_t hold_duration_ms;     // Time at each level

    // Test parameters
    size_t num_concurrent_strategies;
    size_t num_symbols;
    double market_data_rate_hz;    // Ticks per second per symbol
    double order_rate_hz;          // Orders per second

    // Thresholds
    uint64_t max_latency_p99_ns;   // P99 latency threshold
    double max_error_rate;         // Maximum acceptable error rate
    double max_cpu_usage;          // CPU threshold
    double max_memory_mb;          // Memory threshold

    LoadTestConfig()
        : initial_load(100), target_load(10000), load_increment(100),
          ramp_up_duration_ms(5000), hold_duration_ms(10000),
          num_concurrent_strategies(10), num_symbols(100),
          market_data_rate_hz(1000.0), order_rate_hz(100.0),
          max_latency_p99_ns(1000000), max_error_rate(0.01),
          max_cpu_usage(80.0), max_memory_mb(4000.0) {}
};

struct LoadTestResult {
    size_t load_level;             // Events/sec at this level
    uint64_t duration_ms;          // Test duration

    // Performance metrics
    double avg_latency_ns;
    double p50_latency_ns;
    double p95_latency_ns;
    double p99_latency_ns;
    double max_latency_ns;

    // Throughput
    double achieved_throughput;    // Actual events/sec processed
    double throughput_ratio;       // Achieved / Target

    // Resource usage
    double cpu_usage_pct;
    double memory_usage_mb;
    uint64_t queue_depth_avg;
    uint64_t queue_depth_max;

    // Errors
    uint64_t total_errors;
    uint64_t total_timeouts;
    double error_rate;

    // Status
    bool passed_sla;               // Met all SLA requirements
    std::string failure_reason;

    LoadTestResult()
        : load_level(0), duration_ms(0), avg_latency_ns(0),
          p50_latency_ns(0), p95_latency_ns(0), p99_latency_ns(0),
          max_latency_ns(0), achieved_throughput(0), throughput_ratio(0),
          cpu_usage_pct(0), memory_usage_mb(0), queue_depth_avg(0),
          queue_depth_max(0), total_errors(0), total_timeouts(0),
          error_rate(0), passed_sla(false) {}
};

2.2 LOAD TEST ENGINE
--------------------

class LoadTestEngine {
public:
    explicit LoadTestEngine(const LoadTestConfig& config)
        : config_(config) {}

    std::vector<LoadTestResult> runLoadTest(SimulationEngine& sim) {
        std::vector<LoadTestResult> results;

        std::cout << "Starting load test..." << std::endl;
        std::cout << "Initial load: " << config_.initial_load << " events/sec" << std::endl;
        std::cout << "Target load: " << config_.target_load << " events/sec" << std::endl;

        size_t current_load = config_.initial_load;

        while (current_load <= config_.target_load) {
            std::cout << "\nTesting at " << current_load << " events/sec..." << std::endl;

            // Ramp up to target load
            rampUpLoad(sim, current_load);

            // Hold at target load and measure
            auto result = measurePerformance(sim, current_load);

            results.push_back(result);

            // Check if we hit a breaking point
            if (!result.passed_sla) {
                std::cout << "Breaking point reached at " << current_load
                         << " events/sec" << std::endl;
                std::cout << "Failure reason: " << result.failure_reason << std::endl;
                break;
            }

            current_load += config_.load_increment;
        }

        return results;
    }

private:
    LoadTestConfig config_;
    std::atomic<size_t> current_events_per_sec_{0};

    void rampUpLoad(SimulationEngine& sim, size_t target_load) {
        // Gradually increase load
        size_t steps = 10;
        size_t current = current_events_per_sec_.load();
        size_t increment = (target_load - current) / steps;

        for (size_t i = 0; i < steps; ++i) {
            current += increment;
            current_events_per_sec_ = current;
            std::this_thread::sleep_for(
                std::chrono::milliseconds(config_.ramp_up_duration_ms / steps));
        }

        current_events_per_sec_ = target_load;
    }

    LoadTestResult measurePerformance(SimulationEngine& sim, size_t load_level) {
        LoadTestResult result;
        result.load_level = load_level;

        // Start metrics collection
        auto start_time = std::chrono::steady_clock::now();
        std::vector<uint64_t> latencies;
        std::atomic<uint64_t> events_processed{0};
        std::atomic<uint64_t> errors{0};

        // Inject load
        std::thread load_generator([&]() {
            uint64_t events_to_generate = load_level *
                                         (config_.hold_duration_ms / 1000);

            for (uint64_t i = 0; i < events_to_generate; ++i) {
                auto event_start = std::chrono::high_resolution_clock::now();

                try {
                    // Generate and process event
                    generateAndProcessEvent(sim);
                    events_processed++;

                    auto event_end = std::chrono::high_resolution_clock::now();
                    uint64_t latency = std::chrono::duration_cast<
                        std::chrono::nanoseconds>(event_end - event_start).count();

                    latencies.push_back(latency);
                } catch (...) {
                    errors++;
                }

                // Rate limiting
                std::this_thread::sleep_for(std::chrono::microseconds(
                    1000000 / load_level));
            }
        });

        load_generator.join();

        auto end_time = std::chrono::steady_clock::now();
        result.duration_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
            end_time - start_time).count();

        // Calculate metrics
        if (!latencies.empty()) {
            std::sort(latencies.begin(), latencies.end());

            result.avg_latency_ns = std::accumulate(latencies.begin(),
                                                    latencies.end(), 0ULL) /
                                   latencies.size();
            result.p50_latency_ns = latencies[latencies.size() * 50 / 100];
            result.p95_latency_ns = latencies[latencies.size() * 95 / 100];
            result.p99_latency_ns = latencies[latencies.size() * 99 / 100];
            result.max_latency_ns = latencies.back();
        }

        result.achieved_throughput = events_processed.load() /
                                     (result.duration_ms / 1000.0);
        result.throughput_ratio = result.achieved_throughput / load_level;

        result.total_errors = errors.load();
        result.error_rate = static_cast<double>(result.total_errors) /
                           events_processed.load();

        // Check SLA
        checkSLA(result);

        return result;
    }

    void generateAndProcessEvent(SimulationEngine& sim) {
        // Generate synthetic market data event
        MarketDataEvent md_event;
        md_event.timestamp_ns = getCurrentTimeNs();
        // ... populate event ...

        SimulationEvent sim_event;
        sim_event.timestamp_ns = md_event.timestamp_ns;
        sim_event.type = EventType::MARKET_DATA;
        sim_event.payload = &md_event;

        sim.scheduleEvent(std::move(sim_event));
    }

    void checkSLA(LoadTestResult& result) {
        result.passed_sla = true;

        if (result.p99_latency_ns > config_.max_latency_p99_ns) {
            result.passed_sla = false;
            result.failure_reason = "P99 latency exceeded threshold";
        }

        if (result.error_rate > config_.max_error_rate) {
            result.passed_sla = false;
            result.failure_reason = "Error rate exceeded threshold";
        }

        if (result.throughput_ratio < 0.95) {
            result.passed_sla = false;
            result.failure_reason = "Throughput below 95% of target";
        }
    }

    uint64_t getCurrentTimeNs() const {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()
        ).count();
    }
};

================================================================================
3. VOLUME STRESS TESTING
================================================================================

3.1 VOLUME TEST
---------------

class VolumeStressTest {
public:
    struct Config {
        size_t num_symbols;            // Number of symbols to simulate
        size_t ticks_per_symbol;       // Ticks per symbol
        size_t order_book_depth;       // Levels in order book
        size_t max_active_orders;      // Max orders per strategy
        size_t num_strategies;         // Concurrent strategies

        Config() : num_symbols(1000), ticks_per_symbol(1000000),
                  order_book_depth(100), max_active_orders(1000),
                  num_strategies(100) {}
    };

    struct Result {
        size_t total_ticks_processed;
        size_t total_orders_processed;
        double processing_rate_ticks_per_sec;
        double memory_usage_peak_gb;
        bool completed_successfully;
        std::string error_message;

        Result() : total_ticks_processed(0), total_orders_processed(0),
                  processing_rate_ticks_per_sec(0), memory_usage_peak_gb(0),
                  completed_successfully(false) {}
    };

    static Result runVolumeTest(const Config& config) {
        Result result;

        try {
            std::cout << "Running volume stress test..." << std::endl;
            std::cout << "Symbols: " << config.num_symbols << std::endl;
            std::cout << "Total ticks: "
                     << (config.num_symbols * config.ticks_per_symbol) << std::endl;

            auto start_time = std::chrono::high_resolution_clock::now();

            SimulationEngine sim;

            // Create mock exchanges for all symbols
            for (size_t i = 0; i < config.num_symbols; ++i) {
                std::string symbol = "SYM" + std::to_string(i);
                // ... create exchange and add to sim ...
            }

            // Generate and process ticks
            for (size_t i = 0; i < config.ticks_per_symbol; ++i) {
                for (size_t j = 0; j < config.num_symbols; ++j) {
                    // Generate tick
                    result.total_ticks_processed++;
                }
            }

            auto end_time = std::chrono::high_resolution_clock::now();
            double duration_sec = std::chrono::duration_cast<
                std::chrono::duration<double>>(end_time - start_time).count();

            result.processing_rate_ticks_per_sec =
                result.total_ticks_processed / duration_sec;

            result.completed_successfully = true;

        } catch (const std::exception& e) {
            result.error_message = e.what();
        }

        return result;
    }
};

================================================================================
4. LATENCY STRESS TESTING
================================================================================

4.1 LATENCY SPIKE TEST
----------------------

class LatencyStressTest {
public:
    struct Config {
        uint64_t normal_latency_ns;        // Baseline latency
        uint64_t spike_latency_ns;         // Spike latency
        double spike_probability;          // Probability of spike
        uint64_t spike_duration_ms;        // How long spikes last
        size_t num_events;                 // Total events to test

        Config() : normal_latency_ns(100000), spike_latency_ns(10000000),
                  spike_probability(0.1), spike_duration_ms(1000),
                  num_events(100000) {}
    };

    struct Result {
        double avg_latency_ns;
        double p99_latency_ns;
        size_t spikes_encountered;
        size_t timeouts;
        double recovery_time_ms;
        bool system_remained_stable;

        Result() : avg_latency_ns(0), p99_latency_ns(0),
                  spikes_encountered(0), timeouts(0),
                  recovery_time_ms(0), system_remained_stable(true) {}
    };

    static Result runLatencyStressTest(SimulationEngine& sim, const Config& config) {
        Result result;

        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> dis(0.0, 1.0);

        bool in_spike = false;
        auto spike_start = std::chrono::steady_clock::now();

        for (size_t i = 0; i < config.num_events; ++i) {
            // Determine if we should inject a spike
            if (!in_spike && dis(gen) < config.spike_probability) {
                in_spike = true;
                spike_start = std::chrono::steady_clock::now();
                result.spikes_encountered++;
            }

            // Check if spike duration expired
            if (in_spike) {
                auto now = std::chrono::steady_clock::now();
                auto spike_duration = std::chrono::duration_cast<
                    std::chrono::milliseconds>(now - spike_start).count();

                if (spike_duration >= static_cast<long>(config.spike_duration_ms)) {
                    in_spike = false;
                }
            }

            // Inject latency
            uint64_t latency = in_spike ? config.spike_latency_ns :
                                         config.normal_latency_ns;

            std::this_thread::sleep_for(std::chrono::nanoseconds(latency));

            // Process event
            // ... process event in sim ...
        }

        return result;
    }
};

================================================================================
5. RESOURCE EXHAUSTION TESTING
================================================================================

5.1 MEMORY EXHAUSTION TEST
---------------------------

class ResourceExhaustionTest {
public:
    struct MemoryTestResult {
        size_t max_allocated_mb;
        size_t allocation_at_failure_mb;
        bool graceful_degradation;
        std::string failure_mode;

        MemoryTestResult() : max_allocated_mb(0),
                           allocation_at_failure_mb(0),
                           graceful_degradation(false) {}
    };

    static MemoryTestResult testMemoryExhaustion(SimulationEngine& sim) {
        MemoryTestResult result;

        std::cout << "Testing memory exhaustion..." << std::endl;

        try {
            size_t allocated_mb = 0;
            std::vector<std::vector<char>> memory_hog;

            while (true) {
                // Allocate 10MB chunks
                memory_hog.emplace_back(10 * 1024 * 1024);
                allocated_mb += 10;

                result.max_allocated_mb = allocated_mb;

                // Check if system still responsive
                bool responsive = checkSystemResponsive(sim);

                if (!responsive) {
                    result.allocation_at_failure_mb = allocated_mb;
                    result.failure_mode = "System became unresponsive";
                    break;
                }

                // Check memory limit (stop at 8GB for safety)
                if (allocated_mb >= 8192) {
                    result.graceful_degradation = true;
                    break;
                }

                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }

        } catch (const std::bad_alloc&) {
            result.failure_mode = "Out of memory exception";
        } catch (const std::exception& e) {
            result.failure_mode = std::string("Exception: ") + e.what();
        }

        return result;
    }

private:
    static bool checkSystemResponsive(SimulationEngine& sim) {
        // Send test event and check if processed within timeout
        auto start = std::chrono::steady_clock::now();

        // ... send test event ...

        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
            end - start).count();

        return duration < 1000;  // 1 second timeout
    }
};

================================================================================
6. CHAOS ENGINEERING
================================================================================

6.1 CHAOS TEST FRAMEWORK
-------------------------

class ChaosTestFramework {
public:
    enum class FaultType {
        NETWORK_PARTITION,
        HIGH_LATENCY,
        PACKET_LOSS,
        COMPONENT_CRASH,
        DISK_FULL,
        CPU_SATURATION,
        MEMORY_LEAK
    };

    struct ChaosConfig {
        FaultType fault_type;
        double injection_probability;  // Probability per event
        uint64_t fault_duration_ms;
        bool auto_recover;

        ChaosConfig() : fault_type(FaultType::HIGH_LATENCY),
                       injection_probability(0.01),
                       fault_duration_ms(5000),
                       auto_recover(true) {}
    };

    struct ChaosResult {
        size_t faults_injected;
        size_t recovery_attempts;
        size_t successful_recoveries;
        double avg_recovery_time_ms;
        bool system_survived;
        std::vector<std::string> errors_encountered;

        ChaosResult() : faults_injected(0), recovery_attempts(0),
                       successful_recoveries(0), avg_recovery_time_ms(0),
                       system_survived(true) {}
    };

    static ChaosResult runChaosTest(SimulationEngine& sim,
                                    const ChaosConfig& config,
                                    uint64_t test_duration_ms) {
        ChaosResult result;

        auto start_time = std::chrono::steady_clock::now();
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> dis(0.0, 1.0);

        while (true) {
            auto now = std::chrono::steady_clock::now();
            auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
                now - start_time).count();

            if (elapsed >= static_cast<long>(test_duration_ms)) {
                break;
            }

            // Randomly inject faults
            if (dis(gen) < config.injection_probability) {
                std::cout << "Injecting fault: " << getFaultName(config.fault_type)
                         << std::endl;

                result.faults_injected++;

                injectFault(sim, config);

                // Wait for fault duration
                std::this_thread::sleep_for(
                    std::chrono::milliseconds(config.fault_duration_ms));

                // Attempt recovery
                if (config.auto_recover) {
                    result.recovery_attempts++;

                    auto recovery_start = std::chrono::steady_clock::now();
                    bool recovered = attemptRecovery(sim, config.fault_type);

                    if (recovered) {
                        result.successful_recoveries++;

                        auto recovery_end = std::chrono::steady_clock::now();
                        double recovery_time = std::chrono::duration_cast<
                            std::chrono::milliseconds>(
                            recovery_end - recovery_start).count();

                        result.avg_recovery_time_ms =
                            (result.avg_recovery_time_ms *
                             (result.successful_recoveries - 1) + recovery_time) /
                            result.successful_recoveries;
                    }
                }
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }

        // Final system health check
        result.system_survived = checkSystemHealth(sim);

        return result;
    }

private:
    static void injectFault(SimulationEngine& sim, const ChaosConfig& config) {
        switch (config.fault_type) {
            case FaultType::HIGH_LATENCY:
                // Inject high latency
                break;

            case FaultType::NETWORK_PARTITION:
                // Simulate network partition
                break;

            case FaultType::COMPONENT_CRASH:
                // Crash a component
                break;

            default:
                break;
        }
    }

    static bool attemptRecovery(SimulationEngine& sim, FaultType fault) {
        // Recovery logic based on fault type
        return true;
    }

    static bool checkSystemHealth(SimulationEngine& sim) {
        // Health check implementation
        return true;
    }

    static std::string getFaultName(FaultType fault) {
        switch (fault) {
            case FaultType::NETWORK_PARTITION: return "Network Partition";
            case FaultType::HIGH_LATENCY: return "High Latency";
            case FaultType::PACKET_LOSS: return "Packet Loss";
            case FaultType::COMPONENT_CRASH: return "Component Crash";
            case FaultType::DISK_FULL: return "Disk Full";
            case FaultType::CPU_SATURATION: return "CPU Saturation";
            case FaultType::MEMORY_LEAK: return "Memory Leak";
            default: return "Unknown";
        }
    }
};

================================================================================
8. COMPLETE IMPLEMENTATION - USAGE EXAMPLE
================================================================================

#include "stress_testing.hpp"
#include <iostream>

int main() {
    using namespace hft::simulation;

    SimulationEngine sim;
    // ... setup simulation ...

    // 1. Load testing
    std::cout << "=== LOAD TESTING ===" << std::endl;

    LoadTestConfig load_config;
    load_config.initial_load = 100;
    load_config.target_load = 5000;
    load_config.load_increment = 500;

    LoadTestEngine load_engine(load_config);
    auto load_results = load_engine.runLoadTest(sim);

    for (const auto& result : load_results) {
        std::cout << "Load: " << result.load_level << " events/sec" << std::endl;
        std::cout << "  P99 latency: " << (result.p99_latency_ns / 1000.0)
                 << " Î¼s" << std::endl;
        std::cout << "  Throughput: " << result.achieved_throughput << std::endl;
        std::cout << "  Passed SLA: " << (result.passed_sla ? "Yes" : "No") << std::endl;
    }

    // 2. Volume testing
    std::cout << "\n=== VOLUME TESTING ===" << std::endl;

    VolumeStressTest::Config volume_config;
    volume_config.num_symbols = 1000;
    volume_config.ticks_per_symbol = 100000;

    auto volume_result = VolumeStressTest::runVolumeTest(volume_config);

    std::cout << "Ticks processed: " << volume_result.total_ticks_processed << std::endl;
    std::cout << "Processing rate: " << volume_result.processing_rate_ticks_per_sec
             << " ticks/sec" << std::endl;

    // 3. Chaos testing
    std::cout << "\n=== CHAOS TESTING ===" << std::endl;

    ChaosTestFramework::ChaosConfig chaos_config;
    chaos_config.fault_type = ChaosTestFramework::FaultType::HIGH_LATENCY;
    chaos_config.injection_probability = 0.05;

    auto chaos_result = ChaosTestFramework::runChaosTest(sim, chaos_config, 60000);

    std::cout << "Faults injected: " << chaos_result.faults_injected << std::endl;
    std::cout << "Recoveries: " << chaos_result.successful_recoveries << "/"
             << chaos_result.recovery_attempts << std::endl;
    std::cout << "System survived: "
             << (chaos_result.system_survived ? "Yes" : "No") << std::endl;

    return 0;
}

================================================================================
END OF DOCUMENT
================================================================================
