================================================================================
RUNNING STATUS MONITORING
Live System Status, Health Checks, and Real-Time Monitoring
================================================================================

VERSION: 1.0
DOCUMENT: Real-Time System Monitoring and Health Checks
LAST UPDATED: 2025-11-26

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. System Health Monitoring
3. Performance Metrics Tracking
4. Alert System
5. Status Dashboard
6. Heartbeat Monitoring
7. Resource Monitoring
8. Complete Implementation

================================================================================
1. OVERVIEW
================================================================================

The Running Status Monitoring system provides real-time visibility into
simulation and trading system health, performance, and operational status.

KEY FEATURES:
-------------
- Real-time health checks
- Performance metric streaming
- Alert and notification system
- Resource utilization monitoring
- Component status tracking
- Latency monitoring
- Error rate tracking
- Automated recovery mechanisms

MONITORING LEVELS:
------------------
1. SYSTEM: Overall system health
2. COMPONENT: Individual component status
3. STRATEGY: Strategy-level metrics
4. SYMBOL: Per-symbol statistics
5. NETWORK: Network and connectivity status

================================================================================
2. SYSTEM HEALTH MONITORING
================================================================================

2.1 HEALTH STATUS DEFINITIONS
------------------------------

enum class HealthStatus : uint8_t {
    HEALTHY,            // Operating normally
    DEGRADED,           // Reduced performance
    UNHEALTHY,          // Significant issues
    CRITICAL,           // Critical failure
    UNKNOWN             // Status unknown
};

enum class ComponentType : uint8_t {
    SIMULATION_ENGINE,
    MOCK_EXCHANGE,
    TICK_REPLAY,
    STRATEGY,
    LATENCY_SIMULATOR,
    TRADE_EXECUTOR,
    MARKET_DATA_HANDLER,
    ORDER_MANAGER,
    RISK_MANAGER,
    NETWORK_INTERFACE
};

struct ComponentHealth {
    ComponentType type;
    std::string name;
    HealthStatus status;
    uint64_t last_heartbeat_ns;
    uint64_t uptime_ns;

    // Metrics
    double cpu_usage_pct;
    double memory_usage_mb;
    uint64_t messages_processed;
    double avg_processing_latency_ns;

    // Errors
    uint64_t error_count;
    uint64_t warning_count;
    std::string last_error_message;

    ComponentHealth()
        : type(ComponentType::SIMULATION_ENGINE),
          status(HealthStatus::UNKNOWN),
          last_heartbeat_ns(0), uptime_ns(0),
          cpu_usage_pct(0), memory_usage_mb(0),
          messages_processed(0), avg_processing_latency_ns(0),
          error_count(0), warning_count(0) {}
};

struct SystemHealth {
    HealthStatus overall_status;
    uint64_t timestamp_ns;

    std::vector<ComponentHealth> components;

    // Aggregated metrics
    double total_cpu_usage_pct;
    double total_memory_usage_mb;
    uint64_t total_messages_processed;
    uint64_t total_errors;

    // System-wide thresholds
    bool cpu_warning;
    bool memory_warning;
    bool latency_warning;
    bool error_rate_warning;

    SystemHealth()
        : overall_status(HealthStatus::UNKNOWN),
          timestamp_ns(0), total_cpu_usage_pct(0),
          total_memory_usage_mb(0), total_messages_processed(0),
          total_errors(0), cpu_warning(false),
          memory_warning(false), latency_warning(false),
          error_rate_warning(false) {}
};

2.2 HEALTH CHECK ENGINE
------------------------

class HealthCheckEngine {
public:
    struct HealthCheckConfig {
        uint64_t check_interval_ns;         // How often to check
        uint64_t heartbeat_timeout_ns;      // Max time between heartbeats
        double cpu_warning_threshold;       // % CPU for warning
        double cpu_critical_threshold;      // % CPU for critical
        double memory_warning_threshold_mb;
        double memory_critical_threshold_mb;
        uint64_t latency_warning_threshold_ns;
        uint64_t latency_critical_threshold_ns;
        double error_rate_warning;          // Errors per second
    };

    explicit HealthCheckEngine(const HealthCheckConfig& config)
        : config_(config) {}

    SystemHealth performHealthCheck() {
        SystemHealth health;
        health.timestamp_ns = getCurrentTimeNs();

        // Check all registered components
        for (auto& [name, component] : registered_components_) {
            ComponentHealth comp_health = checkComponent(component);
            health.components.push_back(comp_health);

            // Aggregate metrics
            health.total_cpu_usage_pct += comp_health.cpu_usage_pct;
            health.total_memory_usage_mb += comp_health.memory_usage_mb;
            health.total_messages_processed += comp_health.messages_processed;
            health.total_errors += comp_health.error_count;
        }

        // Determine overall status
        health.overall_status = determineOverallStatus(health);

        // Check thresholds
        health.cpu_warning = health.total_cpu_usage_pct >
                            config_.cpu_warning_threshold;
        health.memory_warning = health.total_memory_usage_mb >
                               config_.memory_warning_threshold_mb;

        return health;
    }

    void registerComponent(const std::string& name,
                          std::shared_ptr<IMonitorableComponent> component) {
        registered_components_[name] = component;
    }

private:
    HealthCheckConfig config_;
    std::unordered_map<std::string,
                      std::shared_ptr<IMonitorableComponent>> registered_components_;

    ComponentHealth checkComponent(std::shared_ptr<IMonitorableComponent> component) {
        ComponentHealth health;
        health.name = component->getName();
        health.type = component->getType();

        // Check heartbeat
        uint64_t now = getCurrentTimeNs();
        health.last_heartbeat_ns = component->getLastHeartbeat();
        uint64_t time_since_heartbeat = now - health.last_heartbeat_ns;

        if (time_since_heartbeat > config_.heartbeat_timeout_ns) {
            health.status = HealthStatus::CRITICAL;
        } else {
            // Get component metrics
            auto metrics = component->getMetrics();

            health.cpu_usage_pct = metrics.cpu_usage_pct;
            health.memory_usage_mb = metrics.memory_usage_mb;
            health.messages_processed = metrics.messages_processed;
            health.avg_processing_latency_ns = metrics.avg_processing_latency_ns;
            health.error_count = metrics.error_count;
            health.warning_count = metrics.warning_count;
            health.last_error_message = metrics.last_error_message;

            // Determine status based on metrics
            health.status = evaluateComponentStatus(metrics);
        }

        return health;
    }

    HealthStatus evaluateComponentStatus(const ComponentMetrics& metrics) {
        // Check for critical conditions
        if (metrics.cpu_usage_pct > config_.cpu_critical_threshold ||
            metrics.memory_usage_mb > config_.memory_critical_threshold_mb ||
            metrics.avg_processing_latency_ns > config_.latency_critical_threshold_ns) {
            return HealthStatus::CRITICAL;
        }

        // Check for unhealthy conditions
        double error_rate = metrics.error_count /
                          (metrics.uptime_ns / 1e9);  // errors per second
        if (error_rate > config_.error_rate_warning) {
            return HealthStatus::UNHEALTHY;
        }

        // Check for degraded performance
        if (metrics.cpu_usage_pct > config_.cpu_warning_threshold ||
            metrics.memory_usage_mb > config_.memory_warning_threshold_mb ||
            metrics.avg_processing_latency_ns > config_.latency_warning_threshold_ns) {
            return HealthStatus::DEGRADED;
        }

        return HealthStatus::HEALTHY;
    }

    HealthStatus determineOverallStatus(const SystemHealth& health) {
        // Overall status is worst component status
        HealthStatus worst = HealthStatus::HEALTHY;

        for (const auto& comp : health.components) {
            if (comp.status > worst) {
                worst = comp.status;
            }
        }

        return worst;
    }

    uint64_t getCurrentTimeNs() const {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()
        ).count();
    }
};

================================================================================
3. PERFORMANCE METRICS TRACKING
================================================================================

3.1 REAL-TIME METRICS COLLECTOR
--------------------------------

class RealTimeMetricsCollector {
public:
    struct MetricPoint {
        uint64_t timestamp_ns;
        std::string metric_name;
        double value;
        std::unordered_map<std::string, std::string> tags;
    };

    void recordMetric(const std::string& name, double value,
                     const std::unordered_map<std::string, std::string>& tags = {}) {
        MetricPoint point;
        point.timestamp_ns = getCurrentTimeNs();
        point.metric_name = name;
        point.value = value;
        point.tags = tags;

        {
            std::lock_guard<std::mutex> lock(metrics_mutex_);
            metrics_.push_back(point);

            // Keep only last N points in memory
            if (metrics_.size() > max_points_) {
                metrics_.erase(metrics_.begin(),
                             metrics_.begin() + (metrics_.size() - max_points_));
            }
        }

        // Update time series
        updateTimeSeries(name, value);
    }

    struct TimeSeriesStats {
        double current_value;
        double avg_1min;
        double avg_5min;
        double avg_15min;
        double min_value;
        double max_value;
        double std_dev;

        TimeSeriesStats()
            : current_value(0), avg_1min(0), avg_5min(0), avg_15min(0),
              min_value(0), max_value(0), std_dev(0) {}
    };

    TimeSeriesStats getStats(const std::string& metric_name) const {
        std::lock_guard<std::mutex> lock(time_series_mutex_);

        auto it = time_series_.find(metric_name);
        if (it == time_series_.end()) {
            return TimeSeriesStats();
        }

        return calculateStats(it->second);
    }

    std::vector<MetricPoint> getMetrics(const std::string& name,
                                       uint64_t start_time_ns,
                                       uint64_t end_time_ns) const {
        std::lock_guard<std::mutex> lock(metrics_mutex_);
        std::vector<MetricPoint> result;

        for (const auto& point : metrics_) {
            if (point.metric_name == name &&
                point.timestamp_ns >= start_time_ns &&
                point.timestamp_ns <= end_time_ns) {
                result.push_back(point);
            }
        }

        return result;
    }

private:
    mutable std::mutex metrics_mutex_;
    mutable std::mutex time_series_mutex_;
    std::vector<MetricPoint> metrics_;
    size_t max_points_{100000};

    // Time series data (circular buffers)
    struct TimeSeries {
        std::deque<std::pair<uint64_t, double>> values;
        size_t max_size{10000};
    };

    std::unordered_map<std::string, TimeSeries> time_series_;

    void updateTimeSeries(const std::string& name, double value) {
        std::lock_guard<std::mutex> lock(time_series_mutex_);

        auto& ts = time_series_[name];
        ts.values.push_back({getCurrentTimeNs(), value});

        if (ts.values.size() > ts.max_size) {
            ts.values.pop_front();
        }
    }

    TimeSeriesStats calculateStats(const TimeSeries& ts) const {
        TimeSeriesStats stats;

        if (ts.values.empty()) return stats;

        uint64_t now = getCurrentTimeNs();
        stats.current_value = ts.values.back().second;

        // Calculate time-windowed averages
        const uint64_t ONE_MINUTE = 60ULL * 1000000000;
        const uint64_t FIVE_MINUTES = 5 * ONE_MINUTE;
        const uint64_t FIFTEEN_MINUTES = 15 * ONE_MINUTE;

        double sum_1min = 0, sum_5min = 0, sum_15min = 0;
        size_t count_1min = 0, count_5min = 0, count_15min = 0;

        stats.min_value = std::numeric_limits<double>::max();
        stats.max_value = std::numeric_limits<double>::lowest();

        std::vector<double> all_values;

        for (const auto& [timestamp, value] : ts.values) {
            uint64_t age = now - timestamp;

            if (age <= FIFTEEN_MINUTES) {
                sum_15min += value;
                count_15min++;

                if (age <= FIVE_MINUTES) {
                    sum_5min += value;
                    count_5min++;

                    if (age <= ONE_MINUTE) {
                        sum_1min += value;
                        count_1min++;
                    }
                }

                stats.min_value = std::min(stats.min_value, value);
                stats.max_value = std::max(stats.max_value, value);
                all_values.push_back(value);
            }
        }

        stats.avg_1min = count_1min > 0 ? sum_1min / count_1min : 0;
        stats.avg_5min = count_5min > 0 ? sum_5min / count_5min : 0;
        stats.avg_15min = count_15min > 0 ? sum_15min / count_15min : 0;

        // Calculate standard deviation
        if (!all_values.empty()) {
            double mean = std::accumulate(all_values.begin(),
                                        all_values.end(), 0.0) / all_values.size();
            double sq_sum = 0;
            for (double val : all_values) {
                sq_sum += (val - mean) * (val - mean);
            }
            stats.std_dev = std::sqrt(sq_sum / all_values.size());
        }

        return stats;
    }

    uint64_t getCurrentTimeNs() const {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()
        ).count();
    }
};

================================================================================
4. ALERT SYSTEM
================================================================================

4.1 ALERT DEFINITIONS
----------------------

enum class AlertSeverity : uint8_t {
    INFO,
    WARNING,
    ERROR,
    CRITICAL
};

enum class AlertType : uint8_t {
    PERFORMANCE_DEGRADATION,
    HIGH_CPU_USAGE,
    HIGH_MEMORY_USAGE,
    HIGH_LATENCY,
    HIGH_ERROR_RATE,
    COMPONENT_FAILURE,
    HEARTBEAT_TIMEOUT,
    THRESHOLD_BREACH,
    SYSTEM_RECOVERY,
    CUSTOM
};

struct Alert {
    uint64_t alert_id;
    uint64_t timestamp_ns;
    AlertSeverity severity;
    AlertType type;

    std::string component_name;
    std::string message;
    std::string details;

    // Metric context
    std::string metric_name;
    double metric_value;
    double threshold_value;

    // Alert state
    bool active;
    bool acknowledged;
    uint64_t acknowledged_by;
    uint64_t resolved_timestamp_ns;

    Alert()
        : alert_id(0), timestamp_ns(0),
          severity(AlertSeverity::INFO),
          type(AlertType::CUSTOM),
          metric_value(0), threshold_value(0),
          active(true), acknowledged(false),
          acknowledged_by(0), resolved_timestamp_ns(0) {}
};

4.2 ALERT MANAGER
------------------

class AlertManager {
public:
    using AlertCallback = std::function<void(const Alert&)>;

    struct AlertRule {
        std::string rule_name;
        std::string metric_name;
        AlertType type;
        AlertSeverity severity;

        enum class Condition {
            GREATER_THAN,
            LESS_THAN,
            EQUALS,
            RATE_OF_CHANGE
        } condition;

        double threshold;
        uint64_t duration_ns;  // Must exceed threshold for this duration

        bool enabled;

        AlertRule() : type(AlertType::CUSTOM),
                     severity(AlertSeverity::WARNING),
                     condition(Condition::GREATER_THAN),
                     threshold(0), duration_ns(0), enabled(true) {}
    };

    void addRule(const AlertRule& rule) {
        std::lock_guard<std::mutex> lock(rules_mutex_);
        rules_[rule.rule_name] = rule;
    }

    void evaluateMetric(const std::string& metric_name, double value) {
        std::lock_guard<std::mutex> lock(rules_mutex_);

        for (auto& [name, rule] : rules_) {
            if (!rule.enabled || rule.metric_name != metric_name) {
                continue;
            }

            bool condition_met = evaluateCondition(rule, value);

            if (condition_met) {
                // Check duration
                auto now = getCurrentTimeNs();
                auto it = rule_violations_.find(name);

                if (it == rule_violations_.end()) {
                    // First violation
                    rule_violations_[name] = now;
                } else {
                    // Check if violation duration exceeded
                    uint64_t violation_duration = now - it->second;
                    if (violation_duration >= rule.duration_ns) {
                        // Trigger alert
                        triggerAlert(rule, value);
                        rule_violations_.erase(it);  // Reset
                    }
                }
            } else {
                // Clear violation
                rule_violations_.erase(name);
            }
        }
    }

    void subscribeAlerts(AlertCallback callback) {
        std::lock_guard<std::mutex> lock(callbacks_mutex_);
        alert_callbacks_.push_back(callback);
    }

    void acknowledgeAlert(uint64_t alert_id, uint64_t user_id) {
        std::lock_guard<std::mutex> lock(alerts_mutex_);

        auto it = active_alerts_.find(alert_id);
        if (it != active_alerts_.end()) {
            it->second.acknowledged = true;
            it->second.acknowledged_by = user_id;
        }
    }

    void resolveAlert(uint64_t alert_id) {
        std::lock_guard<std::mutex> lock(alerts_mutex_);

        auto it = active_alerts_.find(alert_id);
        if (it != active_alerts_.end()) {
            it->second.active = false;
            it->second.resolved_timestamp_ns = getCurrentTimeNs();

            // Move to resolved alerts
            resolved_alerts_.push_back(it->second);
            active_alerts_.erase(it);
        }
    }

    std::vector<Alert> getActiveAlerts() const {
        std::lock_guard<std::mutex> lock(alerts_mutex_);
        std::vector<Alert> alerts;

        for (const auto& [id, alert] : active_alerts_) {
            alerts.push_back(alert);
        }

        return alerts;
    }

private:
    mutable std::mutex rules_mutex_;
    mutable std::mutex alerts_mutex_;
    mutable std::mutex callbacks_mutex_;

    std::unordered_map<std::string, AlertRule> rules_;
    std::unordered_map<uint64_t, Alert> active_alerts_;
    std::vector<Alert> resolved_alerts_;
    std::vector<AlertCallback> alert_callbacks_;

    std::unordered_map<std::string, uint64_t> rule_violations_;
    std::atomic<uint64_t> next_alert_id_{1};

    bool evaluateCondition(const AlertRule& rule, double value) {
        switch (rule.condition) {
            case AlertRule::Condition::GREATER_THAN:
                return value > rule.threshold;

            case AlertRule::Condition::LESS_THAN:
                return value < rule.threshold;

            case AlertRule::Condition::EQUALS:
                return std::abs(value - rule.threshold) < 1e-9;

            case AlertRule::Condition::RATE_OF_CHANGE:
                // Would track historical values
                return false;
        }

        return false;
    }

    void triggerAlert(const AlertRule& rule, double value) {
        Alert alert;
        alert.alert_id = next_alert_id_++;
        alert.timestamp_ns = getCurrentTimeNs();
        alert.severity = rule.severity;
        alert.type = rule.type;
        alert.message = "Threshold breach: " + rule.rule_name;
        alert.metric_name = rule.metric_name;
        alert.metric_value = value;
        alert.threshold_value = rule.threshold;
        alert.active = true;

        {
            std::lock_guard<std::mutex> lock(alerts_mutex_);
            active_alerts_[alert.alert_id] = alert;
        }

        // Notify subscribers
        {
            std::lock_guard<std::mutex> lock(callbacks_mutex_);
            for (auto& callback : alert_callbacks_) {
                callback(alert);
            }
        }
    }

    uint64_t getCurrentTimeNs() const {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()
        ).count();
    }
};

================================================================================
5. STATUS DASHBOARD
================================================================================

5.1 DASHBOARD GENERATOR
------------------------

class StatusDashboard {
public:
    struct DashboardData {
        SystemHealth system_health;
        std::map<std::string, RealTimeMetricsCollector::TimeSeriesStats> metrics;
        std::vector<Alert> active_alerts;

        // Key performance indicators
        struct KPIs {
            double orders_per_second;
            double fills_per_second;
            double avg_latency_us;
            double p99_latency_us;
            double error_rate;
            double uptime_pct;
        } kpis;
    };

    std::string generateHTML(const DashboardData& data) {
        std::ostringstream html;

        html << R"(
<!DOCTYPE html>
<html>
<head>
    <title>System Status Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .health-healthy { color: green; }
        .health-degraded { color: orange; }
        .health-unhealthy { color: red; }
        .health-critical { color: darkred; font-weight: bold; }
        .metric { margin: 10px; padding: 10px; border: 1px solid #ddd; }
        .alert { padding: 10px; margin: 5px; border-left: 4px solid red; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    </style>
</head>
<body>
    <h1>System Status Dashboard</h1>
)";

        // Overall health
        html << "<h2>System Health: "
             << "<span class='health-" << getHealthClass(data.system_health.overall_status)
             << "'>" << getHealthName(data.system_health.overall_status) << "</span>"
             << "</h2>";

        // KPIs
        html << "<h2>Key Performance Indicators</h2>";
        html << "<table>";
        html << "<tr><th>Metric</th><th>Value</th></tr>";
        html << "<tr><td>Orders/sec</td><td>" << data.kpis.orders_per_second << "</td></tr>";
        html << "<tr><td>Fills/sec</td><td>" << data.kpis.fills_per_second << "</td></tr>";
        html << "<tr><td>Avg Latency</td><td>" << data.kpis.avg_latency_us << " μs</td></tr>";
        html << "<tr><td>P99 Latency</td><td>" << data.kpis.p99_latency_us << " μs</td></tr>";
        html << "<tr><td>Error Rate</td><td>" << data.kpis.error_rate << "</td></tr>";
        html << "<tr><td>Uptime</td><td>" << data.kpis.uptime_pct << "%</td></tr>";
        html << "</table>";

        // Active alerts
        if (!data.active_alerts.empty()) {
            html << "<h2>Active Alerts (" << data.active_alerts.size() << ")</h2>";
            for (const auto& alert : data.active_alerts) {
                html << "<div class='alert'>";
                html << "<strong>" << getSeverityName(alert.severity) << "</strong>: ";
                html << alert.message;
                html << "</div>";
            }
        }

        // Components
        html << "<h2>Components</h2>";
        html << "<table>";
        html << "<tr><th>Component</th><th>Status</th><th>CPU %</th><th>Memory MB</th><th>Latency ns</th></tr>";
        for (const auto& comp : data.system_health.components) {
            html << "<tr>";
            html << "<td>" << comp.name << "</td>";
            html << "<td class='health-" << getHealthClass(comp.status) << "'>"
                 << getHealthName(comp.status) << "</td>";
            html << "<td>" << comp.cpu_usage_pct << "</td>";
            html << "<td>" << comp.memory_usage_mb << "</td>";
            html << "<td>" << comp.avg_processing_latency_ns << "</td>";
            html << "</tr>";
        }
        html << "</table>";

        html << "</body></html>";

        return html.str();
    }

    std::string generateJSON(const DashboardData& data) {
        // JSON generation
        std::ostringstream json;
        json << "{\n";
        json << "  \"overall_status\": \"" << getHealthName(data.system_health.overall_status) << "\",\n";
        json << "  \"kpis\": {\n";
        json << "    \"orders_per_second\": " << data.kpis.orders_per_second << ",\n";
        json << "    \"avg_latency_us\": " << data.kpis.avg_latency_us << "\n";
        json << "  }\n";
        json << "}\n";
        return json.str();
    }

private:
    std::string getHealthClass(HealthStatus status) {
        switch (status) {
            case HealthStatus::HEALTHY: return "healthy";
            case HealthStatus::DEGRADED: return "degraded";
            case HealthStatus::UNHEALTHY: return "unhealthy";
            case HealthStatus::CRITICAL: return "critical";
            default: return "unknown";
        }
    }

    std::string getHealthName(HealthStatus status) {
        switch (status) {
            case HealthStatus::HEALTHY: return "HEALTHY";
            case HealthStatus::DEGRADED: return "DEGRADED";
            case HealthStatus::UNHEALTHY: return "UNHEALTHY";
            case HealthStatus::CRITICAL: return "CRITICAL";
            default: return "UNKNOWN";
        }
    }

    std::string getSeverityName(AlertSeverity severity) {
        switch (severity) {
            case AlertSeverity::INFO: return "INFO";
            case AlertSeverity::WARNING: return "WARNING";
            case AlertSeverity::ERROR: return "ERROR";
            case AlertSeverity::CRITICAL: return "CRITICAL";
            default: return "UNKNOWN";
        }
    }
};

================================================================================
8. COMPLETE IMPLEMENTATION - USAGE EXAMPLE
================================================================================

#include "running_status.hpp"
#include <iostream>
#include <thread>

int main() {
    using namespace hft::simulation;

    // Create monitoring components
    HealthCheckEngine::HealthCheckConfig health_config;
    health_config.check_interval_ns = 1000000000;  // 1 second
    health_config.heartbeat_timeout_ns = 5000000000;  // 5 seconds
    health_config.cpu_warning_threshold = 70.0;
    health_config.cpu_critical_threshold = 90.0;
    health_config.memory_warning_threshold_mb = 2000.0;
    health_config.memory_critical_threshold_mb = 4000.0;

    HealthCheckEngine health_engine(health_config);
    RealTimeMetricsCollector metrics_collector;
    AlertManager alert_manager;

    // Setup alert rules
    AlertManager::AlertRule latency_rule;
    latency_rule.rule_name = "high_latency";
    latency_rule.metric_name = "order_latency";
    latency_rule.type = AlertType::HIGH_LATENCY;
    latency_rule.severity = AlertSeverity::WARNING;
    latency_rule.condition = AlertManager::AlertRule::Condition::GREATER_THAN;
    latency_rule.threshold = 1000.0;  // 1000 μs
    latency_rule.duration_ns = 10000000000;  // 10 seconds

    alert_manager.addRule(latency_rule);

    // Subscribe to alerts
    alert_manager.subscribeAlerts([](const Alert& alert) {
        std::cout << "ALERT: " << alert.message << std::endl;
    });

    // Monitoring loop
    while (true) {
        // Perform health check
        auto health = health_engine.performHealthCheck();

        std::cout << "System Health: "
                 << (health.overall_status == HealthStatus::HEALTHY ? "HEALTHY" : "UNHEALTHY")
                 << std::endl;

        // Record metrics
        metrics_collector.recordMetric("order_latency", 850.0);
        metrics_collector.recordMetric("cpu_usage", health.total_cpu_usage_pct);

        // Evaluate alerts
        alert_manager.evaluateMetric("order_latency", 850.0);

        // Generate dashboard
        StatusDashboard dashboard;
        StatusDashboard::DashboardData data;
        data.system_health = health;
        data.active_alerts = alert_manager.getActiveAlerts();

        std::string html = dashboard.generateHTML(data);
        // Write to file or serve via HTTP

        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    return 0;
}

================================================================================
END OF DOCUMENT
================================================================================
