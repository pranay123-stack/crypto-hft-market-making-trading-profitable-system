================================================================================
END OF DAY REPORTS
P&L Calculation, Trade Statistics, and Performance Metrics
================================================================================

VERSION: 1.0
DOCUMENT: Comprehensive EOD Reporting System
LAST UPDATED: 2025-11-26

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. P&L Calculation Engine
3. Trade Statistics and Analytics
4. Performance Metrics
5. Risk Metrics
6. Report Generation
7. Data Export Formats
8. Complete Implementation

================================================================================
1. OVERVIEW
================================================================================

The EOD (End of Day) Reporting System generates comprehensive analysis of
trading performance, risk metrics, and strategy evaluation for daily review
and regulatory compliance.

KEY REPORTS:
------------
- Daily P&L Summary
- Trade Statistics
- Performance Metrics (Sharpe, Sortino, etc.)
- Risk Metrics (VaR, Max Drawdown)
- Position Analysis
- Fill Quality Analysis
- Strategy Performance Breakdown
- Compliance Reports

OUTPUT FORMATS:
---------------
- JSON (machine-readable)
- CSV (spreadsheet import)
- HTML (interactive dashboard)
- PDF (archival/regulatory)
- Protocol Buffers (efficient storage)

================================================================================
2. P&L CALCULATION ENGINE
================================================================================

2.1 P&L STRUCTURES
------------------

struct PnLBreakdown {
    // Realized P&L
    double realized_pnl;
    double realized_gross_pnl;
    double realized_net_pnl;

    // Unrealized P&L
    double unrealized_pnl;
    double total_pnl;

    // P&L components
    double trading_pnl;
    double fees_paid;
    double rebates_received;
    double financing_costs;
    double slippage_cost;

    // Returns
    double return_pct;
    double return_bps;

    PnLBreakdown()
        : realized_pnl(0), realized_gross_pnl(0), realized_net_pnl(0),
          unrealized_pnl(0), total_pnl(0), trading_pnl(0),
          fees_paid(0), rebates_received(0), financing_costs(0),
          slippage_cost(0), return_pct(0), return_bps(0) {}
};

struct SymbolPnL {
    char symbol[16];
    PnLBreakdown pnl;

    uint64_t shares_traded;
    double notional_traded;
    uint32_t num_trades;

    // Best/worst trades
    double best_trade_pnl;
    double worst_trade_pnl;

    SymbolPnL() : shares_traded(0), notional_traded(0), num_trades(0),
                  best_trade_pnl(0), worst_trade_pnl(0) {
        symbol[0] = '\0';
    }
};

struct StrategyPnL {
    char strategy_name[64];
    PnLBreakdown pnl;

    std::vector<SymbolPnL> symbol_pnls;
    uint64_t total_trades;
    double avg_trade_pnl;

    StrategyPnL() : total_trades(0), avg_trade_pnl(0) {
        strategy_name[0] = '\0';
    }
};

2.2 P&L CALCULATOR
------------------

class PnLCalculator {
public:
    explicit PnLCalculator(double initial_capital)
        : initial_capital_(initial_capital), current_capital_(initial_capital) {}

    void processFill(const Fill& fill, const Position& position) {
        if (fill.side == OrderSide::BUY) {
            // Opening or adding to long position
            double cost = fill.quantity * fill.price + fill.fee_amount;
            current_capital_ -= cost;

            updatePosition(fill);
        } else {
            // Closing long or opening/adding to short
            double proceeds = fill.quantity * fill.price - fill.fee_amount;
            current_capital_ += proceeds;

            // Calculate realized P&L if closing
            if (position.quantity > 0) {
                double realized = fill.quantity * (fill.price - position.avg_price);
                realized_pnl_ += realized;
                realized_gross_pnl_ += realized;
                realized_net_pnl_ += realized - fill.fee_amount;
            }

            updatePosition(fill);
        }

        // Track fees
        fees_paid_ += fill.fee_amount;
        if (fill.is_maker) {
            rebates_received_ += std::abs(fill.fee_amount);  // Maker rebate
        }
    }

    void updateUnrealizedPnL(const std::unordered_map<std::string, Position>& positions,
                            const std::unordered_map<std::string, double>& current_prices) {
        unrealized_pnl_ = 0.0;

        for (const auto& [symbol, position] : positions) {
            auto it = current_prices.find(symbol);
            if (it != current_prices.end()) {
                double current_price = it->second;
                double position_pnl = position.quantity *
                                     (current_price - position.avg_price);
                unrealized_pnl_ += position_pnl;
            }
        }
    }

    PnLBreakdown getPnLBreakdown() const {
        PnLBreakdown pnl;
        pnl.realized_pnl = realized_pnl_;
        pnl.realized_gross_pnl = realized_gross_pnl_;
        pnl.realized_net_pnl = realized_net_pnl_;
        pnl.unrealized_pnl = unrealized_pnl_;
        pnl.total_pnl = realized_net_pnl_ + unrealized_pnl_;

        pnl.trading_pnl = realized_gross_pnl_;
        pnl.fees_paid = fees_paid_;
        pnl.rebates_received = rebates_received_;

        pnl.return_pct = (pnl.total_pnl / initial_capital_) * 100.0;
        pnl.return_bps = pnl.return_pct * 100.0;

        return pnl;
    }

    double getCurrentCapital() const {
        return current_capital_ + unrealized_pnl_;
    }

    double getInitialCapital() const { return initial_capital_; }

private:
    double initial_capital_;
    double current_capital_;

    double realized_pnl_{0.0};
    double realized_gross_pnl_{0.0};
    double realized_net_pnl_{0.0};
    double unrealized_pnl_{0.0};

    double fees_paid_{0.0};
    double rebates_received_{0.0};

    void updatePosition(const Fill& fill) {
        // Position tracking implementation
    }
};

2.3 ATTRIBUTION ANALYSIS
-------------------------

class PnLAttributionAnalyzer {
public:
    struct Attribution {
        double market_timing_pnl;       // P&L from entry/exit timing
        double position_sizing_pnl;     // P&L from position sizing
        double execution_cost;          // Cost of execution (slippage, fees)
        double market_impact_cost;      // Market impact cost
        double adverse_selection_cost;  // Adverse selection cost

        double total_pnl() const {
            return market_timing_pnl + position_sizing_pnl -
                   execution_cost - market_impact_cost - adverse_selection_cost;
        }
    };

    Attribution analyzeTrade(const Trade& trade, const MarketState& market) {
        Attribution attr;

        // Analyze market timing (alpha)
        attr.market_timing_pnl = calculateTimingAlpha(trade, market);

        // Analyze position sizing
        attr.position_sizing_pnl = calculateSizingEfficiency(trade, market);

        // Calculate costs
        attr.execution_cost = trade.total_fees + trade.total_slippage;
        attr.market_impact_cost = trade.estimated_market_impact;
        attr.adverse_selection_cost = trade.adverse_selection_cost;

        return attr;
    }

private:
    double calculateTimingAlpha(const Trade& trade, const MarketState& market) {
        // Compare trade P&L to market returns
        double market_return = market.getReturn(trade.entry_time, trade.exit_time);
        double trade_return = trade.pnl / trade.entry_value;

        return (trade_return - market_return) * trade.entry_value;
    }

    double calculateSizingEfficiency(const Trade& trade, const MarketState& market) {
        // Analyze if position size was optimal given risk/reward
        double kelly_optimal_size = calculateKellyOptimalSize(trade, market);
        double actual_size = trade.quantity;

        // P&L difference from optimal sizing
        double sizing_efficiency = std::min(actual_size, kelly_optimal_size) /
                                  kelly_optimal_size;

        return trade.pnl * sizing_efficiency;
    }

    double calculateKellyOptimalSize(const Trade& trade, const MarketState& market) {
        // Kelly criterion for optimal position sizing
        double win_prob = market.getWinProbability(trade);
        double avg_win = market.getAverageWin(trade);
        double avg_loss = market.getAverageLoss(trade);

        if (avg_loss == 0) return 0.0;

        double kelly_fraction = (win_prob * avg_win - (1 - win_prob) * avg_loss) /
                               avg_win;
        return std::max(0.0, kelly_fraction);
    }
};

================================================================================
3. TRADE STATISTICS AND ANALYTICS
================================================================================

3.1 TRADE STATISTICS
--------------------

struct TradeStatistics {
    // Volume statistics
    uint64_t total_trades;
    uint64_t total_shares;
    double total_notional;
    double avg_trade_size;
    double median_trade_size;

    // Win/Loss statistics
    uint64_t winning_trades;
    uint64_t losing_trades;
    uint64_t breakeven_trades;
    double win_rate;

    double total_wins;
    double total_losses;
    double avg_win;
    double avg_loss;
    double largest_win;
    double largest_loss;
    double win_loss_ratio;

    // Timing statistics
    double avg_hold_time_ms;
    double median_hold_time_ms;
    double shortest_trade_ms;
    double longest_trade_ms;

    // Execution quality
    double avg_slippage_bps;
    double avg_market_impact_bps;
    double total_fees;
    double total_rebates;
    double net_fees;

    // Consecutive statistics
    uint32_t max_consecutive_wins;
    uint32_t max_consecutive_losses;
    uint32_t current_streak;

    TradeStatistics() { memset(this, 0, sizeof(TradeStatistics)); }
};

class TradeStatisticsCalculator {
public:
    TradeStatistics calculate(const std::vector<Trade>& trades) {
        TradeStatistics stats;

        if (trades.empty()) return stats;

        std::vector<double> trade_sizes;
        std::vector<double> hold_times;
        std::vector<double> pnls;

        for (const auto& trade : trades) {
            stats.total_trades++;
            stats.total_shares += trade.quantity;
            stats.total_notional += trade.quantity * trade.entry_price;

            trade_sizes.push_back(trade.quantity);
            hold_times.push_back((trade.exit_time - trade.entry_time) / 1e6);  // ms

            double pnl = trade.realized_pnl;
            pnls.push_back(pnl);

            if (pnl > 0) {
                stats.winning_trades++;
                stats.total_wins += pnl;
                stats.largest_win = std::max(stats.largest_win, pnl);
            } else if (pnl < 0) {
                stats.losing_trades++;
                stats.total_losses += std::abs(pnl);
                stats.largest_loss = std::min(stats.largest_loss, pnl);
            } else {
                stats.breakeven_trades++;
            }

            stats.total_fees += trade.total_fees;
            stats.total_rebates += trade.total_rebates;
        }

        // Calculate derived statistics
        stats.avg_trade_size = stats.total_notional / stats.total_trades;
        stats.median_trade_size = calculateMedian(trade_sizes);

        if (stats.total_trades > 0) {
            stats.win_rate = static_cast<double>(stats.winning_trades) /
                           stats.total_trades;
        }

        if (stats.winning_trades > 0) {
            stats.avg_win = stats.total_wins / stats.winning_trades;
        }

        if (stats.losing_trades > 0) {
            stats.avg_loss = stats.total_losses / stats.losing_trades;
        }

        if (stats.avg_loss > 0) {
            stats.win_loss_ratio = stats.avg_win / stats.avg_loss;
        }

        stats.avg_hold_time_ms = calculateMean(hold_times);
        stats.median_hold_time_ms = calculateMedian(hold_times);
        stats.shortest_trade_ms = *std::min_element(hold_times.begin(),
                                                     hold_times.end());
        stats.longest_trade_ms = *std::max_element(hold_times.begin(),
                                                   hold_times.end());

        stats.net_fees = stats.total_fees - stats.total_rebates;

        // Calculate consecutive streaks
        calculateStreaks(pnls, stats);

        return stats;
    }

private:
    double calculateMean(const std::vector<double>& values) {
        if (values.empty()) return 0.0;
        return std::accumulate(values.begin(), values.end(), 0.0) / values.size();
    }

    double calculateMedian(std::vector<double> values) {
        if (values.empty()) return 0.0;

        size_t n = values.size();
        std::nth_element(values.begin(), values.begin() + n/2, values.end());

        if (n % 2 == 0) {
            double med1 = values[n/2];
            std::nth_element(values.begin(), values.begin() + n/2 - 1, values.end());
            return (med1 + values[n/2 - 1]) / 2.0;
        }

        return values[n/2];
    }

    void calculateStreaks(const std::vector<double>& pnls, TradeStatistics& stats) {
        uint32_t current_win_streak = 0;
        uint32_t current_loss_streak = 0;

        for (double pnl : pnls) {
            if (pnl > 0) {
                current_win_streak++;
                current_loss_streak = 0;
                stats.max_consecutive_wins = std::max(stats.max_consecutive_wins,
                                                     current_win_streak);
            } else if (pnl < 0) {
                current_loss_streak++;
                current_win_streak = 0;
                stats.max_consecutive_losses = std::max(stats.max_consecutive_losses,
                                                       current_loss_streak);
            }
        }

        stats.current_streak = (current_win_streak > 0) ?
                               current_win_streak : -current_loss_streak;
    }
};

================================================================================
4. PERFORMANCE METRICS
================================================================================

4.1 PERFORMANCE CALCULATOR
---------------------------

class PerformanceMetricsCalculator {
public:
    struct Metrics {
        // Return metrics
        double total_return_pct;
        double annualized_return_pct;
        double cagr_pct;  // Compound Annual Growth Rate

        // Risk-adjusted returns
        double sharpe_ratio;
        double sortino_ratio;
        double calmar_ratio;
        double information_ratio;

        // Risk metrics
        double volatility_annualized;
        double downside_deviation;
        double max_drawdown_pct;
        double max_drawdown_duration_days;

        // Trade efficiency
        double profit_factor;      // Gross profit / Gross loss
        double expectancy;         // Average $ per trade
        double kelly_criterion;    // Optimal position sizing

        // Benchmark comparison
        double alpha;
        double beta;
        double r_squared;

        Metrics() { memset(this, 0, sizeof(Metrics)); }
    };

    Metrics calculate(const std::vector<double>& daily_returns,
                     const std::vector<double>& benchmark_returns = {},
                     double risk_free_rate = 0.02) {
        Metrics metrics;

        if (daily_returns.empty()) return metrics;

        // Return metrics
        double cum_return = 1.0;
        for (double ret : daily_returns) {
            cum_return *= (1.0 + ret);
        }
        metrics.total_return_pct = (cum_return - 1.0) * 100.0;

        double trading_days = daily_returns.size();
        double years = trading_days / 252.0;
        metrics.annualized_return_pct = (std::pow(cum_return, 1.0 / years) - 1.0) * 100.0;
        metrics.cagr_pct = metrics.annualized_return_pct;

        // Volatility
        double mean_return = calculateMean(daily_returns);
        double variance = calculateVariance(daily_returns, mean_return);
        double daily_vol = std::sqrt(variance);
        metrics.volatility_annualized = daily_vol * std::sqrt(252.0) * 100.0;

        // Sharpe ratio
        double daily_rf = risk_free_rate / 252.0;
        double excess_return = mean_return - daily_rf;
        if (daily_vol > 0) {
            metrics.sharpe_ratio = (excess_return / daily_vol) * std::sqrt(252.0);
        }

        // Sortino ratio (downside deviation)
        metrics.downside_deviation = calculateDownsideDeviation(daily_returns, 0.0);
        if (metrics.downside_deviation > 0) {
            metrics.sortino_ratio = (excess_return / metrics.downside_deviation) *
                                   std::sqrt(252.0);
        }

        // Max drawdown
        auto [max_dd, dd_duration] = calculateMaxDrawdown(daily_returns);
        metrics.max_drawdown_pct = max_dd * 100.0;
        metrics.max_drawdown_duration_days = dd_duration;

        // Calmar ratio
        if (metrics.max_drawdown_pct > 0) {
            metrics.calmar_ratio = metrics.annualized_return_pct /
                                  metrics.max_drawdown_pct;
        }

        // Benchmark comparison (if provided)
        if (!benchmark_returns.empty() && benchmark_returns.size() == daily_returns.size()) {
            calculateBenchmarkMetrics(daily_returns, benchmark_returns, metrics);
        }

        return metrics;
    }

private:
    double calculateMean(const std::vector<double>& values) {
        return std::accumulate(values.begin(), values.end(), 0.0) / values.size();
    }

    double calculateVariance(const std::vector<double>& values, double mean) {
        double sq_sum = 0.0;
        for (double val : values) {
            sq_sum += (val - mean) * (val - mean);
        }
        return sq_sum / values.size();
    }

    double calculateDownsideDeviation(const std::vector<double>& returns,
                                     double target_return) {
        double sq_sum = 0.0;
        size_t count = 0;

        for (double ret : returns) {
            if (ret < target_return) {
                double diff = ret - target_return;
                sq_sum += diff * diff;
                count++;
            }
        }

        if (count == 0) return 0.0;
        return std::sqrt(sq_sum / count);
    }

    std::pair<double, double> calculateMaxDrawdown(const std::vector<double>& returns) {
        double cumulative = 0.0;
        double peak = 0.0;
        double max_dd = 0.0;

        size_t peak_idx = 0;
        size_t trough_idx = 0;
        size_t temp_peak_idx = 0;

        for (size_t i = 0; i < returns.size(); ++i) {
            cumulative += returns[i];

            if (cumulative > peak) {
                peak = cumulative;
                temp_peak_idx = i;
            }

            double drawdown = peak - cumulative;
            if (drawdown > max_dd) {
                max_dd = drawdown;
                peak_idx = temp_peak_idx;
                trough_idx = i;
            }
        }

        double dd_duration = static_cast<double>(trough_idx - peak_idx);
        return {max_dd, dd_duration};
    }

    void calculateBenchmarkMetrics(const std::vector<double>& returns,
                                   const std::vector<double>& benchmark,
                                   Metrics& metrics) {
        // Calculate beta (covariance / variance of benchmark)
        double mean_ret = calculateMean(returns);
        double mean_bench = calculateMean(benchmark);

        double covariance = 0.0;
        double bench_variance = 0.0;

        for (size_t i = 0; i < returns.size(); ++i) {
            double ret_dev = returns[i] - mean_ret;
            double bench_dev = benchmark[i] - mean_bench;

            covariance += ret_dev * bench_dev;
            bench_variance += bench_dev * bench_dev;
        }

        covariance /= returns.size();
        bench_variance /= benchmark.size();

        if (bench_variance > 0) {
            metrics.beta = covariance / bench_variance;
        }

        // Calculate alpha (excess return over CAPM)
        double bench_annual_return = calculateMean(benchmark) * 252.0;
        metrics.alpha = metrics.annualized_return_pct / 100.0 -
                       (metrics.beta * bench_annual_return);

        // Calculate R-squared
        double ss_tot = 0.0;
        double ss_res = 0.0;

        for (size_t i = 0; i < returns.size(); ++i) {
            double predicted = metrics.alpha / 252.0 + metrics.beta * benchmark[i];
            ss_res += (returns[i] - predicted) * (returns[i] - predicted);
            ss_tot += (returns[i] - mean_ret) * (returns[i] - mean_ret);
        }

        if (ss_tot > 0) {
            metrics.r_squared = 1.0 - (ss_res / ss_tot);
        }
    }
};

================================================================================
5. RISK METRICS
================================================================================

5.1 RISK CALCULATOR
-------------------

class RiskMetricsCalculator {
public:
    struct RiskMetrics {
        // Value at Risk
        double var_95_daily;
        double var_99_daily;
        double cvar_95;  // Conditional VaR (Expected Shortfall)

        // Position risk
        double gross_exposure;
        double net_exposure;
        double leverage_ratio;

        // Concentration risk
        double largest_position_pct;
        double top5_concentration_pct;
        double herfindahl_index;

        // Greeks (if applicable)
        double delta;
        double gamma;
        double vega;

        RiskMetrics() { memset(this, 0, sizeof(RiskMetrics)); }
    };

    RiskMetrics calculate(const std::vector<double>& returns,
                         const Portfolio& portfolio) {
        RiskMetrics metrics;

        // Calculate VaR using historical simulation
        metrics.var_95_daily = calculateHistoricalVaR(returns, 0.95);
        metrics.var_99_daily = calculateHistoricalVaR(returns, 0.99);
        metrics.cvar_95 = calculateConditionalVaR(returns, 0.95);

        // Position risk
        metrics.gross_exposure = portfolio.getGrossExposure();
        metrics.net_exposure = portfolio.getNetExposure();
        metrics.leverage_ratio = metrics.gross_exposure / portfolio.getCapital();

        // Concentration risk
        auto positions = portfolio.getPositions();
        calculateConcentrationMetrics(positions, portfolio.getTotalValue(), metrics);

        return metrics;
    }

private:
    double calculateHistoricalVaR(std::vector<double> returns, double confidence) {
        if (returns.empty()) return 0.0;

        std::sort(returns.begin(), returns.end());
        size_t idx = static_cast<size_t>((1.0 - confidence) * returns.size());
        return -returns[idx];  // Negative for loss
    }

    double calculateConditionalVaR(std::vector<double> returns, double confidence) {
        if (returns.empty()) return 0.0;

        std::sort(returns.begin(), returns.end());
        size_t idx = static_cast<size_t>((1.0 - confidence) * returns.size());

        double sum = 0.0;
        for (size_t i = 0; i <= idx; ++i) {
            sum += returns[i];
        }

        return -sum / (idx + 1);
    }

    void calculateConcentrationMetrics(const std::vector<Position>& positions,
                                      double total_value,
                                      RiskMetrics& metrics) {
        if (positions.empty() || total_value == 0) return;

        std::vector<double> position_values;
        for (const auto& pos : positions) {
            double value = std::abs(pos.quantity * pos.current_price);
            position_values.push_back(value);
        }

        std::sort(position_values.begin(), position_values.end(), std::greater<double>());

        // Largest position
        metrics.largest_position_pct = (position_values[0] / total_value) * 100.0;

        // Top 5 concentration
        double top5_value = 0.0;
        for (size_t i = 0; i < std::min(size_t(5), position_values.size()); ++i) {
            top5_value += position_values[i];
        }
        metrics.top5_concentration_pct = (top5_value / total_value) * 100.0;

        // Herfindahl index (sum of squared market shares)
        double hhi = 0.0;
        for (double value : position_values) {
            double share = value / total_value;
            hhi += share * share;
        }
        metrics.herfindahl_index = hhi;
    }
};

================================================================================
6. REPORT GENERATION
================================================================================

6.1 EOD REPORT GENERATOR
-------------------------

class EODReportGenerator {
public:
    struct ReportConfig {
        bool include_trades;
        bool include_positions;
        bool include_orders;
        bool include_market_data;
        bool generate_charts;
        std::vector<std::string> output_formats;  // "json", "csv", "html", "pdf"
    };

    struct EODReport {
        uint64_t report_date_ns;
        std::string trading_day;

        PnLBreakdown total_pnl;
        std::vector<StrategyPnL> strategy_pnls;
        std::vector<SymbolPnL> symbol_pnls;

        TradeStatistics trade_stats;
        PerformanceMetricsCalculator::Metrics performance;
        RiskMetricsCalculator::RiskMetrics risk;

        std::vector<Trade> all_trades;
        std::vector<Position> eod_positions;

        std::string comments;
    };

    EODReport generateReport(const SimulationResults& results,
                            const ReportConfig& config) {
        EODReport report;
        report.report_date_ns = getCurrentTimeNs();
        report.trading_day = formatDate(results.end_time_ns);

        // Calculate P&L
        PnLCalculator pnl_calc(results.initial_capital);
        for (const auto& fill : results.fills) {
            pnl_calc.processFill(fill, results.getPosition(fill.symbol));
        }
        report.total_pnl = pnl_calc.getPnLBreakdown();

        // Calculate trade statistics
        TradeStatisticsCalculator stats_calc;
        report.trade_stats = stats_calc.calculate(results.trades);

        // Calculate performance metrics
        PerformanceMetricsCalculator perf_calc;
        report.performance = perf_calc.calculate(results.daily_returns);

        // Calculate risk metrics
        RiskMetricsCalculator risk_calc;
        report.risk = risk_calc.calculate(results.daily_returns, results.portfolio);

        // Add details if requested
        if (config.include_trades) {
            report.all_trades = results.trades;
        }

        if (config.include_positions) {
            report.eod_positions = results.portfolio.getPositions();
        }

        return report;
    }

    void exportReport(const EODReport& report, const ReportConfig& config,
                     const std::string& output_dir) {
        for (const auto& format : config.output_formats) {
            if (format == "json") {
                exportJSON(report, output_dir + "/eod_report.json");
            } else if (format == "csv") {
                exportCSV(report, output_dir + "/eod_report.csv");
            } else if (format == "html") {
                exportHTML(report, output_dir + "/eod_report.html");
            } else if (format == "pdf") {
                exportPDF(report, output_dir + "/eod_report.pdf");
            }
        }
    }

private:
    void exportJSON(const EODReport& report, const std::string& filename) {
        // JSON export implementation
        std::ofstream file(filename);
        file << "{\n";
        file << "  \"report_date\": \"" << report.trading_day << "\",\n";
        file << "  \"total_pnl\": " << report.total_pnl.total_pnl << ",\n";
        file << "  \"return_pct\": " << report.total_pnl.return_pct << ",\n";
        file << "  \"sharpe_ratio\": " << report.performance.sharpe_ratio << ",\n";
        file << "  \"total_trades\": " << report.trade_stats.total_trades << ",\n";
        file << "  \"win_rate\": " << report.trade_stats.win_rate << "\n";
        file << "}\n";
    }

    void exportCSV(const EODReport& report, const std::string& filename) {
        // CSV export for trade list
        std::ofstream file(filename);
        file << "Date,Symbol,Side,Quantity,Entry Price,Exit Price,P&L,Duration\n";

        for (const auto& trade : report.all_trades) {
            file << formatDate(trade.entry_time) << ","
                 << trade.symbol << ","
                 << (trade.side == OrderSide::BUY ? "BUY" : "SELL") << ","
                 << trade.quantity << ","
                 << trade.entry_price << ","
                 << trade.exit_price << ","
                 << trade.realized_pnl << ","
                 << ((trade.exit_time - trade.entry_time) / 1e6) << "\n";
        }
    }

    void exportHTML(const EODReport& report, const std::string& filename) {
        // HTML dashboard export
        std::ofstream file(filename);
        file << "<html><head><title>EOD Report</title></head><body>\n";
        file << "<h1>End of Day Report - " << report.trading_day << "</h1>\n";
        file << "<h2>P&L Summary</h2>\n";
        file << "<p>Total P&L: $" << report.total_pnl.total_pnl << "</p>\n";
        file << "<p>Return: " << report.total_pnl.return_pct << "%</p>\n";
        file << "<h2>Performance Metrics</h2>\n";
        file << "<p>Sharpe Ratio: " << report.performance.sharpe_ratio << "</p>\n";
        file << "<p>Win Rate: " << (report.trade_stats.win_rate * 100) << "%</p>\n";
        file << "</body></html>\n";
    }

    void exportPDF(const EODReport& report, const std::string& filename) {
        // PDF export (would use library like libharu)
        // Placeholder implementation
    }

    std::string formatDate(uint64_t timestamp_ns) {
        time_t seconds = timestamp_ns / 1000000000;
        struct tm* tm_info = localtime(&seconds);
        char buffer[32];
        strftime(buffer, sizeof(buffer), "%Y-%m-%d", tm_info);
        return std::string(buffer);
    }

    uint64_t getCurrentTimeNs() {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();
    }
};

================================================================================
8. COMPLETE IMPLEMENTATION - USAGE EXAMPLE
================================================================================

#include "eod_reporter.hpp"
#include <iostream>

int main() {
    using namespace hft::simulation;

    // Simulate some trading results
    SimulationResults results;
    results.initial_capital = 100000.0;
    // ... populate with trades, fills, positions ...

    // Configure report
    EODReportGenerator::ReportConfig config;
    config.include_trades = true;
    config.include_positions = true;
    config.include_orders = false;
    config.generate_charts = true;
    config.output_formats = {"json", "csv", "html"};

    // Generate report
    EODReportGenerator generator;
    auto report = generator.generateReport(results, config);

    // Print summary
    std::cout << "EOD Report for " << report.trading_day << std::endl;
    std::cout << "================================" << std::endl;
    std::cout << "Total P&L: $" << report.total_pnl.total_pnl << std::endl;
    std::cout << "Return: " << report.total_pnl.return_pct << "%" << std::endl;
    std::cout << "Trades: " << report.trade_stats.total_trades << std::endl;
    std::cout << "Win Rate: " << (report.trade_stats.win_rate * 100) << "%" << std::endl;
    std::cout << "Sharpe Ratio: " << report.performance.sharpe_ratio << std::endl;
    std::cout << "Max Drawdown: " << report.performance.max_drawdown_pct << "%" << std::endl;

    // Export reports
    generator.exportReport(report, config, "output/reports");

    std::cout << "\nReports exported to output/reports/" << std::endl;

    return 0;
}

================================================================================
END OF DOCUMENT
================================================================================
