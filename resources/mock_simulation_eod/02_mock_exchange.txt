================================================================================
MOCK EXCHANGE IMPLEMENTATION
Order Matching Engine and Market Simulation
================================================================================

VERSION: 1.0
DOCUMENT: Mock Exchange - Order Book and Matching Engine
LAST UPDATED: 2025-11-26

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. Order Book Architecture
3. Matching Engine Algorithms
4. Order Types and Handling
5. Market Data Generation
6. Fee Structures
7. Exchange Rejects and Edge Cases
8. Complete Implementation

================================================================================
1. OVERVIEW
================================================================================

The Mock Exchange provides a realistic simulation of exchange behavior including:

- Full order book with multiple price levels
- Price-time priority matching
- Support for multiple order types (limit, market, IOC, FOK, etc.)
- Realistic latency and reject scenarios
- Market data generation (trades, quotes, order book updates)
- Fee calculation (maker/taker rebates)
- Market impact modeling

PERFORMANCE CHARACTERISTICS:
----------------------------
- Order Processing: < 50 nanoseconds
- Book Update: < 30 nanoseconds
- Match Processing: < 20 nanoseconds per level
- Memory per Symbol: ~5MB (1000 price levels)

================================================================================
2. ORDER BOOK ARCHITECTURE
================================================================================

2.1 ORDER BOOK STRUCTURE
-------------------------

The order book maintains bid and ask sides as sorted price levels:

     ASK SIDE (Ascending Price)
┌─────────────────────────────────┐
│ Level 0: $150.03  500 shares    │
│ Level 1: $150.02  1000 shares   │
│ Level 2: $150.01  750 shares    │
└─────────────────────────────────┘
        SPREAD: $0.02
┌─────────────────────────────────┐
│ Level 0: $149.99  800 shares    │
│ Level 1: $149.98  1200 shares   │
│ Level 2: $149.97  600 shares    │
└─────────────────────────────────┘
     BID SIDE (Descending Price)

2.2 PRICE LEVEL IMPLEMENTATION
-------------------------------

// Single price level in order book
struct PriceLevel {
    double price;
    uint64_t total_quantity;
    uint32_t order_count;
    std::deque<Order*> orders;  // FIFO queue for time priority

    PriceLevel() : price(0.0), total_quantity(0), order_count(0) {}

    explicit PriceLevel(double p)
        : price(p), total_quantity(0), order_count(0) {}

    void addOrder(Order* order) {
        orders.push_back(order);
        total_quantity += order->remaining_quantity;
        order_count++;
    }

    void removeOrder(Order* order) {
        auto it = std::find(orders.begin(), orders.end(), order);
        if (it != orders.end()) {
            total_quantity -= order->remaining_quantity;
            orders.erase(it);
            order_count--;
        }
    }

    Order* getFirstOrder() {
        return orders.empty() ? nullptr : orders.front();
    }

    void removeFirstOrder() {
        if (!orders.empty()) {
            total_quantity -= orders.front()->remaining_quantity;
            orders.pop_front();
            order_count--;
        }
    }
};

2.3 ORDER STRUCTURE
-------------------

enum class OrderType : uint8_t {
    LIMIT,      // Standard limit order
    MARKET,     // Market order
    STOP,       // Stop order
    STOP_LIMIT, // Stop-limit order
    IOC,        // Immediate-or-Cancel
    FOK,        // Fill-or-Kill
    POST_ONLY,  // Post-only (must be maker)
    ICEBERG     // Iceberg order (hidden quantity)
};

enum class OrderSide : uint8_t {
    BUY = 0,
    SELL = 1
};

enum class OrderStatus : uint8_t {
    NEW,
    PARTIALLY_FILLED,
    FILLED,
    CANCELLED,
    REJECTED,
    EXPIRED
};

struct Order {
    uint64_t order_id;
    uint64_t client_order_id;
    char symbol[16];
    OrderType type;
    OrderSide side;
    OrderStatus status;

    double price;
    uint64_t quantity;
    uint64_t remaining_quantity;
    uint64_t filled_quantity;

    uint64_t timestamp_ns;          // Order entry time
    uint64_t last_update_ns;        // Last modification time

    // For iceberg orders
    uint64_t visible_quantity;
    uint64_t hidden_quantity;

    // For stop orders
    double stop_price;

    // Time in force
    enum class TimeInForce : uint8_t {
        DAY,        // Good for day
        GTC,        // Good till cancelled
        IOC,        // Immediate or cancel
        FOK         // Fill or kill
    } time_in_force;

    // Account information
    uint64_t account_id;
    char trader_id[32];

    Order()
        : order_id(0), client_order_id(0), type(OrderType::LIMIT),
          side(OrderSide::BUY), status(OrderStatus::NEW), price(0.0),
          quantity(0), remaining_quantity(0), filled_quantity(0),
          timestamp_ns(0), last_update_ns(0), visible_quantity(0),
          hidden_quantity(0), stop_price(0.0),
          time_in_force(TimeInForce::DAY), account_id(0) {
        symbol[0] = '\0';
        trader_id[0] = '\0';
    }

    bool isActive() const {
        return status == OrderStatus::NEW ||
               status == OrderStatus::PARTIALLY_FILLED;
    }

    bool canMatch() const {
        return isActive() && remaining_quantity > 0;
    }
};

2.4 ORDER BOOK CLASS
--------------------

class OrderBook {
public:
    OrderBook(const std::string& symbol, double tick_size = 0.01)
        : symbol_(symbol), tick_size_(tick_size), sequence_number_(0) {}

    // Order management
    bool addOrder(Order* order);
    bool cancelOrder(uint64_t order_id);
    bool modifyOrder(uint64_t order_id, double new_price, uint64_t new_quantity);

    // Market data
    double getBestBid() const;
    double getBestAsk() const;
    double getMidPrice() const;
    double getSpread() const;

    uint64_t getBidSize(double price) const;
    uint64_t getAskSize(double price) const;

    // Book depth
    std::vector<PriceLevel> getBids(size_t depth = 10) const;
    std::vector<PriceLevel> getAsks(size_t depth = 10) const;

    // Statistics
    uint64_t getTotalBidVolume() const { return total_bid_volume_; }
    uint64_t getTotalAskVolume() const { return total_ask_volume_; }
    size_t getOrderCount() const { return orders_.size(); }

private:
    std::string symbol_;
    double tick_size_;
    std::atomic<uint64_t> sequence_number_;

    // Price levels (map: price -> level)
    std::map<double, PriceLevel, std::greater<double>> bid_levels_;  // Descending
    std::map<double, PriceLevel> ask_levels_;  // Ascending

    // All orders (map: order_id -> order)
    std::unordered_map<uint64_t, Order*> orders_;

    // Volume tracking
    uint64_t total_bid_volume_;
    uint64_t total_ask_volume_;

    // Thread safety
    mutable std::shared_mutex mutex_;

    // Helper methods
    void addBidOrder(Order* order);
    void addAskOrder(Order* order);
    void removeBidOrder(Order* order);
    void removeAskOrder(Order* order);

    double normalizePrice(double price) const;
};

================================================================================
3. MATCHING ENGINE ALGORITHMS
================================================================================

3.1 PRICE-TIME PRIORITY MATCHING
---------------------------------

class MatchingEngine {
public:
    struct MatchResult {
        std::vector<Fill> fills;
        Order* aggressor_order;
        uint64_t matched_quantity;
        double average_price;
        bool fully_filled;

        MatchResult() : aggressor_order(nullptr), matched_quantity(0),
                       average_price(0.0), fully_filled(false) {}
    };

    MatchResult matchOrder(Order* order, OrderBook& book);

private:
    MatchResult matchBuyOrder(Order* order, OrderBook& book);
    MatchResult matchSellOrder(Order* order, OrderBook& book);

    Fill createFill(Order* maker, Order* taker, uint64_t quantity,
                   double price, uint64_t timestamp_ns);
};

// Main matching logic
MatchingEngine::MatchResult MatchingEngine::matchOrder(Order* order,
                                                       OrderBook& book) {
    if (order->side == OrderSide::BUY) {
        return matchBuyOrder(order, book);
    } else {
        return matchSellOrder(order, book);
    }
}

// Match buy order against ask side
MatchingEngine::MatchResult MatchingEngine::matchBuyOrder(Order* order,
                                                          OrderBook& book) {
    MatchResult result;
    result.aggressor_order = order;

    double total_value = 0.0;
    uint64_t current_time = getCurrentTimeNs();

    // Get ask levels
    auto ask_levels = book.getAsks(100);  // Check top 100 levels

    for (auto& level : ask_levels) {
        // Stop if no more quantity to fill
        if (order->remaining_quantity == 0) {
            break;
        }

        // Check if price crosses
        if (order->type == OrderType::LIMIT && order->price < level.price) {
            break;  // No more matches possible
        }

        // Match against orders at this level
        while (!level.orders.empty() && order->remaining_quantity > 0) {
            Order* maker_order = level.getFirstOrder();
            if (!maker_order || !maker_order->canMatch()) {
                level.removeFirstOrder();
                continue;
            }

            // Determine fill quantity
            uint64_t fill_qty = std::min(order->remaining_quantity,
                                        maker_order->remaining_quantity);

            // Create fill for both sides
            Fill maker_fill = createFill(maker_order, order, fill_qty,
                                        level.price, current_time);
            Fill taker_fill = createFill(order, maker_order, fill_qty,
                                        level.price, current_time);

            // Update orders
            order->remaining_quantity -= fill_qty;
            order->filled_quantity += fill_qty;
            maker_order->remaining_quantity -= fill_qty;
            maker_order->filled_quantity += fill_qty;

            // Update status
            if (order->remaining_quantity == 0) {
                order->status = OrderStatus::FILLED;
            } else {
                order->status = OrderStatus::PARTIALLY_FILLED;
            }

            if (maker_order->remaining_quantity == 0) {
                maker_order->status = OrderStatus::FILLED;
                level.removeFirstOrder();
            }

            // Add to result
            result.fills.push_back(taker_fill);
            result.matched_quantity += fill_qty;
            total_value += fill_qty * level.price;
        }
    }

    // Calculate average fill price
    if (result.matched_quantity > 0) {
        result.average_price = total_value / result.matched_quantity;
    }

    result.fully_filled = (order->remaining_quantity == 0);

    return result;
}

// Match sell order against bid side (similar to buy)
MatchingEngine::MatchResult MatchingEngine::matchSellOrder(Order* order,
                                                           OrderBook& book) {
    MatchResult result;
    result.aggressor_order = order;

    double total_value = 0.0;
    uint64_t current_time = getCurrentTimeNs();

    // Get bid levels
    auto bid_levels = book.getBids(100);

    for (auto& level : bid_levels) {
        if (order->remaining_quantity == 0) break;

        // Check if price crosses
        if (order->type == OrderType::LIMIT && order->price > level.price) {
            break;
        }

        // Match against orders at this level
        while (!level.orders.empty() && order->remaining_quantity > 0) {
            Order* maker_order = level.getFirstOrder();
            if (!maker_order || !maker_order->canMatch()) {
                level.removeFirstOrder();
                continue;
            }

            uint64_t fill_qty = std::min(order->remaining_quantity,
                                        maker_order->remaining_quantity);

            Fill maker_fill = createFill(maker_order, order, fill_qty,
                                        level.price, current_time);
            Fill taker_fill = createFill(order, maker_order, fill_qty,
                                        level.price, current_time);

            order->remaining_quantity -= fill_qty;
            order->filled_quantity += fill_qty;
            maker_order->remaining_quantity -= fill_qty;
            maker_order->filled_quantity += fill_qty;

            if (order->remaining_quantity == 0) {
                order->status = OrderStatus::FILLED;
            } else {
                order->status = OrderStatus::PARTIALLY_FILLED;
            }

            if (maker_order->remaining_quantity == 0) {
                maker_order->status = OrderStatus::FILLED;
                level.removeFirstOrder();
            }

            result.fills.push_back(taker_fill);
            result.matched_quantity += fill_qty;
            total_value += fill_qty * level.price;
        }
    }

    if (result.matched_quantity > 0) {
        result.average_price = total_value / result.matched_quantity;
    }

    result.fully_filled = (order->remaining_quantity == 0);

    return result;
}

3.2 FILL STRUCTURE
------------------

struct Fill {
    uint64_t fill_id;
    uint64_t order_id;
    uint64_t client_order_id;
    char symbol[16];

    OrderSide side;
    double price;
    uint64_t quantity;

    uint64_t timestamp_ns;
    uint64_t sequence_number;

    // Fee information
    double fee_amount;
    bool is_maker;  // true if maker, false if taker

    // Counterparty (optional, for auditing)
    uint64_t counterparty_order_id;

    Fill() : fill_id(0), order_id(0), client_order_id(0),
             side(OrderSide::BUY), price(0.0), quantity(0),
             timestamp_ns(0), sequence_number(0),
             fee_amount(0.0), is_maker(false),
             counterparty_order_id(0) {
        symbol[0] = '\0';
    }
};

Fill MatchingEngine::createFill(Order* order, Order* counterparty,
                               uint64_t quantity, double price,
                               uint64_t timestamp_ns) {
    static std::atomic<uint64_t> next_fill_id{1};

    Fill fill;
    fill.fill_id = next_fill_id++;
    fill.order_id = order->order_id;
    fill.client_order_id = order->client_order_id;
    strncpy(fill.symbol, order->symbol, sizeof(fill.symbol) - 1);

    fill.side = order->side;
    fill.price = price;
    fill.quantity = quantity;
    fill.timestamp_ns = timestamp_ns;

    fill.counterparty_order_id = counterparty->order_id;

    return fill;
}

================================================================================
4. ORDER TYPES AND HANDLING
================================================================================

4.1 LIMIT ORDER HANDLING
-------------------------

bool MockExchange::handleLimitOrder(Order* order) {
    OrderBook& book = getOrderBook(order->symbol);

    // Try to match immediately
    auto match_result = matching_engine_.matchOrder(order, book);

    // Process fills
    for (const auto& fill : match_result.fills) {
        publishFill(fill);
    }

    // If order has remaining quantity, add to book
    if (order->remaining_quantity > 0 &&
        order->time_in_force != Order::TimeInForce::IOC &&
        order->time_in_force != Order::TimeInForce::FOK) {
        book.addOrder(order);
        publishOrderBookUpdate(order->symbol);
    } else if (order->time_in_force == Order::TimeInForce::FOK &&
               !match_result.fully_filled) {
        // Fill-or-Kill: cancel if not fully filled
        order->status = OrderStatus::CANCELLED;
        publishOrderStatus(order);
    }

    return true;
}

4.2 MARKET ORDER HANDLING
--------------------------

bool MockExchange::handleMarketOrder(Order* order) {
    OrderBook& book = getOrderBook(order->symbol);

    // Market orders must match immediately
    auto match_result = matching_engine_.matchOrder(order, book);

    // Process fills
    for (const auto& fill : match_result.fills) {
        publishFill(fill);
    }

    // Any remaining quantity is cancelled (no book to lean on)
    if (order->remaining_quantity > 0) {
        order->status = OrderStatus::CANCELLED;
        publishOrderStatus(order);
    }

    return true;
}

4.3 ICEBERG ORDER HANDLING
---------------------------

bool MockExchange::handleIcebergOrder(Order* order) {
    // Show only visible quantity in book
    uint64_t original_qty = order->quantity;
    order->quantity = order->visible_quantity;
    order->remaining_quantity = order->visible_quantity;

    // Process like normal limit order
    bool result = handleLimitOrder(order);

    // When visible portion is filled, replenish from hidden
    if (order->remaining_quantity == 0 && order->hidden_quantity > 0) {
        uint64_t replenish = std::min(order->visible_quantity,
                                     order->hidden_quantity);
        order->quantity = replenish;
        order->remaining_quantity = replenish;
        order->hidden_quantity -= replenish;

        // Add back to book with new timestamp (lose priority)
        order->timestamp_ns = getCurrentTimeNs();
        OrderBook& book = getOrderBook(order->symbol);
        book.addOrder(order);
    }

    return result;
}

4.4 POST-ONLY ORDER HANDLING
-----------------------------

bool MockExchange::handlePostOnlyOrder(Order* order) {
    OrderBook& book = getOrderBook(order->symbol);

    // Check if order would cross
    bool would_cross = false;
    if (order->side == OrderSide::BUY) {
        double best_ask = book.getBestAsk();
        would_cross = (best_ask > 0 && order->price >= best_ask);
    } else {
        double best_bid = book.getBestBid();
        would_cross = (best_bid > 0 && order->price <= best_bid);
    }

    if (would_cross) {
        // Reject order - would take liquidity
        order->status = OrderStatus::REJECTED;
        publishOrderStatus(order);
        return false;
    }

    // Add to book without matching
    book.addOrder(order);
    publishOrderBookUpdate(order->symbol);
    return true;
}

================================================================================
5. MARKET DATA GENERATION
================================================================================

5.1 MARKET DATA TYPES
----------------------

struct QuoteData {
    char symbol[16];
    uint64_t timestamp_ns;
    uint64_t sequence_number;

    double bid_price;
    uint64_t bid_size;
    double ask_price;
    uint64_t ask_size;

    // Additional depth (optional)
    struct Level {
        double price;
        uint64_t size;
    };
    std::vector<Level> bid_levels;
    std::vector<Level> ask_levels;
};

struct TradeData {
    char symbol[16];
    uint64_t timestamp_ns;
    uint64_t sequence_number;

    double price;
    uint64_t quantity;
    char aggressor_side;  // 'B' or 'S'

    uint64_t buy_order_id;
    uint64_t sell_order_id;
};

struct OrderBookUpdate {
    char symbol[16];
    uint64_t timestamp_ns;
    uint64_t sequence_number;

    enum class Action : uint8_t {
        ADD, MODIFY, DELETE
    };

    Action action;
    OrderSide side;
    double price;
    uint64_t quantity;
    uint64_t order_id;
};

5.2 MARKET DATA PUBLISHER
--------------------------

class MarketDataPublisher {
public:
    using QuoteCallback = std::function<void(const QuoteData&)>;
    using TradeCallback = std::function<void(const TradeData&)>;
    using BookCallback = std::function<void(const OrderBookUpdate&)>;

    void subscribeQuotes(const std::string& symbol, QuoteCallback callback) {
        quote_subscribers_[symbol].push_back(std::move(callback));
    }

    void subscribeTrades(const std::string& symbol, TradeCallback callback) {
        trade_subscribers_[symbol].push_back(std::move(callback));
    }

    void subscribeBookUpdates(const std::string& symbol, BookCallback callback) {
        book_subscribers_[symbol].push_back(std::move(callback));
    }

    void publishQuote(const QuoteData& quote) {
        auto it = quote_subscribers_.find(quote.symbol);
        if (it != quote_subscribers_.end()) {
            for (auto& callback : it->second) {
                callback(quote);
            }
        }
    }

    void publishTrade(const TradeData& trade) {
        auto it = trade_subscribers_.find(trade.symbol);
        if (it != trade_subscribers_.end()) {
            for (auto& callback : it->second) {
                callback(trade);
            }
        }
    }

    void publishBookUpdate(const OrderBookUpdate& update) {
        auto it = book_subscribers_.find(update.symbol);
        if (it != book_subscribers_.end()) {
            for (auto& callback : it->second) {
                callback(update);
            }
        }
    }

private:
    std::unordered_map<std::string, std::vector<QuoteCallback>> quote_subscribers_;
    std::unordered_map<std::string, std::vector<TradeCallback>> trade_subscribers_;
    std::unordered_map<std::string, std::vector<BookCallback>> book_subscribers_;
};

================================================================================
6. FEE STRUCTURES
================================================================================

6.1 FEE CALCULATOR
------------------

class FeeCalculator {
public:
    struct FeeSchedule {
        double maker_fee_bps;      // Negative = rebate
        double taker_fee_bps;
        double min_fee;
        double max_fee;

        // Tiered pricing
        struct Tier {
            uint64_t volume_threshold;  // Monthly volume
            double maker_fee_bps;
            double taker_fee_bps;
        };
        std::vector<Tier> tiers;
    };

    explicit FeeCalculator(const FeeSchedule& schedule)
        : schedule_(schedule) {}

    double calculateFee(const Fill& fill, uint64_t monthly_volume) const {
        // Determine tier
        const auto* tier = getTier(monthly_volume);
        double fee_bps = fill.is_maker ? tier->maker_fee_bps : tier->taker_fee_bps;

        // Calculate fee
        double notional = fill.price * fill.quantity;
        double fee = notional * fee_bps / 10000.0;

        // Apply limits
        if (fee > 0) {
            fee = std::max(fee, schedule_.min_fee);
            fee = std::min(fee, schedule_.max_fee);
        }

        return fee;
    }

private:
    FeeSchedule schedule_;

    const FeeSchedule::Tier* getTier(uint64_t volume) const {
        for (const auto& tier : schedule_.tiers) {
            if (volume < tier.volume_threshold) {
                return &tier;
            }
        }
        // Return highest tier
        return schedule_.tiers.empty() ? nullptr : &schedule_.tiers.back();
    }
};

// Typical fee schedule
FeeSchedule createTypicalFeeSchedule() {
    FeeSchedule schedule;
    schedule.maker_fee_bps = -2.0;   // 0.02% rebate
    schedule.taker_fee_bps = 3.0;    // 0.03% fee
    schedule.min_fee = 0.01;
    schedule.max_fee = 1000.0;

    // Volume tiers
    schedule.tiers = {
        {0,          -2.0,  3.0},   // 0-1M
        {1000000,    -2.5,  2.5},   // 1M-10M
        {10000000,   -3.0,  2.0},   // 10M-100M
        {100000000,  -3.5,  1.5}    // 100M+
    };

    return schedule;
}

================================================================================
7. EXCHANGE REJECTS AND EDGE CASES
================================================================================

7.1 ORDER VALIDATION
---------------------

enum class RejectReason : uint8_t {
    INVALID_SYMBOL,
    INVALID_PRICE,
    INVALID_QUANTITY,
    INSUFFICIENT_BALANCE,
    DUPLICATE_ORDER_ID,
    MARKET_CLOSED,
    HALTED,
    POSITION_LIMIT,
    NOTIONAL_LIMIT,
    RISK_CHECK_FAILED,
    SELF_TRADE_PREVENTION,
    POST_ONLY_WOULD_CROSS,
    UNKNOWN_ERROR
};

struct ValidationResult {
    bool valid;
    RejectReason reason;
    std::string message;

    ValidationResult() : valid(true), reason(RejectReason::UNKNOWN_ERROR) {}
};

class OrderValidator {
public:
    ValidationResult validate(const Order* order, const ExchangeState& state) {
        ValidationResult result;

        // Check symbol
        if (!state.isValidSymbol(order->symbol)) {
            result.valid = false;
            result.reason = RejectReason::INVALID_SYMBOL;
            result.message = "Invalid symbol: " + std::string(order->symbol);
            return result;
        }

        // Check price
        if (order->type == OrderType::LIMIT) {
            if (order->price <= 0 || !std::isfinite(order->price)) {
                result.valid = false;
                result.reason = RejectReason::INVALID_PRICE;
                result.message = "Invalid price";
                return result;
            }

            // Check tick size
            double tick_size = state.getTickSize(order->symbol);
            double price_ticks = order->price / tick_size;
            if (std::abs(price_ticks - std::round(price_ticks)) > 1e-9) {
                result.valid = false;
                result.reason = RejectReason::INVALID_PRICE;
                result.message = "Price not on tick size";
                return result;
            }
        }

        // Check quantity
        if (order->quantity == 0 || order->quantity > 1000000) {
            result.valid = false;
            result.reason = RejectReason::INVALID_QUANTITY;
            result.message = "Invalid quantity";
            return result;
        }

        // Check market hours
        if (!state.isMarketOpen(order->symbol)) {
            result.valid = false;
            result.reason = RejectReason::MARKET_CLOSED;
            result.message = "Market closed";
            return result;
        }

        // Check if halted
        if (state.isHalted(order->symbol)) {
            result.valid = false;
            result.reason = RejectReason::HALTED;
            result.message = "Symbol halted";
            return result;
        }

        // Risk checks
        auto risk_result = state.checkRiskLimits(order);
        if (!risk_result.valid) {
            return risk_result;
        }

        return result;
    }
};

7.2 SELF-TRADE PREVENTION
--------------------------

class SelfTradePreventionEngine {
public:
    enum class STPMode {
        NONE,           // No STP
        CANCEL_RESTING, // Cancel resting order
        CANCEL_INCOMING,// Cancel incoming order
        CANCEL_BOTH     // Cancel both orders
    };

    bool checkSelfTrade(const Order* incoming, const Order* resting,
                       STPMode mode) {
        // Check if same account/trader
        if (incoming->account_id != resting->account_id) {
            return false;  // Not a self-trade
        }

        // Self-trade detected - apply policy
        switch (mode) {
            case STPMode::CANCEL_RESTING:
                const_cast<Order*>(resting)->status = OrderStatus::CANCELLED;
                return true;

            case STPMode::CANCEL_INCOMING:
                const_cast<Order*>(incoming)->status = OrderStatus::CANCELLED;
                return true;

            case STPMode::CANCEL_BOTH:
                const_cast<Order*>(resting)->status = OrderStatus::CANCELLED;
                const_cast<Order*>(incoming)->status = OrderStatus::CANCELLED;
                return true;

            default:
                return false;  // Allow self-trade
        }
    }
};

================================================================================
8. COMPLETE MOCK EXCHANGE IMPLEMENTATION
================================================================================

File: include/mock_exchange.hpp

#ifndef MOCK_EXCHANGE_HPP
#define MOCK_EXCHANGE_HPP

#include "simulation_engine.hpp"
#include <memory>
#include <unordered_map>
#include <shared_mutex>

namespace hft {
namespace simulation {

class MockExchange : public ISimulationComponent {
public:
    explicit MockExchange(const std::string& name = "MockExchange");
    ~MockExchange() override;

    // ISimulationComponent interface
    void initialize(SimulationContext& ctx) override;
    void start() override;
    void stop() override;
    void shutdown() override;
    void onEvent(const IEvent& event) override;
    void onTimerTick(uint64_t timestamp_ns) override;
    ComponentState getState() const override;
    std::string getName() const override { return name_; }

    // Order management
    uint64_t submitOrder(const Order& order);
    bool cancelOrder(uint64_t order_id);
    bool modifyOrder(uint64_t order_id, double new_price, uint64_t new_qty);

    // Market data
    OrderBook& getOrderBook(const std::string& symbol);
    QuoteData getQuote(const std::string& symbol);
    std::vector<TradeData> getRecentTrades(const std::string& symbol,
                                          size_t count = 100);

    // Configuration
    void setFeeSchedule(const FeeSchedule& schedule);
    void addSymbol(const std::string& symbol, double tick_size = 0.01);
    void setMarketHours(const std::string& symbol, uint64_t open_ns,
                       uint64_t close_ns);

    // Market data subscriptions
    void subscribeQuotes(const std::string& symbol,
                        std::function<void(const QuoteData&)> callback);
    void subscribeTrades(const std::string& symbol,
                        std::function<void(const TradeData&)> callback);

private:
    std::string name_;
    SimulationContext* ctx_;
    ComponentState state_;

    // Order books per symbol
    std::unordered_map<std::string, std::unique_ptr<OrderBook>> order_books_;

    // All orders
    std::unordered_map<uint64_t, std::unique_ptr<Order>> orders_;
    std::atomic<uint64_t> next_order_id_{1};

    // Matching engine
    MatchingEngine matching_engine_;

    // Validators
    OrderValidator validator_;
    SelfTradePreventionEngine stp_engine_;

    // Fee calculation
    FeeCalculator fee_calculator_;

    // Market data publisher
    MarketDataPublisher md_publisher_;

    // Synchronization
    mutable std::shared_mutex mutex_;

    // Helper methods
    bool processOrder(Order* order);
    void publishFill(const Fill& fill);
    void publishOrderStatus(const Order* order);
    void publishOrderBookUpdate(const std::string& symbol);

    uint64_t getCurrentTimeNs() const;
};

} // namespace simulation
} // namespace hft

#endif // MOCK_EXCHANGE_HPP

================================================================================
USAGE EXAMPLE
================================================================================

#include "mock_exchange.hpp"
#include <iostream>

int main() {
    using namespace hft::simulation;

    // Create simulation environment
    SimulationEngine sim;
    MockExchange exchange("NYSE");

    // Configure exchange
    exchange.addSymbol("AAPL", 0.01);
    exchange.setFeeSchedule(createTypicalFeeSchedule());

    // Subscribe to market data
    exchange.subscribeQuotes("AAPL",
        [](const QuoteData& quote) {
            std::cout << "Quote: " << quote.bid_price << " x " << quote.ask_price
                     << std::endl;
        });

    exchange.subscribeTrades("AAPL",
        [](const TradeData& trade) {
            std::cout << "Trade: " << trade.price << " x " << trade.quantity
                     << std::endl;
        });

    // Submit orders
    Order buy_order;
    strcpy(buy_order.symbol, "AAPL");
    buy_order.side = OrderSide::BUY;
    buy_order.type = OrderType::LIMIT;
    buy_order.price = 150.00;
    buy_order.quantity = 100;
    buy_order.remaining_quantity = 100;

    uint64_t order_id = exchange.submitOrder(buy_order);
    std::cout << "Submitted order: " << order_id << std::endl;

    // Submit matching sell order
    Order sell_order;
    strcpy(sell_order.symbol, "AAPL");
    sell_order.side = OrderSide::SELL;
    sell_order.type = OrderType::LIMIT;
    sell_order.price = 150.00;
    sell_order.quantity = 50;
    sell_order.remaining_quantity = 50;

    exchange.submitOrder(sell_order);

    // Get order book
    OrderBook& book = exchange.getOrderBook("AAPL");
    std::cout << "Best bid: " << book.getBestBid() << std::endl;
    std::cout << "Best ask: " << book.getBestAsk() << std::endl;
    std::cout << "Spread: " << book.getSpread() << std::endl;

    return 0;
}

================================================================================
END OF DOCUMENT
================================================================================
