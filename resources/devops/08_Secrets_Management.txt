================================================================================
SECRETS MANAGEMENT FOR HFT SYSTEMS
================================================================================
Complete guide for managing secrets, credentials, and sensitive data using
HashiCorp Vault, AWS Secrets Manager, and Kubernetes Secrets.

Last Updated: 2025-11-25
================================================================================

TABLE OF CONTENTS
================================================================================
1. HashiCorp Vault Setup
2. AWS Secrets Manager
3. Kubernetes Secrets
4. Secret Rotation
5. Encryption at Rest
6. Access Control
7. Audit Logging
8. Best Practices

================================================================================
1. HASHICORP VAULT SETUP
================================================================================

# docker-compose.vault.yml
version: '3.8'

services:
  vault:
    image: vault:1.15
    container_name: vault
    ports:
      - "8200:8200"
    environment:
      - VAULT_DEV_ROOT_TOKEN_ID=root
      - VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200
    cap_add:
      - IPC_LOCK
    volumes:
      - vault-data:/vault/file
      - ./vault/config:/vault/config
    command: server

  vault-init:
    image: vault:1.15
    depends_on:
      - vault
    environment:
      - VAULT_ADDR=http://vault:8200
      - VAULT_TOKEN=root
    volumes:
      - ./vault/scripts:/scripts
    entrypoint: /scripts/init-vault.sh

volumes:
  vault-data:

---
# vault/config/vault.hcl
storage "file" {
  path = "/vault/file"
}

listener "tcp" {
  address     = "0.0.0.0:8200"
  tls_disable = 1
}

# Production configuration with TLS
# listener "tcp" {
#   address       = "0.0.0.0:8200"
#   tls_cert_file = "/vault/certs/vault.crt"
#   tls_key_file  = "/vault/certs/vault.key"
# }

ui = true
api_addr = "http://0.0.0.0:8200"
cluster_addr = "https://127.0.0.1:8201"

# Enable Prometheus metrics
telemetry {
  prometheus_retention_time = "30s"
  disable_hostname = true
}

---
# vault/scripts/init-vault.sh
#!/bin/bash
set -e

echo "Waiting for Vault to start..."
sleep 5

# Check if Vault is already initialized
if vault status | grep -q "Initialized.*true"; then
    echo "Vault is already initialized"
    exit 0
fi

# Initialize Vault
vault operator init -key-shares=5 -key-threshold=3 \
    -format=json > /vault/init-keys.json

# Unseal Vault
UNSEAL_KEY_1=$(jq -r '.unseal_keys_b64[0]' < /vault/init-keys.json)
UNSEAL_KEY_2=$(jq -r '.unseal_keys_b64[1]' < /vault/init-keys.json)
UNSEAL_KEY_3=$(jq -r '.unseal_keys_b64[2]' < /vault/init-keys.json)

vault operator unseal $UNSEAL_KEY_1
vault operator unseal $UNSEAL_KEY_2
vault operator unseal $UNSEAL_KEY_3

# Get root token
ROOT_TOKEN=$(jq -r '.root_token' < /vault/init-keys.json)
export VAULT_TOKEN=$ROOT_TOKEN

# Enable secret engines
vault secrets enable -path=secret kv-v2
vault secrets enable -path=database database
vault secrets enable pki

# Enable auth methods
vault auth enable kubernetes
vault auth enable approle

# Create policies
vault policy write trading-engine - <<EOF
path "secret/data/hft-trading/*" {
  capabilities = ["read", "list"]
}

path "database/creds/hft-trading" {
  capabilities = ["read"]
}
EOF

# Configure Kubernetes auth
vault write auth/kubernetes/config \
    kubernetes_host="https://kubernetes.default.svc:443" \
    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    token_reviewer_jwt=@/var/run/secrets/kubernetes.io/serviceaccount/token

# Create Kubernetes role
vault write auth/kubernetes/role/trading-engine \
    bound_service_account_names=trading-engine \
    bound_service_account_namespaces=hft-trading \
    policies=trading-engine \
    ttl=24h

# Store initial secrets
vault kv put secret/hft-trading/database \
    username=hftuser \
    password=changeme123 \
    host=postgres.hft-trading.svc.cluster.local \
    port=5432 \
    database=hft_trading

vault kv put secret/hft-trading/redis \
    host=redis.hft-trading.svc.cluster.local \
    port=6379 \
    password=redispassword123

vault kv put secret/hft-trading/api-keys \
    exchange_api_key=api_key_here \
    exchange_secret_key=secret_key_here

echo "Vault initialization complete!"

---
# scripts/vault-setup-production.sh
#!/bin/bash
set -e

echo "Setting up Vault for production..."

# Deploy Vault via Helm
helm repo add hashicorp https://helm.releases.hashicorp.com
helm repo update

helm install vault hashicorp/vault \
    --namespace vault \
    --create-namespace \
    --values - <<EOF
server:
  standalone:
    enabled: false
  ha:
    enabled: true
    replicas: 3
    raft:
      enabled: true
      setNodeId: true
      config: |
        ui = true
        listener "tcp" {
          tls_disable = 0
          address = "[::]:8200"
          cluster_address = "[::]:8201"
          tls_cert_file = "/vault/userconfig/vault-tls/tls.crt"
          tls_key_file = "/vault/userconfig/vault-tls/tls.key"
        }
        storage "raft" {
          path = "/vault/data"
        }
        service_registration "kubernetes" {}

  dataStorage:
    enabled: true
    size: 10Gi
    storageClass: fast-ssd

  auditStorage:
    enabled: true
    size: 10Gi

injector:
  enabled: true
  metrics:
    enabled: true
EOF

# Wait for Vault pods
kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=vault -n vault --timeout=300s

# Initialize Vault (only on first pod)
kubectl exec vault-0 -n vault -- vault operator init \
    -key-shares=5 \
    -key-threshold=3 \
    -format=json > vault-init-keys.json

# Securely store init keys
aws s3 cp vault-init-keys.json s3://hft-vault-backup/init-keys.json \
    --sse aws:kms \
    --sse-kms-key-id alias/vault-backup

echo "Vault production setup complete!"

---
# Client application integration
# src/vault_client.cpp
#include <curl/curl.h>
#include <nlohmann/json.hpp>
#include <string>
#include <memory>

class VaultClient {
public:
    VaultClient(const std::string& vault_addr, const std::string& role)
        : vault_addr_(vault_addr), role_(role) {
        authenticate();
    }

    std::string getSecret(const std::string& path, const std::string& key) {
        auto url = vault_addr_ + "/v1/" + path;

        CURL* curl = curl_easy_init();
        if (!curl) {
            throw std::runtime_error("Failed to initialize CURL");
        }

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers, ("X-Vault-Token: " + token_).c_str());

        std::string response;
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

        CURLcode res = curl_easy_perform(curl);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        if (res != CURLE_OK) {
            throw std::runtime_error("Failed to fetch secret: " + std::string(curl_easy_strerror(res)));
        }

        auto json = nlohmann::json::parse(response);
        return json["data"]["data"][key].get<std::string>();
    }

private:
    std::string vault_addr_;
    std::string role_;
    std::string token_;

    void authenticate() {
        // Read Kubernetes service account token
        std::ifstream jwt_file("/var/run/secrets/kubernetes.io/serviceaccount/token");
        std::string jwt((std::istreambuf_iterator<char>(jwt_file)),
                        std::istreambuf_iterator<char>());

        // Authenticate with Vault
        auto url = vault_addr_ + "/v1/auth/kubernetes/login";

        nlohmann::json payload = {
            {"role", role_},
            {"jwt", jwt}
        };

        CURL* curl = curl_easy_init();
        std::string response;

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload.dump().c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

        curl_easy_perform(curl);
        curl_easy_cleanup(curl);

        auto json = nlohmann::json::parse(response);
        token_ = json["auth"]["client_token"].get<std::string>();
    }

    static size_t writeCallback(void* contents, size_t size, size_t nmemb, void* userp) {
        ((std::string*)userp)->append((char*)contents, size * nmemb);
        return size * nmemb;
    }
};

// Usage
int main() {
    VaultClient vault("http://vault.vault.svc.cluster.local:8200", "trading-engine");

    auto db_password = vault.getSecret("secret/data/hft-trading/database", "password");
    auto api_key = vault.getSecret("secret/data/hft-trading/api-keys", "exchange_api_key");

    // Use secrets...
}

================================================================================
2. AWS SECRETS MANAGER
================================================================================

# terraform/aws/secrets.tf
# KMS key for Secrets Manager
resource "aws_kms_key" "secrets" {
  description             = "KMS key for Secrets Manager"
  deletion_window_in_days = 7
  enable_key_rotation     = true

  tags = {
    Name = "hft-trading-secrets"
  }
}

resource "aws_kms_alias" "secrets" {
  name          = "alias/hft-trading-secrets"
  target_key_id = aws_kms_key.secrets.key_id
}

# Database credentials
resource "aws_secretsmanager_secret" "database_credentials" {
  name                    = "hft-trading/database/credentials"
  kms_key_id             = aws_kms_key.secrets.id
  recovery_window_in_days = 7

  tags = {
    Environment = var.environment
  }
}

resource "aws_secretsmanager_secret_version" "database_credentials" {
  secret_id = aws_secretsmanager_secret.database_credentials.id
  secret_string = jsonencode({
    username = "hftadmin"
    password = random_password.db_password.result
    host     = module.rds.db_instance_endpoint
    port     = 5432
    database = "hft_trading"
  })
}

# API keys
resource "aws_secretsmanager_secret" "api_keys" {
  name                    = "hft-trading/api-keys"
  kms_key_id             = aws_kms_key.secrets.id
  recovery_window_in_days = 7
}

resource "aws_secretsmanager_secret_version" "api_keys" {
  secret_id = aws_secretsmanager_secret.api_keys.id
  secret_string = jsonencode({
    exchange_api_key    = var.exchange_api_key
    exchange_secret_key = var.exchange_secret_key
    jwt_secret          = random_password.jwt_secret.result
  })
}

# Redis password
resource "aws_secretsmanager_secret" "redis_password" {
  name                    = "hft-trading/redis/password"
  kms_key_id             = aws_kms_key.secrets.id
  recovery_window_in_days = 7
}

resource "aws_secretsmanager_secret_version" "redis_password" {
  secret_id     = aws_secretsmanager_secret.redis_password.id
  secret_string = random_password.redis_password.result
}

# Random passwords
resource "random_password" "db_password" {
  length  = 32
  special = true
}

resource "random_password" "redis_password" {
  length  = 32
  special = true
}

resource "random_password" "jwt_secret" {
  length  = 64
  special = true
}

# IAM policy for accessing secrets
resource "aws_iam_policy" "secrets_access" {
  name        = "hft-trading-secrets-access"
  description = "Allow access to HFT trading secrets"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "secretsmanager:GetSecretValue",
          "secretsmanager:DescribeSecret"
        ]
        Resource = [
          aws_secretsmanager_secret.database_credentials.arn,
          aws_secretsmanager_secret.api_keys.arn,
          aws_secretsmanager_secret.redis_password.arn
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "kms:Decrypt",
          "kms:DescribeKey"
        ]
        Resource = aws_kms_key.secrets.arn
      }
    ]
  })
}

---
# scripts/fetch-secrets-from-aws.sh
#!/bin/bash
set -e

SECRET_NAME=$1
REGION=${AWS_REGION:-us-east-1}

if [ -z "$SECRET_NAME" ]; then
    echo "Usage: $0 <secret_name>"
    exit 1
fi

# Fetch secret
SECRET_VALUE=$(aws secretsmanager get-secret-value \
    --secret-id ${SECRET_NAME} \
    --region ${REGION} \
    --query SecretString \
    --output text)

echo ${SECRET_VALUE}

---
# Kubernetes External Secrets Operator
# k8s/external-secrets/secretstore.yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: hft-trading
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa

---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: database-credentials
  namespace: hft-trading
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: database-credentials
    creationPolicy: Owner
  data:
  - secretKey: username
    remoteRef:
      key: hft-trading/database/credentials
      property: username
  - secretKey: password
    remoteRef:
      key: hft-trading/database/credentials
      property: password
  - secretKey: host
    remoteRef:
      key: hft-trading/database/credentials
      property: host
  - secretKey: port
    remoteRef:
      key: hft-trading/database/credentials
      property: port
  - secretKey: database
    remoteRef:
      key: hft-trading/database/credentials
      property: database

================================================================================
3. KUBERNETES SECRETS
================================================================================

# k8s/secrets/database-credentials.yaml
apiVersion: v1
kind: Secret
metadata:
  name: database-credentials
  namespace: hft-trading
type: Opaque
stringData:
  username: hftadmin
  password: changeme123  # Use sealed secrets or external secrets in production
  host: postgres.hft-trading.svc.cluster.local
  port: "5432"
  database: hft_trading

---
# Sealed Secrets for GitOps
# Install sealed-secrets controller
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml

# Create sealed secret
# scripts/create-sealed-secret.sh
#!/bin/bash
set -e

SECRET_NAME=$1
NAMESPACE=$2

if [ -z "$SECRET_NAME" ] || [ -z "$NAMESPACE" ]; then
    echo "Usage: $0 <secret_name> <namespace>"
    exit 1
fi

# Create regular secret
kubectl create secret generic ${SECRET_NAME} \
    --from-literal=username=hftadmin \
    --from-literal=password=secretpassword \
    --namespace=${NAMESPACE} \
    --dry-run=client -o yaml > secret.yaml

# Seal the secret
kubeseal --format=yaml < secret.yaml > sealed-secret.yaml

# Apply sealed secret
kubectl apply -f sealed-secret.yaml

# Clean up
rm secret.yaml

echo "Sealed secret created: sealed-secret.yaml"

---
# k8s/secrets/tls-certificates.yaml
apiVersion: v1
kind: Secret
metadata:
  name: tls-certificates
  namespace: hft-trading
type: kubernetes.io/tls
data:
  tls.crt: LS0tLS1CRUdJTi...  # Base64 encoded certificate
  tls.key: LS0tLS1CRUdJTi...  # Base64 encoded private key

---
# Using cert-manager for automatic TLS
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: trading-engine-tls
  namespace: hft-trading
spec:
  secretName: trading-engine-tls
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
  - trading.example.com
  - api.trading.example.com

================================================================================
4. SECRET ROTATION
================================================================================

# scripts/rotate-database-password.sh
#!/bin/bash
set -e

ENVIRONMENT=$1

if [ -z "$ENVIRONMENT" ]; then
    echo "Usage: $0 <environment>"
    exit 1
fi

echo "Rotating database password for ${ENVIRONMENT}..."

# Generate new password
NEW_PASSWORD=$(openssl rand -base64 32)

# Update password in RDS
aws rds modify-db-instance \
    --db-instance-identifier hft-trading-${ENVIRONMENT} \
    --master-user-password ${NEW_PASSWORD} \
    --apply-immediately

# Update password in Secrets Manager
aws secretsmanager update-secret \
    --secret-id hft-trading/${ENVIRONMENT}/database/credentials \
    --secret-string "{\"username\":\"hftadmin\",\"password\":\"${NEW_PASSWORD}\"}"

# Restart application pods to pick up new password
kubectl rollout restart statefulset/trading-engine \
    -n hft-trading-${ENVIRONMENT}

echo "Password rotation complete!"

---
# Automatic rotation with AWS Lambda
# lambda/rotate-secrets.py
import boto3
import os
import json

def lambda_handler(event, context):
    secretsmanager = boto3.client('secretsmanager')
    rds = boto3.client('rds')

    secret_arn = event['SecretId']
    token = event['ClientRequestToken']
    step = event['Step']

    if step == "createSecret":
        # Generate new password
        new_password = os.urandom(32).hex()

        # Store new password in AWSPENDING stage
        secretsmanager.put_secret_value(
            SecretId=secret_arn,
            ClientRequestToken=token,
            SecretString=json.dumps({"password": new_password}),
            VersionStages=['AWSPENDING']
        )

    elif step == "setSecret":
        # Update RDS password
        secret = secretsmanager.get_secret_value(
            SecretId=secret_arn,
            VersionStage="AWSPENDING"
        )
        password = json.loads(secret['SecretString'])['password']

        rds.modify_db_instance(
            DBInstanceIdentifier='hft-trading-prod',
            MasterUserPassword=password,
            ApplyImmediately=True
        )

    elif step == "testSecret":
        # Test new password
        pass

    elif step == "finishSecret":
        # Move AWSPENDING to AWSCURRENT
        secretsmanager.update_secret_version_stage(
            SecretId=secret_arn,
            VersionStage="AWSCURRENT",
            MoveToVersionId=token,
            RemoveFromVersionId=secretsmanager.describe_secret(
                SecretId=secret_arn
            )['VersionIdsToStages'].keys()[0]
        )

---
# Vault dynamic secrets
# vault/database-config.sh
#!/bin/bash

# Configure database secrets engine
vault write database/config/hft-trading \
    plugin_name=postgresql-database-plugin \
    allowed_roles="hft-trading" \
    connection_url="postgresql://{{username}}:{{password}}@postgres:5432/hft_trading?sslmode=require" \
    username="vaultadmin" \
    password="vaultpass"

# Create role for dynamic credentials
vault write database/roles/hft-trading \
    db_name=hft-trading \
    creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \
        GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
    default_ttl="1h" \
    max_ttl="24h"

# Application can now request temporary credentials:
# vault read database/creds/hft-trading

================================================================================
5. ENCRYPTION AT REST
================================================================================

# Kubernetes encryption config
# /etc/kubernetes/encryption-config.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: <base64-encoded-32-byte-key>
      - identity: {}

# Apply to API server
# --encryption-provider-config=/etc/kubernetes/encryption-config.yaml

---
# AWS EBS encryption
# terraform/aws/storage.tf
resource "aws_ebs_default_kms_key" "example" {
  key_arn = aws_kms_key.ebs.arn
}

resource "aws_ebs_encryption_by_default" "example" {
  enabled = true
}

================================================================================
6. ACCESS CONTROL
================================================================================

# Vault policies
# vault/policies/trading-engine-readonly.hcl
path "secret/data/hft-trading/*" {
  capabilities = ["read", "list"]
}

path "database/creds/hft-trading" {
  capabilities = ["read"]
}

# vault/policies/trading-engine-admin.hcl
path "secret/data/hft-trading/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

path "secret/metadata/hft-trading/*" {
  capabilities = ["list", "read", "delete"]
}

path "database/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

---
# AWS IAM policies
# terraform/aws/iam-secrets.tf
resource "aws_iam_role" "app_secrets_access" {
  name = "hft-trading-app-secrets-access"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRoleWithWebIdentity"
        Effect = "Allow"
        Principal = {
          Federated = module.eks.oidc_provider_arn
        }
        Condition = {
          StringEquals = {
            "${replace(module.eks.cluster_oidc_issuer_url, "https://", "")}:sub" = "system:serviceaccount:hft-trading:trading-engine"
          }
        }
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "app_secrets_access" {
  role       = aws_iam_role.app_secrets_access.name
  policy_arn = aws_iam_policy.secrets_access.arn
}

================================================================================
7. AUDIT LOGGING
================================================================================

# Vault audit logging
vault audit enable file file_path=/vault/logs/audit.log

# AWS Secrets Manager logging
# terraform/aws/secrets-logging.tf
resource "aws_cloudwatch_log_group" "secrets_audit" {
  name              = "/aws/secretsmanager/hft-trading"
  retention_in_days = 90
  kms_key_id        = aws_kms_key.cloudwatch.arn
}

resource "aws_cloudtrail" "secrets_audit" {
  name                          = "hft-trading-secrets-audit"
  s3_bucket_name                = aws_s3_bucket.audit_logs.id
  include_global_service_events = true
  is_multi_region_trail         = true
  enable_log_file_validation    = true

  event_selector {
    read_write_type           = "All"
    include_management_events = true

    data_resource {
      type   = "AWS::SecretsManager::Secret"
      values = ["arn:aws:secretsmanager:*:*:secret:hft-trading/*"]
    }
  }
}

================================================================================
8. BEST PRACTICES
================================================================================

1. NEVER COMMIT SECRETS TO VERSION CONTROL
   - Use .gitignore for sensitive files
   - Scan repositories for leaked secrets
   - Use pre-commit hooks to prevent leaks

2. PRINCIPLE OF LEAST PRIVILEGE
   - Grant minimum necessary permissions
   - Use separate credentials per environment
   - Rotate credentials regularly

3. SECRET ROTATION
   - Implement automatic rotation
   - Test rotation procedures
   - Monitor rotation failures

4. ENCRYPTION
   - Encrypt secrets at rest
   - Encrypt secrets in transit
   - Use strong encryption algorithms

5. AUDIT AND MONITORING
   - Log all secret access
   - Monitor for anomalies
   - Alert on suspicious activity

6. DISASTER RECOVERY
   - Backup encryption keys securely
   - Document recovery procedures
   - Test recovery regularly

================================================================================
END OF SECRETS MANAGEMENT GUIDE
================================================================================
