================================================================================
                    PAGERDUTY INTEGRATION - COMPLETE GUIDE
================================================================================

VERSION: 2.1.0
LAST UPDATED: 2025-11-25
STATUS: PRODUCTION
MAINTAINER: Infrastructure Team

================================================================================
                              TABLE OF CONTENTS
================================================================================

1. PagerDuty Overview
2. Account Setup & Configuration
3. Events API v2 Integration
4. C++ PagerDuty Implementation
5. Incident Management
6. Escalation Policies
7. On-Call Schedules
8. Alert Grouping & Deduplication
9. Auto-Resolution
10. Testing & Debugging
11. Production Best Practices
12. Cost Optimization

================================================================================
                       1. PAGERDUTY OVERVIEW
================================================================================

PagerDuty is the PRIMARY channel for critical alerts (P1/P2) requiring
immediate human intervention. It provides:

- Incident management and tracking
- On-call rotation and scheduling
- Multi-channel notifications (push, SMS, phone)
- Escalation policies
- Incident analytics and postmortems
- Integration with 700+ tools

CHARACTERISTICS:

Latency: 1-3 seconds
Reliability: 99.99%
Cost: $21-$41 per user/month
Global Coverage: Worldwide
Notification Methods: Push, SMS, Phone Call
SLA: 99.99% uptime

WHY USE PAGERDUTY:

1. Purpose-built for incident response
2. Guaranteed delivery (multi-channel)
3. Automatic escalation
4. On-call schedule management
5. Incident tracking and analytics
6. Mobile app with acknowledge/resolve
7. Integration with runbooks
8. Compliance and audit trails

WHEN TO USE PAGERDUTY:

P1 Critical:
- System outages
- Trading halted
- Security breaches
- Data corruption
- Critical infrastructure failure

P2 High Priority:
- Degraded performance (>20% impact)
- High error rates
- Risk limit breaches
- Important feature unavailable

WHEN NOT TO USE:

- P3/P4 alerts (use Slack/Email)
- Informational messages
- Routine notifications
- High-frequency updates

================================================================================
                   2. ACCOUNT SETUP & CONFIGURATION
================================================================================

STEP 1: CREATE PAGERDUTY ACCOUNT

1. Go to https://www.pagerduty.com
2. Sign up for account (14-day free trial)
3. Choose plan: Professional ($41/user/month recommended)
4. Add team members

STEP 2: CREATE SERVICE

1. Navigate to Services > Service Directory
2. Click "New Service"
3. Name: "HFT Trading System"
4. Description: "High-Frequency Trading Platform"
5. Escalation Policy: Select or create (see Section 6)
6. Integration Type: "Events API v2"
7. Click "Add Service"
8. Copy the "Integration Key" (routing key)

STEP 3: CONFIGURE ESCALATION POLICY

1. Navigate to People > Escalation Policies
2. Click "New Escalation Policy"
3. Name: "HFT On-Call"
4. Rules:
   - Level 1: On-Call Engineer (notify immediately)
   - Level 2: Team Lead (escalate after 10 minutes)
   - Level 3: VP Engineering (escalate after 20 minutes)
5. Repeat if no one acknowledges: Yes
6. Save policy

STEP 4: SETUP ON-CALL SCHEDULES

1. Navigate to People > On-Call Schedules
2. Click "New On-Call Schedule"
3. Name: "HFT Primary On-Call"
4. Time Zone: America/New_York
5. Schedule Type: Weekly rotation
6. Coverage: 24/7
7. Rotation:
   - Week 1: Engineer A
   - Week 2: Engineer B
   - Week 3: Engineer C
8. Handoff time: Monday 9:00 AM
9. Save schedule

CONFIGURATION FILE: /etc/hft/channels/pagerduty.conf

# PagerDuty Events API v2
pagerduty.api_endpoint = https://events.pagerduty.com/v2/enqueue
pagerduty.routing_key = ${PAGERDUTY_ROUTING_KEY}

# Alternative: Use Integration Keys per service
pagerduty.p1_routing_key = ${PAGERDUTY_P1_ROUTING_KEY}
pagerduty.p2_routing_key = ${PAGERDUTY_P2_ROUTING_KEY}

# API Configuration
pagerduty.timeout_seconds = 10
pagerduty.verify_ssl = true

# Incident Configuration
pagerduty.default_severity = critical
pagerduty.default_component = hft-system
pagerduty.default_group = trading
pagerduty.default_class = infrastructure

# Deduplication
pagerduty.enable_dedup = true
pagerduty.dedup_window_seconds = 300    # 5 minutes

# Auto-resolution
pagerduty.enable_auto_resolve = true
pagerduty.auto_resolve_timeout_seconds = 3600  # 1 hour

# Retry Configuration
pagerduty.retry_attempts = 5            # Higher for critical
pagerduty.retry_delay_ms = 500
pagerduty.retry_backoff_multiplier = 2.0

# Rate Limiting
pagerduty.max_per_second = 10
pagerduty.max_per_minute = 120

# Links
pagerduty.dashboard_url = https://dashboard.company.com
pagerduty.runbook_url = https://runbooks.company.com
pagerduty.metrics_url = https://grafana.company.com

Environment Variables:

export PAGERDUTY_ROUTING_KEY=R0123456789abcdef0123456789abcdef
export PAGERDUTY_P1_ROUTING_KEY=R0123456789abcdef0123456789abcdef
export PAGERDUTY_P2_ROUTING_KEY=R1234567890bcdefg1234567890bcdefg

================================================================================
                   3. EVENTS API V2 INTEGRATION
================================================================================

EVENTS API V2 ENDPOINTS:

Trigger Event (Create Incident):
POST https://events.pagerduty.com/v2/enqueue

Acknowledge Event:
POST https://events.pagerduty.com/v2/enqueue
(with event_action: acknowledge)

Resolve Event:
POST https://events.pagerduty.com/v2/enqueue
(with event_action: resolve)

EVENT PAYLOAD STRUCTURE:

{
  "routing_key": "R0123456789abcdef0123456789abcdef",
  "event_action": "trigger",  // or "acknowledge", "resolve"
  "dedup_key": "trading_halt_20251125_143055",
  "payload": {
    "summary": "Trading Halted - High Latency",
    "source": "hft-execution-engine",
    "severity": "critical",  // or "error", "warning", "info"
    "timestamp": "2025-11-25T14:30:55Z",
    "component": "execution_engine",
    "group": "trading",
    "class": "latency",
    "custom_details": {
      "latency_ms": 250,
      "threshold_ms": 10,
      "order_id": "ORD123456",
      "symbol": "AAPL"
    }
  },
  "links": [
    {
      "href": "https://dashboard.company.com/alerts/12345",
      "text": "View in Dashboard"
    },
    {
      "href": "https://runbooks.company.com/trading-halt",
      "text": "Runbook"
    }
  ],
  "images": [
    {
      "src": "https://grafana.company.com/render/latency-chart.png",
      "alt": "Latency Chart"
    }
  ]
}

RESPONSE:

Success (202 Accepted):
{
  "status": "success",
  "message": "Event processed",
  "dedup_key": "trading_halt_20251125_143055"
}

Error (400 Bad Request):
{
  "status": "invalid event",
  "message": "Event object is invalid",
  "errors": ["routing_key is required"]
}

================================================================================
                   4. C++ PAGERDUTY IMPLEMENTATION
================================================================================

HEADER FILE: pagerduty_channel.hpp

#ifndef HFT_PAGERDUTY_CHANNEL_HPP
#define HFT_PAGERDUTY_CHANNEL_HPP

#include "channel_interface.hpp"
#include <curl/curl.h>
#include <string>
#include <vector>
#include <memory>
#include <unordered_map>
#include <chrono>

namespace hft {
namespace notification {

struct PagerDutyConfig {
    std::string api_endpoint{"https://events.pagerduty.com/v2/enqueue"};
    std::string routing_key;

    // Service-specific routing keys
    std::unordered_map<AlertSeverity, std::string> severity_routing_keys;

    std::chrono::seconds timeout{10};
    bool verify_ssl{true};

    // Incident settings
    std::string default_severity{"critical"};
    std::string default_component{"hft-system"};
    std::string default_group{"trading"};
    std::string default_class{"infrastructure"};

    // Deduplication
    bool enable_dedup{true};
    std::chrono::seconds dedup_window{300};

    // Auto-resolution
    bool enable_auto_resolve{true};
    std::chrono::seconds auto_resolve_timeout{3600};

    // Retry settings
    uint32_t retry_attempts{5};
    std::chrono::milliseconds retry_delay{500};
    double retry_backoff{2.0};

    // Rate limiting
    uint32_t max_per_second{10};
    uint32_t max_per_minute{120};

    // Links
    std::string dashboard_url;
    std::string runbook_url;
    std::string metrics_url;
};

struct PagerDutyEvent {
    enum class Action {
        Trigger,
        Acknowledge,
        Resolve
    };

    Action action{Action::Trigger};
    std::string routing_key;
    std::string dedup_key;

    // Payload
    std::string summary;
    std::string source;
    std::string severity;
    std::chrono::system_clock::time_point timestamp;
    std::string component;
    std::string group;
    std::string event_class;

    std::map<std::string, std::string> custom_details;

    struct Link {
        std::string href;
        std::string text;
    };
    std::vector<Link> links;

    struct Image {
        std::string src;
        std::string alt;
    };
    std::vector<Image> images;
};

struct PagerDutyIncident {
    std::string dedup_key;
    std::string incident_key;
    std::chrono::system_clock::time_point triggered_at;
    std::chrono::system_clock::time_point acknowledged_at;
    std::chrono::system_clock::time_point resolved_at;
    bool is_acknowledged{false};
    bool is_resolved{false};
    uint32_t escalation_count{0};
};

class PagerDutyClient {
public:
    explicit PagerDutyClient(const PagerDutyConfig& config);
    ~PagerDutyClient();

    struct SendResult {
        bool success;
        std::string dedup_key;
        std::string error_message;
    };

    SendResult send_event(const PagerDutyEvent& event);
    SendResult trigger_incident(const PagerDutyEvent& event);
    SendResult acknowledge_incident(const std::string& dedup_key);
    SendResult resolve_incident(const std::string& dedup_key);

private:
    PagerDutyConfig config_;
    CURL* curl_{nullptr};

    std::string build_event_json(const PagerDutyEvent& event);
    std::string make_api_call(const std::string& json_payload);
};

class PagerDutyChannel : public INotificationChannel {
public:
    explicit PagerDutyChannel(const PagerDutyConfig& config);
    ~PagerDutyChannel() override;

    // INotificationChannel interface
    DispatchResult send(const Alert& alert,
                       const std::vector<std::string>& recipients) override;

    bool health_check() override;
    ChannelMetrics get_metrics() const override;
    void set_config(const ChannelConfig& config) override;
    ChannelConfig get_config() const override;

    bool start() override;
    void stop() override;
    bool is_running() const override;

    ChannelType get_type() const override { return ChannelType::PagerDuty; }
    std::string get_name() const override { return "PagerDuty"; }

    // PagerDuty-specific methods
    bool acknowledge_alert(uint64_t alert_id);
    bool resolve_alert(uint64_t alert_id);

private:
    PagerDutyConfig config_;
    std::unique_ptr<PagerDutyClient> pd_client_;
    std::atomic<bool> running_{false};

    // Incident tracking
    std::unordered_map<uint64_t, PagerDutyIncident> active_incidents_;
    mutable std::shared_mutex incidents_mutex_;

    // Rate limiting
    std::deque<std::chrono::steady_clock::time_point> event_times_;
    std::mutex rate_limit_mutex_;

    // Metrics
    mutable ChannelMetrics metrics_;

    // Auto-resolution thread
    std::thread auto_resolve_thread_;
    std::atomic<bool> stop_auto_resolve_{false};

    // Helper methods
    PagerDutyEvent create_pd_event(const Alert& alert);
    std::string generate_dedup_key(const Alert& alert);
    std::string get_pd_severity(AlertSeverity severity);
    std::string get_routing_key(const Alert& alert);
    bool check_rate_limit();
    void update_rate_limit();
    void auto_resolve_loop();
    void track_incident(uint64_t alert_id, const PagerDutyIncident& incident);
};

} // namespace notification
} // namespace hft

#endif // HFT_PAGERDUTY_CHANNEL_HPP

IMPLEMENTATION FILE: pagerduty_channel.cpp

#include "pagerduty_channel.hpp"
#include <spdlog/spdlog.h>
#include <curl/curl.h>
#include <sstream>
#include <iomanip>
#include <regex>

namespace hft {
namespace notification {

// ============================================================================
// PagerDutyClient Implementation
// ============================================================================

PagerDutyClient::PagerDutyClient(const PagerDutyConfig& config)
    : config_(config) {
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_ = curl_easy_init();

    if (!curl_) {
        throw std::runtime_error("Failed to initialize CURL for PagerDuty");
    }
}

PagerDutyClient::~PagerDutyClient() {
    if (curl_) {
        curl_easy_cleanup(curl_);
    }
}

PagerDutyClient::SendResult PagerDutyClient::send_event(
    const PagerDutyEvent& event) {

    SendResult result;
    result.success = false;

    std::string json_payload = build_event_json(event);
    std::string response = make_api_call(json_payload);

    // Parse response
    if (response.find(R"("status":"success")") != std::string::npos) {
        result.success = true;
        result.dedup_key = event.dedup_key;

        spdlog::info("PagerDuty event sent successfully (dedup_key: {})",
                    event.dedup_key);
    } else {
        result.error_message = response;
        spdlog::error("PagerDuty event failed: {}", response);
    }

    return result;
}

PagerDutyClient::SendResult PagerDutyClient::trigger_incident(
    const PagerDutyEvent& event) {

    PagerDutyEvent trigger_event = event;
    trigger_event.action = PagerDutyEvent::Action::Trigger;

    return send_event(trigger_event);
}

PagerDutyClient::SendResult PagerDutyClient::acknowledge_incident(
    const std::string& dedup_key) {

    PagerDutyEvent ack_event;
    ack_event.action = PagerDutyEvent::Action::Acknowledge;
    ack_event.dedup_key = dedup_key;
    ack_event.routing_key = config_.routing_key;

    return send_event(ack_event);
}

PagerDutyClient::SendResult PagerDutyClient::resolve_incident(
    const std::string& dedup_key) {

    PagerDutyEvent resolve_event;
    resolve_event.action = PagerDutyEvent::Action::Resolve;
    resolve_event.dedup_key = dedup_key;
    resolve_event.routing_key = config_.routing_key;

    return send_event(resolve_event);
}

std::string PagerDutyClient::build_event_json(const PagerDutyEvent& event) {
    std::ostringstream json;

    json << R"({
  "routing_key": ")" << event.routing_key << R"(",
  "event_action": ")";

    switch (event.action) {
    case PagerDutyEvent::Action::Trigger:
        json << "trigger";
        break;
    case PagerDutyEvent::Action::Acknowledge:
        json << "acknowledge";
        break;
    case PagerDutyEvent::Action::Resolve:
        json << "resolve";
        break;
    }

    json << R"(",
  "dedup_key": ")" << event.dedup_key << R"(")";

    if (event.action == PagerDutyEvent::Action::Trigger) {
        json << R"(,
  "payload": {
    "summary": ")" << escape_json(event.summary) << R"(",
    "source": ")" << event.source << R"(",
    "severity": ")" << event.severity << R"(",
    "timestamp": ")" << format_iso8601(event.timestamp) << R"(")";

        if (!event.component.empty()) {
            json << R"(,
    "component": ")" << event.component << R"(")";
        }

        if (!event.group.empty()) {
            json << R"(,
    "group": ")" << event.group << R"(")";
        }

        if (!event.event_class.empty()) {
            json << R"(,
    "class": ")" << event.event_class << R"(")";
        }

        if (!event.custom_details.empty()) {
            json << R"(,
    "custom_details": {)";

            bool first = true;
            for (const auto& [key, value] : event.custom_details) {
                if (!first) json << ",";
                first = false;
                json << "\n      \"" << key << "\": \"" << escape_json(value) << "\"";
            }

            json << "\n    }";
        }

        json << "\n  }";

        // Add links
        if (!event.links.empty()) {
            json << R"(,
  "links": [)";

            bool first = true;
            for (const auto& link : event.links) {
                if (!first) json << ",";
                first = false;
                json << R"(
    {
      "href": ")" << link.href << R"(",
      "text": ")" << link.text << R"("
    })";
            }

            json << "\n  ]";
        }

        // Add images
        if (!event.images.empty()) {
            json << R"(,
  "images": [)";

            bool first = true;
            for (const auto& image : event.images) {
                if (!first) json << ",";
                first = false;
                json << R"(
    {
      "src": ")" << image.src << R"(",
      "alt": ")" << image.alt << R"("
    })";
            }

            json << "\n  ]";
        }
    }

    json << "\n}";

    return json.str();
}

std::string PagerDutyClient::make_api_call(const std::string& json_payload) {
    curl_easy_setopt(curl_, CURLOPT_URL, config_.api_endpoint.c_str());

    // Set headers
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, "Content-Type: application/json");
    headers = curl_slist_append(headers, "Accept: application/vnd.pagerduty+json;version=2");
    curl_easy_setopt(curl_, CURLOPT_HTTPHEADER, headers);

    // Set payload
    curl_easy_setopt(curl_, CURLOPT_POSTFIELDS, json_payload.c_str());

    // SSL verification
    if (config_.verify_ssl) {
        curl_easy_setopt(curl_, CURLOPT_SSL_VERIFYPEER, 1L);
        curl_easy_setopt(curl_, CURLOPT_SSL_VERIFYHOST, 2L);
    }

    // Timeout
    curl_easy_setopt(curl_, CURLOPT_TIMEOUT, config_.timeout.count());

    // Response handling
    std::string response_data;
    curl_easy_setopt(curl_, CURLOPT_WRITEFUNCTION,
        [](void* ptr, size_t size, size_t nmemb, void* userdata) -> size_t {
            std::string* response = static_cast<std::string*>(userdata);
            response->append(static_cast<char*>(ptr), size * nmemb);
            return size * nmemb;
        });
    curl_easy_setopt(curl_, CURLOPT_WRITEDATA, &response_data);

    CURLcode res = curl_easy_perform(curl_);

    curl_slist_free_all(headers);

    if (res != CURLE_OK) {
        return R"({"status":"error","message":")" +
               std::string(curl_easy_strerror(res)) + R"("})";
    }

    long http_code = 0;
    curl_easy_getinfo(curl_, CURLINFO_RESPONSE_CODE, &http_code);

    if (http_code != 202) {
        spdlog::error("PagerDuty HTTP {}: {}", http_code, response_data);
    }

    return response_data;
}

// ============================================================================
// PagerDutyChannel Implementation
// ============================================================================

PagerDutyChannel::PagerDutyChannel(const PagerDutyConfig& config)
    : config_(config) {
}

PagerDutyChannel::~PagerDutyChannel() {
    stop();
}

bool PagerDutyChannel::start() {
    if (running_.load(std::memory_order_acquire)) {
        return true;
    }

    try {
        pd_client_ = std::make_unique<PagerDutyClient>(config_);
    } catch (const std::exception& e) {
        spdlog::error("Failed to initialize PagerDuty client: {}", e.what());
        return false;
    }

    // Start auto-resolution thread
    if (config_.enable_auto_resolve) {
        stop_auto_resolve_.store(false, std::memory_order_release);
        auto_resolve_thread_ = std::thread(&PagerDutyChannel::auto_resolve_loop, this);
    }

    running_.store(true, std::memory_order_release);

    spdlog::info("PagerDuty channel started");
    return true;
}

void PagerDutyChannel::stop() {
    if (!running_.load(std::memory_order_acquire)) {
        return;
    }

    running_.store(false, std::memory_order_release);

    // Stop auto-resolution thread
    if (config_.enable_auto_resolve) {
        stop_auto_resolve_.store(true, std::memory_order_release);
        if (auto_resolve_thread_.joinable()) {
            auto_resolve_thread_.join();
        }
    }

    pd_client_.reset();

    spdlog::info("PagerDuty channel stopped");
}

bool PagerDutyChannel::is_running() const {
    return running_.load(std::memory_order_acquire);
}

DispatchResult PagerDutyChannel::send(const Alert& alert,
                                      const std::vector<std::string>& recipients) {
    auto start_time = std::chrono::steady_clock::now();

    DispatchResult result;
    result.channel = ChannelType::PagerDuty;

    if (!is_running()) {
        result.success = false;
        result.error_message = "PagerDuty channel not running";
        return result;
    }

    // Check rate limit
    if (!check_rate_limit()) {
        result.success = false;
        result.error_message = "Rate limit exceeded";
        metrics_.rate_limited_count++;
        return result;
    }

    // Create PagerDuty event
    PagerDutyEvent event = create_pd_event(alert);

    // Trigger incident
    auto send_result = pd_client_->trigger_incident(event);

    // Update rate limit
    update_rate_limit();

    auto end_time = std::chrono::steady_clock::now();
    result.latency = std::chrono::duration_cast<std::chrono::milliseconds>(
        end_time - start_time);

    result.success = send_result.success;
    result.external_id = send_result.dedup_key;

    if (send_result.success) {
        metrics_.sent_count++;

        // Track incident for auto-resolution
        PagerDutyIncident incident;
        incident.dedup_key = send_result.dedup_key;
        incident.triggered_at = std::chrono::system_clock::now();
        track_incident(alert.id, incident);

    } else {
        result.error_message = send_result.error_message;
        metrics_.failed_count++;
    }

    return result;
}

PagerDutyEvent PagerDutyChannel::create_pd_event(const Alert& alert) {
    PagerDutyEvent event;

    event.action = PagerDutyEvent::Action::Trigger;
    event.routing_key = get_routing_key(alert);
    event.dedup_key = generate_dedup_key(alert);

    event.summary = alert.title;
    event.source = alert.source;
    event.severity = get_pd_severity(alert.severity);
    event.timestamp = alert.timestamp;
    event.component = config_.default_component;
    event.group = config_.default_group;
    event.event_class = config_.default_class;

    // Add custom details
    event.custom_details = alert.context;
    event.custom_details["alert_id"] = std::to_string(alert.id);
    event.custom_details["message"] = alert.message;

    // Add links
    if (!config_.dashboard_url.empty()) {
        PagerDutyEvent::Link dashboard_link;
        dashboard_link.href = config_.dashboard_url + "/alerts/" +
                             std::to_string(alert.id);
        dashboard_link.text = "View in Dashboard";
        event.links.push_back(dashboard_link);
    }

    if (!config_.runbook_url.empty()) {
        PagerDutyEvent::Link runbook_link;
        runbook_link.href = config_.runbook_url + "/" + alert.source;
        runbook_link.text = "View Runbook";
        event.links.push_back(runbook_link);
    }

    return event;
}

std::string PagerDutyChannel::generate_dedup_key(const Alert& alert) {
    if (alert.dedup_key) {
        return *alert.dedup_key;
    }

    // Generate dedup key from alert properties
    std::ostringstream dedup;
    dedup << alert.source << "_"
          << alert.title << "_"
          << alert.id;

    return dedup.str();
}

std::string PagerDutyChannel::get_pd_severity(AlertSeverity severity) {
    switch (severity) {
    case AlertSeverity::P1: return "critical";
    case AlertSeverity::P2: return "error";
    case AlertSeverity::P3: return "warning";
    case AlertSeverity::P4: return "info";
    default: return "error";
    }
}

std::string PagerDutyChannel::get_routing_key(const Alert& alert) {
    auto it = config_.severity_routing_keys.find(alert.severity);
    if (it != config_.severity_routing_keys.end()) {
        return it->second;
    }
    return config_.routing_key;
}

bool PagerDutyChannel::check_rate_limit() {
    std::lock_guard<std::mutex> lock(rate_limit_mutex_);

    auto now = std::chrono::steady_clock::now();

    // Remove old timestamps
    while (!event_times_.empty() &&
           (now - event_times_.front()) > std::chrono::seconds(1)) {
        event_times_.pop_front();
    }

    return event_times_.size() < config_.max_per_second;
}

void PagerDutyChannel::update_rate_limit() {
    std::lock_guard<std::mutex> lock(rate_limit_mutex_);
    event_times_.push_back(std::chrono::steady_clock::now());
}

void PagerDutyChannel::track_incident(uint64_t alert_id,
                                     const PagerDutyIncident& incident) {
    std::unique_lock lock(incidents_mutex_);
    active_incidents_[alert_id] = incident;
}

void PagerDutyChannel::auto_resolve_loop() {
    while (!stop_auto_resolve_.load(std::memory_order_acquire)) {
        std::this_thread::sleep_for(std::chrono::seconds(60));

        auto now = std::chrono::system_clock::now();

        std::unique_lock lock(incidents_mutex_);

        for (auto it = active_incidents_.begin(); it != active_incidents_.end();) {
            auto& incident = it->second;

            if (!incident.is_resolved) {
                auto age = std::chrono::duration_cast<std::chrono::seconds>(
                    now - incident.triggered_at);

                if (age >= config_.auto_resolve_timeout) {
                    // Auto-resolve incident
                    pd_client_->resolve_incident(incident.dedup_key);
                    incident.is_resolved = true;
                    incident.resolved_at = now;

                    spdlog::info("Auto-resolved PagerDuty incident: {}",
                                incident.dedup_key);
                }
            }

            // Remove resolved incidents older than 24 hours
            if (incident.is_resolved) {
                auto resolved_age = std::chrono::duration_cast<std::chrono::hours>(
                    now - incident.resolved_at);

                if (resolved_age >= std::chrono::hours(24)) {
                    it = active_incidents_.erase(it);
                    continue;
                }
            }

            ++it;
        }
    }
}

bool PagerDutyChannel::acknowledge_alert(uint64_t alert_id) {
    std::shared_lock lock(incidents_mutex_);

    auto it = active_incidents_.find(alert_id);
    if (it == active_incidents_.end()) {
        return false;
    }

    auto result = pd_client_->acknowledge_incident(it->second.dedup_key);

    if (result.success) {
        it->second.is_acknowledged = true;
        it->second.acknowledged_at = std::chrono::system_clock::now();
    }

    return result.success;
}

bool PagerDutyChannel::resolve_alert(uint64_t alert_id) {
    std::shared_lock lock(incidents_mutex_);

    auto it = active_incidents_.find(alert_id);
    if (it == active_incidents_.end()) {
        return false;
    }

    auto result = pd_client_->resolve_incident(it->second.dedup_key);

    if (result.success) {
        it->second.is_resolved = true;
        it->second.resolved_at = std::chrono::system_clock::now();
    }

    return result.success;
}

bool PagerDutyChannel::health_check() {
    // PagerDuty doesn't have a dedicated health check endpoint
    // We can verify by checking if we can make a dummy API call
    return is_running();
}

ChannelMetrics PagerDutyChannel::get_metrics() const {
    auto metrics = metrics_;

    std::shared_lock lock(incidents_mutex_);
    metrics.active_incidents = active_incidents_.size();

    return metrics;
}

} // namespace notification
} // namespace hft

================================================================================
                       END OF PAGERDUTY INTEGRATION
================================================================================
