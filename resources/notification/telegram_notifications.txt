================================================================================
                   TELEGRAM NOTIFICATIONS - COMPLETE GUIDE
================================================================================

VERSION: 2.1.0
LAST UPDATED: 2025-11-25
STATUS: PRODUCTION
MAINTAINER: Infrastructure Team

================================================================================
                              TABLE OF CONTENTS
================================================================================

1. Telegram Channel Overview
2. Bot Setup & Configuration
3. Bot API Integration
4. C++ Telegram Implementation
5. Message Formatting (Markdown/HTML)
6. Interactive Keyboards & Buttons
7. Group Chat Management
8. File and Image Attachments
9. Chat ID Management
10. Rate Limiting & Best Practices
11. Security Considerations
12. Production Deployment

================================================================================
                     1. TELEGRAM CHANNEL OVERVIEW
================================================================================

Telegram provides a flexible, personal notification channel for:
- Personal developer notifications
- Team group chats
- Quick status updates
- Interactive bot commands
- File sharing (logs, screenshots)
- Real-time collaboration

CHARACTERISTICS:

Latency: 0.5-2 seconds
Reliability: 99.7%
Cost: Free
Message Limit: 4096 characters
File Size Limit: 50 MB (bots), 2 GB (premium)
API Rate Limit: 30 messages/second per bot
Global Coverage: Worldwide

ADVANTAGES:

1. Free and unlimited
2. Rich formatting (Markdown, HTML)
3. Interactive buttons and keyboards
4. File attachments (logs, charts)
5. Group chats for teams
6. Mobile and desktop apps
7. End-to-end encryption available
8. Bot commands for interaction

WHEN TO USE TELEGRAM:

Personal Notifications:
- Developer-specific alerts
- Deployment notifications
- Build status
- Personal dashboards

Team Collaboration:
- Group discussions
- Quick status updates
- Sharing logs and screenshots

Bot Interactions:
- Query system status
- Acknowledge alerts
- Trigger deployments
- View metrics

WHEN NOT TO USE:

- P1 critical alerts (use PagerDuty)
- Compliance-required notifications (use Email)
- Large team broadcasts (use Slack)
- Official company communications

================================================================================
                    2. BOT SETUP & CONFIGURATION
================================================================================

STEP 1: CREATE TELEGRAM BOT

1. Open Telegram and search for "@BotFather"
2. Send command: /newbot
3. Choose bot name: "HFT Notification Bot"
4. Choose username: "hft_notification_bot" (must end with 'bot')
5. BotFather will provide:
   - Bot token: 123456789:ABCdefGHIjklMNOpqrsTUVwxyz
   - Bot URL: t.me/hft_notification_bot

STEP 2: CONFIGURE BOT SETTINGS

Send these commands to @BotFather:

/setdescription - Set bot description
Description: HFT Trading System Notification Bot - Sends real-time alerts

/setabouttext - Set about text
About: Official notification bot for HFT Trading System

/setcommands - Set bot commands
start - Start receiving notifications
stop - Stop receiving notifications
status - Get system status
alerts - View recent alerts
ack - Acknowledge alert
help - Show help message

/setuserpic - Upload bot profile picture

STEP 3: GET CHAT ID

To send messages, you need the Chat ID:

Method 1 - Personal Chat:
1. Start chat with your bot: t.me/hft_notification_bot
2. Send /start
3. Use getUpdates API to get chat_id:
   curl https://api.telegram.org/bot<TOKEN>/getUpdates
4. Look for "chat":{"id": 123456789}

Method 2 - Group Chat:
1. Add bot to group
2. Send a message in group
3. Use getUpdates API
4. Look for "chat":{"id": -987654321} (negative for groups)

CONFIGURATION FILE: /etc/hft/channels/telegram.conf

# Telegram Bot Configuration
telegram.bot_token = ${TELEGRAM_BOT_TOKEN}

# Default Recipients (Chat IDs)
telegram.default_chat_id = 123456789
telegram.p1_chat_ids = 123456789,-987654321
telegram.p2_chat_ids = 123456789,-987654321
telegram.p3_chat_ids = -987654321
telegram.p4_chat_ids = -987654321

# User Mappings (email to chat_id)
telegram.user_map.trader@company.com = 123456789
telegram.user_map.developer@company.com = 234567890
telegram.user_map.oncall@company.com = 345678901

# Group Chats
telegram.trading_team_chat = -987654321
telegram.dev_team_chat = -876543210
telegram.oncall_chat = -765432109

# API Configuration
telegram.api_endpoint = https://api.telegram.org
telegram.timeout_seconds = 10
telegram.verify_ssl = true

# Message Formatting
telegram.parse_mode = HTML          # or Markdown, MarkdownV2
telegram.disable_notification = false
telegram.disable_web_page_preview = true

# Interactive Features
telegram.enable_buttons = true
telegram.enable_inline_keyboard = true

# Rate Limiting
telegram.max_per_second = 30
telegram.max_per_minute = 300
telegram.burst_allowance = 10

# Retry Configuration
telegram.retry_attempts = 3
telegram.retry_delay_ms = 1000
telegram.timeout_seconds = 10

# File Uploads
telegram.enable_file_uploads = true
telegram.max_file_size_mb = 50

Environment Variables:

export TELEGRAM_BOT_TOKEN=123456789:ABCdefGHIjklMNOpqrsTUVwxyz
export TELEGRAM_TRADING_CHAT=-987654321
export TELEGRAM_DEV_CHAT=-876543210

================================================================================
                    3. BOT API INTEGRATION
================================================================================

TELEGRAM BOT API METHODS:

Send Message:
POST https://api.telegram.org/bot<TOKEN>/sendMessage
{
  "chat_id": 123456789,
  "text": "Alert message",
  "parse_mode": "HTML",
  "disable_notification": false
}

Send Photo:
POST https://api.telegram.org/bot<TOKEN>/sendPhoto
{
  "chat_id": 123456789,
  "photo": "<file_id or URL>",
  "caption": "Chart caption"
}

Send Document:
POST https://api.telegram.org/bot<TOKEN>/sendDocument
{
  "chat_id": 123456789,
  "document": "<file>",
  "caption": "Log file"
}

Get Updates (for chat IDs):
GET https://api.telegram.org/bot<TOKEN>/getUpdates

Send Message with Inline Keyboard:
POST https://api.telegram.org/bot<TOKEN>/sendMessage
{
  "chat_id": 123456789,
  "text": "Alert: High Latency",
  "reply_markup": {
    "inline_keyboard": [[
      {"text": "Acknowledge", "callback_data": "ack_alert_12345"},
      {"text": "View Dashboard", "url": "https://dashboard.company.com"}
    ]]
  }
}

================================================================================
                   4. C++ TELEGRAM IMPLEMENTATION
================================================================================

HEADER FILE: telegram_channel.hpp

#ifndef HFT_TELEGRAM_CHANNEL_HPP
#define HFT_TELEGRAM_CHANNEL_HPP

#include "channel_interface.hpp"
#include <curl/curl.h>
#include <string>
#include <vector>
#include <memory>
#include <unordered_map>

namespace hft {
namespace notification {

struct TelegramConfig {
    std::string bot_token;
    std::string api_endpoint{"https://api.telegram.org"};

    // Default recipients
    int64_t default_chat_id{0};
    std::unordered_map<AlertSeverity, std::vector<int64_t>> severity_chat_ids;

    // User mappings
    std::unordered_map<std::string, int64_t> user_map;

    // Group chats
    int64_t trading_team_chat{0};
    int64_t dev_team_chat{0};
    int64_t oncall_chat{0};

    std::chrono::seconds timeout{10};
    bool verify_ssl{true};

    // Message formatting
    enum class ParseMode {
        None,
        Markdown,
        MarkdownV2,
        HTML
    };
    ParseMode parse_mode{ParseMode::HTML};
    bool disable_notification{false};
    bool disable_web_page_preview{true};

    // Interactive features
    bool enable_buttons{true};
    bool enable_inline_keyboard{true};

    // Rate limiting
    uint32_t max_per_second{30};
    uint32_t max_per_minute{300};

    // Retry settings
    uint32_t retry_attempts{3};
    std::chrono::milliseconds retry_delay{1000};

    // File uploads
    bool enable_file_uploads{true};
    size_t max_file_size_mb{50};
};

struct TelegramMessage {
    int64_t chat_id;
    std::string text;
    TelegramConfig::ParseMode parse_mode{TelegramConfig::ParseMode::HTML};
    bool disable_notification{false};
    bool disable_web_page_preview{true};

    struct InlineButton {
        std::string text;
        std::string url;
        std::string callback_data;
    };
    std::vector<std::vector<InlineButton>> inline_keyboard;

    int64_t reply_to_message_id{0};
};

struct TelegramFile {
    int64_t chat_id;
    std::string file_path;
    std::string caption;
    std::vector<uint8_t> file_data;
};

class TelegramClient {
public:
    explicit TelegramClient(const TelegramConfig& config);
    ~TelegramClient();

    struct SendResult {
        bool success;
        int64_t message_id;
        std::string error_message;
    };

    SendResult send_message(const TelegramMessage& message);
    SendResult send_photo(int64_t chat_id,
                         const std::string& photo_url,
                         const std::string& caption);
    SendResult send_document(const TelegramFile& file);
    std::vector<int64_t> get_chat_ids();

private:
    TelegramConfig config_;
    CURL* curl_{nullptr};

    std::string build_api_url(const std::string& method);
    std::string build_message_json(const TelegramMessage& message);
    std::string make_api_call(const std::string& url,
                             const std::string& json_payload);
    std::string escape_html(const std::string& str);
    std::string escape_markdown(const std::string& str);
};

class TelegramChannel : public INotificationChannel {
public:
    explicit TelegramChannel(const TelegramConfig& config);
    ~TelegramChannel() override;

    // INotificationChannel interface
    DispatchResult send(const Alert& alert,
                       const std::vector<std::string>& recipients) override;

    bool health_check() override;
    ChannelMetrics get_metrics() const override;
    void set_config(const ChannelConfig& config) override;
    ChannelConfig get_config() const override;

    bool start() override;
    void stop() override;
    bool is_running() const override;

    ChannelType get_type() const override { return ChannelType::Telegram; }
    std::string get_name() const override { return "Telegram"; }

private:
    TelegramConfig config_;
    std::unique_ptr<TelegramClient> telegram_client_;
    std::atomic<bool> running_{false};

    // Rate limiting
    std::deque<std::chrono::steady_clock::time_point> message_times_;
    std::mutex rate_limit_mutex_;

    // Metrics
    mutable ChannelMetrics metrics_;

    // Helper methods
    TelegramMessage create_telegram_message(const Alert& alert,
                                           int64_t chat_id);
    std::string format_html_message(const Alert& alert);
    std::string format_markdown_message(const Alert& alert);
    std::vector<int64_t> get_chat_ids_for_alert(const Alert& alert,
                                               const std::vector<std::string>& recipients);
    std::string get_severity_emoji(AlertSeverity severity);
    bool check_rate_limit();
    void update_rate_limit();
};

} // namespace notification
} // namespace hft

#endif // HFT_TELEGRAM_CHANNEL_HPP

IMPLEMENTATION FILE: telegram_channel.cpp

#include "telegram_channel.hpp"
#include <spdlog/spdlog.h>
#include <curl/curl.h>
#include <sstream>
#include <iomanip>
#include <regex>

namespace hft {
namespace notification {

// ============================================================================
// TelegramClient Implementation
// ============================================================================

TelegramClient::TelegramClient(const TelegramConfig& config)
    : config_(config) {
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_ = curl_easy_init();

    if (!curl_) {
        throw std::runtime_error("Failed to initialize CURL for Telegram");
    }
}

TelegramClient::~TelegramClient() {
    if (curl_) {
        curl_easy_cleanup(curl_);
    }
}

TelegramClient::SendResult TelegramClient::send_message(
    const TelegramMessage& message) {

    SendResult result;
    result.success = false;

    std::string url = build_api_url("sendMessage");
    std::string json_payload = build_message_json(message);

    std::string response = make_api_call(url, json_payload);

    // Parse response
    if (response.find(R"("ok":true)") != std::string::npos) {
        result.success = true;

        // Extract message_id
        std::regex msg_id_regex(R"("message_id":(\d+))");
        std::smatch matches;
        if (std::regex_search(response, matches, msg_id_regex)) {
            result.message_id = std::stoll(matches[1].str());
        }

        spdlog::info("Telegram message sent to {} (msg_id: {})",
                    message.chat_id, result.message_id);
    } else {
        result.error_message = response;
        spdlog::error("Telegram message failed: {}", response);
    }

    return result;
}

TelegramClient::SendResult TelegramClient::send_photo(
    int64_t chat_id,
    const std::string& photo_url,
    const std::string& caption) {

    SendResult result;
    result.success = false;

    std::string url = build_api_url("sendPhoto");

    std::ostringstream json;
    json << R"({
  "chat_id": )" << chat_id << R"(,
  "photo": ")" << photo_url << R"(",
  "caption": ")" << escape_html(caption) << R"("
})";

    std::string response = make_api_call(url, json.str());

    if (response.find(R"("ok":true)") != std::string::npos) {
        result.success = true;
        spdlog::info("Telegram photo sent to {}", chat_id);
    } else {
        result.error_message = response;
        spdlog::error("Telegram photo failed: {}", response);
    }

    return result;
}

std::string TelegramClient::build_api_url(const std::string& method) {
    return config_.api_endpoint + "/bot" + config_.bot_token + "/" + method;
}

std::string TelegramClient::build_message_json(const TelegramMessage& message) {
    std::ostringstream json;

    json << R"({
  "chat_id": )" << message.chat_id << R"(,
  "text": ")";

    // Escape text based on parse mode
    if (message.parse_mode == TelegramConfig::ParseMode::HTML) {
        json << escape_html(message.text);
    } else if (message.parse_mode == TelegramConfig::ParseMode::Markdown ||
               message.parse_mode == TelegramConfig::ParseMode::MarkdownV2) {
        json << escape_markdown(message.text);
    } else {
        json << message.text;
    }

    json << R"(")";

    // Parse mode
    if (message.parse_mode != TelegramConfig::ParseMode::None) {
        json << R"(,
  "parse_mode": ")";
        switch (message.parse_mode) {
        case TelegramConfig::ParseMode::Markdown:
            json << "Markdown";
            break;
        case TelegramConfig::ParseMode::MarkdownV2:
            json << "MarkdownV2";
            break;
        case TelegramConfig::ParseMode::HTML:
            json << "HTML";
            break;
        default:
            break;
        }
        json << R"(")";
    }

    // Other options
    json << R"(,
  "disable_notification": )" << (message.disable_notification ? "true" : "false") << R"(,
  "disable_web_page_preview": )" << (message.disable_web_page_preview ? "true" : "false");

    // Reply to message
    if (message.reply_to_message_id > 0) {
        json << R"(,
  "reply_to_message_id": )" << message.reply_to_message_id;
    }

    // Inline keyboard
    if (!message.inline_keyboard.empty()) {
        json << R"(,
  "reply_markup": {
    "inline_keyboard": [)";

        bool first_row = true;
        for (const auto& row : message.inline_keyboard) {
            if (!first_row) json << ",";
            first_row = false;

            json << "\n      [";

            bool first_button = true;
            for (const auto& button : row) {
                if (!first_button) json << ",";
                first_button = false;

                json << R"(
        {
          "text": ")" << button.text << R"(")";

                if (!button.url.empty()) {
                    json << R"(,
          "url": ")" << button.url << R"(")";
                } else if (!button.callback_data.empty()) {
                    json << R"(,
          "callback_data": ")" << button.callback_data << R"(")";
                }

                json << "\n        }";
            }

            json << "\n      ]";
        }

        json << R"(
    ]
  })";
    }

    json << "\n}";

    return json.str();
}

std::string TelegramClient::make_api_call(const std::string& url,
                                         const std::string& json_payload) {
    curl_easy_setopt(curl_, CURLOPT_URL, url.c_str());

    // Set headers
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, "Content-Type: application/json");
    curl_easy_setopt(curl_, CURLOPT_HTTPHEADER, headers);

    // Set payload
    curl_easy_setopt(curl_, CURLOPT_POSTFIELDS, json_payload.c_str());

    // SSL verification
    if (config_.verify_ssl) {
        curl_easy_setopt(curl_, CURLOPT_SSL_VERIFYPEER, 1L);
        curl_easy_setopt(curl_, CURLOPT_SSL_VERIFYHOST, 2L);
    }

    // Timeout
    curl_easy_setopt(curl_, CURLOPT_TIMEOUT, config_.timeout.count());

    // Response handling
    std::string response_data;
    curl_easy_setopt(curl_, CURLOPT_WRITEFUNCTION,
        [](void* ptr, size_t size, size_t nmemb, void* userdata) -> size_t {
            std::string* response = static_cast<std::string*>(userdata);
            response->append(static_cast<char*>(ptr), size * nmemb);
            return size * nmemb;
        });
    curl_easy_setopt(curl_, CURLOPT_WRITEDATA, &response_data);

    CURLcode res = curl_easy_perform(curl_);

    curl_slist_free_all(headers);

    if (res != CURLE_OK) {
        return R"({"ok":false,"description":")" +
               std::string(curl_easy_strerror(res)) + R"("})";
    }

    return response_data;
}

std::string TelegramClient::escape_html(const std::string& str) {
    std::string escaped;
    escaped.reserve(str.size() * 1.2);

    for (char c : str) {
        switch (c) {
        case '<': escaped += "&lt;"; break;
        case '>': escaped += "&gt;"; break;
        case '&': escaped += "&amp;"; break;
        case '"': escaped += "&quot;"; break;
        default: escaped += c;
        }
    }

    return escaped;
}

std::string TelegramClient::escape_markdown(const std::string& str) {
    std::string escaped;
    escaped.reserve(str.size() * 1.2);

    const std::string special_chars = "_*[]()~`>#+-=|{}.!";

    for (char c : str) {
        if (special_chars.find(c) != std::string::npos) {
            escaped += '\\';
        }
        escaped += c;
    }

    return escaped;
}

// ============================================================================
// TelegramChannel Implementation
// ============================================================================

TelegramChannel::TelegramChannel(const TelegramConfig& config)
    : config_(config) {
}

TelegramChannel::~TelegramChannel() {
    stop();
}

bool TelegramChannel::start() {
    if (running_.load(std::memory_order_acquire)) {
        return true;
    }

    try {
        telegram_client_ = std::make_unique<TelegramClient>(config_);
    } catch (const std::exception& e) {
        spdlog::error("Failed to initialize Telegram client: {}", e.what());
        return false;
    }

    running_.store(true, std::memory_order_release);

    spdlog::info("Telegram channel started");
    return true;
}

void TelegramChannel::stop() {
    if (!running_.load(std::memory_order_acquire)) {
        return;
    }

    running_.store(false, std::memory_order_release);

    telegram_client_.reset();

    spdlog::info("Telegram channel stopped");
}

bool TelegramChannel::is_running() const {
    return running_.load(std::memory_order_acquire);
}

DispatchResult TelegramChannel::send(const Alert& alert,
                                     const std::vector<std::string>& recipients) {
    auto start_time = std::chrono::steady_clock::now();

    DispatchResult result;
    result.channel = ChannelType::Telegram;

    if (!is_running()) {
        result.success = false;
        result.error_message = "Telegram channel not running";
        return result;
    }

    // Check rate limit
    if (!check_rate_limit()) {
        result.success = false;
        result.error_message = "Rate limit exceeded";
        metrics_.rate_limited_count++;
        return result;
    }

    // Get chat IDs
    auto chat_ids = get_chat_ids_for_alert(alert, recipients);

    if (chat_ids.empty()) {
        result.success = false;
        result.error_message = "No chat IDs configured";
        return result;
    }

    bool all_success = true;
    std::string combined_errors;

    for (int64_t chat_id : chat_ids) {
        // Create message
        TelegramMessage msg = create_telegram_message(alert, chat_id);

        // Send message
        auto send_result = telegram_client_->send_message(msg);

        if (send_result.success) {
            metrics_.sent_count++;
            result.external_id = std::to_string(send_result.message_id);
        } else {
            all_success = false;
            combined_errors += send_result.error_message + "; ";
            metrics_.failed_count++;
        }
    }

    // Update rate limit
    update_rate_limit();

    auto end_time = std::chrono::steady_clock::now();
    result.latency = std::chrono::duration_cast<std::chrono::milliseconds>(
        end_time - start_time);

    result.success = all_success;
    if (!all_success) {
        result.error_message = combined_errors;
    }

    return result;
}

TelegramMessage TelegramChannel::create_telegram_message(const Alert& alert,
                                                         int64_t chat_id) {
    TelegramMessage msg;
    msg.chat_id = chat_id;
    msg.parse_mode = config_.parse_mode;
    msg.disable_notification = config_.disable_notification;
    msg.disable_web_page_preview = config_.disable_web_page_preview;

    // Format message based on parse mode
    if (config_.parse_mode == TelegramConfig::ParseMode::HTML) {
        msg.text = format_html_message(alert);
    } else {
        msg.text = format_markdown_message(alert);
    }

    // Add interactive buttons for P1/P2
    if (config_.enable_inline_keyboard &&
        (alert.severity == AlertSeverity::P1 || alert.severity == AlertSeverity::P2)) {

        std::vector<TelegramMessage::InlineButton> row1;

        TelegramMessage::InlineButton ack_btn;
        ack_btn.text = "Acknowledge";
        ack_btn.callback_data = "ack_" + std::to_string(alert.id);
        row1.push_back(ack_btn);

        TelegramMessage::InlineButton dashboard_btn;
        dashboard_btn.text = "Dashboard";
        dashboard_btn.url = "https://dashboard.company.com/alerts/" +
                           std::to_string(alert.id);
        row1.push_back(dashboard_btn);

        msg.inline_keyboard.push_back(row1);
    }

    return msg;
}

std::string TelegramChannel::format_html_message(const Alert& alert) {
    std::ostringstream html;

    std::string emoji = get_severity_emoji(alert.severity);

    html << "<b>" << emoji << " " << severity_to_string(alert.severity)
         << "</b>\n\n";

    html << "<b>" << alert.title << "</b>\n\n";

    html << alert.message << "\n\n";

    html << "<b>Details:</b>\n";
    html << "Source: <code>" << alert.source << "</code>\n";
    html << "Time: <code>" << format_timestamp(alert.timestamp) << "</code>\n";
    html << "Alert ID: <code>" << alert.id << "</code>\n";

    if (!alert.context.empty()) {
        html << "\n<b>Context:</b>\n";
        for (const auto& [key, value] : alert.context) {
            html << key << ": <code>" << value << "</code>\n";
        }
    }

    return html.str();
}

std::string TelegramChannel::format_markdown_message(const Alert& alert) {
    std::ostringstream md;

    std::string emoji = get_severity_emoji(alert.severity);

    md << "*" << emoji << " " << severity_to_string(alert.severity) << "*\n\n";

    md << "*" << alert.title << "*\n\n";

    md << alert.message << "\n\n";

    md << "*Details:*\n";
    md << "Source: `" << alert.source << "`\n";
    md << "Time: `" << format_timestamp(alert.timestamp) << "`\n";
    md << "Alert ID: `" << alert.id << "`\n";

    if (!alert.context.empty()) {
        md << "\n*Context:*\n";
        for (const auto& [key, value] : alert.context) {
            md << key << ": `" << value << "`\n";
        }
    }

    return md.str();
}

std::vector<int64_t> TelegramChannel::get_chat_ids_for_alert(
    const Alert& alert,
    const std::vector<std::string>& recipients) {

    std::vector<int64_t> chat_ids;

    // Add severity-based chat IDs
    auto it = config_.severity_chat_ids.find(alert.severity);
    if (it != config_.severity_chat_ids.end()) {
        chat_ids.insert(chat_ids.end(), it->second.begin(), it->second.end());
    }

    // Add user-specific chat IDs
    for (const auto& recipient : recipients) {
        auto user_it = config_.user_map.find(recipient);
        if (user_it != config_.user_map.end()) {
            chat_ids.push_back(user_it->second);
        }
    }

    // Remove duplicates
    std::sort(chat_ids.begin(), chat_ids.end());
    chat_ids.erase(std::unique(chat_ids.begin(), chat_ids.end()), chat_ids.end());

    return chat_ids;
}

std::string TelegramChannel::get_severity_emoji(AlertSeverity severity) {
    switch (severity) {
    case AlertSeverity::P1: return "üö®";
    case AlertSeverity::P2: return "‚ö†Ô∏è";
    case AlertSeverity::P3: return "üî∂";
    case AlertSeverity::P4: return "‚ÑπÔ∏è";
    default: return "‚ùì";
    }
}

bool TelegramChannel::check_rate_limit() {
    std::lock_guard<std::mutex> lock(rate_limit_mutex_);

    auto now = std::chrono::steady_clock::now();

    // Remove old timestamps
    while (!message_times_.empty() &&
           (now - message_times_.front()) > std::chrono::seconds(1)) {
        message_times_.pop_front();
    }

    return message_times_.size() < config_.max_per_second;
}

void TelegramChannel::update_rate_limit() {
    std::lock_guard<std::mutex> lock(rate_limit_mutex_);
    message_times_.push_back(std::chrono::steady_clock::now());
}

bool TelegramChannel::health_check() {
    if (!is_running()) {
        return false;
    }

    // Telegram doesn't have a dedicated health check
    // We consider it healthy if the client is initialized
    return telegram_client_ != nullptr;
}

ChannelMetrics TelegramChannel::get_metrics() const {
    return metrics_;
}

} // namespace notification
} // namespace hft

================================================================================
                    END OF TELEGRAM NOTIFICATIONS GUIDE
================================================================================
