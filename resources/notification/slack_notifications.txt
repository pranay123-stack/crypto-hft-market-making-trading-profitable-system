================================================================================
                     SLACK NOTIFICATIONS - COMPLETE GUIDE
================================================================================

VERSION: 2.1.0
LAST UPDATED: 2025-11-25
STATUS: PRODUCTION
MAINTAINER: Infrastructure Team

================================================================================
                              TABLE OF CONTENTS
================================================================================

1. Slack Channel Overview
2. Slack App Setup & Configuration
3. Webhook vs Bot API Comparison
4. C++ Slack Implementation
5. Block Kit Message Formatting
6. Interactive Components
7. Threading & Context
8. Channel Management & Routing
9. Rate Limiting & Best Practices
10. Testing & Debugging
11. Production Deployment
12. Advanced Features

================================================================================
                       1. SLACK CHANNEL OVERVIEW
================================================================================

Slack is the primary real-time notification channel for:
- Team coordination and collaboration
- General alerts (P2, P3, P4)
- System status updates
- Trading activity summaries
- Development notifications
- Incident response coordination

CHARACTERISTICS:

Latency: 0.5-2 seconds
Reliability: 99.8%
Cost: Free (up to 10k messages/month), then $0.00001/message
Rich Formatting: Yes (Block Kit, Markdown)
Interactive: Yes (buttons, menus, modals)
Threading: Yes (organize conversations)
File Attachments: Yes (logs, screenshots)
Search: Full-text search history

WHY USE SLACK:

1. Real-time team communication
2. Rich formatting (colors, buttons, charts)
3. Persistent history and search
4. Mobile and desktop notifications
5. Integration with workflow
6. Thread conversations for context
7. Emoji reactions for quick acknowledgment

WHEN TO USE SLACK:

P2 Alerts:
- Degraded performance
- High error rates
- Important but not critical

P3 Alerts:
- Minor issues
- Configuration changes
- Deployment notifications

P4 Informational:
- Daily summaries
- System health reports
- Trading statistics

WHEN NOT TO USE SLACK:

- P1 critical alerts requiring immediate attention (use PagerDuty + SMS)
- Sensitive information (use secure channels)
- High-frequency updates (causes noise)
- Compliance-critical notifications (use email)

RECOMMENDED SLACK CHANNELS:

#hft-alerts          All automated system alerts
#hft-critical        P1/P2 critical issues only
#hft-trading         Trading activity and fills
#hft-deployments     Deployment notifications
#hft-monitoring      System health metrics
#hft-oncall          On-call coordination
#hft-incidents       Active incident response

================================================================================
                   2. SLACK APP SETUP & CONFIGURATION
================================================================================

STEP 1: CREATE SLACK APP

1. Go to https://api.slack.com/apps
2. Click "Create New App"
3. Choose "From scratch"
4. Name: "HFT Notification System"
5. Select your workspace

STEP 2: CONFIGURE BOT PERMISSIONS

Navigate to "OAuth & Permissions" and add scopes:
- chat:write          Send messages
- chat:write.public   Send to public channels without joining
- files:write         Upload files
- channels:read       List public channels
- groups:read         List private channels
- users:read          Read user information
- reactions:write     Add emoji reactions

STEP 3: INSTALL APP TO WORKSPACE

1. Click "Install to Workspace"
2. Authorize the app
3. Copy the "Bot User OAuth Token" (starts with xoxb-)

STEP 4: SETUP INCOMING WEBHOOKS (Alternative/Additional)

1. Navigate to "Incoming Webhooks"
2. Activate Incoming Webhooks
3. Add New Webhook to Workspace
4. Select channel (e.g., #hft-alerts)
5. Copy webhook URL

CONFIGURATION FILE: /etc/hft/channels/slack.conf

# Slack Bot API Configuration (Recommended)
slack.use_bot_api = true
slack.bot_token = ${SLACK_BOT_TOKEN}
slack.app_token = ${SLACK_APP_TOKEN}      # For Socket Mode (optional)

# Webhook Configuration (Alternative or Backup)
slack.use_webhook = true
slack.webhook_url = ${SLACK_WEBHOOK_URL}

# Default Settings
slack.default_channel = hft-alerts
slack.default_username = HFT System
slack.default_icon_emoji = :robot_face:

# Channel Routing (severity-based)
slack.p1_channel = hft-critical
slack.p2_channel = hft-critical
slack.p3_channel = hft-alerts
slack.p4_channel = hft-alerts

# Message Formatting
slack.use_blocks = true               # Use Block Kit (recommended)
slack.use_markdown = true
slack.enable_threading = true         # Group related alerts
slack.thread_timeout_seconds = 300    # Group alerts within 5 minutes

# Rate Limiting
slack.max_per_second = 1              # Slack limit: 1 message/second
slack.max_per_minute = 60
slack.burst_allowance = 5

# Retry Configuration
slack.retry_attempts = 3
slack.retry_delay_ms = 1000
slack.timeout_seconds = 10

# Advanced Features
slack.enable_unfurling = true         # Auto-expand links
slack.enable_reactions = true         # Add emoji reactions
slack.mention_users = true            # @mention users for P1/P2

# User Mappings (email to Slack user ID)
slack.user_map.trader@company.com = U01234ABCDE
slack.user_map.oncall@company.com = U56789FGHIJ
slack.user_map.devops@company.com = U09876KLMNO

Environment Variables:

export SLACK_BOT_TOKEN=xoxb-your-bot-token-here
export SLACK_WEBHOOK_URL=https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXX
export SLACK_APP_TOKEN=xapp-your-app-token-here

================================================================================
                   3. WEBHOOK VS BOT API COMPARISON
================================================================================

INCOMING WEBHOOKS:

Pros:
- Simplest to setup (one URL)
- No rate limiting concerns
- No token management
- Works immediately

Cons:
- Fixed channel only
- No threading support
- No interactive components
- Cannot read messages
- Cannot upload files
- Limited to one channel per webhook

When to use:
- Quick setup for single channel
- Simple notifications only
- No need for advanced features

BOT API:

Pros:
- Send to any channel
- Full Block Kit support
- Threading and replies
- Interactive components
- File uploads
- Read channel history
- User mentions

Cons:
- More complex setup
- Token management required
- Rate limits to consider
- OAuth flow needed

When to use:
- Production deployments
- Multiple channels
- Rich formatting needed
- Interactive features
- Thread management

RECOMMENDATION: Use Bot API for production HFT system

================================================================================
                     4. C++ SLACK IMPLEMENTATION
================================================================================

HEADER FILE: slack_channel.hpp

#ifndef HFT_SLACK_CHANNEL_HPP
#define HFT_SLACK_CHANNEL_HPP

#include "channel_interface.hpp"
#include <curl/curl.h>
#include <string>
#include <vector>
#include <memory>
#include <unordered_map>
#include <mutex>
#include <deque>

namespace hft {
namespace notification {

struct SlackConfig {
    // Bot API settings
    bool use_bot_api{true};
    std::string bot_token;
    std::string app_token;

    // Webhook settings
    bool use_webhook{false};
    std::string webhook_url;

    // Default settings
    std::string default_channel{"hft-alerts"};
    std::string default_username{"HFT System"};
    std::string default_icon_emoji{":robot_face:"};

    // Channel routing
    std::unordered_map<AlertSeverity, std::string> severity_channels{
        {AlertSeverity::P1, "hft-critical"},
        {AlertSeverity::P2, "hft-critical"},
        {AlertSeverity::P3, "hft-alerts"},
        {AlertSeverity::P4, "hft-alerts"}
    };

    // Message formatting
    bool use_blocks{true};
    bool use_markdown{true};
    bool enable_threading{true};
    std::chrono::seconds thread_timeout{300};

    // Rate limiting
    uint32_t max_per_second{1};
    uint32_t max_per_minute{60};
    uint32_t burst_allowance{5};

    // Retry settings
    uint32_t retry_attempts{3};
    std::chrono::milliseconds retry_delay{1000};
    std::chrono::seconds timeout{10};

    // Advanced features
    bool enable_unfurling{true};
    bool enable_reactions{true};
    bool mention_users{true};

    // User mappings (email -> Slack user ID)
    std::unordered_map<std::string, std::string> user_map;
};

struct SlackMessage {
    std::string channel;
    std::string text;              // Fallback text
    std::string blocks_json;       // Block Kit JSON
    std::string thread_ts;         // Parent message timestamp for threading
    std::string username;
    std::string icon_emoji;
    bool unfurl_links{true};
    bool unfurl_media{true};

    std::map<std::string, std::string> metadata;
};

struct SlackThread {
    std::string thread_ts;                           // Thread parent timestamp
    std::chrono::system_clock::time_point last_used;
    std::string alert_type;                          // Type of alerts in thread
    uint32_t message_count{0};
};

class SlackBlockBuilder {
public:
    SlackBlockBuilder();

    // Block methods
    SlackBlockBuilder& add_header(const std::string& text);
    SlackBlockBuilder& add_section(const std::string& text);
    SlackBlockBuilder& add_divider();
    SlackBlockBuilder& add_context(const std::vector<std::string>& elements);
    SlackBlockBuilder& add_fields(const std::map<std::string, std::string>& fields);
    SlackBlockBuilder& add_button(const std::string& text,
                                   const std::string& url,
                                   const std::string& style = "default");

    // Color coding
    SlackBlockBuilder& set_color(const std::string& color);

    // Build final JSON
    std::string build() const;

private:
    std::vector<std::string> blocks_;
    std::string color_;

    std::string escape_json(const std::string& str) const;
};

class SlackClient {
public:
    explicit SlackClient(const SlackConfig& config);
    ~SlackClient();

    struct SendResult {
        bool success;
        std::string timestamp;      // Message timestamp (for threading)
        std::string error_message;
        std::string channel_id;
    };

    SendResult send_message(const SlackMessage& message);
    SendResult send_to_webhook(const SlackMessage& message);
    bool upload_file(const std::string& channel,
                    const std::string& filename,
                    const std::vector<uint8_t>& content);
    bool add_reaction(const std::string& channel,
                     const std::string& timestamp,
                     const std::string& emoji);

private:
    SlackConfig config_;
    CURL* curl_{nullptr};

    std::string make_api_call(const std::string& endpoint,
                             const std::string& json_payload);
};

class SlackChannel : public INotificationChannel {
public:
    explicit SlackChannel(const SlackConfig& config);
    ~SlackChannel() override;

    // INotificationChannel interface
    DispatchResult send(const Alert& alert,
                       const std::vector<std::string>& recipients) override;

    bool health_check() override;
    ChannelMetrics get_metrics() const override;
    void set_config(const ChannelConfig& config) override;
    ChannelConfig get_config() const override;

    bool start() override;
    void stop() override;
    bool is_running() const override;

    ChannelType get_type() const override { return ChannelType::Slack; }
    std::string get_name() const override { return "Slack"; }

private:
    SlackConfig config_;
    std::unique_ptr<SlackClient> slack_client_;
    std::atomic<bool> running_{false};

    // Rate limiting
    std::deque<std::chrono::steady_clock::time_point> message_times_;
    std::mutex rate_limit_mutex_;

    // Threading management
    std::unordered_map<std::string, SlackThread> threads_;
    std::mutex threads_mutex_;

    // Metrics
    mutable ChannelMetrics metrics_;

    // Helper methods
    SlackMessage create_slack_message(const Alert& alert,
                                     const std::string& channel);
    std::string build_block_kit_message(const Alert& alert);
    std::string build_simple_message(const Alert& alert);
    std::string get_channel_for_alert(const Alert& alert);
    std::string get_severity_color(AlertSeverity severity);
    std::string get_severity_emoji(AlertSeverity severity);
    bool check_rate_limit();
    void update_rate_limit();
    std::string find_or_create_thread(const Alert& alert,
                                     const std::string& channel);
    void cleanup_old_threads();
    std::string mention_users(const std::vector<std::string>& recipients);
};

} // namespace notification
} // namespace hft

#endif // HFT_SLACK_CHANNEL_HPP

IMPLEMENTATION FILE: slack_channel.cpp

#include "slack_channel.hpp"
#include <spdlog/spdlog.h>
#include <curl/curl.h>
#include <sstream>
#include <iomanip>
#include <algorithm>

namespace hft {
namespace notification {

// ============================================================================
// SlackBlockBuilder Implementation
// ============================================================================

SlackBlockBuilder::SlackBlockBuilder() {
}

SlackBlockBuilder& SlackBlockBuilder::add_header(const std::string& text) {
    std::ostringstream block;
    block << R"({
        "type": "header",
        "text": {
            "type": "plain_text",
            "text": ")" << escape_json(text) << R"("
        }
    })";
    blocks_.push_back(block.str());
    return *this;
}

SlackBlockBuilder& SlackBlockBuilder::add_section(const std::string& text) {
    std::ostringstream block;
    block << R"({
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": ")" << escape_json(text) << R"("
        }
    })";
    blocks_.push_back(block.str());
    return *this;
}

SlackBlockBuilder& SlackBlockBuilder::add_divider() {
    blocks_.push_back(R"({"type": "divider"})");
    return *this;
}

SlackBlockBuilder& SlackBlockBuilder::add_fields(
    const std::map<std::string, std::string>& fields) {

    if (fields.empty()) {
        return *this;
    }

    std::ostringstream block;
    block << R"({
        "type": "section",
        "fields": [)";

    bool first = true;
    for (const auto& [key, value] : fields) {
        if (!first) block << ",";
        first = false;

        block << R"(
            {
                "type": "mrkdwn",
                "text": "*)" << escape_json(key) << R"(:*\n)"
                           << escape_json(value) << R"("
            })";
    }

    block << R"(
        ]
    })";

    blocks_.push_back(block.str());
    return *this;
}

SlackBlockBuilder& SlackBlockBuilder::add_button(const std::string& text,
                                                 const std::string& url,
                                                 const std::string& style) {
    std::ostringstream block;
    block << R"({
        "type": "actions",
        "elements": [
            {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": ")" << escape_json(text) << R"("
                },
                "url": ")" << escape_json(url) << R"(",
                "style": ")" << style << R"("
            }
        ]
    })";
    blocks_.push_back(block.str());
    return *this;
}

SlackBlockBuilder& SlackBlockBuilder::add_context(
    const std::vector<std::string>& elements) {

    if (elements.empty()) {
        return *this;
    }

    std::ostringstream block;
    block << R"({
        "type": "context",
        "elements": [)";

    bool first = true;
    for (const auto& element : elements) {
        if (!first) block << ",";
        first = false;

        block << R"(
            {
                "type": "mrkdwn",
                "text": ")" << escape_json(element) << R"("
            })";
    }

    block << R"(
        ]
    })";

    blocks_.push_back(block.str());
    return *this;
}

SlackBlockBuilder& SlackBlockBuilder::set_color(const std::string& color) {
    color_ = color;
    return *this;
}

std::string SlackBlockBuilder::build() const {
    std::ostringstream json;

    json << R"({
        "blocks": [)";

    bool first = true;
    for (const auto& block : blocks_) {
        if (!first) json << ",";
        first = false;
        json << block;
    }

    json << R"(
        ])";

    if (!color_.empty()) {
        json << R"(,
        "attachments": [{
            "color": ")" << color_ << R"(",
            "blocks": [)" << blocks_[0] << R"(]
        }])";
    }

    json << "}";

    return json.str();
}

std::string SlackBlockBuilder::escape_json(const std::string& str) const {
    std::ostringstream escaped;

    for (char c : str) {
        switch (c) {
        case '"':  escaped << "\\\""; break;
        case '\\': escaped << "\\\\"; break;
        case '\b': escaped << "\\b"; break;
        case '\f': escaped << "\\f"; break;
        case '\n': escaped << "\\n"; break;
        case '\r': escaped << "\\r"; break;
        case '\t': escaped << "\\t"; break;
        default:
            if (c < 0x20) {
                escaped << "\\u" << std::hex << std::setw(4)
                       << std::setfill('0') << static_cast<int>(c);
            } else {
                escaped << c;
            }
        }
    }

    return escaped.str();
}

// ============================================================================
// SlackClient Implementation
// ============================================================================

SlackClient::SlackClient(const SlackConfig& config)
    : config_(config) {
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_ = curl_easy_init();

    if (!curl_) {
        throw std::runtime_error("Failed to initialize CURL for Slack");
    }
}

SlackClient::~SlackClient() {
    if (curl_) {
        curl_easy_cleanup(curl_);
    }
}

SlackClient::SendResult SlackClient::send_message(const SlackMessage& message) {
    SendResult result;
    result.success = false;

    // Build JSON payload
    std::ostringstream payload;
    payload << R"({
        "channel": ")" << message.channel << R"(",
        "text": ")" << message.text << R"(")";

    if (!message.blocks_json.empty()) {
        // Extract blocks from blocks_json
        payload << R"(,
        "blocks": )" << message.blocks_json;
    }

    if (!message.thread_ts.empty()) {
        payload << R"(,
        "thread_ts": ")" << message.thread_ts << R"(")";
    }

    if (!message.username.empty()) {
        payload << R"(,
        "username": ")" << message.username << R"(")";
    }

    if (!message.icon_emoji.empty()) {
        payload << R"(,
        "icon_emoji": ")" << message.icon_emoji << R"(")";
    }

    payload << R"(,
        "unfurl_links": )" << (message.unfurl_links ? "true" : "false") << R"(,
        "unfurl_media": )" << (message.unfurl_media ? "true" : "false") << R"(
    })";

    std::string response = make_api_call("chat.postMessage", payload.str());

    // Parse response
    if (response.find(R"("ok":true)") != std::string::npos) {
        result.success = true;

        // Extract timestamp
        size_t ts_pos = response.find(R"("ts":")");
        if (ts_pos != std::string::npos) {
            size_t start = ts_pos + 6;
            size_t end = response.find('"', start);
            result.timestamp = response.substr(start, end - start);
        }

        spdlog::info("Slack message sent to {} (ts: {})",
                    message.channel, result.timestamp);
    } else {
        result.error_message = response;
        spdlog::error("Slack message failed: {}", response);
    }

    return result;
}

SlackClient::SendResult SlackClient::send_to_webhook(const SlackMessage& message) {
    SendResult result;
    result.success = false;

    curl_easy_setopt(curl_, CURLOPT_URL, config_.webhook_url.c_str());

    // Build JSON payload
    std::ostringstream payload;
    payload << R"({"text": ")" << message.text << R"("})";

    std::string payload_str = payload.str();
    curl_easy_setopt(curl_, CURLOPT_POSTFIELDS, payload_str.c_str());

    // Set headers
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, "Content-Type: application/json");
    curl_easy_setopt(curl_, CURLOPT_HTTPHEADER, headers);

    // Response handling
    std::string response_data;
    curl_easy_setopt(curl_, CURLOPT_WRITEFUNCTION,
        [](void* ptr, size_t size, size_t nmemb, void* userdata) -> size_t {
            std::string* response = static_cast<std::string*>(userdata);
            response->append(static_cast<char*>(ptr), size * nmemb);
            return size * nmemb;
        });
    curl_easy_setopt(curl_, CURLOPT_WRITEDATA, &response_data);

    CURLcode res = curl_easy_perform(curl_);

    curl_slist_free_all(headers);

    if (res == CURLE_OK) {
        long http_code = 0;
        curl_easy_getinfo(curl_, CURLINFO_RESPONSE_CODE, &http_code);

        if (http_code == 200) {
            result.success = true;
            spdlog::info("Slack webhook message sent successfully");
        } else {
            result.error_message = "HTTP " + std::to_string(http_code);
            spdlog::error("Slack webhook failed with HTTP {}", http_code);
        }
    } else {
        result.error_message = curl_easy_strerror(res);
        spdlog::error("Slack webhook CURL error: {}", result.error_message);
    }

    return result;
}

std::string SlackClient::make_api_call(const std::string& endpoint,
                                      const std::string& json_payload) {
    std::string url = "https://slack.com/api/" + endpoint;
    curl_easy_setopt(curl_, CURLOPT_URL, url.c_str());

    // Set authorization header
    std::string auth_header = "Authorization: Bearer " + config_.bot_token;
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, auth_header.c_str());
    headers = curl_slist_append(headers, "Content-Type: application/json");
    curl_easy_setopt(curl_, CURLOPT_HTTPHEADER, headers);

    // Set payload
    curl_easy_setopt(curl_, CURLOPT_POSTFIELDS, json_payload.c_str());

    // Timeout
    curl_easy_setopt(curl_, CURLOPT_TIMEOUT, config_.timeout.count());

    // Response handling
    std::string response_data;
    curl_easy_setopt(curl_, CURLOPT_WRITEFUNCTION,
        [](void* ptr, size_t size, size_t nmemb, void* userdata) -> size_t {
            std::string* response = static_cast<std::string*>(userdata);
            response->append(static_cast<char*>(ptr), size * nmemb);
            return size * nmemb;
        });
    curl_easy_setopt(curl_, CURLOPT_WRITEDATA, &response_data);

    CURLcode res = curl_easy_perform(curl_);

    curl_slist_free_all(headers);

    if (res != CURLE_OK) {
        return R"({"ok":false,"error":")" + std::string(curl_easy_strerror(res)) + R"("})";
    }

    return response_data;
}

bool SlackClient::add_reaction(const std::string& channel,
                               const std::string& timestamp,
                               const std::string& emoji) {
    std::ostringstream payload;
    payload << R"({
        "channel": ")" << channel << R"(",
        "timestamp": ")" << timestamp << R"(",
        "name": ")" << emoji << R"("
    })";

    std::string response = make_api_call("reactions.add", payload.str());

    return response.find(R"("ok":true)") != std::string::npos;
}

// ============================================================================
// SlackChannel Implementation
// ============================================================================

SlackChannel::SlackChannel(const SlackConfig& config)
    : config_(config) {
}

SlackChannel::~SlackChannel() {
    stop();
}

bool SlackChannel::start() {
    if (running_.load(std::memory_order_acquire)) {
        return true;
    }

    try {
        slack_client_ = std::make_unique<SlackClient>(config_);
    } catch (const std::exception& e) {
        spdlog::error("Failed to initialize Slack client: {}", e.what());
        return false;
    }

    running_.store(true, std::memory_order_release);

    spdlog::info("Slack channel started");
    return true;
}

void SlackChannel::stop() {
    if (!running_.load(std::memory_order_acquire)) {
        return;
    }

    running_.store(false, std::memory_order_release);

    slack_client_.reset();

    spdlog::info("Slack channel stopped");
}

bool SlackChannel::is_running() const {
    return running_.load(std::memory_order_acquire);
}

DispatchResult SlackChannel::send(const Alert& alert,
                                  const std::vector<std::string>& recipients) {
    auto start_time = std::chrono::steady_clock::now();

    DispatchResult result;
    result.channel = ChannelType::Slack;

    if (!is_running()) {
        result.success = false;
        result.error_message = "Slack channel not running";
        return result;
    }

    // Check rate limit
    if (!check_rate_limit()) {
        result.success = false;
        result.error_message = "Rate limit exceeded";
        metrics_.rate_limited_count++;
        return result;
    }

    // Determine channel
    std::string channel = get_channel_for_alert(alert);

    // Create Slack message
    SlackMessage msg = create_slack_message(alert, channel);

    // Add user mentions for P1/P2
    if (config_.mention_users &&
        (alert.severity == AlertSeverity::P1 || alert.severity == AlertSeverity::P2)) {
        std::string mentions = mention_users(recipients);
        if (!mentions.empty()) {
            msg.text = mentions + " " + msg.text;
        }
    }

    // Find or create thread
    if (config_.enable_threading) {
        msg.thread_ts = find_or_create_thread(alert, channel);
    }

    // Send message
    SlackClient::SendResult send_result;

    if (config_.use_bot_api) {
        send_result = slack_client_->send_message(msg);
    } else if (config_.use_webhook) {
        send_result = slack_client_->send_to_webhook(msg);
    } else {
        result.success = false;
        result.error_message = "No Slack method configured";
        return result;
    }

    // Update rate limit
    update_rate_limit();

    auto end_time = std::chrono::steady_clock::now();
    result.latency = std::chrono::duration_cast<std::chrono::milliseconds>(
        end_time - start_time);

    result.success = send_result.success;
    result.external_id = send_result.timestamp;

    if (send_result.success) {
        metrics_.sent_count++;

        // Add reaction for P1 alerts
        if (config_.enable_reactions && alert.severity == AlertSeverity::P1) {
            slack_client_->add_reaction(channel, send_result.timestamp, "rotating_light");
        }
    } else {
        result.error_message = send_result.error_message;
        metrics_.failed_count++;
    }

    return result;
}

SlackMessage SlackChannel::create_slack_message(const Alert& alert,
                                                const std::string& channel) {
    SlackMessage msg;
    msg.channel = channel;
    msg.username = config_.default_username;
    msg.icon_emoji = config_.default_icon_emoji;
    msg.unfurl_links = config_.enable_unfurling;
    msg.unfurl_media = config_.enable_unfurling;

    // Fallback text
    msg.text = "[" + severity_to_string(alert.severity) + "] " + alert.title;

    // Build Block Kit message
    if (config_.use_blocks) {
        msg.blocks_json = build_block_kit_message(alert);
    }

    return msg;
}

std::string SlackChannel::build_block_kit_message(const Alert& alert) {
    SlackBlockBuilder builder;

    // Severity emoji and header
    std::string emoji = get_severity_emoji(alert.severity);
    std::string color = get_severity_color(alert.severity);

    builder.set_color(color);
    builder.add_header(emoji + " " + severity_to_string(alert.severity) +
                      ": " + alert.title);

    // Message body
    builder.add_section(alert.message);

    builder.add_divider();

    // Context fields
    std::map<std::string, std::string> fields;
    fields["Source"] = alert.source;
    fields["Timestamp"] = format_timestamp(alert.timestamp);
    fields["Alert ID"] = std::to_string(alert.id);

    // Add alert context
    for (const auto& [key, value] : alert.context) {
        fields[key] = value;
    }

    builder.add_fields(fields);

    // Add action buttons for P1/P2
    if (alert.severity == AlertSeverity::P1 || alert.severity == AlertSeverity::P2) {
        builder.add_button("View Dashboard",
                          "https://dashboard.company.com/alerts/" + std::to_string(alert.id),
                          "primary");
    }

    // Footer context
    std::vector<std::string> context_elements;
    context_elements.push_back("HFT Notification System");
    context_elements.push_back("Alert ID: " + std::to_string(alert.id));

    builder.add_context(context_elements);

    return builder.build();
}

std::string SlackChannel::get_channel_for_alert(const Alert& alert) {
    auto it = config_.severity_channels.find(alert.severity);
    if (it != config_.severity_channels.end()) {
        return it->second;
    }
    return config_.default_channel;
}

std::string SlackChannel::get_severity_color(AlertSeverity severity) {
    switch (severity) {
    case AlertSeverity::P1: return "#dc3545"; // Red
    case AlertSeverity::P2: return "#fd7e14"; // Orange
    case AlertSeverity::P3: return "#ffc107"; // Yellow
    case AlertSeverity::P4: return "#28a745"; // Green
    default: return "#6c757d";                // Gray
    }
}

std::string SlackChannel::get_severity_emoji(AlertSeverity severity) {
    switch (severity) {
    case AlertSeverity::P1: return ":rotating_light:";
    case AlertSeverity::P2: return ":warning:";
    case AlertSeverity::P3: return ":large_orange_diamond:";
    case AlertSeverity::P4: return ":information_source:";
    default: return ":question:";
    }
}

bool SlackChannel::check_rate_limit() {
    std::lock_guard<std::mutex> lock(rate_limit_mutex_);

    auto now = std::chrono::steady_clock::now();

    // Remove timestamps older than 1 second
    while (!message_times_.empty() &&
           (now - message_times_.front()) > std::chrono::seconds(1)) {
        message_times_.pop_front();
    }

    // Check if under rate limit
    return message_times_.size() < config_.max_per_second;
}

void SlackChannel::update_rate_limit() {
    std::lock_guard<std::mutex> lock(rate_limit_mutex_);
    message_times_.push_back(std::chrono::steady_clock::now());
}

std::string SlackChannel::find_or_create_thread(const Alert& alert,
                                                const std::string& channel) {
    std::lock_guard<std::mutex> lock(threads_mutex_);

    cleanup_old_threads();

    std::string thread_key = channel + ":" + alert.source;

    auto it = threads_.find(thread_key);
    if (it != threads_.end()) {
        // Update existing thread
        it->second.last_used = std::chrono::system_clock::now();
        it->second.message_count++;
        return it->second.thread_ts;
    }

    // No thread found, this will be a new parent message
    return "";
}

void SlackChannel::cleanup_old_threads() {
    auto now = std::chrono::system_clock::now();

    for (auto it = threads_.begin(); it != threads_.end();) {
        auto age = std::chrono::duration_cast<std::chrono::seconds>(
            now - it->second.last_used);

        if (age > config_.thread_timeout) {
            it = threads_.erase(it);
        } else {
            ++it;
        }
    }
}

std::string SlackChannel::mention_users(const std::vector<std::string>& recipients) {
    std::ostringstream mentions;

    for (const auto& recipient : recipients) {
        auto it = config_.user_map.find(recipient);
        if (it != config_.user_map.end()) {
            mentions << "<@" << it->second << "> ";
        }
    }

    return mentions.str();
}

bool SlackChannel::health_check() {
    if (!is_running()) {
        return false;
    }

    // Try to make a simple API call
    // In production, implement auth.test API call

    return true;
}

ChannelMetrics SlackChannel::get_metrics() const {
    return metrics_;
}

} // namespace notification
} // namespace hft

================================================================================
                       END OF SLACK NOTIFICATIONS GUIDE
================================================================================
