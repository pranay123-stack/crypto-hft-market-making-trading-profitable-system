================================================================================
                      POST-FAILURE ANALYSIS FRAMEWORK
                   Root Cause Analysis & Continuous Improvement
================================================================================

DOCUMENT: Post-Failure Analysis Methodology
VERSION: 2.1.0
LAST UPDATED: 2025-11-26
SCOPE: Incident analysis and prevention

================================================================================
                          TABLE OF CONTENTS
================================================================================

1. Post-Mortem Philosophy
2. Incident Response Process
3. Root Cause Analysis (RCA)
4. Post-Mortem Templates
5. Timeline Reconstruction
6. Corrective Actions
7. Knowledge Base
8. Blameless Culture
9. Examples

================================================================================
                  1. POST-MORTEM PHILOSOPHY
================================================================================

CORE PRINCIPLES:
----------------
1. BLAMELESS CULTURE
   - Focus on systems, not people
   - Psychological safety
   - Learning over punishment

2. LEARNING ORGANIZATION
   - Every failure is an opportunity
   - Share lessons learned
   - Continuous improvement

3. PREVENTION-FOCUSED
   - Identify root causes
   - Implement systemic fixes
   - Prevent recurrence

4. DOCUMENTATION
   - Complete incident records
   - Searchable knowledge base
   - Historical trends

POST-MORTEM TRIGGERS:
---------------------
Mandatory post-mortem for:
- P1/P2 incidents
- System outages > 5 minutes
- Financial loss > $10,000
- Regulatory reporting required
- Circuit breaker activations
- Emergency halts

Optional post-mortem for:
- P3/P4 incidents
- Near-misses
- Interesting anomalies
- Learning opportunities

TIMELINE:
---------
Within 24 hours: Initial timeline
Within 48 hours: Draft post-mortem
Within 1 week: Final post-mortem
Within 2 weeks: Corrective actions started
Within 1 month: Review of implemented fixes

================================================================================
                    3. ROOT CAUSE ANALYSIS (RCA)
================================================================================

5 WHYS TECHNIQUE:

Problem: Trading system stopped responding

Why 1: Why did the system stop responding?
  → Memory usage reached 100%

Why 2: Why did memory usage reach 100%?
  → Memory leak in order book processing

Why 3: Why was there a memory leak?
  → Order book entries not being cleaned up

Why 4: Why weren't entries being cleaned up?
  → Cleanup logic only ran on explicit deletes

Why 5: Why didn't cleanup run automatically?
  → No timeout-based cleanup was implemented

ROOT CAUSE: Missing automatic cleanup for stale order book entries
ACTION: Implement periodic cleanup with TTL

FISHBONE DIAGRAM:

           People           Process          Technology
              |                |                 |
              |                |                 |
              +----------------+-----------------+
                               |
                          [PROBLEM]
                               |
              +----------------+-----------------+
              |                |                 |
              |                |                 |
         Environment      Procedures         Tools

IMPLEMENTATION:

namespace hft::analysis {

class RootCauseAnalyzer {
public:
    struct RCAResult {
        std::string incident_id;
        std::vector<std::string> contributing_factors;
        std::string root_cause;
        std::vector<std::string> corrective_actions;
        std::chrono::system_clock::time_point analysis_date;
    };
    
    RCAResult analyze_incident(const Incident& incident) {
        RCAResult result;
        result.incident_id = incident.id;
        result.analysis_date = std::chrono::system_clock::now();
        
        // Collect all events around incident
        auto events = collect_related_events(incident);
        
        // Build timeline
        auto timeline = build_timeline(events);
        
        // Identify contributing factors
        result.contributing_factors = identify_factors(timeline);
        
        // Perform 5 whys
        result.root_cause = perform_five_whys(incident, timeline);
        
        // Generate corrective actions
        result.corrective_actions = generate_corrective_actions(
            result.root_cause
        );
        
        // Save analysis
        save_rca_result(result);
        
        return result;
    }
    
private:
    std::string perform_five_whys(const Incident& incident,
                                  const Timeline& timeline) {
        std::vector<std::string> whys;
        std::string current_question = incident.description;
        
        for (int i = 0; i < 5; ++i) {
            std::string answer = analyze_why(current_question, timeline);
            whys.push_back(answer);
            
            if (is_root_cause(answer)) {
                break;  // Found root cause
            }
            
            current_question = "Why " + answer + "?";
        }
        
        return whys.back();  // Last "why" is root cause
    }
};

} // namespace hft::analysis

================================================================================
                     4. POST-MORTEM TEMPLATES
================================================================================

POST-MORTEM DOCUMENT TEMPLATE:

# Post-Mortem: [INCIDENT TITLE]

## Incident Summary
- **Date**: 2025-11-26
- **Time**: 10:30:00 UTC - 10:45:00 UTC
- **Duration**: 15 minutes
- **Severity**: P1-CRITICAL
- **Impact**: Trading halted on NASDAQ
- **Financial Impact**: ~$25,000 in lost opportunity cost
- **Incident Commander**: John Doe
- **Responders**: Jane Smith, Bob Johnson

## Executive Summary
Brief 2-3 paragraph summary of what happened, why it happened,
and what we're doing to prevent it.

## Timeline (UTC)
| Time     | Event |
|----------|-------|
| 10:27:35 | First error log: "Connection timeout to NASDAQ"
| 10:28:10 | Automated reconnection attempts start
| 10:28:45 | Circuit breaker opens
| 10:29:00 | PagerDuty alert sent
| 10:30:00 | On-call engineer acknowledged alert
| 10:32:15 | Manual investigation begins
| 10:35:00 | Root cause identified: DNS failure
| 10:37:30 | DNS failover initiated
| 10:40:00 | Connection restored
| 10:42:00 | Circuit breaker reset
| 10:45:00 | Trading resumed, system normal

## Root Cause Analysis

### What Happened
Detailed explanation of the incident.

### Why It Happened (5 Whys)
1. Why did trading halt?
   - Lost connection to NASDAQ exchange
2. Why did we lose connection?
   - DNS resolution failed for exchange endpoint
3. Why did DNS fail?
   - Primary DNS server was unreachable
4. Why was DNS server unreachable?
   - Network route to DNS server was down
5. Why didn't we failover to secondary DNS?
   - **ROOT CAUSE**: DNS failover was not configured

### Contributing Factors
- No monitoring of DNS server health
- Single point of failure in DNS resolution
- Insufficient testing of network failure scenarios
- Circuit breaker timeout too short for DNS failover

## Impact Assessment

### Technical Impact
- 15 minutes of trading downtime
- 437 orders cancelled
- Market making stopped for 12 symbols

### Financial Impact
- Estimated opportunity cost: $25,000
- No actual financial loss (positions protected)
- No regulatory penalties

### Customer Impact
- Internal systems only (no external customers)
- Risk team unable to get real-time positions

## What Went Well
- Circuit breaker activated correctly
- PagerDuty alert delivered promptly
- On-call engineer responded quickly
- No data corruption or position discrepancies
- Recovery was successful

## What Went Poorly
- DNS failover not configured
- No monitoring of DNS health
- Manual intervention required (should be automatic)
- Detection took 3 minutes (should be < 30 seconds)

## Corrective Actions

### Immediate (Next 24 hours)
- [x] Configure DNS failover to secondary server
- [x] Add monitoring for DNS server health
- [ ] Document DNS failover procedure

### Short-term (Next 2 weeks)
- [ ] Implement automatic DNS failover
- [ ] Add network connectivity health checks
- [ ] Improve circuit breaker timeout configuration
- [ ] Create runbook for DNS failures

### Long-term (Next quarter)
- [ ] Full network redundancy review
- [ ] Chaos engineering testing for DNS failures
- [ ] Multi-region DNS architecture
- [ ] Enhanced monitoring and alerting

## Lessons Learned
1. Single points of failure exist even in "redundant" systems
2. Network layer failures need same attention as application failures
3. Automated failover is critical for sub-minute recovery
4. Testing must include infrastructure layer

## Action Items
| Owner | Action | Due Date | Status |
|-------|--------|----------|--------|
| DevOps | Configure DNS failover | 2025-11-27 | Done |
| DevOps | Add DNS monitoring | 2025-11-27 | Done |
| SRE | Document procedure | 2025-11-28 | In Progress |
| Dev | Implement auto-failover | 2025-12-10 | Not Started |

## Supporting Information
- Incident ticket: INC-20251126-001
- Related alerts: [link]
- Log files: [link]
- Metrics dashboard: [link]

## Review
- **Reviewed by**: Engineering leadership
- **Date**: 2025-11-27
- **Approved**: Yes

================================================================================
                              END OF DOCUMENT
================================================================================

================================================================================
                   5. AUTOMATED TIMELINE RECONSTRUCTION
================================================================================

class TimelineReconstructor {
public:
    struct TimelineEvent {
        std::chrono::system_clock::time_point timestamp;
        std::string source;  // log, metric, alert, etc.
        std::string event_type;
        std::string description;
        std::map<std::string, std::string> metadata;
    };
    
    std::vector<TimelineEvent> reconstruct_timeline(
        const Incident& incident,
        std::chrono::minutes window_before = std::chrono::minutes(15),
        std::chrono::minutes window_after = std::chrono::minutes(15)
    ) {
        std::vector<TimelineEvent> timeline;
        
        auto start_time = incident.start_time - window_before;
        auto end_time = incident.end_time + window_after;
        
        // Collect events from various sources
        collect_log_events(timeline, start_time, end_time);
        collect_metric_events(timeline, start_time, end_time);
        collect_alert_events(timeline, start_time, end_time);
        collect_order_events(timeline, start_time, end_time);
        collect_system_events(timeline, start_time, end_time);
        
        // Sort chronologically
        std::sort(timeline.begin(), timeline.end(),
                 [](const TimelineEvent& a, const TimelineEvent& b) {
                     return a.timestamp < b.timestamp;
                 });
        
        return timeline;
    }
    
private:
    void collect_log_events(std::vector<TimelineEvent>& timeline,
                           const std::chrono::system_clock::time_point& start,
                           const std::chrono::system_clock::time_point& end) {
        // Query log database
        auto logs = log_db_.query(
            "SELECT * FROM logs WHERE timestamp BETWEEN ? AND ? "
            "AND level IN ('ERROR', 'CRITICAL', 'FATAL')",
            start, end
        );
        
        for (const auto& log : logs) {
            timeline.push_back({
                .timestamp = log.timestamp,
                .source = "log",
                .event_type = log.level,
                .description = log.message,
                .metadata = {
                    {"logger", log.logger_name},
                    {"thread_id", std::to_string(log.thread_id)},
                    {"file", log.file},
                    {"line", std::to_string(log.line)}
                }
            });
        }
    }
    
    void collect_metric_events(std::vector<TimelineEvent>& timeline,
                               const std::chrono::system_clock::time_point& start,
                               const std::chrono::system_clock::time_point& end) {
        // Query metric database for anomalies
        auto metrics = metric_db_.query_anomalies(start, end, 3.0);  // 3-sigma
        
        for (const auto& metric : metrics) {
            timeline.push_back({
                .timestamp = metric.timestamp,
                .source = "metric",
                .event_type = "anomaly",
                .description = "Metric anomaly: " + metric.name,
                .metadata = {
                    {"metric", metric.name},
                    {"value", std::to_string(metric.value)},
                    {"mean", std::to_string(metric.mean)},
                    {"std_dev", std::to_string(metric.std_dev)}
                }
            });
        }
    }
    
    void collect_alert_events(std::vector<TimelineEvent>& timeline,
                             const std::chrono::system_clock::time_point& start,
                             const std::chrono::system_clock::time_point& end) {
        auto alerts = alert_db_.query(start, end);
        
        for (const auto& alert : alerts) {
            timeline.push_back({
                .timestamp = alert.timestamp,
                .source = "alert",
                .event_type = to_string(alert.severity),
                .description = alert.message,
                .metadata = {
                    {"alert_id", alert.id},
                    {"component", alert.component}
                }
            });
        }
    }
};

================================================================================
                   6. CORRECTIVE ACTION TRACKING
================================================================================

class CorrectiveActionTracker {
public:
    struct CorrectiveAction {
        std::string id;
        std::string incident_id;
        std::string description;
        std::string owner;
        std::chrono::system_clock::time_point due_date;
        std::chrono::system_clock::time_point completed_at;
        std::string status;  // "NOT_STARTED", "IN_PROGRESS", "COMPLETED", "BLOCKED"
        int priority;  // 1 = highest
        std::vector<std::string> dependencies;
    };
    
    void create_action(const CorrectiveAction& action) {
        actions_[action.id] = action;
        
        logger_.info("Corrective action created", {
            {"action_id", action.id},
            {"incident_id", action.incident_id},
            {"description", action.description},
            {"owner", action.owner},
            {"priority", action.priority}
        });
        
        // Send notification to owner
        notify_owner(action);
    }
    
    void update_status(const std::string& action_id,
                      const std::string& new_status) {
        auto it = actions_.find(action_id);
        if (it == actions_.end()) {
            logger_.error("Action not found", {{"action_id", action_id}});
            return;
        }
        
        std::string old_status = it->second.status;
        it->second.status = new_status;
        
        if (new_status == "COMPLETED") {
            it->second.completed_at = std::chrono::system_clock::now();
        }
        
        logger_.info("Corrective action status updated", {
            {"action_id", action_id},
            {"old_status", old_status},
            {"new_status", new_status}
        });
        
        // Check if incident can be closed
        check_incident_closure(it->second.incident_id);
    }
    
    std::vector<CorrectiveAction> get_overdue_actions() {
        std::vector<CorrectiveAction> overdue;
        auto now = std::chrono::system_clock::now();
        
        for (const auto& [id, action] : actions_) {
            if (action.status != "COMPLETED" &&
                action.due_date < now) {
                overdue.push_back(action);
            }
        }
        
        // Sort by priority
        std::sort(overdue.begin(), overdue.end(),
                 [](const CorrectiveAction& a, const CorrectiveAction& b) {
                     return a.priority < b.priority;
                 });
        
        return overdue;
    }
    
    void generate_weekly_report() {
        auto actions = get_all_actions_last_week();
        
        size_t completed = 0;
        size_t in_progress = 0;
        size_t not_started = 0;
        size_t overdue = 0;
        
        auto now = std::chrono::system_clock::now();
        
        for (const auto& action : actions) {
            if (action.status == "COMPLETED") {
                completed++;
            } else if (action.status == "IN_PROGRESS") {
                in_progress++;
            } else {
                not_started++;
            }
            
            if (action.status != "COMPLETED" && action.due_date < now) {
                overdue++;
            }
        }
        
        logger_.info("Weekly corrective action report", {
            {"total", actions.size()},
            {"completed", completed},
            {"in_progress", in_progress},
            {"not_started", not_started},
            {"overdue", overdue}
        });
        
        // Send report
        send_weekly_report(actions, completed, in_progress,
                          not_started, overdue);
    }
    
private:
    std::unordered_map<std::string, CorrectiveAction> actions_;
};

================================================================================
                   7. INCIDENT KNOWLEDGE BASE
================================================================================

class IncidentKnowledgeBase {
public:
    struct KnowledgeEntry {
        std::string incident_id;
        std::string title;
        std::string root_cause;
        std::vector<std::string> symptoms;
        std::vector<std::string> resolution_steps;
        std::vector<std::string> prevention_measures;
        std::vector<std::string> related_incidents;
        std::vector<std::string> tags;
    };
    
    void add_entry(const KnowledgeEntry& entry) {
        kb_[entry.incident_id] = entry;
        
        // Index by symptoms for quick lookup
        for (const auto& symptom : entry.symptoms) {
            symptom_index_[symptom].push_back(entry.incident_id);
        }
        
        // Index by tags
        for (const auto& tag : entry.tags) {
            tag_index_[tag].push_back(entry.incident_id);
        }
        
        logger_.info("Knowledge base entry added", {
            {"incident_id", entry.incident_id},
            {"title", entry.title}
        });
    }
    
    std::vector<KnowledgeEntry> search_by_symptom(
        const std::string& symptom
    ) {
        std::vector<KnowledgeEntry> results;
        
        auto it = symptom_index_.find(symptom);
        if (it != symptom_index_.end()) {
            for (const auto& incident_id : it->second) {
                results.push_back(kb_[incident_id]);
            }
        }
        
        return results;
    }
    
    std::vector<std::string> suggest_resolution_steps(
        const std::vector<std::string>& current_symptoms
    ) {
        // Find matching incidents
        std::unordered_map<std::string, int> incident_scores;
        
        for (const auto& symptom : current_symptoms) {
            auto matching = search_by_symptom(symptom);
            for (const auto& entry : matching) {
                incident_scores[entry.incident_id]++;
            }
        }
        
        // Get incident with highest score
        std::string best_match;
        int best_score = 0;
        
        for (const auto& [incident_id, score] : incident_scores) {
            if (score > best_score) {
                best_score = score;
                best_match = incident_id;
            }
        }
        
        if (!best_match.empty()) {
            return kb_[best_match].resolution_steps;
        }
        
        return {};
    }
    
private:
    std::unordered_map<std::string, KnowledgeEntry> kb_;
    std::unordered_map<std::string, std::vector<std::string>> symptom_index_;
    std::unordered_map<std::string, std::vector<std::string>> tag_index_;
};

================================================================================
                              END OF DOCUMENT
================================================================================
