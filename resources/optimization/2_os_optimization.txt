================================================================================
HFT OPERATING SYSTEM OPTIMIZATION TECHNIQUES
================================================================================

TABLE OF CONTENTS
-----------------
1. Theory and Fundamental Concepts
2. Kernel Tuning
3. CPU Isolation and Affinity
4. Real-Time Configuration
5. Scheduler Optimization
6. Interrupt Handling
7. Memory Management
8. File System Optimization
9. System Call Reduction
10. Benchmarking and Measurement
11. Expected Improvements

================================================================================
1. THEORY AND FUNDAMENTAL CONCEPTS
================================================================================

Operating System Impact on HFT:
--------------------------------
The OS introduces several sources of latency:
- Context switches: 1-10 μs
- System calls: 50-500 ns
- Interrupt handling: 5-50 μs
- Page faults: 100-1000 μs
- Kernel scheduling: 1-100 μs
- TLB misses: 10-100 ns

HFT OS Optimization Goals:
---------------------------
1. Eliminate kernel preemption of critical threads
2. Minimize context switches
3. Reduce interrupt interference
4. Ensure deterministic execution
5. Minimize jitter (latency variance)
6. Maximize CPU cache efficiency
7. Prevent memory swapping

Recommended Linux Distribution:
--------------------------------
- Ubuntu Server 22.04/24.04 LTS or RHEL 8/9
- Real-time kernel (PREEMPT_RT patch)
- Custom kernel compilation for minimal features

Target Latency Profile:
-----------------------
- P50: < 500 ns
- P99: < 2 μs
- P99.9: < 10 μs
- P99.99: < 50 μs
- Jitter: < 1 μs variance

================================================================================
2. KERNEL TUNING
================================================================================

2.1 Real-Time Kernel Installation
----------------------------------

Install RT-PREEMPT kernel:
```bash
# Check current kernel
uname -r

# Install RT kernel (Ubuntu)
sudo apt-get install linux-image-rt-amd64

# Or build from source with RT patches
wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.6.tar.xz
wget https://cdn.kernel.org/pub/linux/kernel/projects/rt/6.6/patch-6.6-rt15.patch.xz

tar xf linux-6.6.tar.xz
cd linux-6.6
xzcat ../patch-6.6-rt15.patch.xz | patch -p1

# Configure for real-time
make menuconfig
# Enable: General setup -> Preemption Model -> Fully Preemptible Kernel (RT)
# Enable: General setup -> Timers subsystem -> High Resolution Timer Support
# Enable: Processor type and features -> Timer frequency -> 1000 HZ

make -j$(nproc)
sudo make modules_install install

# Update GRUB and reboot
sudo update-grub
sudo reboot
```

2.2 Kernel Boot Parameters
---------------------------

Edit /etc/default/grub:
```bash
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash \
    isolcpus=2-7 \                    # Isolate CPUs 2-7 for HFT
    nohz_full=2-7 \                   # Disable timer ticks on isolated CPUs
    rcu_nocbs=2-7 \                   # Move RCU callbacks off isolated CPUs
    rcu_nocb_poll \                   # RCU callback offload polling
    intel_idle.max_cstate=0 \         # Disable deep C-states (Intel)
    processor.max_cstate=1 \          # Keep CPU in C1 state maximum
    intel_pstate=disable \            # Disable Intel P-state driver
    nosoftlockup \                    # Disable soft lockup detector
    tsc=reliable \                    # Trust TSC for timing
    clocksource=tsc \                 # Use TSC as clock source
    nmi_watchdog=0 \                  # Disable NMI watchdog
    audit=0 \                         # Disable auditing
    idle=poll \                       # CPU polling instead of halt
    mce=ignore_ce \                   # Ignore correctable memory errors
    hugepagesz=2M hugepages=1024 \    # Pre-allocate huge pages
    transparent_hugepage=never \      # Disable THP
    skew_tick=1 \                     # Skew timer ticks
    intel_iommu=off \                 # Disable IOMMU if not needed
    iommu=off"

# Apply changes
sudo update-grub
sudo reboot
```

2.3 Kernel Runtime Parameters
------------------------------

Create /etc/sysctl.d/99-hft-tuning.conf:
```bash
# CPU Scheduling
kernel.sched_rt_runtime_us = -1              # Unlimited RT scheduling
kernel.sched_rt_period_us = 1000000          # RT period
kernel.sched_latency_ns = 1000000            # Scheduler latency
kernel.sched_min_granularity_ns = 100000     # Minimum granularity
kernel.sched_wakeup_granularity_ns = 500000  # Wakeup granularity
kernel.sched_migration_cost_ns = 5000000     # Migration cost
kernel.sched_nr_migrate = 0                  # Disable migration

# Real-Time Throttling
kernel.sched_rt_runtime_us = -1              # Disable RT throttling

# Timer Settings
kernel.timer_migration = 0                   # Disable timer migration

# Performance
kernel.perf_cpu_time_max_percent = 0         # Disable perf CPU limit
kernel.perf_event_max_sample_rate = 1        # Minimize perf overhead

# Huge Pages
vm.nr_hugepages = 1024                       # Number of 2MB huge pages
vm.hugetlb_shm_group = 1000                  # HFT group ID

# Memory Management
vm.swappiness = 0                            # Disable swapping
vm.zone_reclaim_mode = 0                     # Disable zone reclaim
vm.dirty_ratio = 80                          # Dirty page ratio
vm.dirty_background_ratio = 5                # Background dirty ratio
vm.dirty_expire_centisecs = 12000            # Expire time
vm.overcommit_memory = 1                     # Allow overcommit

# Network (covered in network optimization)
net.core.busy_poll = 50                      # Busy polling
net.core.busy_read = 50                      # Busy read polling

# File System
fs.file-max = 2097152                        # Max open files
fs.nr_open = 2097152                         # Per-process max

# Apply settings
sudo sysctl -p /etc/sysctl.d/99-hft-tuning.conf
```

2.4 IRQ Affinity Configuration
-------------------------------

```bash
#!/bin/bash
# Script: configure_irq_affinity.sh

# Move all IRQs away from isolated CPUs (2-7) to housekeeping CPUs (0-1)
HOUSEKEEPING_CPUS="0,1"
ISOLATED_CPUS="2-7"

# Get all IRQ numbers
for irq in $(ls /proc/irq/ | grep -E '^[0-9]+$'); do
    # Skip default IRQs
    if [ "$irq" -eq 0 ] || [ "$irq" -eq 2 ]; then
        continue
    fi

    # Set IRQ affinity to housekeeping CPUs
    echo "$HOUSEKEEPING_CPUS" > /proc/irq/$irq/smp_affinity_list 2>/dev/null

    # Disable irqbalance for this IRQ
    echo "0" > /proc/irq/$irq/smp_affinity 2>/dev/null
done

# Disable irqbalance service
systemctl stop irqbalance
systemctl disable irqbalance

echo "IRQ affinity configured: IRQs on CPUs $HOUSEKEEPING_CPUS"
echo "Isolated CPUs: $ISOLATED_CPUS"
```

================================================================================
3. CPU ISOLATION AND AFFINITY
================================================================================

3.1 CPU Isolation Strategy
---------------------------

Typical HFT CPU allocation (16-core system):
```
CPU 0-1:   Housekeeping (OS, system processes, IRQs)
CPU 2-3:   Market data processing threads
CPU 4-5:   Order processing threads
CPU 6-7:   Risk management threads
CPU 8-15:  Additional trading strategies or backup
```

3.2 Thread Affinity Implementation
-----------------------------------

```cpp
#include <pthread.h>
#include <sched.h>

class CPUAffinity {
public:
    // Pin thread to specific CPU
    static bool pinThreadToCPU(int cpuId) {
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        CPU_SET(cpuId, &cpuset);

        pthread_t thread = pthread_self();
        int result = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);

        if (result != 0) {
            fprintf(stderr, "Failed to set CPU affinity to CPU %d\n", cpuId);
            return false;
        }

        printf("Thread pinned to CPU %d\n", cpuId);
        return true;
    }

    // Verify thread is running on correct CPU
    static int getCurrentCPU() {
        return sched_getcpu();
    }

    // Set thread scheduling policy
    static bool setRealtimePriority(int priority = 99) {
        struct sched_param param;
        param.sched_priority = priority;

        pthread_t thread = pthread_self();
        int result = pthread_setschedparam(thread, SCHED_FIFO, &param);

        if (result != 0) {
            fprintf(stderr, "Failed to set realtime priority\n");
            return false;
        }

        printf("Thread set to SCHED_FIFO with priority %d\n", priority);
        return true;
    }
};

// HFT Thread Initialization
class TradingThread {
public:
    void initialize(int cpuId, int priority) {
        // Pin to CPU
        CPUAffinity::pinThreadToCPU(cpuId);

        // Set real-time priority
        CPUAffinity::setRealtimePriority(priority);

        // Verify
        int currentCPU = CPUAffinity::getCurrentCPU();
        printf("Trading thread initialized on CPU %d\n", currentCPU);
    }

    void run() {
        while (running) {
            processOrders();
        }
    }
};
```

3.3 Complete HFT Process Configuration
---------------------------------------

```cpp
#include <sys/mman.h>
#include <sys/resource.h>

class HFTProcessConfig {
public:
    static void configure(int cpuId) {
        // 1. Lock memory to prevent swapping
        lockMemory();

        // 2. Pin to CPU
        CPUAffinity::pinThreadToCPU(cpuId);

        // 3. Set real-time priority
        CPUAffinity::setRealtimePriority(99);

        // 4. Increase resource limits
        setResourceLimits();

        // 5. Pre-fault stack
        preFaultStack();

        // 6. Disable address space randomization
        disableASLR();

        printf("HFT process configured on CPU %d\n", cpuId);
    }

private:
    static void lockMemory() {
        // Lock all current and future pages
        if (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) {
            perror("mlockall failed");
            exit(1);
        }
        printf("Memory locked\n");
    }

    static void setResourceLimits() {
        struct rlimit rlim;

        // Set locked memory limit
        rlim.rlim_cur = RLIM_INFINITY;
        rlim.rlim_max = RLIM_INFINITY;
        setrlimit(RLIMIT_MEMLOCK, &rlim);

        // Set real-time priority limit
        rlim.rlim_cur = 99;
        rlim.rlim_max = 99;
        setrlimit(RLIMIT_RTPRIO, &rlim);

        // Set nice value limit
        rlim.rlim_cur = -20;
        rlim.rlim_max = -20;
        setrlimit(RLIMIT_NICE, &rlim);

        printf("Resource limits set\n");
    }

    static void preFaultStack() {
        // Touch stack pages to ensure they're resident
        constexpr size_t STACK_SIZE = 8 * 1024 * 1024;  // 8MB
        unsigned char dummy[STACK_SIZE];

        for (size_t i = 0; i < STACK_SIZE; i += 4096) {
            dummy[i] = 0;
        }

        printf("Stack pre-faulted\n");
    }

    static void disableASLR() {
        // Disable address space layout randomization
        // This must be done before process starts:
        // echo 0 > /proc/sys/kernel/randomize_va_space
        printf("ASLR should be disabled system-wide\n");
    }
};
```

================================================================================
4. REAL-TIME CONFIGURATION
================================================================================

4.1 Real-Time Scheduling Policies
----------------------------------

```cpp
#include <sched.h>
#include <stdio.h>

class RealtimeScheduler {
public:
    enum class Policy {
        FIFO,      // First-In-First-Out (deterministic)
        RR,        // Round-Robin (time-sliced)
        DEADLINE   // Earliest Deadline First
    };

    static bool setPolicy(Policy policy, int priority = 99) {
        struct sched_param param;
        param.sched_priority = priority;

        int schedPolicy;
        switch (policy) {
            case Policy::FIFO:
                schedPolicy = SCHED_FIFO;
                break;
            case Policy::RR:
                schedPolicy = SCHED_RR;
                break;
            case Policy::DEADLINE:
                schedPolicy = SCHED_DEADLINE;
                break;
            default:
                return false;
        }

        if (sched_setscheduler(0, schedPolicy, &param) != 0) {
            perror("sched_setscheduler failed");
            return false;
        }

        printf("Set scheduling policy: %d, priority: %d\n", schedPolicy, priority);
        return true;
    }

    // Get current scheduling info
    static void printSchedulingInfo() {
        int policy = sched_getscheduler(0);
        struct sched_param param;
        sched_getparam(0, &param);

        const char* policyName;
        switch (policy) {
            case SCHED_FIFO:     policyName = "SCHED_FIFO"; break;
            case SCHED_RR:       policyName = "SCHED_RR"; break;
            case SCHED_DEADLINE: policyName = "SCHED_DEADLINE"; break;
            case SCHED_OTHER:    policyName = "SCHED_OTHER"; break;
            default:             policyName = "UNKNOWN"; break;
        }

        printf("Scheduling Policy: %s, Priority: %d\n",
               policyName, param.sched_priority);
    }
};

// HFT Trading Engine with Real-Time Configuration
class TradingEngine {
public:
    void initialize() {
        // Use SCHED_FIFO for deterministic execution
        RealtimeScheduler::setPolicy(RealtimeScheduler::Policy::FIFO, 99);

        // Lock memory
        mlockall(MCL_CURRENT | MCL_FUTURE);

        // Pin to isolated CPU
        CPUAffinity::pinThreadToCPU(4);

        printf("Trading engine initialized with real-time configuration\n");
    }
};
```

4.2 Real-Time Priority Assignment
----------------------------------

```bash
# Priority hierarchy (higher = more important)
# Valid range: 1-99 (99 is highest)

Critical threads:
- Market data parser:        Priority 99
- Order matching engine:     Priority 98
- Order sender:              Priority 97
- Risk checker:              Priority 96

Non-critical threads:
- Logging:                   Priority 50
- Monitoring:                Priority 40
- Backup/archiving:          Priority 30
```

4.3 Deadline Scheduling (Linux 3.14+)
--------------------------------------

```cpp
#include <linux/sched.h>
#include <sys/syscall.h>

struct sched_attr {
    uint32_t size;
    uint32_t sched_policy;
    uint64_t sched_flags;
    int32_t sched_nice;
    uint32_t sched_priority;
    uint64_t sched_runtime;
    uint64_t sched_deadline;
    uint64_t sched_period;
};

class DeadlineScheduler {
public:
    static bool setDeadlineScheduling(uint64_t runtime_ns,
                                      uint64_t deadline_ns,
                                      uint64_t period_ns) {
        struct sched_attr attr = {};
        attr.size = sizeof(struct sched_attr);
        attr.sched_policy = SCHED_DEADLINE;
        attr.sched_flags = 0;
        attr.sched_runtime = runtime_ns;
        attr.sched_deadline = deadline_ns;
        attr.sched_period = period_ns;

        int ret = syscall(__NR_sched_setattr, 0, &attr, 0);
        if (ret != 0) {
            perror("sched_setattr failed");
            return false;
        }

        printf("Deadline scheduling set: runtime=%lu ns, deadline=%lu ns, period=%lu ns\n",
               runtime_ns, deadline_ns, period_ns);
        return true;
    }
};

// Example: Order processor must complete within 100μs every 1ms
void initializeOrderProcessor() {
    DeadlineScheduler::setDeadlineScheduling(
        100000,    // 100 μs runtime
        1000000,   // 1 ms deadline
        1000000    // 1 ms period
    );
}
```

================================================================================
5. SCHEDULER OPTIMIZATION
================================================================================

5.1 Disabling Automatic Balancing
----------------------------------

```bash
#!/bin/bash
# Disable scheduler features for isolated CPUs

ISOLATED_CPUS="2-7"

# Disable scheduler domains
for cpu in {2..7}; do
    # Disable automatic load balancing
    echo 0 > /sys/devices/system/cpu/cpu$cpu/cpufreq/scaling_governor 2>/dev/null || true

    # Set performance governor
    echo performance > /sys/devices/system/cpu/cpu$cpu/cpufreq/scaling_governor 2>/dev/null || true
done

# Disable CPU frequency scaling globally
echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor

# Disable ondemand governor
systemctl stop ondemand
systemctl disable ondemand

# Set minimum and maximum frequencies to the same value
for cpu in /sys/devices/system/cpu/cpu*/cpufreq/; do
    max_freq=$(cat ${cpu}cpuinfo_max_freq)
    echo $max_freq > ${cpu}scaling_min_freq
    echo $max_freq > ${cpu}scaling_max_freq
done

echo "Scheduler optimization complete"
```

5.2 CPU Frequency Scaling Control
----------------------------------

```cpp
#include <fstream>
#include <string>

class CPUFrequencyControl {
public:
    static bool setMaxPerformance(int cpuId) {
        std::string basePath = "/sys/devices/system/cpu/cpu" +
                               std::to_string(cpuId) + "/cpufreq/";

        // Set governor to performance
        if (!writeFile(basePath + "scaling_governor", "performance")) {
            return false;
        }

        // Read max frequency
        std::string maxFreq = readFile(basePath + "cpuinfo_max_freq");
        if (maxFreq.empty()) {
            return false;
        }

        // Set min frequency to max frequency
        if (!writeFile(basePath + "scaling_min_freq", maxFreq)) {
            return false;
        }

        printf("CPU %d set to maximum performance: %s kHz\n",
               cpuId, maxFreq.c_str());
        return true;
    }

private:
    static bool writeFile(const std::string& path, const std::string& value) {
        std::ofstream file(path);
        if (!file.is_open()) {
            return false;
        }
        file << value;
        return true;
    }

    static std::string readFile(const std::string& path) {
        std::ifstream file(path);
        if (!file.is_open()) {
            return "";
        }
        std::string content;
        std::getline(file, content);
        return content;
    }
};
```

================================================================================
6. INTERRUPT HANDLING
================================================================================

6.1 Interrupt Affinity Configuration
-------------------------------------

```bash
#!/bin/bash
# Configure interrupt affinity for HFT

HOUSEKEEPING_MASK="03"  # CPUs 0-1 (binary: 11)

# Move all interrupts to housekeeping CPUs
for irq_dir in /proc/irq/*; do
    if [ -d "$irq_dir" ]; then
        irq=$(basename "$irq_dir")

        # Skip special IRQs
        if [ "$irq" = "default_smp_affinity" ]; then
            continue
        fi

        # Set affinity
        echo "$HOUSEKEEPING_MASK" > "$irq_dir/smp_affinity" 2>/dev/null || true
    fi
done

# Set default affinity for new IRQs
echo "$HOUSEKEEPING_MASK" > /proc/irq/default_smp_affinity

echo "All interrupts moved to housekeeping CPUs (0-1)"
```

6.2 Network Interrupt Coalescing
---------------------------------

```bash
#!/bin/bash
# Optimize network interrupt coalescing

NIC="eth0"

# Disable interrupt coalescing for ultra-low latency
ethtool -C $NIC rx-usecs 0
ethtool -C $NIC rx-frames 1
ethtool -C $NIC tx-usecs 0
ethtool -C $NIC tx-frames 1

# Or enable adaptive coalescing
ethtool -C $NIC adaptive-rx on
ethtool -C $NIC adaptive-tx on

# View current settings
ethtool -c $NIC
```

6.3 Disabling Unnecessary Interrupts
-------------------------------------

```bash
#!/bin/bash
# Disable unnecessary interrupt sources

# Disable power management interrupts
echo 0 > /proc/sys/kernel/nmi_watchdog

# Disable MCE (Machine Check Exception) interrupts
echo 0 > /sys/devices/system/machinecheck/machinecheck0/check_interval

# Disable kernel sampler
echo 0 > /proc/sys/kernel/perf_event_paranoid

# Disable printk
echo 0 > /proc/sys/kernel/printk

# Check interrupt counts
watch -n 1 'cat /proc/interrupts | grep "CPU0\|CPU1\|CPU2\|CPU3"'
```

================================================================================
7. MEMORY MANAGEMENT
================================================================================

7.1 Huge Pages Configuration
-----------------------------

```bash
#!/bin/bash
# Configure huge pages for HFT

# Calculate required huge pages (2MB each)
# For 4GB application: 4096 / 2 = 2048 pages
HUGEPAGES=2048

# Set huge pages at boot time (add to /etc/sysctl.conf)
echo "vm.nr_hugepages = $HUGEPAGES" >> /etc/sysctl.conf

# Or set at runtime
echo $HUGEPAGES > /proc/sys/vm/nr_hugepages

# Verify
cat /proc/meminfo | grep Huge

# Create mount point
mkdir -p /mnt/huge
mount -t hugetlbfs nodev /mnt/huge

# Add to /etc/fstab for persistence
echo "nodev /mnt/huge hugetlbfs defaults 0 0" >> /etc/fstab
```

7.2 Using Huge Pages in C++
----------------------------

```cpp
#include <sys/mman.h>
#include <cstdint>

template<typename T>
class HugePageAllocator {
public:
    using value_type = T;

    static constexpr size_t HUGE_PAGE_SIZE = 2 * 1024 * 1024;  // 2MB

    T* allocate(size_t n) {
        size_t size = n * sizeof(T);

        // Round up to huge page boundary
        size_t allocSize = ((size + HUGE_PAGE_SIZE - 1) / HUGE_PAGE_SIZE) * HUGE_PAGE_SIZE;

        void* ptr = mmap(nullptr, allocSize,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,
                        -1, 0);

        if (ptr == MAP_FAILED) {
            throw std::bad_alloc();
        }

        printf("Allocated %zu bytes on huge pages at %p\n", allocSize, ptr);
        return static_cast<T*>(ptr);
    }

    void deallocate(T* ptr, size_t n) {
        size_t size = n * sizeof(T);
        size_t allocSize = ((size + HUGE_PAGE_SIZE - 1) / HUGE_PAGE_SIZE) * HUGE_PAGE_SIZE;
        munmap(ptr, allocSize);
    }
};

// Usage example
class OrderBook {
    using HugePageVector = std::vector<Order, HugePageAllocator<Order>>;
    HugePageVector orders;

public:
    OrderBook() {
        orders.reserve(1000000);  // Pre-allocate on huge pages
    }
};
```

7.3 Memory Pre-Allocation and Warming
--------------------------------------

```cpp
class MemoryWarmer {
public:
    // Pre-fault and warm up memory
    static void warmMemory(void* ptr, size_t size) {
        volatile unsigned char* mem = static_cast<unsigned char*>(ptr);

        // Touch every page (4KB)
        for (size_t i = 0; i < size; i += 4096) {
            mem[i] = 0;
        }

        // Write to ensure pages are dirtied
        for (size_t i = 0; i < size; i += 4096) {
            mem[i] = 1;
        }

        printf("Warmed %zu bytes of memory\n", size);
    }

    // Pre-allocate critical data structures
    static void preallocateOrderBook(OrderBook& book, size_t maxOrders) {
        // Reserve memory
        book.reserve(maxOrders);

        // Pre-fault
        for (size_t i = 0; i < maxOrders; ++i) {
            book.addDummyOrder();
        }

        book.clear();

        printf("Pre-allocated order book for %zu orders\n", maxOrders);
    }
};
```

================================================================================
8. FILE SYSTEM OPTIMIZATION
================================================================================

8.1 Tmpfs for Low-Latency File I/O
-----------------------------------

```bash
#!/bin/bash
# Create RAM-based file system for logs and temporary files

# Create tmpfs mount point
mkdir -p /mnt/hft_tmpfs

# Mount tmpfs (8GB)
mount -t tmpfs -o size=8G,mode=0755 tmpfs /mnt/hft_tmpfs

# Add to /etc/fstab
echo "tmpfs /mnt/hft_tmpfs tmpfs size=8G,mode=0755 0 0" >> /etc/fstab

# Verify
df -h /mnt/hft_tmpfs
```

8.2 Direct I/O
--------------

```cpp
#include <fcntl.h>
#include <unistd.h>

class DirectIO {
public:
    static int openDirect(const char* path) {
        int fd = open(path, O_RDWR | O_DIRECT | O_SYNC);
        if (fd < 0) {
            perror("open O_DIRECT failed");
            return -1;
        }
        return fd;
    }

    // Aligned buffer for direct I/O
    static void* allocateAlignedBuffer(size_t size) {
        void* buffer;
        int ret = posix_memalign(&buffer, 512, size);
        if (ret != 0) {
            return nullptr;
        }
        return buffer;
    }
};
```

================================================================================
9. SYSTEM CALL REDUCTION
================================================================================

9.1 Minimizing System Calls
----------------------------

BEFORE (Many system calls):
```cpp
void logMessage(const char* msg) {
    // Every log message triggers write() system call
    printf("%s\n", msg);
}
```

AFTER (Batched system calls):
```cpp
class BatchedLogger {
    static constexpr size_t BUFFER_SIZE = 1024 * 1024;  // 1MB
    char buffer[BUFFER_SIZE];
    size_t offset = 0;

public:
    void log(const char* msg) {
        size_t len = strlen(msg);

        if (offset + len + 1 > BUFFER_SIZE) {
            flush();
        }

        memcpy(buffer + offset, msg, len);
        buffer[offset + len] = '\n';
        offset += len + 1;
    }

    void flush() {
        if (offset > 0) {
            write(STDOUT_FILENO, buffer, offset);
            offset = 0;
        }
    }
};
```

9.2 Using vDSO
--------------

```cpp
// vDSO (virtual dynamic shared object) provides syscalls without kernel context switch

// Get time without system call
#include <time.h>

inline uint64_t getTimeNs() {
    struct timespec ts;
    // clock_gettime uses vDSO - no context switch
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000000000ULL + ts.tv_nsec;
}

// Compare with system call version
inline uint64_t getTimeNsSyscall() {
    struct timespec ts;
    syscall(SYS_clock_gettime, CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000000000ULL + ts.tv_nsec;
}

// vDSO version: ~20 ns
// Syscall version: ~100 ns
```

================================================================================
10. BENCHMARKING AND MEASUREMENT
================================================================================

10.1 Latency Measurement Tools
-------------------------------

```bash
# 1. perf for system-wide analysis
perf stat -e context-switches,cpu-migrations,page-faults ./trading_engine

# 2. cyclictest for real-time latency
cyclictest -p 99 -t 1 -n -h 1000 -q -D 60

# 3. hwlat_detector for hardware latency
echo hwlat > /sys/kernel/debug/tracing/current_tracer
echo 1 > /sys/kernel/debug/tracing/tracing_on
sleep 60
cat /sys/kernel/debug/tracing/trace

# 4. ftrace for kernel latency
echo function_graph > /sys/kernel/debug/tracing/current_tracer
echo 1 > /sys/kernel/debug/tracing/tracing_on
# Run workload
echo 0 > /sys/kernel/debug/tracing/tracing_on
cat /sys/kernel/debug/tracing/trace
```

10.2 Context Switch Monitoring
-------------------------------

```cpp
#include <fstream>
#include <string>

class ContextSwitchMonitor {
    uint64_t voluntaryStart, involuntaryStart;

public:
    void start() {
        readContextSwitches(voluntaryStart, involuntaryStart);
    }

    void stop() {
        uint64_t voluntaryEnd, involuntaryEnd;
        readContextSwitches(voluntaryEnd, involuntaryEnd);

        uint64_t voluntary = voluntaryEnd - voluntaryStart;
        uint64_t involuntary = involuntaryEnd - involuntaryStart;

        printf("Context switches - Voluntary: %lu, Involuntary: %lu\n",
               voluntary, involuntary);

        if (involuntary > 0) {
            printf("WARNING: Involuntary context switches detected!\n");
        }
    }

private:
    void readContextSwitches(uint64_t& voluntary, uint64_t& involuntary) {
        std::ifstream status("/proc/self/status");
        std::string line;

        while (std::getline(status, line)) {
            if (line.find("voluntary_ctxt_switches:") == 0) {
                sscanf(line.c_str(), "voluntary_ctxt_switches:\t%lu", &voluntary);
            } else if (line.find("nonvoluntary_ctxt_switches:") == 0) {
                sscanf(line.c_str(), "nonvoluntary_ctxt_switches:\t%lu", &involuntary);
            }
        }
    }
};

// Usage
ContextSwitchMonitor monitor;
monitor.start();
// Run trading workload
runTradingEngine();
monitor.stop();
```

================================================================================
11. EXPECTED IMPROVEMENTS
================================================================================

Optimization Technique                    | Latency Reduction | Jitter Reduction
------------------------------------------|-------------------|------------------
Real-time kernel (PREEMPT_RT)             | 40-60%           | 80-90%
CPU isolation (isolcpus)                  | 50-70%           | 85-95%
CPU pinning + SCHED_FIFO                  | 30-50%           | 70-85%
Huge pages                                | 10-20%           | 30-50%
IRQ affinity optimization                 | 20-40%           | 60-80%
Disabled C-states/P-states                | 15-30%           | 50-70%
Memory locking (mlockall)                 | 5-15%            | 40-60%
Disabled timer ticks (nohz_full)          | 20-35%           | 55-75%

Combined Effect: 90-98% latency reduction, 95-99% jitter reduction

Real-World HFT Example:
-----------------------
Order-to-Wire Latency:

BEFORE OS optimization (stock Linux):
- Mean latency: 15 μs
- P99 latency: 45 μs
- P99.9 latency: 120 μs
- Jitter (std dev): 25 μs
- Context switches: 50-100/sec

AFTER OS optimization:
- Mean latency: 2 μs (7.5x faster)
- P99 latency: 5 μs (9x faster)
- P99.9 latency: 12 μs (10x faster)
- Jitter (std dev): 0.5 μs (50x better)
- Context switches: 0-2/sec

Competitive Advantage:
- 13 μs faster mean latency
- Orders arrive at exchange 13 μs earlier
- Can capture price improvements competitors miss
- Consistent execution (low jitter) = predictable fills

================================================================================
COMPLETE SYSTEM CONFIGURATION SCRIPT
================================================================================

```bash
#!/bin/bash
# complete_hft_os_setup.sh

set -e

echo "HFT Operating System Optimization"
echo "=================================="

# 1. Install real-time kernel
echo "Installing RT kernel..."
apt-get update
apt-get install -y linux-image-rt-amd64

# 2. Configure GRUB
echo "Configuring GRUB..."
cat >> /etc/default/grub <<EOF
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash isolcpus=2-7 nohz_full=2-7 rcu_nocbs=2-7 intel_idle.max_cstate=0 processor.max_cstate=1 intel_pstate=disable nosoftlockup tsc=reliable clocksource=tsc nmi_watchdog=0 audit=0 idle=poll mce=ignore_ce hugepagesz=2M hugepages=1024 transparent_hugepage=never"
EOF
update-grub

# 3. Configure sysctl
echo "Configuring sysctl..."
cat > /etc/sysctl.d/99-hft.conf <<EOF
kernel.sched_rt_runtime_us = -1
vm.swappiness = 0
vm.nr_hugepages = 1024
net.core.busy_poll = 50
EOF
sysctl -p /etc/sysctl.d/99-hft.conf

# 4. Configure IRQ affinity
echo "Configuring IRQ affinity..."
systemctl stop irqbalance
systemctl disable irqbalance

# 5. Set CPU governor
echo "Setting CPU governor to performance..."
for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
    echo performance > $cpu
done

# 6. Create tmpfs
echo "Creating tmpfs..."
mkdir -p /mnt/hft_tmpfs
echo "tmpfs /mnt/hft_tmpfs tmpfs size=8G,mode=0755 0 0" >> /etc/fstab
mount /mnt/hft_tmpfs

echo ""
echo "Configuration complete!"
echo "REBOOT REQUIRED to apply all changes"
echo ""
echo "After reboot, verify with:"
echo "  uname -r                  # Check RT kernel"
echo "  cat /proc/cmdline         # Check boot parameters"
echo "  cat /proc/meminfo | grep Huge  # Check huge pages"
echo "  taskset -pc \$\$            # Check CPU affinity"
```

================================================================================
END OF OS OPTIMIZATION GUIDE
================================================================================
