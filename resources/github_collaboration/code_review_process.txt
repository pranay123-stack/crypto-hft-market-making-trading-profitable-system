================================================================================
CODE REVIEW PROCESS - HFT DEVELOPMENT TEAMS
================================================================================
Pull Request Reviews, Standards, and Best Practices for High-Frequency Trading
Teams of 4-10 Developers
Last Updated: 2025-11-25
================================================================================

TABLE OF CONTENTS
================================================================================
1. Code Review Philosophy for HFT
2. Pull Request Creation Guidelines
3. Review Process Workflow
4. Reviewer Responsibilities
5. Author Responsibilities
6. Review Checklist Templates
7. Code Quality Standards
8. Performance Review Criteria
9. Security Review Guidelines
10. Common Review Patterns
11. Feedback Guidelines
12. Tools and Automation

================================================================================
SECTION 1: CODE REVIEW PHILOSOPHY FOR HFT
================================================================================

Why Code Reviews Matter for HFT Systems
----------------------------------------

Critical Importance:
1. Trading systems handle real money - bugs are expensive
2. Latency-sensitive code requires expert review
3. Regulatory compliance requires audit trails
4. Complex algorithms need multiple perspectives
5. Knowledge sharing across team members

Goals of Code Review:
--------------------
PRIMARY:
- Catch bugs before production
- Ensure performance requirements met
- Verify security and data integrity
- Maintain code quality standards

SECONDARY:
- Knowledge transfer
- Consistency across codebase
- Mentoring junior developers
- Architectural alignment

Review Principles:
-----------------
1. Everyone's code gets reviewed (no exceptions)
2. Review code, not people
3. Be specific, constructive, and kind
4. Ask questions rather than making demands
5. Praise good solutions
6. Respond promptly (within 4 hours during business hours)
7. Assume good intent

Review Requirements by Component:
---------------------------------

CRITICAL PATH CODE (Order execution, matching, market data):
- Minimum 2 reviewers
- At least 1 senior engineer
- Performance testing required
- Security audit for sensitive operations

BUSINESS LOGIC (Algorithms, risk management):
- Minimum 2 reviewers
- Domain expert review
- Unit test coverage > 90%

INFRASTRUCTURE (Build, deployment, monitoring):
- Minimum 1 reviewer
- DevOps approval required
- Tested in staging environment

DOCUMENTATION/TESTS:
- Minimum 1 reviewer
- Quick review turnaround expected

================================================================================
SECTION 2: PULL REQUEST CREATION GUIDELINES
================================================================================

Before Creating a Pull Request
-------------------------------

Pre-PR Checklist:
[ ] All tests passing locally
[ ] Code compiles without warnings
[ ] Static analysis passes (cppcheck, clang-tidy)
[ ] Performance benchmarks run (if applicable)
[ ] Documentation updated
[ ] Commit messages follow conventions
[ ] Branch rebased on latest develop
[ ] Self-review completed

Self-Review Process:
-------------------
1. Review your own diff on GitHub
2. Add inline comments explaining complex logic
3. Check for debug code, TODOs, commented code
4. Verify no secrets or credentials
5. Ensure consistent formatting

Pull Request Size Guidelines:
-----------------------------

IDEAL PR SIZE:
- 200-400 lines of code changes
- 1-3 files modified
- Single, focused change
- Review time: 15-30 minutes

TOO LARGE (split into multiple PRs):
- > 800 lines of code
- > 10 files changed
- Multiple unrelated changes
- Review time: > 1 hour

EXCEPTIONS (large PRs acceptable):
- Auto-generated code
- Major refactoring (with plan)
- Third-party code integration
- Data migration scripts

Pull Request Template
----------------------

Title Format:
[TYPE] Brief description (JIRA-123)

Examples:
[FEAT] Add smart order routing algorithm (JIRA-1234)
[FIX] Prevent market data null pointer crash (JIRA-5678)
[PERF] Optimize order matching by 25% (JIRA-9012)
[REFACTOR] Simplify risk calculation logic (JIRA-3456)

PR Description Template:
-----------------------
## Summary
Brief description of the change and motivation.

## Type of Change
- [ ] New feature
- [ ] Bug fix
- [ ] Performance improvement
- [ ] Refactoring
- [ ] Documentation update
- [ ] Configuration change

## Changes Made
- Detailed bullet point list of changes
- Each logical change on separate line
- Include file names for context

## Testing
- [ ] Unit tests added/updated
- [ ] Integration tests added/updated
- [ ] Manual testing completed
- [ ] Performance testing completed

### Test Results
```
Performance benchmarks:
- Before: 10μs average latency
- After: 7.5μs average latency
- Improvement: 25%

Test coverage:
- Lines: 95%
- Functions: 100%
- Branches: 88%
```

## Performance Impact
- Latency: +/- Xμs
- Memory: +/- XMB
- CPU: +/- X%
- Throughput: +/- X orders/sec

## Breaking Changes
- None
OR
- List breaking changes
- Migration steps
- Backward compatibility plan

## Deployment Notes
- [ ] No special deployment steps
OR
- Database migration required
- Configuration changes needed
- Service restart required
- Deployment order matters

## Related Issues
Fixes #1234
Related to #5678
Depends on #9012

## Screenshots (if applicable)
[Attach before/after screenshots for UI changes]

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Comments added for complex logic
- [ ] Documentation updated
- [ ] Tests added and passing
- [ ] No compiler warnings
- [ ] Static analysis passes
- [ ] Performance tested

Example Complete PR:
-------------------
Title: [PERF] Optimize order book updates using lock-free queue (JIRA-1234)

## Summary
Replaced std::queue with lock-free queue for order book updates to reduce
contention and improve latency. This change targets the critical path of
order processing.

## Type of Change
- [x] Performance improvement

## Changes Made
- Replaced std::queue with boost::lockfree::queue in OrderBook class
- Added CPU affinity for order processing threads
- Reduced memory allocations in hot path
- Updated unit tests for thread safety

Files changed:
- src/order_book.cpp (150 lines)
- include/order_book.h (20 lines)
- tests/test_order_book.cpp (80 lines)

## Testing
- [x] Unit tests added/updated
- [x] Integration tests added/updated
- [x] Manual testing completed
- [x] Performance testing completed

### Test Results
```
Performance benchmarks (1M orders):
- Before: 10.2μs avg, 18.5μs p99
- After: 7.5μs avg, 12.1μs p99
- Improvement: 26% avg, 35% p99

Memory profile:
- Before: 2.5GB
- After: 2.1GB (reduced allocations)

Test coverage:
- Lines: 96% (+3%)
- Functions: 100%
- Branches: 89% (+2%)
```

## Performance Impact
- Latency: -2.7μs (26% improvement)
- Memory: -400MB (reduced allocations)
- CPU: Similar (slightly higher due to spin locks)
- Throughput: +100k orders/sec (from 400k to 500k)

## Breaking Changes
None. API remains unchanged.

## Deployment Notes
- [x] No special deployment steps
- No configuration changes
- Standard rolling deployment

## Related Issues
Fixes #1234
Related to #5555 (overall latency reduction initiative)

## Checklist
- [x] Code follows style guidelines
- [x] Self-review completed
- [x] Comments added for lock-free queue usage
- [x] Documentation updated
- [x] Tests added and passing
- [x] No compiler warnings
- [x] Static analysis passes
- [x] Performance benchmarks included

/cc @senior-engineer @performance-team

================================================================================
SECTION 3: REVIEW PROCESS WORKFLOW
================================================================================

Standard Review Workflow
------------------------

STEP 1: PR Created
------------------
Time: Developer creates PR
Actions:
- CI/CD automatically triggered
- Automated checks run (build, tests, linting)
- Reviewers automatically assigned based on CODEOWNERS
- Team notified in Slack

STEP 2: Automated Checks
------------------------
Time: 2-5 minutes
Checks:
- Build successful
- Unit tests pass (100% required)
- Integration tests pass
- Code coverage meets threshold (>80%)
- Static analysis passes
- No security vulnerabilities
- Performance benchmarks run

If any check fails:
- PR marked as not ready
- Author notified
- Author fixes and pushes
- Checks re-run

STEP 3: Initial Review
----------------------
Time: Within 4 hours
Reviewer actions:
1. Read PR description
2. Understand context and motivation
3. Review code changes
4. Check tests
5. Verify performance impact
6. Leave comments or approve

Review states:
- COMMENT: Feedback without approval/rejection
- APPROVE: Code ready to merge
- REQUEST CHANGES: Must address before merge

STEP 4: Author Responds
-----------------------
Time: Within 4 hours
Author actions:
1. Read all comments
2. Respond to questions
3. Make requested changes
4. Push updates
5. Re-request review

STEP 5: Follow-up Review
------------------------
Time: Within 2 hours
Reviewer actions:
1. Review new changes
2. Verify comments addressed
3. Approve or request more changes

STEP 6: Final Approval
---------------------
Time: When all reviewers approve
Requirements:
- Minimum reviews met (1-2 depending on component)
- All automated checks pass
- All conversations resolved
- Branch up to date with base

STEP 7: Merge
-------------
Time: Immediately after approval
Process:
1. Squash or merge commit (based on team preference)
2. Delete source branch
3. Deploy to staging (automatic)
4. Monitor for issues

Timeline SLAs:
-------------
FEATURE PRs:
- Initial review: 4 hours
- Follow-up review: 2 hours
- Total time to merge: < 24 hours

HOTFIX PRs:
- Initial review: 15 minutes
- Follow-up review: 15 minutes
- Total time to merge: < 1 hour

DOCUMENTATION PRs:
- Initial review: 2 hours
- Total time to merge: < 8 hours

Review Assignment Strategy:
---------------------------

Auto-assignment rules:
1. Code owner always assigned
2. Round-robin for additional reviewers
3. Senior engineer for critical path code
4. Domain expert for algorithmic changes

Manual assignment:
- Tag specific experts with /cc @username
- Request architecture review for large changes
- Request security review for sensitive code

GitHub CODEOWNERS example:
-------------------------
# Default reviewers
* @tech-lead

# Critical path code
/src/order_executor/ @senior-eng1 @senior-eng2
/src/matching_engine/ @senior-eng1 @senior-eng3

# Algorithms
/src/algorithms/ @quant-team @senior-eng1

# Risk management
/src/risk/ @risk-team @compliance-lead

# Infrastructure
/infrastructure/ @devops-team
/.github/ @devops-team

# Documentation
/docs/ @tech-writer

================================================================================
SECTION 4: REVIEWER RESPONSIBILITIES
================================================================================

What Reviewers Should Check
---------------------------

1. CORRECTNESS
--------------
- Logic errors
- Edge cases handled
- Null pointer checks
- Array bounds
- Integer overflow/underflow
- Race conditions
- Deadlocks

Questions to ask:
- Does this code do what it claims?
- Are error cases handled?
- What happens with invalid input?
- Are there thread safety issues?

2. PERFORMANCE
--------------
For HFT code, check:
- Algorithmic complexity (O(n) vs O(log n))
- Memory allocations in hot path
- Lock contention
- Cache efficiency
- Branch prediction
- System calls in critical path

Red flags:
- Dynamic allocation in order processing
- Mutex locks in latency-sensitive code
- Unnecessary copying of large objects
- Non-inlined functions in hot path

Example comment:
```cpp
// PERFORMANCE CONCERN:
std::vector<Order> orders = getOrders();  // Copies all orders
for (const auto& order : orders) {
    process(order);
}

// SUGGESTION:
const std::vector<Order>& orders = getOrders();  // No copy
for (const auto& order : orders) {
    process(order);
}
```

3. SECURITY
-----------
Check for:
- Input validation
- SQL injection risks
- Buffer overflows
- Authentication/authorization
- Secrets in code
- Logging sensitive data

Example comment:
```cpp
// SECURITY ISSUE:
std::string query = "SELECT * FROM orders WHERE user_id = " + user_id;

// FIX:
// Use parameterized query to prevent SQL injection
auto stmt = db.prepare("SELECT * FROM orders WHERE user_id = ?");
stmt.bind(user_id);
```

4. TESTING
----------
Verify:
- Unit tests for new code
- Integration tests for API changes
- Edge cases tested
- Performance tests for critical path
- Test names descriptive
- Tests actually test something

Example comment:
```
Missing test case:
What happens when order quantity is zero?
Please add test: test_zero_quantity_rejected()
```

5. MAINTAINABILITY
------------------
Check:
- Code readability
- Function length (< 50 lines ideal)
- Complexity (cyclomatic complexity < 10)
- Naming clarity
- Comments for complex logic
- No code duplication

Example comment:
```
This function is 200 lines and does too much.
Consider splitting into:
1. validateOrder()
2. calculateCommission()
3. executeOrder()
```

6. STYLE CONSISTENCY
--------------------
Verify:
- Follows team style guide
- Consistent naming conventions
- Consistent formatting
- No unnecessary changes (whitespace, formatting)

Note: Automated linters should catch most of this

7. DOCUMENTATION
----------------
Check:
- Public APIs documented
- Complex algorithms explained
- TODOs tracked in issue tracker
- README updated if needed
- Architecture docs updated

Example comment:
```
Please add docstring for this public function:

/**
 * Calculates VWAP for the given orders
 * @param orders Vector of orders to process
 * @param time_window Time window in seconds
 * @return VWAP price or -1 if insufficient data
 */
double calculateVWAP(const std::vector<Order>& orders, int time_window);
```

Review Depth by Component:
--------------------------

CRITICAL PATH (deep review):
- Line-by-line review
- Performance analysis
- Security audit
- Multiple reviewers
- Testing verification
Time: 30-60 minutes

BUSINESS LOGIC (thorough review):
- Logic verification
- Test coverage
- API contracts
Time: 20-40 minutes

INFRASTRUCTURE (focused review):
- Configuration correctness
- Deployment safety
- Rollback plan
Time: 15-30 minutes

TESTS/DOCS (quick review):
- Accuracy
- Completeness
- Clarity
Time: 10-20 minutes

Review Speed vs Quality:
-----------------------

Fast review (15 minutes):
- Small PR (< 200 lines)
- Low-risk changes
- Documentation/tests
- Single file

Thorough review (30-45 minutes):
- Medium PR (200-500 lines)
- New features
- Algorithm changes
- Multiple files

Deep review (1+ hours):
- Large PR (> 500 lines)
- Critical path changes
- Security-sensitive
- Architecture changes

Reviewer Comments Guidelines:
-----------------------------

Types of comments:

BLOCKER (must fix):
"BLOCKER: This will cause a crash when price is zero"

IMPORTANT (should fix):
"Consider using a lock-free queue here for better performance"

SUGGESTION (nice to have):
"Nit: Consider renaming 'tmp' to 'pending_orders' for clarity"

QUESTION (seeking clarification):
"Why did you choose this approach over using the existing utility?"

PRAISE (acknowledge good work):
"Nice optimization! This is much cleaner than the previous approach"

Format examples:
---------------

Good comment:
```
BLOCKER: Race condition in order processing

Line 45: order_map is accessed without lock
This can cause data corruption when multiple threads process orders

Suggestion:
std::lock_guard<std::mutex> lock(order_mutex);
order_map[order.id] = order;
```

Bad comment:
```
This is wrong
```

Good comment:
```
Consider using std::array instead of std::vector here

Since the size is known at compile time (MAX_ORDERS = 1000),
std::array will be faster (no heap allocation) and safer
(size checking at compile time).

Example:
std::array<Order, MAX_ORDERS> orders;
```

Bad comment:
```
Use array not vector
```

================================================================================
SECTION 5: AUTHOR RESPONSIBILITIES
================================================================================

Before Requesting Review
------------------------

1. Self-review checklist:
[ ] Read your own diff
[ ] Remove debug code, console.logs
[ ] Remove commented code
[ ] Fix formatting issues
[ ] Add comments for complex logic
[ ] Check for hardcoded values
[ ] Verify test coverage
[ ] Run static analysis

2. Prepare the PR:
[ ] Write clear title and description
[ ] Add performance benchmarks
[ ] Include test results
[ ] Link related issues
[ ] Tag appropriate reviewers
[ ] Add labels (feature, bug, performance, etc.)

During Review
-------------

1. Respond promptly:
- Acknowledge comments within 4 hours
- Ask questions if unclear
- Explain your reasoning
- Be open to feedback

2. Address feedback:
- Fix blocking issues immediately
- Consider suggestions thoughtfully
- Discuss trade-offs openly
- Mark conversations as resolved

3. Update the PR:
- Push fixes in new commits (don't force push)
- Comment when ready for re-review
- Update PR description if scope changes

Example responses:

Good response:
```
Good catch! Fixed in commit abc123.

I also added a unit test to prevent regression.
```

Good response with discussion:
```
I considered that approach, but chose the current implementation because:
1. It's 30% faster in benchmarks (see attached results)
2. The memory overhead is only 100KB
3. It simplifies error handling

Happy to discuss further if you have concerns.
```

Bad response:
```
Works fine for me
```

After Approval
--------------

1. Final checks:
[ ] All comments resolved
[ ] All reviewers approved
[ ] CI/CD passing
[ ] Branch up to date

2. Merge:
- Use appropriate merge strategy
- Delete branch after merge
- Monitor deployment

3. Follow-up:
- Verify deployment successful
- Monitor metrics
- Address any issues quickly

Post-Merge Issues:
-----------------

If issues found after merge:
1. Create hotfix PR immediately
2. Revert if critical
3. Document in post-mortem
4. Update tests to prevent regression

================================================================================
SECTION 6: REVIEW CHECKLIST TEMPLATES
================================================================================

General Code Review Checklist
-----------------------------

CORRECTNESS:
[ ] Logic is correct
[ ] Edge cases handled
[ ] Error handling appropriate
[ ] No obvious bugs
[ ] Thread safety verified

PERFORMANCE:
[ ] No unnecessary allocations
[ ] Efficient algorithms
[ ] No performance regressions
[ ] Benchmarks provided for critical path

SECURITY:
[ ] Input validated
[ ] No hardcoded secrets
[ ] SQL injection prevented
[ ] Buffer overflows prevented
[ ] Sensitive data not logged

TESTING:
[ ] Unit tests added
[ ] Integration tests updated
[ ] Test coverage adequate (>80%)
[ ] Tests actually test the code
[ ] Edge cases tested

CODE QUALITY:
[ ] Readable and maintainable
[ ] Functions < 50 lines
[ ] No code duplication
[ ] Clear naming
[ ] Appropriate comments

STYLE:
[ ] Follows style guide
[ ] Consistent formatting
[ ] No unnecessary changes

DOCUMENTATION:
[ ] Public APIs documented
[ ] Complex logic explained
[ ] README updated if needed

HFT-Specific Checklist
----------------------

LATENCY CRITICAL CODE:
[ ] No dynamic memory allocation in hot path
[ ] No system calls in critical path
[ ] Lock-free or wait-free algorithms used
[ ] Cache-friendly data structures
[ ] Branch prediction considered
[ ] CPU affinity set for critical threads
[ ] Performance benchmarks show improvement
[ ] No performance regression

ALGORITHM CHANGES:
[ ] Algorithm correctness verified
[ ] Backtested with historical data
[ ] Edge cases tested (zero prices, large orders, etc.)
[ ] Risk limits enforced
[ ] Audit trail maintained
[ ] Compliance requirements met

MARKET DATA PROCESSING:
[ ] Message parsing correct
[ ] Timestamp handling precise
[ ] Missing data handled
[ ] Sequence number validation
[ ] Reconnection logic tested
[ ] Data integrity verified

ORDER EXECUTION:
[ ] Order validation comprehensive
[ ] Idempotency ensured
[ ] Duplicate prevention
[ ] Position limits checked
[ ] Risk controls active
[ ] Audit logging complete

CONFIGURATION CHANGES:
[ ] Backward compatible or migration provided
[ ] Default values sensible
[ ] Validation added
[ ] Documentation updated
[ ] Tested in all environments

DEPLOYMENT CHANGES:
[ ] Rollback plan documented
[ ] Zero-downtime deployment
[ ] Database migrations safe
[ ] Monitoring updated
[ ] Alerts configured

Feature-Specific Checklists
---------------------------

NEW TRADING ALGORITHM:
[ ] Algorithm logic verified by quant team
[ ] Backtested with 6+ months data
[ ] Risk limits configured
[ ] Kill switch implemented
[ ] Monitoring dashboards created
[ ] Alerts configured
[ ] Performance benchmarks met
[ ] Paper trading results reviewed
[ ] Regulatory approval (if needed)

EXCHANGE INTEGRATION:
[ ] API documentation reviewed
[ ] Authentication implemented
[ ] Rate limiting handled
[ ] Error handling comprehensive
[ ] Reconnection logic tested
[ ] Message validation complete
[ ] Certification testing passed
[ ] Failover tested

RISK MANAGEMENT:
[ ] Risk calculations verified
[ ] Position limits enforced
[ ] Loss limits enforced
[ ] Circuit breakers tested
[ ] Manual override available
[ ] Audit trail complete
[ ] Compliance review passed

DATABASE CHANGES:
[ ] Migration tested
[ ] Rollback tested
[ ] Indexes appropriate
[ ] Query performance verified
[ ] No table locks on large tables
[ ] Backup before deployment

================================================================================
SECTION 7: CODE QUALITY STANDARDS
================================================================================

C++ Code Quality Standards for HFT
----------------------------------

NAMING CONVENTIONS:
------------------

Classes: PascalCase
class OrderExecutor { };

Functions: camelCase
void processOrder(const Order& order);

Variables: snake_case
int order_count = 0;

Constants: UPPER_SNAKE_CASE
const int MAX_ORDER_SIZE = 10000;

Members: snake_case with trailing underscore
class OrderBook {
private:
    std::map<double, Order> orders_;
    int total_volume_;
};

FUNCTION LENGTH:
---------------
Target: < 30 lines
Maximum: 50 lines
Exceptions: Auto-generated code

Example violation:
```cpp
// BAD: 100-line function
void processMarketData(const MarketData& data) {
    // 100 lines of logic
}

// GOOD: Split into smaller functions
void processMarketData(const MarketData& data) {
    validateData(data);
    updateOrderBook(data);
    triggerStrategies(data);
    publishToSubscribers(data);
}
```

CYCLOMATIC COMPLEXITY:
---------------------
Target: < 5
Maximum: 10

Tools to measure:
- lizard
- cppcheck --enable=all
- clang-tidy

Example violation:
```cpp
// BAD: Complexity = 8
int getOrderStatus(const Order& order) {
    if (order.state == PENDING) {
        if (order.time < cutoff) {
            if (order.price > limit) {
                return REJECTED;
            } else if (order.quantity > max_qty) {
                return REJECTED;
            } else {
                return ACCEPTED;
            }
        } else {
            return EXPIRED;
        }
    } else {
        return order.state;
    }
}

// GOOD: Complexity = 3, early returns
int getOrderStatus(const Order& order) {
    if (order.state != PENDING) return order.state;
    if (order.time >= cutoff) return EXPIRED;
    if (order.price > limit || order.quantity > max_qty) {
        return REJECTED;
    }
    return ACCEPTED;
}
```

ERROR HANDLING:
--------------
Use exceptions for exceptional cases
Use error codes for expected failures
Always handle errors

```cpp
// BAD: Ignoring errors
auto result = database.query(sql);
process(result);

// GOOD: Handling errors
auto result = database.query(sql);
if (!result.ok()) {
    LOG(ERROR) << "Database query failed: " << result.error();
    return Status::DATABASE_ERROR;
}
process(result.value());
```

RESOURCE MANAGEMENT:
-------------------
Use RAII (Resource Acquisition Is Initialization)
Use smart pointers
Avoid manual memory management

```cpp
// BAD: Manual memory management
Order* order = new Order();
process(order);
delete order;  // Easy to forget!

// GOOD: Smart pointer
auto order = std::make_unique<Order>();
process(*order);
// Automatically deleted

// GOOD: Stack allocation
Order order;
process(order);
// Automatically destroyed
```

CONST CORRECTNESS:
-----------------
Use const liberally
Mark member functions const when appropriate
Use const references for read-only parameters

```cpp
// GOOD: Const correctness
class OrderBook {
public:
    double getBestBid() const;  // Doesn't modify state
    void addOrder(const Order& order);  // Read-only parameter

private:
    const int max_depth_;  // Never changes after construction
};
```

PERFORMANCE GUIDELINES:
----------------------

Avoid unnecessary copies:
```cpp
// BAD: Copies vector
void process(std::vector<Order> orders) { }

// GOOD: Reference
void process(const std::vector<Order>& orders) { }

// GOOD: Move semantics for large objects
void add(std::vector<Order>&& orders) {
    orders_ = std::move(orders);
}
```

Use inline for small, frequently-called functions:
```cpp
// In header
inline double getPrice(const Order& order) {
    return order.price;
}
```

Prefer stack allocation:
```cpp
// BAD: Heap allocation
auto* order = new Order();

// GOOD: Stack allocation
Order order;
```

Avoid virtual functions in hot path:
```cpp
// BAD for HFT critical path
class Executor {
    virtual void execute(Order& order);
};

// GOOD: Template-based polymorphism
template<typename Strategy>
class Executor {
    void execute(Order& order) {
        strategy_.execute(order);
    }
};
```

THREAD SAFETY:
-------------
Document thread-safety guarantees
Use locks appropriately
Consider lock-free algorithms

```cpp
// GOOD: Documented thread safety
/**
 * Thread-safe order book
 * All methods can be called from multiple threads
 */
class OrderBook {
public:
    void addOrder(const Order& order) {
        std::lock_guard<std::mutex> lock(mutex_);
        orders_.insert(order);
    }

private:
    mutable std::mutex mutex_;
    std::set<Order> orders_;
};
```

COMMENTS:
--------
Comment WHY, not WHAT
Avoid obvious comments
Update comments when code changes

```cpp
// BAD: Obvious comment
// Increment counter
counter++;

// GOOD: Explains why
// Skip validation for internal orders to reduce latency
if (order.source == INTERNAL) {
    execute(order);
}

// GOOD: Explains complex algorithm
// Use exponential backoff to avoid overwhelming exchange
// Retry delays: 100ms, 200ms, 400ms, 800ms, 1600ms
int retry_delay = 100 << retry_count;
```

================================================================================
SECTION 8: PERFORMANCE REVIEW CRITERIA
================================================================================

Performance Benchmarking Requirements
-------------------------------------

For all performance-sensitive code changes:

1. BASELINE MEASUREMENT:
   - Measure performance before change
   - Include latency percentiles (avg, p50, p95, p99, p99.9)
   - Measure throughput
   - Measure memory usage
   - Measure CPU usage

2. POST-CHANGE MEASUREMENT:
   - Measure with same workload
   - Compare to baseline
   - Document improvement/regression
   - Include in PR description

3. BENCHMARK FORMAT:
```
Performance Impact:
Component: Order Matching Engine
Workload: 1M orders, mixed buy/sell

Latency:
                Before      After       Change
Average:        10.2μs      7.5μs       -26%
p50:            9.8μs       7.1μs       -28%
p95:            15.3μs      11.2μs      -27%
p99:            18.5μs      12.1μs      -35%
p99.9:          25.3μs      16.8μs      -34%

Throughput:
Orders/sec:     400k        500k        +25%

Resources:
CPU:            45%         47%         +2%
Memory:         2.5GB       2.1GB       -16%

Conclusion: Significant improvement with minimal CPU cost
```

Performance Review Checklist:
-----------------------------

[ ] Benchmarks provided
[ ] No performance regression
[ ] Improvement meets expectations
[ ] Memory usage acceptable
[ ] CPU usage acceptable
[ ] No increased lock contention
[ ] Cache efficiency maintained
[ ] Branch prediction not harmed

Critical Performance Patterns:
------------------------------

1. HOT PATH OPTIMIZATION:
Review for:
- Zero allocations
- No system calls
- Minimal branches
- Cache-friendly access patterns
- Lock-free when possible

Example review comment:
```cpp
PERFORMANCE ISSUE on line 45:
std::vector<Order> pending_orders;
pending_orders.reserve(1000);

This allocates memory in the hot path.

Suggestion: Use pre-allocated buffer or lock-free queue
std::array<Order, 1000> pending_orders;  // Stack allocated
int pending_count = 0;
```

2. ALGORITHMIC EFFICIENCY:
Review for:
- Appropriate data structures
- Optimal algorithm complexity
- Unnecessary iterations

Example review comment:
```
Algorithm complexity concern:

Current: O(n) linear search through orders
for (const auto& order : all_orders) {
    if (order.id == target_id) return order;
}

Suggestion: O(1) lookup with hash map
std::unordered_map<OrderId, Order> order_map;
return order_map[target_id];
```

3. MEMORY EFFICIENCY:
Review for:
- Unnecessary copies
- Memory leaks
- Excessive memory usage
- Memory fragmentation

Performance Testing Tools:
-------------------------

Latency measurement:
```cpp
#include <chrono>

auto start = std::chrono::high_resolution_clock::now();
processOrder(order);
auto end = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
```

Profiling tools:
- perf (Linux performance analysis)
- valgrind (memory profiling)
- gprof (CPU profiling)
- Intel VTune (advanced profiling)

Benchmarking framework:
```cpp
#include <benchmark/benchmark.h>

static void BM_OrderMatching(benchmark::State& state) {
    OrderBook book;
    for (auto _ : state) {
        book.match(create_order());
    }
}
BENCHMARK(BM_OrderMatching);
```

================================================================================
SECTION 9: SECURITY REVIEW GUIDELINES
================================================================================

Security Review Checklist
-------------------------

INPUT VALIDATION:
[ ] All external input validated
[ ] Type checking performed
[ ] Range checking performed
[ ] SQL injection prevented
[ ] Command injection prevented

Example review:
```cpp
// SECURITY ISSUE:
void executeQuery(const std::string& user_input) {
    std::string query = "SELECT * FROM orders WHERE id = " + user_input;
    db.execute(query);  // SQL INJECTION RISK
}

// FIX:
void executeQuery(int order_id) {
    auto stmt = db.prepare("SELECT * FROM orders WHERE id = ?");
    stmt.bind(order_id);
    stmt.execute();
}
```

AUTHENTICATION & AUTHORIZATION:
[ ] Authentication required for sensitive operations
[ ] Authorization checked before access
[ ] Session management secure
[ ] Tokens validated

SECRETS MANAGEMENT:
[ ] No hardcoded passwords
[ ] No hardcoded API keys
[ ] No credentials in code
[ ] Secrets loaded from secure storage

Example review:
```cpp
// BLOCKER: Hardcoded credentials
const std::string API_KEY = "sk_live_abc123xyz";  // NEVER DO THIS

// FIX: Load from environment or secret manager
const std::string API_KEY = getenv("EXCHANGE_API_KEY");
```

DATA PROTECTION:
[ ] Sensitive data encrypted at rest
[ ] Sensitive data encrypted in transit
[ ] Sensitive data not logged
[ ] PII handled appropriately

BUFFER SAFETY:
[ ] No buffer overflows
[ ] Array bounds checked
[ ] String operations safe

Example review:
```cpp
// SECURITY ISSUE: Buffer overflow
char buffer[100];
strcpy(buffer, user_input.c_str());  // UNSAFE

// FIX: Use safe string operations
std::string buffer = user_input.substr(0, 99);
// OR
strncpy(buffer, user_input.c_str(), sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';
```

THIRD-PARTY DEPENDENCIES:
[ ] Dependencies from trusted sources
[ ] No known vulnerabilities
[ ] Minimal privileges
[ ] Version pinned

Security Scanning:
-----------------

Automated tools:
- snyk (dependency scanning)
- OWASP Dependency-Check
- cppcheck (static analysis)
- clang-tidy (static analysis)

Manual review focus:
- Authentication/authorization
- Input validation
- Cryptography usage
- Secret management

================================================================================
SECTION 10: COMMON REVIEW PATTERNS
================================================================================

Frequently Found Issues
----------------------

1. NULL POINTER DEREFERENCE:
```cpp
// ISSUE:
Order* order = getOrder(id);
process(order->price);  // Crash if order is null

// FIX:
Order* order = getOrder(id);
if (order != nullptr) {
    process(order->price);
}
// OR use references
Order& order = getOrder(id);  // Throws if not found
```

2. RACE CONDITION:
```cpp
// ISSUE:
if (order_map.find(id) != order_map.end()) {
    // Another thread might erase here!
    auto& order = order_map[id];  // Potential crash
}

// FIX:
auto it = order_map.find(id);
if (it != order_map.end()) {
    auto& order = it->second;  // Safe
}
```

3. RESOURCE LEAK:
```cpp
// ISSUE:
FILE* file = fopen("data.txt", "r");
process(file);
// File never closed!

// FIX:
FILE* file = fopen("data.txt", "r");
if (file) {
    process(file);
    fclose(file);
}
// BETTER: Use RAII
std::ifstream file("data.txt");
process(file);
// Automatically closed
```

4. UNNECESSARY COPYING:
```cpp
// ISSUE:
std::vector<Order> getOrders() {
    return all_orders;  // Copies entire vector
}

// FIX:
const std::vector<Order>& getOrders() const {
    return all_orders;  // No copy
}
```

5. MAGIC NUMBERS:
```cpp
// ISSUE:
if (price > 1000.0) reject();

// FIX:
const double MAX_PRICE = 1000.0;
if (price > MAX_PRICE) reject();
```

6. ERROR HANDLING MISSING:
```cpp
// ISSUE:
auto result = database.query(sql);
process(result);  // What if query failed?

// FIX:
auto result = database.query(sql);
if (!result.ok()) {
    LOG(ERROR) << "Query failed: " << result.error();
    return Status::ERROR;
}
process(result.value());
```

7. TOO MANY PARAMETERS:
```cpp
// ISSUE:
void createOrder(int id, double price, int qty, std::string symbol,
                 std::string side, std::string type, double stop_price,
                 int expire_time, bool reduce_only) {
}

// FIX: Use struct
struct OrderParams {
    int id;
    double price;
    int qty;
    std::string symbol;
    // ...
};
void createOrder(const OrderParams& params) {
}
```

================================================================================
SECTION 11: FEEDBACK GUIDELINES
================================================================================

Giving Constructive Feedback
----------------------------

DO:
- Be specific
- Explain reasoning
- Offer alternatives
- Ask questions
- Praise good work
- Focus on code, not person
- Use "we" instead of "you"

DON'T:
- Be vague
- Be condescending
- Just say "wrong"
- Make demands
- Ignore good aspects
- Attack the person
- Be dismissive

Good Examples:
-------------

Example 1:
"Consider using std::array instead of std::vector here.

Since the size is fixed at compile time (MAX_ORDERS = 1000),
std::array will be faster (no heap allocation) and safer
(compile-time size checking).

Before:
std::vector<Order> orders(1000);

After:
std::array<Order, 1000> orders;

This should reduce allocation overhead in the hot path."

Example 2:
"Nice work on the optimization! The lock-free queue is a great choice.

One suggestion: Consider adding memory_order parameters to the
atomic operations for even better performance.

std::atomic<int>::load(std::memory_order_acquire);

This documents the ordering guarantees and may allow compiler
optimizations."

Example 3:
"Question: Why did you choose a map instead of an unordered_map?

I noticed this is in the critical path where we lookup orders
frequently. unordered_map would give O(1) instead of O(log n)
lookups.

Is there a reason you need the ordering? If not, I suggest:
std::unordered_map<OrderId, Order> order_map;

Let me know if I'm missing something!"

Bad Examples:
------------

Bad Example 1:
"This is wrong."
(Not specific, not helpful)

Bad Example 2:
"You should know better than to use a mutex here."
(Condescending, attacks person)

Bad Example 3:
"Use unordered_map."
(No explanation, sounds like demand)

Bad Example 4:
"This will never work in production."
(Dismissive, not constructive)

Receiving Feedback
------------------

DO:
- Thank reviewer
- Ask for clarification
- Explain your reasoning
- Be open to change
- Respond promptly

DON'T:
- Get defensive
- Ignore feedback
- Argue without reason
- Take it personally

Good Responses:
--------------

Response 1:
"Good catch! I'll change it to unordered_map.

I originally used map for debugging (wanted ordered output),
but you're right that unordered_map is better for production.

Fixed in commit abc123."

Response 2:
"Thanks for the suggestion about std::array.

I considered it, but chose vector because the size varies
based on configuration (loaded from config.json at runtime).

std::array requires compile-time size, so vector is necessary here.

Does that make sense?"

Response 3:
"I'm not sure I understand the concern about thread safety.

Could you elaborate on the race condition you're seeing?
I thought the mutex on line 45 protects this access.

Maybe I'm missing something?"

================================================================================
SECTION 12: TOOLS AND AUTOMATION
================================================================================

Code Review Tools
----------------

GitHub Features:
- Pull request templates
- Code owners (CODEOWNERS file)
- Required reviews
- Status checks
- Draft PRs
- Suggested changes
- Review assignments

GitHub CLI:
```bash
# Create PR
gh pr create --title "Add feature" --body "Description"

# List PRs
gh pr list

# Check out PR
gh pr checkout 123

# Review PR
gh pr review 123 --approve
gh pr review 123 --request-changes --body "Needs fixes"
gh pr review 123 --comment --body "Question about line 45"

# Merge PR
gh pr merge 123 --squash
```

Static Analysis:
---------------

cppcheck:
```bash
cppcheck --enable=all --inconclusive --std=c++17 src/
```

clang-tidy:
```bash
clang-tidy src/*.cpp -- -std=c++17 -Iinclude/
```

.clang-tidy configuration:
```yaml
Checks: '-*,
  bugprone-*,
  performance-*,
  readability-*,
  modernize-*,
  cppcoreguidelines-*'
```

Formatting:
----------

clang-format:
```bash
clang-format -i src/*.cpp include/*.h
```

.clang-format configuration:
```yaml
BasedOnStyle: Google
IndentWidth: 4
ColumnLimit: 100
```

Automated Testing:
-----------------

Run in CI/CD:
- Unit tests (gtest)
- Integration tests
- Performance benchmarks
- Static analysis
- Security scans
- Code coverage

Example GitHub Actions:
```yaml
name: Code Review Checks

on: [pull_request]

jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Build
        run: make build

      - name: Run Tests
        run: make test

      - name: Static Analysis
        run: cppcheck --enable=all src/

      - name: Code Coverage
        run: |
          make coverage
          if [ $(cat coverage.txt) -lt 80 ]; then
            echo "Coverage below 80%"
            exit 1
          fi

      - name: Performance Benchmark
        run: make benchmark
```

Review Metrics:
--------------

Track:
- Average review time
- Number of review rounds
- PR size distribution
- Comments per PR
- Defect detection rate

Dashboard tools:
- GitHub Insights
- Codecov
- SonarQube

Automation Ideas:
----------------

1. Auto-assign reviewers based on files changed
2. Auto-label PRs (feature, bug, perf)
3. Auto-run benchmarks
4. Auto-comment with lint results
5. Auto-merge when approved (for low-risk changes)
6. Auto-notify on Slack when review needed

Example bot comment:
```
Performance Benchmark Results:

Latency: 7.5μs (was 10.2μs) - 26% improvement ✅
Memory: 2.1GB (was 2.5GB) - 16% reduction ✅
CPU: 47% (was 45%) - 2% increase ⚠️

Coverage: 96% (was 93%) - +3% ✅

All checks passed! Ready for review.
```

================================================================================
END OF DOCUMENT
================================================================================

This comprehensive code review process ensures high-quality code for HFT
systems while maintaining team velocity and developer satisfaction.

Last Updated: 2025-11-25
Version: 1.0
Maintained by: Engineering Team
