================================================================================
BRANCH PROTECTION RULES - HFT DEVELOPMENT
================================================================================
Branch Policies and Protection for High-Frequency Trading Systems
Teams of 4-10 Developers
Last Updated: 2025-11-25
================================================================================

TABLE OF CONTENTS
================================================================================
1. Branch Protection Overview
2. Main Branch Protection
3. Develop Branch Protection
4. Feature Branch Policies
5. Release Branch Protection
6. Rulesets Configuration
7. Status Checks Requirements
8. Code Owner Requirements
9. Deployment Protection
10. Emergency Override Procedures

================================================================================
SECTION 1: BRANCH PROTECTION OVERVIEW
================================================================================

Why Branch Protection for HFT
------------------------------

Critical for trading systems because:
1. Prevents direct commits to production code
2. Enforces code review requirements
3. Ensures automated tests pass
4. Maintains audit trail for compliance
5. Prevents accidental force pushes
6. Requires security checks
7. Enforces deployment approvals

Branch Protection Hierarchy
---------------------------

HIGHEST PROTECTION (main branch):
- No direct pushes
- Minimum 2 approving reviews
- All status checks must pass
- No force push
- No deletions
- Require signed commits
- Deployment environment protection

HIGH PROTECTION (develop branch):
- No direct pushes (PRs only)
- Minimum 1 approving review
- All status checks must pass
- No force push
- No deletions

MEDIUM PROTECTION (release/* branches):
- Direct pushes allowed for maintainers
- No force push from non-maintainers
- Status checks recommended

LOW PROTECTION (feature/* branches):
- Developers have full control
- Can force push own branches
- Can delete own branches

Protection Strategy by Team Size
--------------------------------

4-6 Developers (Small Team):
- main: 1 required reviewer
- develop: 0 required reviewers, but CI must pass
- Faster iteration, trust-based

7-10 Developers (Medium Team):
- main: 2 required reviewers
- develop: 1 required reviewer
- More formal process

10+ Developers (Large Team):
- main: 2+ required reviewers + code owners
- develop: 1+ required reviewer + code owners
- Strict process with ownership

================================================================================
SECTION 2: MAIN BRANCH PROTECTION
================================================================================

Main Branch Configuration
-------------------------

GitHub Settings > Branches > Add branch protection rule

Branch name pattern: main

Protection Settings:
--------------------

[x] Require a pull request before merging
    [x] Require approvals: 2
    [x] Dismiss stale pull request approvals when new commits are pushed
    [x] Require review from Code Owners
    [x] Restrict who can dismiss pull request reviews
        - Senior Engineers team
        - Tech Leads team
    [x] Allow specified actors to bypass required pull requests
        - (Leave empty - nobody should bypass)
    [x] Require approval of the most recent reviewable push

[x] Require status checks to pass before merging
    [x] Require branches to be up to date before merging
    Required status checks:
        - build
        - test-unit
        - test-integration
        - test-performance
        - security-scan
        - code-coverage
        - static-analysis

[x] Require conversation resolution before merging

[x] Require signed commits

[x] Require linear history
    (All commits must be made to a non-protected branch and squashed or rebased before merging)

[x] Require deployments to succeed before merging
    Required environments:
        - staging

[x] Lock branch
    (Make the branch read-only - for production freeze periods)

[x] Do not allow bypassing the above settings
    (Enforces rules for administrators too)

[x] Restrict who can push to matching branches
    Allowed to push:
        - (None - all changes via PR)

[x] Allow force pushes
    [ ] Everyone
    [ ] Specify who can force push
        - (None allowed)

[x] Allow deletions
    [ ] (Unchecked - prevent accidental deletion)

GitHub CLI Configuration:
------------------------

```bash
# Create main branch protection
gh api repos/{owner}/{repo}/branches/main/protection \
  --method PUT \
  --field required_status_checks='{"strict":true,"contexts":["build","test-unit","test-integration","security-scan"]}' \
  --field enforce_admins=true \
  --field required_pull_request_reviews='{"required_approving_review_count":2,"dismiss_stale_reviews":true,"require_code_owner_reviews":true}' \
  --field restrictions=null \
  --field required_signatures=true \
  --field required_linear_history=true \
  --field allow_force_pushes=false \
  --field allow_deletions=false
```

Terraform Configuration:
-----------------------

```hcl
resource "github_branch_protection" "main" {
  repository_id = github_repository.hft_system.node_id
  pattern       = "main"

  required_status_checks {
    strict   = true
    contexts = [
      "build",
      "test-unit",
      "test-integration",
      "test-performance",
      "security-scan",
      "code-coverage",
    ]
  }

  required_pull_request_reviews {
    required_approving_review_count = 2
    dismiss_stale_reviews           = true
    require_code_owner_reviews      = true
    dismissal_restrictions          = [
      "senior-engineers",
      "tech-leads",
    ]
  }

  enforce_admins                = true
  require_signed_commits        = true
  require_linear_history        = true
  require_conversation_resolution = true
  allows_deletions              = false
  allows_force_pushes           = false

  required_deployments {
    environments = ["staging"]
  }
}
```

Main Branch Merge Requirements
------------------------------

Before a PR can be merged to main:

1. Code Review:
   - Minimum 2 approvals
   - At least 1 from code owner
   - All conversations resolved
   - No changes since last approval

2. Automated Checks:
   - Build successful (all platforms)
   - Unit tests pass (100%)
   - Integration tests pass (100%)
   - Performance tests pass (no regression)
   - Security scan clean
   - Code coverage >= 80%
   - Static analysis pass

3. Manual Verifications:
   - Deployed to staging successfully
   - Smoke tests pass in staging
   - Performance metrics acceptable
   - No active incidents

4. Documentation:
   - Changelog updated
   - API docs updated (if applicable)
   - Migration guide (if breaking changes)

5. Compliance:
   - Commits signed with GPG
   - No secrets in code
   - Audit trail complete

Emergency Override Process:
--------------------------

For P0 incidents during trading hours:

1. Get approval from:
   - CTO or VP Engineering
   - Risk Manager
   - Compliance Officer

2. Document in incident report:
   - Reason for override
   - Business impact
   - Approvers
   - Timestamp

3. Create tracking issue:
   - Must follow up with proper PR
   - Include post-mortem
   - Add tests to prevent regression

4. Override command:
```bash
# Temporary disable protection
gh api repos/{owner}/{repo}/branches/main/protection \
  --method DELETE

# Make emergency change
git push origin main

# Re-enable protection
# (Use same command as protection setup)
```

5. Post-incident:
   - Restore protection immediately
   - Create proper PR for review
   - Update runbooks

================================================================================
SECTION 3: DEVELOP BRANCH PROTECTION
================================================================================

Develop Branch Configuration
----------------------------

Branch name pattern: develop

Protection Settings:
-------------------

[x] Require a pull request before merging
    [x] Require approvals: 1
    [x] Dismiss stale pull request approvals when new commits are pushed
    [x] Require review from Code Owners
    [ ] Restrict who can dismiss pull request reviews
        (Allow all senior developers)
    [x] Require approval of the most recent reviewable push

[x] Require status checks to pass before merging
    [x] Require branches to be up to date before merging
    Required status checks:
        - build
        - test-unit
        - code-coverage
        - static-analysis

[x] Require conversation resolution before merging

[ ] Require signed commits
    (Recommended but not enforced for develop)

[ ] Require linear history
    (Allow merge commits for develop)

[ ] Require deployments to succeed before merging
    (Not required for develop, auto-deploys to dev environment)

[ ] Lock branch

[x] Do not allow bypassing the above settings

[x] Restrict who can push to matching branches
    Allowed to push:
        - Maintainers team (for hotfix backports)

[ ] Allow force pushes
    Specify who can force push:
        - Maintainers team (for cleanup)

[ ] Allow deletions

GitHub CLI Configuration:
------------------------

```bash
gh api repos/{owner}/{repo}/branches/develop/protection \
  --method PUT \
  --field required_status_checks='{"strict":true,"contexts":["build","test-unit","code-coverage"]}' \
  --field enforce_admins=true \
  --field required_pull_request_reviews='{"required_approving_review_count":1,"dismiss_stale_reviews":true,"require_code_owner_reviews":true}' \
  --field restrictions='{"users":[],"teams":["maintainers"],"apps":[]}' \
  --field required_signatures=false \
  --field required_linear_history=false \
  --field allow_force_pushes='{"users":[],"teams":["maintainers"],"apps":[]}' \
  --field allow_deletions=false
```

Develop Branch Merge Requirements
---------------------------------

Before a feature PR can be merged to develop:

1. Code Review:
   - Minimum 1 approval
   - From code owner if touching owned code
   - All conversations resolved

2. Automated Checks:
   - Build successful
   - Unit tests pass
   - Code coverage >= 80%
   - Static analysis clean

3. Testing:
   - New tests for new code
   - Existing tests updated
   - Integration tests pass (if applicable)

4. Documentation:
   - Code comments for complex logic
   - Function documentation
   - README updated if needed

Develop Branch Workflow
-----------------------

Typical flow:
1. Create feature branch from develop
2. Develop feature
3. Create PR to develop
4. Get 1 approval
5. Merge to develop
6. Auto-deploy to dev environment
7. Auto-run integration tests

Fast-track for minor changes:
- Documentation updates
- Test additions
- Config changes
- Can merge with passing CI, no review required

================================================================================
SECTION 4: FEATURE BRANCH POLICIES
================================================================================

Feature Branch Guidelines
------------------------

Pattern: feature/*

Protection: Minimal (developer controlled)

Settings:
- No branch protection rules
- Developers can force push
- Developers can delete
- No required reviews
- No required checks

Reasoning:
- Developers need flexibility during development
- Can rebase and clean history
- Can experiment freely
- Protection enforced at merge to develop

Recommendations (not enforced):
------------------------------

1. Naming Convention:
   feature/JIRA-123-short-description

2. Lifetime:
   - Maximum 5 days
   - Delete after merge
   - Keep up to date with develop

3. Commits:
   - Commit frequently (at least daily)
   - Push daily for backup
   - Clean up before PR

4. Testing:
   - Run tests locally before pushing
   - Fix broken tests immediately
   - Add tests for new code

Self-Service Branch Management:
-------------------------------

Developers can:
```bash
# Create feature branch
git checkout -b feature/JIRA-123-new-algo develop

# Force push for history cleanup
git push --force-with-lease origin feature/JIRA-123-new-algo

# Delete remote branch after merge
git push origin --delete feature/JIRA-123-new-algo

# Rebase on develop
git rebase develop
git push --force-with-lease
```

Optional Feature Branch Protection:
-----------------------------------

For long-running features or shared feature branches:

```bash
# Protect specific feature branch
gh api repos/{owner}/{repo}/branches/feature/big-refactor/protection \
  --method PUT \
  --field required_status_checks='{"strict":false,"contexts":["build"]}' \
  --field allow_force_pushes='{"users":[],"teams":["feature-team"],"apps":[]}'
```

================================================================================
SECTION 5: RELEASE BRANCH PROTECTION
================================================================================

Release Branch Configuration
----------------------------

Pattern: release/*

Protection Settings:
-------------------

[x] Require a pull request before merging
    [x] Require approvals: 1
    [x] Dismiss stale pull request approvals when new commits are pushed
    [ ] Require review from Code Owners

[x] Require status checks to pass before merging
    [x] Require branches to be up to date before merging
    Required status checks:
        - build
        - test-unit
        - test-integration

[ ] Require conversation resolution before merging
    (Allow quick bug fixes during release)

[ ] Require signed commits

[ ] Require linear history

[x] Restrict who can push to matching branches
    Allowed to push:
        - Release managers
        - Tech leads

[ ] Allow force pushes
    Specify who can force push:
        - (None)

[ ] Allow deletions
    (Deleted after merge to main)

GitHub CLI Configuration:
------------------------

```bash
gh api repos/{owner}/{repo}/branches/release/*/protection \
  --method PUT \
  --field required_status_checks='{"strict":true,"contexts":["build","test-unit","test-integration"]}' \
  --field required_pull_request_reviews='{"required_approving_review_count":1}' \
  --field restrictions='{"users":[],"teams":["release-managers","tech-leads"],"apps":[]}' \
  --field allow_force_pushes=false \
  --field allow_deletions=true
```

Release Branch Workflow
-----------------------

1. Create release branch:
```bash
git checkout -b release/v1.2.0 develop
```

2. Bug fixes during release:
```bash
# Can commit directly to release branch
git commit -m "fix: Critical bug in order validation"

# Or create PR for review
git checkout -b bugfix/release-fix release/v1.2.0
# Make changes
git push origin bugfix/release-fix
# Create PR to release/v1.2.0
```

3. Merge to main:
```bash
# Create PR from release/v1.2.0 to main
# Requires all checks to pass
# Requires 2 approvals (main branch protection)
```

4. Merge back to develop:
```bash
git checkout develop
git merge --no-ff release/v1.2.0
git push origin develop
```

5. Delete release branch:
```bash
git branch -d release/v1.2.0
git push origin --delete release/v1.2.0
```

================================================================================
SECTION 6: RULESETS CONFIGURATION
================================================================================

GitHub Rulesets (Modern Approach)
----------------------------------

Rulesets are the newer, more flexible alternative to branch protection rules.

Benefits:
- Target multiple branches with patterns
- More granular permissions
- Better inheritance
- Easier to manage at scale

Creating Rulesets via GitHub UI:
--------------------------------

Settings > Rules > Rulesets > New ruleset

Ruleset 1: Production Branches
------------------------------
Name: Production Branches
Enforcement: Active
Target: Branches matching pattern

Include:
- main
- release/*

Rules:
- Restrict creations: Yes
- Restrict updates: Yes
  - Require pull request
    - Required approvals: 2
    - Dismiss stale reviews: Yes
    - Required review from code owners: Yes
  - Require status checks
    - build
    - test-unit
    - test-integration
    - security-scan
  - Block force pushes: Yes
- Restrict deletions: Yes
- Require signed commits: Yes
- Require linear history: Yes

Bypass list:
- (None)

Ruleset 2: Integration Branches
-------------------------------
Name: Integration Branches
Enforcement: Active
Target: Branches

Include:
- develop
- staging

Rules:
- Restrict updates: Yes
  - Require pull request
    - Required approvals: 1
  - Require status checks
    - build
    - test-unit
- Block force pushes: Yes (except for specific teams)

Bypass list:
- Maintainers team (for cleanup)

Ruleset 3: Feature Branches
---------------------------
Name: Feature Branches
Enforcement: Evaluate (report mode, not enforced)
Target: Branches matching pattern

Include:
- feature/*
- bugfix/*
- hotfix/*

Rules:
- Require status checks (recommended)
  - build

Bypass list:
- All developers

GitHub API for Rulesets:
-----------------------

```bash
# Create ruleset for production branches
gh api repos/{owner}/{repo}/rulesets \
  --method POST \
  --field name="Production Branches" \
  --field enforcement=active \
  --field target=branch \
  --field conditions='{"ref_name":{"include":["refs/heads/main","refs/heads/release/*"]}}' \
  --field rules='[
    {
      "type": "pull_request",
      "parameters": {
        "required_approving_review_count": 2,
        "dismiss_stale_reviews_on_push": true,
        "require_code_owner_review": true,
        "require_last_push_approval": true
      }
    },
    {
      "type": "required_status_checks",
      "parameters": {
        "strict_required_status_checks_policy": true,
        "required_status_checks": [
          {"context": "build"},
          {"context": "test-unit"},
          {"context": "test-integration"}
        ]
      }
    },
    {
      "type": "non_fast_forward"
    },
    {
      "type": "required_signatures"
    }
  ]'
```

Terraform Ruleset Configuration:
--------------------------------

```hcl
resource "github_repository_ruleset" "production" {
  name        = "Production Branches"
  repository  = github_repository.hft_system.name
  target      = "branch"
  enforcement = "active"

  conditions {
    ref_name {
      include = ["~DEFAULT_BRANCH", "refs/heads/release/*"]
      exclude = []
    }
  }

  rules {
    pull_request {
      required_approving_review_count   = 2
      dismiss_stale_reviews_on_push     = true
      require_code_owner_review         = true
      require_last_push_approval        = true
      required_review_thread_resolution = true
    }

    required_status_checks {
      strict_required_status_checks_policy = true

      required_check {
        context = "build"
      }

      required_check {
        context = "test-unit"
      }

      required_check {
        context = "test-integration"
      }

      required_check {
        context = "security-scan"
      }
    }

    non_fast_forward = true

    required_signatures = true

    required_linear_history = true

    deletion = false
  }

  bypass_actors {
    # No bypass allowed
  }
}
```

================================================================================
SECTION 7: STATUS CHECKS REQUIREMENTS
================================================================================

Required Status Checks Configuration
------------------------------------

Status checks are automated tests/validations that must pass before merging.

Essential Status Checks for HFT:
--------------------------------

1. build
   - Compiles code successfully
   - All compiler warnings resolved
   - Release and debug builds

2. test-unit
   - All unit tests pass
   - Code coverage >= 80%
   - No test failures

3. test-integration
   - Integration tests pass
   - Database tests pass
   - API tests pass

4. test-performance
   - No performance regression (>5%)
   - Latency within thresholds
   - Memory usage acceptable

5. security-scan
   - No high/critical vulnerabilities
   - Dependency scan clean
   - Secret scan clean

6. static-analysis
   - cppcheck passes
   - clang-tidy passes
   - No critical issues

7. code-coverage
   - Overall coverage >= 80%
   - New code coverage >= 90%
   - No coverage decrease

8. lint
   - Code formatting correct
   - Style guide followed
   - No linting errors

GitHub Actions Status Check:
----------------------------

```yaml
name: Required Checks

on:
  pull_request:
    branches: [main, develop]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: make build
      # Status: build

  test-unit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run unit tests
        run: make test
      # Status: test-unit

  test-integration:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run integration tests
        run: make integration-test
      # Status: test-integration

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Security scan
        run: make security-scan
      # Status: security-scan
```

Configuring Required Checks:
----------------------------

GitHub UI:
1. Settings > Branches
2. Edit branch protection rule
3. Enable "Require status checks to pass before merging"
4. Select required checks from list
5. Enable "Require branches to be up to date before merging"

GitHub CLI:
```bash
gh api repos/{owner}/{repo}/branches/main/protection \
  --method PUT \
  --field required_status_checks='{"strict":true,"contexts":["build","test-unit","test-integration","security-scan"]}'
```

Status Check Best Practices:
----------------------------

1. Fast Feedback:
   - Build: < 5 minutes
   - Unit tests: < 10 minutes
   - Integration tests: < 20 minutes

2. Reliable:
   - No flaky tests
   - Retry transient failures
   - Clear error messages

3. Comprehensive:
   - Cover all critical paths
   - Test edge cases
   - Verify performance

4. Actionable:
   - Clear failure messages
   - Link to logs
   - Suggest fixes

Bypass Status Checks (Emergency):
---------------------------------

In rare emergencies, administrators can bypass:

```bash
# Merge PR without waiting for checks
gh pr merge 123 --admin --squash
```

Document in incident report:
- Why bypass was necessary
- Who approved
- Risk assessment
- Follow-up actions

================================================================================
SECTION 8: CODE OWNER REQUIREMENTS
================================================================================

CODEOWNERS File Configuration
-----------------------------

File location: .github/CODEOWNERS

Purpose: Automatically request reviews from code owners when files are modified

Basic syntax:
```
# Pattern      Owner(s)
path/to/file   @username
*.js           @js-team
/docs/         @tech-writers
```

HFT System CODEOWNERS Example:
------------------------------

```
# .github/CODEOWNERS
# Code owners for HFT trading system

# Default owner for everything
* @tech-lead @senior-engineer

# Critical path - order execution
/src/order_executor/      @senior-eng-1 @senior-eng-2 @tech-lead
/src/matching_engine/     @senior-eng-1 @algo-team
/include/order_executor.h @senior-eng-1 @senior-eng-2

# Algorithms and trading strategies
/src/algorithms/          @quant-team @algo-lead
/src/strategies/          @quant-team @traders
/include/algorithm_base.h @quant-team

# Risk management
/src/risk/                @risk-team @compliance-lead
/src/position_manager/    @risk-team
/config/risk_limits.json  @risk-team @compliance-lead

# Market data processing
/src/market_data/         @market-data-team
/src/feed_handlers/       @market-data-team

# Database and persistence
/src/database/            @backend-team @dba
/migrations/              @backend-team @dba
/schema/                  @backend-team @dba

# Infrastructure and deployment
/infrastructure/          @devops-team
/terraform/               @devops-team @infra-lead
/.github/workflows/       @devops-team
/docker/                  @devops-team
/kubernetes/              @devops-team @infra-lead

# Configuration files
/config/production/       @tech-lead @devops-team @compliance-lead
/config/staging/          @devops-team
/config/*.json            @tech-lead

# Build system
/CMakeLists.txt           @senior-eng-1 @build-team
/Makefile                 @senior-eng-1 @build-team
/vcpkg.json               @build-team

# Documentation
/docs/                    @tech-writer @tech-lead
README.md                 @tech-writer
CONTRIBUTING.md           @tech-lead
CHANGELOG.md              @tech-lead

# Tests
/tests/unit/              @test-team
/tests/integration/       @test-team @qa-team
/tests/performance/       @perf-team @senior-eng-1

# Security
/src/auth/                @security-team
/src/encryption/          @security-team
/secrets/                 @security-team @devops-team

# Compliance and audit
/audit/                   @compliance-lead
/logs/                    @compliance-lead @devops-team

# Specific critical files (multiple owners required)
/src/order_executor/main.cpp    @senior-eng-1 @senior-eng-2 @tech-lead
/config/production/main.json    @tech-lead @devops-team @risk-team
```

Code Owner Patterns:
-------------------

Match entire directory:
```
/src/algorithms/ @quant-team
```

Match specific file types:
```
*.cpp @cpp-team
*.h @cpp-team
```

Match files anywhere:
```
**/*.json @config-team
```

Match specific files:
```
/config/production/main.json @tech-lead @devops
```

Multiple owners (all must approve):
```
/src/critical/ @eng1 @eng2 @eng3
```

Team ownership:
```
/src/risk/ @risk-team
```

Code Owner Enforcement:
----------------------

In branch protection settings:

[x] Require review from Code Owners
    - Automatically requests review from code owners
    - PR cannot merge without code owner approval
    - Dismissing code owner reviews requires special permission

Benefits:
- Ensures domain expertise
- Distributes review load
- Maintains code quality
- Creates accountability

Code Owner Best Practices:
--------------------------

1. Assign based on expertise:
   - Domain knowledge
   - Component ownership
   - On-call responsibility

2. Have backup owners:
   - Primary and secondary
   - Avoid single points of failure
   - Cover time zones

3. Keep teams small:
   - 2-4 owners per component
   - Avoid too many approvals
   - Balance thoroughness and velocity

4. Document ownership:
   - Why each team owns what
   - Contact information
   - Escalation path

5. Review regularly:
   - Update as team changes
   - Remove inactive members
   - Add new components

Override Code Owner Requirement:
-------------------------------

For emergencies:

```bash
# Admins can merge without code owner approval
gh pr merge 123 --admin
```

Must be documented in incident report.

================================================================================
SECTION 9: DEPLOYMENT PROTECTION
================================================================================

Environment Protection Rules
----------------------------

GitHub Environments provide deployment-specific protection.

Configure: Settings > Environments > New environment

Production Environment:
-----------------------

Environment name: production

Protection rules:

[x] Required reviewers
    - Select reviewers: @tech-lead, @devops-lead, @cto
    - Number required: 2

[x] Wait timer
    - Delay: 15 minutes
    - Allows monitoring staging before production

[x] Deployment branches
    - Selected branches: main
    - Only main can deploy to production

Environment secrets:
- PROD_DATABASE_URL
- PROD_API_KEY
- PROD_SIGNING_KEY

Environment variables:
- ENVIRONMENT=production
- LOG_LEVEL=info
- RATE_LIMIT=1000

Custom deployment protection rules:
[x] Market hours check
    - Block deployments during 9:30 AM - 4:00 PM EST
[x] Incident check
    - Block if active P0/P1 incidents
[x] Change freeze
    - Block during monthly/quarterly close

Staging Environment:
-------------------

Environment name: staging

Protection rules:

[x] Required reviewers
    - Select reviewers: @qa-team
    - Number required: 1
    - Can approve own deployment

[ ] Wait timer
    - No delay for staging

[x] Deployment branches
    - Selected branches: develop, release/*

Environment secrets:
- STAGING_DATABASE_URL
- STAGING_API_KEY

Environment variables:
- ENVIRONMENT=staging
- LOG_LEVEL=debug

Development Environment:
-----------------------

Environment name: development

Protection rules:
- No protection rules
- Auto-deploy on merge to develop

Environment variables:
- ENVIRONMENT=development
- LOG_LEVEL=debug

Deployment Workflow with Protection:
------------------------------------

```yaml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy-production:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://trading.example.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pre-deployment checks
        run: |
          # Check market hours
          ./scripts/check_market_hours.sh

          # Check for incidents
          ./scripts/check_incidents.sh

      - name: Deploy
        env:
          DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
          API_KEY: ${{ secrets.PROD_API_KEY }}
        run: |
          ./scripts/deploy.sh production

      - name: Post-deployment verification
        run: |
          ./scripts/verify_deployment.sh
          ./scripts/smoke_test.sh
```

When triggered:
1. Workflow starts
2. Waits for 2 approvals (tech-lead, devops-lead, or CTO)
3. Waits 15 minutes
4. Runs pre-deployment checks
5. Deploys if all checks pass
6. Runs post-deployment verification

Manual Approval Process:
-----------------------

1. Developer merges to main
2. Deployment workflow triggered
3. Notification sent to approvers
4. Approvers review:
   - Code changes
   - Test results
   - Performance impact
   - Risk assessment
5. Approvers click "Review pending deployments"
6. Approve or reject with comment
7. If approved, deployment proceeds

Deployment Protection API:
-------------------------

```bash
# Get environment protection rules
gh api repos/{owner}/{repo}/environments/production

# Approve pending deployment
gh api repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments \
  --method POST \
  --field environment_ids[]={env_id} \
  --field state=approved \
  --field comment="Approved for deployment"

# Reject deployment
gh api repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments \
  --method POST \
  --field environment_ids[]={env_id} \
  --field state=rejected \
  --field comment="Rejecting due to active incident"
```

Custom Deployment Protection:
-----------------------------

Create custom checks:

```bash
# deployment-protection-app.js
app.on('deployment_protection_rule.requested', async (context) => {
  const { deployment, environment } = context.payload;

  // Check market hours
  const isMarketOpen = await checkMarketHours();
  if (isMarketOpen && environment === 'production') {
    return context.octokit.repos.createDeploymentStatus({
      ...context.repo,
      deployment_id: deployment.id,
      state: 'failure',
      description: 'Cannot deploy during market hours'
    });
  }

  // Check for incidents
  const hasIncidents = await checkIncidents();
  if (hasIncidents) {
    return context.octokit.repos.createDeploymentStatus({
      ...context.repo,
      deployment_id: deployment.id,
      state: 'failure',
      description: 'Active incidents prevent deployment'
    });
  }

  // Allow deployment
  return context.octokit.repos.createDeploymentStatus({
    ...context.repo,
    deployment_id: deployment.id,
    state: 'success',
    description: 'All checks passed'
  });
});
```

================================================================================
SECTION 10: EMERGENCY OVERRIDE PROCEDURES
================================================================================

When to Use Emergency Override
-------------------------------

ONLY for:
- P0 production incidents
- Trading system down
- Data integrity issues
- Security breaches
- Regulatory violations

NEVER for:
- Feature releases
- Performance improvements
- Convenience
- Skipping code review

Emergency Override Process
-------------------------

Step 1: Declare Incident
------------------------
```bash
# Create incident in tracking system
incident create \
  --severity P0 \
  --title "Order execution failure" \
  --description "Orders failing to execute" \
  --on-call @devops-team
```

Step 2: Get Approvals
---------------------
Required approvers (at least 2):
- CTO or VP Engineering
- Head of Trading
- Risk Manager
- Compliance Officer

Document approvals:
```
Incident ID: INC-20251125-001
Approvers:
- John Doe (CTO) - 2025-11-25 14:30 EST
- Jane Smith (Head of Trading) - 2025-11-25 14:32 EST
Reason: Critical order execution bug causing trading halt
Business Impact: $50k/minute revenue loss
```

Step 3: Disable Branch Protection
---------------------------------
```bash
# Temporary disable main branch protection
gh api repos/{owner}/{repo}/branches/main/protection \
  --method DELETE

# Document in incident
incident update INC-20251125-001 \
  --comment "Branch protection disabled at 14:35 EST"
```

Step 4: Make Emergency Fix
--------------------------
```bash
# Fix directly on main
git checkout main
git pull origin main

# Make fix
vim src/order_executor.cpp

# Commit with incident reference
git commit -m "fix(critical): Prevent order execution failure

EMERGENCY FIX for INC-20251125-001
Approved by: CTO, Head of Trading
Business impact: Critical

Details:
- Fixed null pointer dereference
- Added validation
- Resolves INC-20251125-001"

# Push directly
git push origin main
```

Step 5: Immediate Deployment
----------------------------
```bash
# Tag for deployment
git tag -a v2.4.2-hotfix -m "Emergency hotfix INC-20251125-001"
git push origin v2.4.2-hotfix

# Deploy immediately
./scripts/emergency_deploy.sh v2.4.2-hotfix

# Monitor deployment
./scripts/monitor_deployment.sh --duration 600
```

Step 6: Restore Protection
--------------------------
```bash
# Re-enable branch protection immediately
gh api repos/{owner}/{repo}/branches/main/protection \
  --method PUT \
  --field required_status_checks='{"strict":true,"contexts":["build","test-unit"]}' \
  --field enforce_admins=true \
  --field required_pull_request_reviews='{"required_approving_review_count":2}'

# Verify protection restored
gh api repos/{owner}/{repo}/branches/main/protection
```

Step 7: Follow-Up
-----------------
Required within 24 hours:

1. Create proper PR:
```bash
# Create branch from emergency fix
git checkout -b hotfix/INC-20251125-001-proper main~1
git cherry-pick <emergency-commit>

# Add tests
# Add documentation
# Create PR
gh pr create --title "[HOTFIX] Proper fix for INC-20251125-001" \
  --body "Post-emergency proper fix with tests and review"
```

2. Post-mortem:
   - What happened
   - Why emergency override was necessary
   - How to prevent in future
   - Process improvements

3. Update runbooks:
   - Add to troubleshooting guide
   - Update monitoring
   - Add tests to prevent regression

Emergency Override Audit Log:
----------------------------

Track all overrides:

```
Date: 2025-11-25
Time: 14:35 EST
Incident: INC-20251125-001
Severity: P0
Reason: Order execution failure causing trading halt
Business Impact: $50k/minute revenue loss
Approvers:
  - John Doe (CTO) - 14:30 EST
  - Jane Smith (Head of Trading) - 14:32 EST
Protection Disabled: main branch - 14:35 EST
Emergency Commit: abc123def
Protection Restored: 14:45 EST
Follow-up PR: #456
Post-mortem: docs/postmortems/2025-11-25-order-execution.md
```

Emergency Contacts:
------------------

Primary (must approve):
- CTO: +1-555-0100
- Head of Trading: +1-555-0101

Secondary (can approve):
- VP Engineering: +1-555-0102
- Risk Manager: +1-555-0103
- Compliance Officer: +1-555-0104

On-call rotation:
- Check PagerDuty schedule
- Escalate after 5 minutes
- Use emergency broadcast if needed

Post-Emergency Review:
---------------------

Within 7 days, review:

1. Was override necessary?
2. Could it have been avoided?
3. Was process followed correctly?
4. What can be improved?
5. Update procedures

Track metrics:
- Number of overrides per month
- Time to restore protection
- Follow-up completion rate
- Recurrence of similar issues

Goal: Minimize emergency overrides through better processes and automation.

================================================================================
END OF DOCUMENT
================================================================================

This comprehensive branch protection guide ensures code quality and compliance
for HFT trading systems while providing emergency procedures when needed.

Last Updated: 2025-11-25
Version: 1.0
Maintained by: DevOps Team
