================================================================================
GIT WORKFLOW FOR TEAMS - HFT DEVELOPMENT
================================================================================
Comprehensive Git Branching Strategies and Workflows for High-Frequency Trading
Teams of 4-10 Developers
Last Updated: 2025-11-25
================================================================================

TABLE OF CONTENTS
================================================================================
1. Git Branching Strategies Overview
2. GitFlow Model for HFT Systems
3. Trunk-Based Development
4. Feature Branch Workflow
5. Release Management
6. Hotfix Procedures
7. Git Commands Reference
8. Branch Naming Conventions
9. Commit Message Standards
10. Merge vs Rebase Strategies
11. Conflict Resolution
12. Best Practices for HFT Teams

================================================================================
SECTION 1: GIT BRANCHING STRATEGIES OVERVIEW
================================================================================

HFT systems require careful version control due to:
- Real-time trading constraints
- Zero-downtime deployment requirements
- Regulatory compliance and audit trails
- Multiple environments (dev, staging, production)
- High code quality standards

Recommended Strategy: Modified GitFlow
--------------------------------------
For HFT teams of 4-10 developers, we recommend a modified GitFlow that balances:
- Structured release process
- Quick hotfix deployment
- Feature isolation
- Production stability

Branch Types:
-------------
1. main (production) - Production-ready code only
2. develop - Integration branch for features
3. feature/* - Individual feature development
4. release/* - Release preparation
5. hotfix/* - Emergency production fixes
6. bugfix/* - Non-emergency bug fixes

================================================================================
SECTION 2: GITFLOW MODEL FOR HFT SYSTEMS
================================================================================

PERMANENT BRANCHES
------------------

main Branch:
-----------
Purpose: Production-ready code
Protection: Highest level
Deployment: Automated to production after approval
Tagging: All commits tagged with version numbers

Commands:
git checkout main
git pull origin main
git tag -a v1.2.3 -m "Release version 1.2.3"
git push origin v1.2.3

develop Branch:
--------------
Purpose: Integration branch for completed features
Protection: High level, requires PR approval
Testing: Full test suite must pass
Deployment: Automated to staging environment

Commands:
git checkout develop
git pull origin develop
git merge --no-ff feature/new-algo
git push origin develop

TEMPORARY BRANCHES
------------------

Feature Branches (feature/*)
----------------------------
Naming: feature/JIRA-123-order-matching-optimization
Base: develop
Merge to: develop
Lifetime: 1-5 days for HFT features

Creation:
git checkout develop
git pull origin develop
git checkout -b feature/JIRA-123-order-matching-optimization

Development:
git add src/order_matching.cpp
git commit -m "feat(matching): Implement priority queue optimization"
git push -u origin feature/JIRA-123-order-matching-optimization

Merge back:
git checkout develop
git pull origin develop
git merge --no-ff feature/JIRA-123-order-matching-optimization
git push origin develop
git branch -d feature/JIRA-123-order-matching-optimization

Release Branches (release/*)
----------------------------
Naming: release/v1.2.0
Base: develop
Merge to: main AND develop
Lifetime: 1-3 days

Creation:
git checkout develop
git pull origin develop
git checkout -b release/v1.2.0

Version bump:
echo "1.2.0" > VERSION
git add VERSION
git commit -m "chore(release): Bump version to 1.2.0"

Final merge to main:
git checkout main
git pull origin main
git merge --no-ff release/v1.2.0
git tag -a v1.2.0 -m "Release version 1.2.0"
git push origin main --tags

Merge back to develop:
git checkout develop
git merge --no-ff release/v1.2.0
git push origin develop
git branch -d release/v1.2.0

Hotfix Branches (hotfix/*)
--------------------------
Naming: hotfix/JIRA-456-market-data-crash
Base: main
Merge to: main AND develop
Lifetime: Hours (critical fixes)
Priority: Immediate

Creation:
git checkout main
git pull origin main
git checkout -b hotfix/JIRA-456-market-data-crash

Fix and test:
git add src/market_data.cpp
git commit -m "fix(market-data): Prevent null pointer dereference"
git push -u origin hotfix/JIRA-456-market-data-crash

Merge to main:
git checkout main
git merge --no-ff hotfix/JIRA-456-market-data-crash
git tag -a v1.2.1 -m "Hotfix: Market data crash"
git push origin main --tags

Merge to develop:
git checkout develop
git merge --no-ff hotfix/JIRA-456-market-data-crash
git push origin develop
git branch -d hotfix/JIRA-456-market-data-crash

================================================================================
SECTION 3: TRUNK-BASED DEVELOPMENT (ALTERNATIVE)
================================================================================

For smaller HFT teams (4-6 developers) or rapid iteration:

Single main Branch with Short-Lived Feature Branches
----------------------------------------------------

Principles:
- Feature branches live < 1 day
- Continuous integration to main
- Feature flags for incomplete features
- Automated testing before merge

Workflow:
---------

1. Create short-lived feature branch:
git checkout main
git pull origin main
git checkout -b feature/quick-latency-fix

2. Develop and commit frequently:
git add .
git commit -m "feat(latency): Add CPU affinity for order threads"

3. Rebase on main before merging:
git checkout main
git pull origin main
git checkout feature/quick-latency-fix
git rebase main

4. Create PR and merge same day:
git push -u origin feature/quick-latency-fix
# Create PR via GitHub
# After approval, squash merge to main

5. Delete branch immediately:
git branch -d feature/quick-latency-fix

Feature Flags for HFT:
---------------------

config.h:
#define FEATURE_NEW_ALGO_ENABLED false
#define FEATURE_LATENCY_MONITORING true

main.cpp:
#if FEATURE_NEW_ALGO_ENABLED
    new_algorithm.execute(order);
#else
    legacy_algorithm.execute(order);
#endif

================================================================================
SECTION 4: FEATURE BRANCH WORKFLOW DETAILED
================================================================================

Standard Feature Development Cycle
-----------------------------------

Day 1: Feature Start
--------------------
09:00 - Create feature branch
git checkout develop
git pull origin develop
git checkout -b feature/JIRA-789-smart-order-routing

09:15 - Set up tracking
git push -u origin feature/JIRA-789-smart-order-routing

10:00 - First commit (scaffold)
git add include/smart_routing.h src/smart_routing.cpp
git commit -m "feat(routing): Add smart order routing skeleton"
git push

16:00 - End of day commit
git add .
git commit -m "feat(routing): Implement venue selection logic"
git push

Day 2: Continued Development
----------------------------
09:00 - Sync with develop
git fetch origin
git rebase origin/develop

12:00 - Midday commit
git add tests/test_smart_routing.cpp
git commit -m "test(routing): Add venue selection unit tests"
git push

Day 3: Completion
-----------------
09:00 - Final sync
git fetch origin
git rebase origin/develop

10:00 - Final commits
git add .
git commit -m "feat(routing): Add latency-based venue ranking"
git push

11:00 - Create Pull Request
# Via GitHub UI or gh CLI:
gh pr create --title "Smart Order Routing Implementation" \
             --body "Implements JIRA-789" \
             --base develop \
             --head feature/JIRA-789-smart-order-routing

14:00 - Address review comments
git add src/smart_routing.cpp
git commit -m "refactor(routing): Apply code review suggestions"
git push

15:00 - Merge after approval
# Merge via GitHub UI with "Merge commit" strategy
git checkout develop
git pull origin develop
git branch -d feature/JIRA-789-smart-order-routing

Parallel Feature Development
----------------------------

Developer 1: Market Data Feature
git checkout -b feature/JIRA-100-market-data-websocket develop

Developer 2: Order Management Feature
git checkout -b feature/JIRA-101-order-validation develop

Developer 3: Risk Management Feature
git checkout -b feature/JIRA-102-position-limits develop

Each developer works independently, commits regularly, and merges to develop
when complete. Features are isolated and don't interfere with each other.

================================================================================
SECTION 5: RELEASE MANAGEMENT
================================================================================

Semantic Versioning for HFT Systems
-----------------------------------
Format: MAJOR.MINOR.PATCH (e.g., 2.3.1)

MAJOR: Breaking changes, protocol changes, architecture rewrites
MINOR: New features, performance improvements, new algorithms
PATCH: Bug fixes, small optimizations, security patches

Release Cycle: Bi-weekly
------------------------

Week 1: Feature Development
---------------------------
Monday-Friday: Features merged to develop
Testing: Continuous on staging environment

Commands:
git checkout develop
git pull origin develop
git merge --no-ff feature/JIRA-123-new-feature
git push origin develop

Week 2: Release Preparation
---------------------------

Monday: Create release branch
git checkout develop
git pull origin develop
git checkout -b release/v2.4.0

Tuesday-Thursday: Testing and bug fixes
git add bugfix/critical-fix.cpp
git commit -m "fix(release): Address performance regression"
git push origin release/v2.4.0

Friday: Release to production

1. Update version:
echo "2.4.0" > VERSION
git add VERSION CHANGELOG.md
git commit -m "chore(release): Version 2.4.0"

2. Merge to main:
git checkout main
git pull origin main
git merge --no-ff release/v2.4.0
git tag -a v2.4.0 -m "Release 2.4.0: Smart routing and latency improvements"
git push origin main --tags

3. Merge back to develop:
git checkout develop
git merge --no-ff release/v2.4.0
git push origin develop

4. Cleanup:
git branch -d release/v2.4.0
git push origin --delete release/v2.4.0

Release Checklist:
-----------------
[ ] All tests passing on release branch
[ ] Performance benchmarks meet thresholds
[ ] Security scan completed
[ ] Changelog updated
[ ] Documentation updated
[ ] Deployment runbook prepared
[ ] Rollback plan documented
[ ] Stakeholders notified
[ ] Production deployment window scheduled

CHANGELOG.md Format:
-------------------
# Changelog

## [2.4.0] - 2025-11-25

### Added
- Smart order routing with venue selection
- Real-time latency monitoring dashboard
- Position limit validation

### Changed
- Improved order matching performance by 15%
- Updated market data parser for new protocol

### Fixed
- Market data reconnection on network failure
- Race condition in order book updates

### Security
- Updated authentication token encryption

================================================================================
SECTION 6: HOTFIX PROCEDURES
================================================================================

Critical Production Issue Response
-----------------------------------

Incident Detection:
------------------
1. Production monitoring alerts
2. Customer reports
3. Automated health checks

Severity Levels:
---------------
P0 (Critical): Trading halted, data loss, security breach
    Response time: Immediate
    Approval: CTO or VP Engineering

P1 (High): Degraded performance, non-critical feature failure
    Response time: < 2 hours
    Approval: Team Lead

P2 (Medium): Minor issues, workarounds available
    Response time: Next release
    Approval: Standard PR review

Hotfix Workflow (P0/P1):
-----------------------

Step 1: Create hotfix branch (5 minutes)
git checkout main
git pull origin main
git checkout -b hotfix/P0-order-execution-failure

Step 2: Implement fix (15-60 minutes)
# Fix the issue
git add src/order_executor.cpp
git commit -m "fix(executor): Prevent divide by zero in commission calc"

# Add test to prevent regression
git add tests/test_order_executor.cpp
git commit -m "test(executor): Add commission calculation edge cases"

git push -u origin hotfix/P0-order-execution-failure

Step 3: Fast-track review (15 minutes)
gh pr create --title "HOTFIX P0: Order execution failure" \
             --body "Critical fix for production issue" \
             --base main \
             --head hotfix/P0-order-execution-failure \
             --label "hotfix,P0"

# Request immediate review from 2 senior engineers
gh pr review --approve <PR-NUMBER>

Step 4: Deploy to production (10 minutes)
git checkout main
git merge --no-ff hotfix/P0-order-execution-failure
git tag -a v2.4.1 -m "Hotfix: Order execution divide by zero"
git push origin main --tags

# CI/CD automatically deploys to production

Step 5: Backport to develop (5 minutes)
git checkout develop
git merge --no-ff hotfix/P0-order-execution-failure
git push origin develop

Step 6: Post-mortem (within 24 hours)
# Document in docs/postmortems/2025-11-25-order-execution.md

Step 7: Cleanup
git branch -d hotfix/P0-order-execution-failure
git push origin --delete hotfix/P0-order-execution-failure

Hotfix Communication Template:
------------------------------
Subject: [HOTFIX] Production Issue - Order Execution Failure

Issue: Order execution failing due to divide by zero in commission calculation
Impact: 100% of orders affected, trading halted
Detection: 2025-11-25 14:23 UTC
Resolution: 2025-11-25 14:58 UTC (35 minutes)
Root Cause: Division by zero when fee percentage is not configured
Fix: Added null check and default fee percentage
Prevention: Added unit tests for edge cases

Deployed version: v2.4.1
Affected versions: v2.4.0
Rollback plan: Revert to v2.3.9 if issues persist

================================================================================
SECTION 7: GIT COMMANDS REFERENCE
================================================================================

Essential Daily Commands
------------------------

Check status:
git status
git status -sb  # Short format with branch info

View differences:
git diff                    # Unstaged changes
git diff --staged          # Staged changes
git diff develop...HEAD    # Compare with develop branch

Stage changes:
git add file.cpp                    # Stage specific file
git add src/                        # Stage directory
git add -p                          # Interactive staging
git add -u                          # Stage modified files only
git add .                           # Stage all changes

Commit changes:
git commit -m "feat(algo): Add new matching algorithm"
git commit -v                       # Verbose mode with diff
git commit --amend                  # Amend last commit
git commit --amend --no-edit        # Amend without changing message

Branch operations:
git branch                          # List local branches
git branch -r                       # List remote branches
git branch -a                       # List all branches
git branch -d feature/old          # Delete merged branch
git branch -D feature/old          # Force delete branch
git checkout -b feature/new        # Create and checkout new branch
git switch feature/name            # Modern way to switch branches

Synchronization:
git fetch origin                    # Fetch all remote changes
git fetch origin develop           # Fetch specific branch
git pull origin develop            # Fetch and merge
git pull --rebase origin develop   # Fetch and rebase
git push origin feature/name       # Push branch
git push -u origin feature/name    # Push and set upstream
git push --force-with-lease        # Safe force push

Advanced Commands
-----------------

Stashing:
git stash                          # Stash current changes
git stash save "WIP: algorithm"    # Stash with message
git stash list                     # List all stashes
git stash pop                      # Apply and remove stash
git stash apply stash@{1}          # Apply specific stash
git stash drop stash@{0}           # Delete specific stash
git stash clear                    # Delete all stashes

Rebasing:
git rebase develop                 # Rebase current branch on develop
git rebase -i HEAD~3               # Interactive rebase last 3 commits
git rebase --continue              # Continue after resolving conflicts
git rebase --abort                 # Abort rebase operation

Cherry-picking:
git cherry-pick abc123def          # Apply specific commit
git cherry-pick abc123..def456     # Apply range of commits
git cherry-pick --continue         # Continue after conflicts
git cherry-pick --abort            # Abort cherry-pick

Log and history:
git log --oneline                  # Compact log
git log --graph --all --decorate   # Visual branch history
git log --author="John"            # Filter by author
git log --since="2 weeks ago"      # Filter by date
git log --grep="fix"               # Filter by message
git log -p file.cpp                # Show changes to specific file
git log --stat                     # Show files changed
git reflog                         # Show reference log

Reset and revert:
git reset --soft HEAD~1            # Undo commit, keep changes staged
git reset --mixed HEAD~1           # Undo commit, keep changes unstaged
git reset --hard HEAD~1            # Undo commit, discard changes
git revert abc123def               # Create new commit that undoes changes
git clean -fd                      # Remove untracked files and directories

Tagging:
git tag                            # List all tags
git tag -l "v1.*"                  # List tags matching pattern
git tag -a v1.2.3 -m "Version 1.2.3"  # Create annotated tag
git tag v1.2.3                     # Create lightweight tag
git push origin v1.2.3             # Push specific tag
git push origin --tags             # Push all tags
git tag -d v1.2.3                  # Delete local tag
git push origin :refs/tags/v1.2.3  # Delete remote tag

Performance Commands for HFT Repositories
-----------------------------------------

Large repository optimizations:
git gc                             # Garbage collection
git gc --aggressive               # Aggressive optimization
git prune                          # Remove unreachable objects
git fsck                          # File system check

Shallow clone for CI/CD:
git clone --depth 1 --single-branch --branch main <repo>

Sparse checkout for large repos:
git sparse-checkout init
git sparse-checkout set src/algo tests/algo

================================================================================
SECTION 8: BRANCH NAMING CONVENTIONS
================================================================================

Standard Naming Format
---------------------
<type>/<ticket-id>-<short-description>

Type Prefixes:
-------------
feature/    - New features or enhancements
bugfix/     - Bug fixes (non-production)
hotfix/     - Production bug fixes
release/    - Release preparation
refactor/   - Code refactoring
docs/       - Documentation updates
test/       - Test additions or modifications
perf/       - Performance improvements
security/   - Security enhancements

Examples:
--------
feature/JIRA-1234-smart-order-routing
bugfix/JIRA-5678-order-book-memory-leak
hotfix/JIRA-9012-market-data-crash
release/v2.4.0
refactor/JIRA-3456-order-matching-cleanup
docs/JIRA-7890-api-documentation
test/JIRA-2345-integration-test-suite
perf/JIRA-6789-latency-optimization
security/JIRA-4567-encryption-upgrade

HFT-Specific Conventions:
------------------------
feature/latency-<description>     - Latency improvements
feature/algo-<description>        - Algorithm changes
feature/risk-<description>        - Risk management features
perf/cpu-<description>            - CPU optimizations
perf/memory-<description>         - Memory optimizations
perf/network-<description>        - Network optimizations

Invalid Branch Names:
--------------------
AVOID:
- feature/fix-bug                 (Too vague)
- john-changes                    (No context)
- temp                            (Not descriptive)
- test123                         (No ticket reference)
- feature-new-algo                (Wrong separator)
- FEATURE/JIRA-123-ALGO          (Wrong case)

Branch Lifecycle:
----------------
Creation:     feature/JIRA-123-description
Development:  (Regular commits)
Review:       (Pull request created)
Merge:        (Merged to develop/main)
Deletion:     (Branch removed after merge)

Typical lifetime: 1-5 days maximum

================================================================================
SECTION 9: COMMIT MESSAGE STANDARDS
================================================================================

Conventional Commits Format
---------------------------
<type>(<scope>): <subject>

<body>

<footer>

Type:
-----
feat:     New feature
fix:      Bug fix
docs:     Documentation changes
style:    Code style changes (formatting, semicolons, etc.)
refactor: Code refactoring without feature changes
perf:     Performance improvements
test:     Test additions or modifications
build:    Build system changes
ci:       CI/CD configuration changes
chore:    Maintenance tasks
revert:   Revert previous commit

Scope (HFT-specific):
--------------------
algo:         Trading algorithms
matching:     Order matching engine
market-data:  Market data processing
order:        Order management
risk:         Risk management
gateway:      Exchange gateways
latency:      Latency optimizations
memory:       Memory management
network:      Network layer
config:       Configuration

Subject Line:
------------
- Use imperative mood ("Add feature" not "Added feature")
- Don't capitalize first letter after type
- No period at the end
- Maximum 50-72 characters
- Be specific and descriptive

Body (optional):
---------------
- Wrap at 72 characters
- Explain what and why, not how
- Include motivation for change
- Reference related issues

Footer (optional):
-----------------
- Breaking changes: BREAKING CHANGE: <description>
- Issue references: Fixes #123, Closes #456
- Reviewed by: Reviewed-by: John Doe <john@example.com>

Examples:
--------

Simple commit:
git commit -m "feat(algo): Add VWAP execution algorithm"

Detailed commit:
git commit -m "feat(matching): Implement price-time priority matching

The new matching algorithm provides strict price-time priority
matching for improved fairness. This implementation uses a
priority queue with microsecond timestamp resolution.

Performance:
- Average latency: 2.3μs
- 99th percentile: 4.1μs
- Throughput: 500k orders/sec

Fixes #1234"

Bug fix:
git commit -m "fix(market-data): Prevent null pointer dereference

Added null check for exchange connection before processing
market data updates. This prevents crashes when connection
drops during high-volume periods.

Fixes #5678"

Performance improvement:
git commit -m "perf(latency): Reduce order processing by 30%

Optimizations:
- Changed order queue from std::queue to lock-free queue
- Added CPU affinity for critical threads
- Reduced memory allocations in hot path

Before: 10μs avg latency
After:  7μs avg latency

Closes #9012"

Breaking change:
git commit -m "feat(api): Update REST API to v2

BREAKING CHANGE: API endpoints changed from /v1/* to /v2/*

Migration guide:
- /v1/orders -> /v2/trading/orders
- /v1/positions -> /v2/portfolio/positions

Refs #3456"

Hotfix:
git commit -m "fix(critical): Prevent order duplication on retry

HOTFIX for production issue where order retries caused
duplicate executions. Added idempotency key to all orders.

Impact: High - prevents duplicate trades
Severity: P0
Deployed: v2.4.1

Fixes #7890"

Multiple authors:
git commit -m "feat(risk): Add real-time position limits

Implemented real-time position limit checks with configurable
thresholds per symbol and strategy.

Co-authored-by: Jane Smith <jane@example.com>
Co-authored-by: Bob Johnson <bob@example.com>

Closes #2345"

Commit Message Checklist:
-------------------------
[ ] Type is one of: feat, fix, docs, style, refactor, perf, test, build, ci, chore
[ ] Scope is specified and relevant
[ ] Subject line is imperative mood
[ ] Subject line is < 72 characters
[ ] Body explains what and why (if needed)
[ ] References issue number
[ ] Signed-off (for compliance)

================================================================================
SECTION 10: MERGE VS REBASE STRATEGIES
================================================================================

When to Merge vs Rebase
-----------------------

Use Merge (--no-ff):
-------------------
1. Integrating feature branches to develop
2. Release branches to main
3. Hotfix branches to main and develop
4. When preserving branch history is important
5. For collaboration on shared branches

Command:
git checkout develop
git merge --no-ff feature/JIRA-123-new-algo
git push origin develop

Advantages:
- Preserves complete history
- Shows when features were integrated
- Non-destructive operation
- Clear feature boundaries

Disadvantages:
- Creates merge commits
- More complex history graph
- Harder to trace linear history

Use Rebase:
----------
1. Updating feature branch with develop changes
2. Cleaning up local commits before PR
3. Maintaining linear history
4. For personal feature branches

Command:
git checkout feature/JIRA-123-new-algo
git rebase develop
git push --force-with-lease

Advantages:
- Linear, clean history
- Easier to trace changes
- No merge commits
- Better for git bisect

Disadvantages:
- Rewrites history
- Can cause issues on shared branches
- Requires force push
- Risk of conflicts

HFT Team Strategy:
-----------------

For develop and main branches:
Always use merge commits (--no-ff)

git merge --no-ff feature/branch
# This preserves feature history

For feature branches:
Rebase before creating PR

git checkout feature/JIRA-123
git rebase develop
git push --force-with-lease

For hotfixes:
Use merge to preserve urgency context

git merge --no-ff hotfix/critical-fix

Interactive Rebase Workflow:
---------------------------

Clean up commits before PR:
git rebase -i HEAD~5

Editor opens with:
pick abc1234 WIP: start algorithm
pick def5678 More changes
pick ghi9012 Fix typo
pick jkl3456 Add tests
pick mno7890 Final tweaks

Change to:
pick abc1234 feat(algo): Implement new matching algorithm
squash def5678 More changes
squash ghi9012 Fix typo
pick jkl3456 test(algo): Add matching algorithm tests
squash mno7890 Final tweaks

Result: 2 clean commits instead of 5 messy ones

Rebase Commands:
---------------
pick:   Use commit as-is
reword: Use commit but edit message
edit:   Use commit but stop for amending
squash: Combine with previous commit
fixup:  Like squash but discard message
drop:   Remove commit

Safe Force Push:
---------------
git push --force-with-lease origin feature/branch

This prevents overwriting others' changes

Team Guidelines:
---------------

NEVER rebase:
- main branch
- develop branch
- Published release branches
- Shared feature branches

ALWAYS rebase:
- Personal feature branches before PR
- Local commits not yet pushed

ALWAYS merge with --no-ff:
- Features to develop
- Releases to main
- Hotfixes to main/develop

================================================================================
SECTION 11: CONFLICT RESOLUTION
================================================================================

Understanding Merge Conflicts
-----------------------------

Conflicts occur when:
1. Same file modified in both branches
2. Same lines modified differently
3. File deleted in one branch, modified in other
4. Binary files changed

Conflict Markers:
----------------
<<<<<<< HEAD
Current branch changes
=======
Incoming branch changes
>>>>>>> feature/branch-name

Conflict Resolution Process:
----------------------------

Step 1: Start merge or rebase
git checkout develop
git merge feature/JIRA-123-algo

Output:
Auto-merging src/algorithm.cpp
CONFLICT (content): Merge conflict in src/algorithm.cpp
Automatic merge failed; fix conflicts and then commit the result.

Step 2: Identify conflicted files
git status

Output:
Unmerged paths:
  both modified:   src/algorithm.cpp
  both modified:   include/algorithm.h

Step 3: Open and resolve conflicts

src/algorithm.cpp:
<<<<<<< HEAD
double calculatePrice(Order& order) {
    return order.price * 1.01;  // Add 1% commission
=======
double calculatePrice(Order& order) {
    return order.price * 1.005;  // Add 0.5% commission
>>>>>>> feature/JIRA-123-algo
}

Resolution (choose appropriate):
double calculatePrice(Order& order) {
    return order.price * config.commission_rate;  // Configurable commission
}

Step 4: Mark as resolved
git add src/algorithm.cpp
git add include/algorithm.h

Step 5: Complete merge
git commit -m "Merge feature/JIRA-123-algo into develop

Resolved conflicts in algorithm commission calculation.
Using configurable commission rate for flexibility."

Step 6: Verify and test
./build.sh
./run_tests.sh
git push origin develop

Conflict Resolution Tools:
-------------------------

Using Git mergetool:
git mergetool

Configure merge tool:
git config --global merge.tool meld
git config --global mergetool.meld.path "/usr/bin/meld"

Other tools:
- vimdiff
- kdiff3
- Beyond Compare
- VS Code built-in merge

Aborting Merge:
--------------
git merge --abort

Aborting Rebase:
---------------
git rebase --abort

Complex Conflict Scenarios:
---------------------------

Scenario 1: Multiple files conflicted
------------------------------------
git status
# Resolve each file individually
git add file1.cpp
git add file2.cpp
git add file3.h
git commit

Scenario 2: Binary file conflict
--------------------------------
git checkout --ours config.dat    # Keep current version
# OR
git checkout --theirs config.dat  # Use incoming version
git add config.dat
git commit

Scenario 3: Deleted file conflict
---------------------------------
# File deleted in current branch, modified in incoming
git rm src/old_algo.cpp           # Accept deletion
# OR
git add src/old_algo.cpp          # Keep modifications
git commit

Scenario 4: Rebase conflict
---------------------------
git rebase develop

CONFLICT in src/trader.cpp

# Resolve conflict
vim src/trader.cpp
git add src/trader.cpp
git rebase --continue

# If more conflicts, repeat
# Otherwise, rebase completes

Prevention Strategies:
---------------------

1. Communicate with team:
- Announce major refactorings
- Coordinate on shared files
- Use code ownership

2. Small, frequent merges:
- Merge develop to feature daily
- Keep feature branches short-lived
- Regular integration

3. Modular code:
- Reduce shared file modifications
- Use interfaces and abstractions
- Separate concerns

4. Code review:
- Catch potential conflicts early
- Discuss overlapping changes
- Plan refactoring together

HFT-Specific Conflict Resolution:
---------------------------------

Performance-critical code conflicts:
-----------------------------------
When both branches optimize same code:
1. Benchmark both versions
2. Combine best aspects
3. Run performance tests
4. Document decision

Example:
<<<<<<< HEAD
inline void processOrder(Order& order) {
    // Optimized with loop unrolling
    for (int i = 0; i < 4; i++) {
        validateField(order, i);
    }
=======
inline void processOrder(Order& order) {
    // Optimized with branchless validation
    bool valid = (order.price > 0) & (order.qty > 0);
>>>>>>> feature/optimization

Resolution:
inline void processOrder(Order& order) {
    // Combined: branchless validation with unrolling
    bool valid = (order.price > 0) & (order.qty > 0) &
                 (order.symbol != nullptr);
    // Continue with fastest approach based on benchmarks
}

Configuration conflicts:
-----------------------
<<<<<<< HEAD
const int MAX_ORDERS = 10000;
=======
const int MAX_ORDERS = 50000;
>>>>>>> feature/capacity-increase

Resolution:
// Make configurable instead of hardcoded
extern const int MAX_ORDERS;  // In config file

================================================================================
SECTION 12: BEST PRACTICES FOR HFT TEAMS
================================================================================

Daily Workflow Best Practices
-----------------------------

Morning Routine:
---------------
1. Pull latest develop:
   git checkout develop
   git pull origin develop

2. Check for conflicts before starting work:
   git checkout feature/my-feature
   git rebase develop

3. Review overnight changes:
   git log develop --since="yesterday" --oneline

Development:
-----------
1. Commit frequently (every 30-60 minutes):
   git add -p
   git commit -m "feat(algo): Add order validation logic"

2. Push at least daily:
   git push origin feature/my-feature

3. Keep feature branches up to date:
   git fetch origin
   git rebase origin/develop

End of Day:
----------
1. Push all work:
   git push origin feature/my-feature

2. Create PR if feature complete:
   gh pr create --base develop --head feature/my-feature

3. Update team on progress

Code Review Integration:
-----------------------

Before requesting review:
1. Self-review your changes
2. Run full test suite
3. Check code coverage
4. Run static analysis
5. Update documentation
6. Rebase and clean commits

Performance Considerations:
--------------------------

Git configuration for HFT repos:
-------------------------------
# Enable parallel processing
git config --global pack.threads 4
git config --global index.threads 4

# Optimize for large repos
git config --global core.preloadindex true
git config --global core.fscache true

# Use SSH for faster operations
git remote set-url origin git@github.com:company/hft-system.git

# Shallow clone for CI/CD
git clone --depth 1 --single-branch

Security Best Practices:
-----------------------

1. Never commit secrets:
   # Add to .gitignore
   *.key
   *.pem
   secrets.json
   .env

2. Use git-secrets:
   git secrets --install
   git secrets --register-aws

3. Sign commits:
   git config --global user.signingkey <GPG-KEY-ID>
   git config --global commit.gpgsign true

4. Verify signatures:
   git log --show-signature

Team Collaboration:
------------------

1. Use branch protection:
   - Require PR reviews (minimum 2 for main, 1 for develop)
   - Require status checks
   - Require up-to-date branches
   - No force push to main/develop

2. Establish code owners:
   # In .github/CODEOWNERS
   /src/algo/ @algo-team
   /src/risk/ @risk-team
   *.cpp @senior-devs

3. Use templates:
   # Pull request template
   # Bug report template
   # Feature request template

4. Regular sync meetings:
   - Daily standups
   - Weekly technical reviews
   - Sprint planning

Troubleshooting:
---------------

Detached HEAD state:
git checkout develop

Lost commits:
git reflog
git checkout <commit-hash>
git checkout -b recovery-branch

Large files accidentally committed:
git filter-branch --tree-filter 'rm -f large_file.dat' HEAD

Reset to remote state:
git fetch origin
git reset --hard origin/develop

Recovery from bad merge:
git reset --hard ORIG_HEAD

Documentation Standards:
-----------------------

Maintain these Git-related docs:
1. CONTRIBUTING.md - How to contribute
2. BRANCHING_STRATEGY.md - Branching model
3. COMMIT_GUIDELINES.md - Commit standards
4. CODE_REVIEW.md - Review process
5. RELEASE_PROCESS.md - Release workflow

Automation Recommendations:
--------------------------

Pre-commit hooks:
#!/bin/bash
# .git/hooks/pre-commit
# Run tests before commit
./run_tests.sh
if [ $? -ne 0 ]; then
    echo "Tests failed, commit aborted"
    exit 1
fi

Pre-push hooks:
#!/bin/bash
# .git/hooks/pre-push
# Run static analysis before push
cppcheck src/
if [ $? -ne 0 ]; then
    echo "Static analysis failed"
    exit 1
fi

Monitoring and Metrics:
----------------------

Track these Git metrics:
- Average PR merge time
- Number of conflicts per week
- Feature branch lifetime
- Commit frequency
- Code review turnaround
- Build success rate

Tools:
- GitHub Insights
- GitPrime
- Git Analytics

================================================================================
END OF DOCUMENT
================================================================================

This comprehensive guide provides HFT teams with enterprise-grade Git workflows,
ensuring code quality, collaboration efficiency, and production stability.

Last Updated: 2025-11-25
Version: 1.0
Maintained by: DevOps Team
