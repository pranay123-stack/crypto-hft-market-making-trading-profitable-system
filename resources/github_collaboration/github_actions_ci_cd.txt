================================================================================
GITHUB ACTIONS CI/CD - HFT SYSTEMS
================================================================================
Complete CI/CD Workflows for High-Frequency Trading Development
Teams of 4-10 Developers
Last Updated: 2025-11-25
================================================================================

TABLE OF CONTENTS
================================================================================
1. CI/CD Overview for HFT
2. GitHub Actions Fundamentals
3. Build and Test Workflows
4. Deployment Workflows
5. Performance Testing Automation
6. Security Scanning
7. Release Management
8. Environment-Specific Workflows
9. Secrets Management
10. Monitoring and Notifications
11. Advanced Patterns
12. Troubleshooting

================================================================================
SECTION 1: CI/CD OVERVIEW FOR HFT
================================================================================

Why CI/CD for Trading Systems
------------------------------

Benefits:
1. Fast feedback on code quality
2. Automated testing prevents bugs
3. Consistent builds across environments
4. Zero-downtime deployments
5. Audit trail for compliance
6. Reduced human error

HFT-Specific Requirements:
-------------------------
1. Sub-second build times for critical components
2. Performance regression detection
3. Latency testing in CI
4. Market hours awareness
5. Gradual rollouts
6. Instant rollback capability
7. Multi-environment testing (dev, staging, production)

CI/CD Pipeline Overview:
-----------------------

STAGE 1: Code Quality (30 seconds)
- Linting
- Format checking
- Static analysis

STAGE 2: Build (2 minutes)
- Compile C++ code
- Build optimizations (-O3, LTO)
- Generate binaries

STAGE 3: Test (5 minutes)
- Unit tests
- Integration tests
- Code coverage

STAGE 4: Performance (10 minutes)
- Latency benchmarks
- Throughput tests
- Memory profiling

STAGE 5: Security (5 minutes)
- Dependency scanning
- Vulnerability detection
- Secret scanning

STAGE 6: Deploy (varies)
- Deploy to staging
- Deploy to production (manual approval)
- Health checks

Total pipeline time: ~25 minutes

================================================================================
SECTION 2: GITHUB ACTIONS FUNDAMENTALS
================================================================================

Basic Workflow Structure
------------------------

File location: .github/workflows/ci.yml

Basic syntax:
```yaml
name: CI Pipeline

# When to run
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

# Environment variables
env:
  BUILD_TYPE: Release
  CXX: g++-11

# Jobs to run
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build
        run: make build

      - name: Test
        run: make test
```

Workflow Triggers
-----------------

Push to branches:
```yaml
on:
  push:
    branches:
      - main
      - develop
      - 'release/*'
```

Pull requests:
```yaml
on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop
```

Manual trigger:
```yaml
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - staging
          - production
```

Scheduled runs:
```yaml
on:
  schedule:
    # Run nightly at 2 AM UTC (outside trading hours)
    - cron: '0 2 * * *'
```

Multiple triggers:
```yaml
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:
```

Runners
-------

GitHub-hosted:
```yaml
jobs:
  build:
    runs-on: ubuntu-latest  # Ubuntu 22.04
    # OR
    runs-on: ubuntu-20.04
    runs-on: windows-latest
    runs-on: macos-latest
```

Self-hosted (recommended for HFT):
```yaml
jobs:
  build:
    runs-on: [self-hosted, linux, x64, high-performance]
```

Matrix builds:
```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        compiler: [g++-11, clang-14]
        build_type: [Debug, Release]
    steps:
      - name: Build
        run: cmake -DCMAKE_CXX_COMPILER=${{ matrix.compiler }} -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
```

Job Dependencies
----------------

Sequential jobs:
```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Build
        run: make build

  test:
    needs: build  # Runs after build
    runs-on: ubuntu-latest
    steps:
      - name: Test
        run: make test

  deploy:
    needs: [build, test]  # Runs after both
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: make deploy
```

Conditional execution:
```yaml
jobs:
  deploy:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to production
        run: ./deploy.sh
```

================================================================================
SECTION 3: BUILD AND TEST WORKFLOWS
================================================================================

Complete Build Pipeline
-----------------------

.github/workflows/build.yml:
```yaml
name: Build and Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  BUILD_TYPE: Release
  CXX: g++-11
  CXXFLAGS: "-O3 -march=native -mtune=native"

jobs:
  # Job 1: Code quality checks
  lint:
    name: Code Quality
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-format-14 cppcheck

      - name: Check formatting
        run: |
          find src include -name "*.cpp" -o -name "*.h" | xargs clang-format-14 --dry-run --Werror

      - name: Static analysis
        run: |
          cppcheck --enable=all --inconclusive --error-exitcode=1 src/

      - name: Clang-tidy
        run: |
          find src -name "*.cpp" | xargs clang-tidy-14

  # Job 2: Build
  build:
    name: Build
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/vcpkg
            build/_deps
          key: ${{ runner.os }}-deps-${{ hashFiles('vcpkg.json') }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            cmake \
            ninja-build \
            g++-11 \
            libboost-all-dev \
            libssl-dev

      - name: Configure CMake
        run: |
          cmake -B build \
            -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER=g++-11 \
            -DCMAKE_CXX_FLAGS="-O3 -march=native" \
            -DBUILD_TESTING=ON \
            -DENABLE_COVERAGE=ON

      - name: Build
        run: cmake --build build --parallel $(nproc)

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: binaries
          path: |
            build/bin/
            build/lib/
          retention-days: 7

  # Job 3: Unit tests
  test-unit:
    name: Unit Tests
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: binaries
          path: build/

      - name: Run unit tests
        run: |
          cd build
          ctest --output-on-failure --parallel $(nproc)

      - name: Generate coverage
        run: |
          cd build
          gcov $(find . -name "*.gcno")
          lcov --capture --directory . --output-file coverage.info
          lcov --remove coverage.info '/usr/*' --output-file coverage.info
          lcov --list coverage.info

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: build/coverage.info
          fail_ci_if_error: true

      - name: Check coverage threshold
        run: |
          COVERAGE=$(lcov --summary build/coverage.info | grep lines | awk '{print $2}' | sed 's/%//')
          if (( $(echo "$COVERAGE < 80" | bc -l) )); then
            echo "Coverage $COVERAGE% is below 80%"
            exit 1
          fi

  # Job 4: Integration tests
  test-integration:
    name: Integration Tests
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 20

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: binaries
          path: build/

      - name: Setup test environment
        run: |
          export DATABASE_URL=postgresql://postgres:testpass@localhost:5432/testdb
          export REDIS_URL=redis://localhost:6379

      - name: Run integration tests
        run: |
          cd build
          ./bin/integration_tests --gtest_filter=* --gtest_output=xml:integration_results.xml

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: integration-test-results
          path: build/integration_results.xml

  # Job 5: Performance tests
  test-performance:
    name: Performance Tests
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: binaries
          path: build/

      - name: Run benchmarks
        run: |
          cd build
          ./bin/benchmark_suite --benchmark_format=json --benchmark_out=benchmark_results.json

      - name: Analyze performance
        run: |
          python3 scripts/analyze_benchmarks.py \
            --current build/benchmark_results.json \
            --baseline benchmarks/baseline.json \
            --threshold 10

      - name: Upload benchmark results
        uses: actions/upload-artifact@v3
        with:
          name: benchmark-results
          path: build/benchmark_results.json

      - name: Comment on PR with results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const results = JSON.parse(fs.readFileSync('build/benchmark_results.json'));
            const comment = `## Performance Benchmark Results\n\n${formatResults(results)}`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

C++ Specific Build Configurations
---------------------------------

CMake configuration:
```yaml
- name: Configure CMake
  run: |
    cmake -B build \
      -DCMAKE_BUILD_TYPE=Release \
      -DCMAKE_CXX_COMPILER=g++-11 \
      -DCMAKE_CXX_FLAGS="-O3 -march=native -flto" \
      -DCMAKE_EXE_LINKER_FLAGS="-flto" \
      -DBUILD_SHARED_LIBS=OFF \
      -DENABLE_IPO=ON
```

Compiler matrix:
```yaml
strategy:
  matrix:
    include:
      - compiler: g++-11
        cxx_flags: "-O3 -march=native"
      - compiler: clang-14
        cxx_flags: "-O3 -march=native"
      - compiler: g++-11
        cxx_flags: "-O2"  # Fallback optimization
```

================================================================================
SECTION 4: DEPLOYMENT WORKFLOWS
================================================================================

Multi-Environment Deployment
----------------------------

.github/workflows/deploy.yml:
```yaml
name: Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests (emergency only)'
        required: false
        type: boolean
        default: false

jobs:
  # Deploy to staging (automatic)
  deploy-staging:
    name: Deploy to Staging
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'staging'
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.trading.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: binaries

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy to staging
        run: |
          # Upload to S3
          aws s3 sync build/ s3://hft-staging-binaries/$(git rev-parse --short HEAD)/

          # Update ECS task definition
          aws ecs update-service \
            --cluster hft-staging \
            --service trading-engine \
            --force-new-deployment

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster hft-staging \
            --services trading-engine

      - name: Run smoke tests
        run: |
          ./scripts/smoke_test.sh https://staging.trading.example.com

      - name: Notify deployment
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK }}
          payload: |
            {
              "text": "Staging deployment successful: ${{ github.sha }}"
            }

  # Deploy to production (manual approval)
  deploy-production:
    name: Deploy to Production
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production'
    needs: [deploy-staging]
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://trading.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: binaries

      - name: Pre-deployment checks
        run: |
          # Verify market hours
          if ./scripts/is_market_open.sh; then
            echo "ERROR: Cannot deploy during market hours"
            exit 1
          fi

          # Verify staging health
          if ! ./scripts/check_staging_health.sh; then
            echo "ERROR: Staging not healthy"
            exit 1
          fi

      - name: Create deployment backup
        run: |
          aws s3 sync s3://hft-prod-binaries/current/ s3://hft-prod-binaries/backup-$(date +%Y%m%d-%H%M%S)/

      - name: Blue-Green Deployment
        run: |
          # Deploy to green environment
          ./scripts/deploy_green.sh

          # Health check
          ./scripts/health_check.sh green

          # Switch traffic to green
          ./scripts/switch_traffic.sh green

          # Monitor for 5 minutes
          ./scripts/monitor.sh --duration 300

          # If successful, terminate blue
          ./scripts/terminate_blue.sh

      - name: Rollback on failure
        if: failure()
        run: |
          ./scripts/switch_traffic.sh blue
          ./scripts/terminate_green.sh

      - name: Post-deployment verification
        run: |
          ./scripts/verify_deployment.sh production

      - name: Notify deployment
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK }}
          payload: |
            {
              "text": ":rocket: Production deployment successful: ${{ github.sha }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Deployment Complete*\n\nCommit: ${{ github.sha }}\nAuthor: ${{ github.actor }}\nTime: $(date)"
                  }
                }
              ]
            }

  # Canary deployment (gradual rollout)
  deploy-canary:
    name: Canary Deployment
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Deploy to 10% of servers
        run: ./scripts/canary_deploy.sh --percentage 10

      - name: Monitor for 30 minutes
        run: ./scripts/monitor_canary.sh --duration 1800

      - name: Deploy to 50% of servers
        run: ./scripts/canary_deploy.sh --percentage 50

      - name: Monitor for 30 minutes
        run: ./scripts/monitor_canary.sh --duration 1800

      - name: Deploy to 100% of servers
        run: ./scripts/canary_deploy.sh --percentage 100

      - name: Rollback on high error rate
        if: failure()
        run: ./scripts/rollback_canary.sh
```

Docker Build and Push
--------------------

```yaml
jobs:
  docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            company/trading-engine:${{ github.sha }}
            company/trading-engine:latest
          cache-from: type=registry,ref=company/trading-engine:buildcache
          cache-to: type=registry,ref=company/trading-engine:buildcache,mode=max
          build-args: |
            BUILD_TYPE=Release
            OPTIMIZATION_LEVEL=3
```

Kubernetes Deployment
--------------------

```yaml
jobs:
  deploy-k8s:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Update deployment
        run: |
          kubectl set image deployment/trading-engine \
            trading-engine=company/trading-engine:${{ github.sha }} \
            --namespace=production

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/trading-engine \
            --namespace=production \
            --timeout=10m

      - name: Verify deployment
        run: |
          kubectl get pods -n production -l app=trading-engine
          kubectl logs -n production -l app=trading-engine --tail=100
```

================================================================================
SECTION 5: PERFORMANCE TESTING AUTOMATION
================================================================================

Latency Testing Workflow
------------------------

.github/workflows/performance.yml:
```yaml
name: Performance Tests

on:
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '0 2 * * *'  # Nightly

jobs:
  latency-test:
    name: Latency Benchmarks
    runs-on: [self-hosted, high-performance]  # Dedicated hardware

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Checkout baseline
        uses: actions/checkout@v4
        with:
          ref: main
          path: baseline

      - name: Build current
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=Release
          cmake --build build

      - name: Build baseline
        run: |
          cd baseline
          cmake -B build -DCMAKE_BUILD_TYPE=Release
          cmake --build build

      - name: Set CPU affinity
        run: |
          # Pin to specific CPU cores for consistent results
          sudo cpupower frequency-set --governor performance
          sudo echo "isolated_cores=2,3" >> /etc/default/grub
          sudo update-grub

      - name: Run latency benchmarks
        run: |
          # Run current version
          taskset -c 2 ./build/bin/latency_benchmark \
            --benchmark_format=json \
            --benchmark_out=current_latency.json \
            --benchmark_repetitions=100

          # Run baseline
          cd baseline
          taskset -c 2 ./build/bin/latency_benchmark \
            --benchmark_format=json \
            --benchmark_out=baseline_latency.json \
            --benchmark_repetitions=100

      - name: Compare results
        run: |
          python3 scripts/compare_latency.py \
            --current current_latency.json \
            --baseline baseline/baseline_latency.json \
            --output comparison.md

      - name: Check for regression
        run: |
          # Fail if latency increased by more than 5%
          python3 scripts/check_regression.py \
            --current current_latency.json \
            --baseline baseline/baseline_latency.json \
            --threshold 5

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const comparison = fs.readFileSync('comparison.md', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comparison
            });

      - name: Upload results
        uses: actions/upload-artifact@v3
        with:
          name: latency-results
          path: |
            current_latency.json
            baseline/baseline_latency.json
            comparison.md

  throughput-test:
    name: Throughput Benchmarks
    runs-on: [self-hosted, high-performance]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=Release
          cmake --build build

      - name: Run throughput test
        run: |
          ./build/bin/throughput_benchmark \
            --duration=60 \
            --threads=8 \
            --output=throughput_results.json

      - name: Analyze results
        run: |
          python3 scripts/analyze_throughput.py \
            --input throughput_results.json \
            --min_required 500000  # 500k orders/sec minimum

      - name: Upload results
        uses: actions/upload-artifact@v3
        with:
          name: throughput-results
          path: throughput_results.json

  memory-profile:
    name: Memory Profiling
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install valgrind
        run: sudo apt-get install -y valgrind

      - name: Build with debug symbols
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo
          cmake --build build

      - name: Run memory check
        run: |
          valgrind --tool=massif \
            --massif-out-file=massif.out \
            ./build/bin/trading_engine --duration=60

      - name: Analyze memory usage
        run: |
          ms_print massif.out > memory_report.txt
          python3 scripts/check_memory_leak.py massif.out

      - name: Upload memory report
        uses: actions/upload-artifact@v3
        with:
          name: memory-report
          path: |
            massif.out
            memory_report.txt
```

Performance Comparison Script
-----------------------------

scripts/compare_latency.py:
```python
#!/usr/bin/env python3
import json
import sys

def compare_latency(current_file, baseline_file):
    with open(current_file) as f:
        current = json.load(f)
    with open(baseline_file) as f:
        baseline = json.load(f)

    report = "## Performance Comparison\n\n"
    report += "| Benchmark | Baseline | Current | Change |\n"
    report += "|-----------|----------|---------|--------|\n"

    for curr_bench in current['benchmarks']:
        name = curr_bench['name']
        base_bench = next((b for b in baseline['benchmarks'] if b['name'] == name), None)

        if base_bench:
            base_time = base_bench['real_time']
            curr_time = curr_bench['real_time']
            change = ((curr_time - base_time) / base_time) * 100

            emoji = "✅" if change <= 0 else "⚠️" if change < 5 else "❌"

            report += f"| {name} | {base_time:.2f}μs | {curr_time:.2f}μs | {change:+.1f}% {emoji} |\n"

    return report

if __name__ == '__main__':
    report = compare_latency(sys.argv[1], sys.argv[2])
    print(report)
    with open('comparison.md', 'w') as f:
        f.write(report)
```

================================================================================
SECTION 6: SECURITY SCANNING
================================================================================

Security Scanning Workflow
--------------------------

.github/workflows/security.yml:
```yaml
name: Security Scanning

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday

jobs:
  dependency-check:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Snyk
        uses: snyk/actions/cpp@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

      - name: Run OWASP Dependency Check
        run: |
          wget https://github.com/jeremylong/DependencyCheck/releases/download/v8.0.0/dependency-check-8.0.0-release.zip
          unzip dependency-check-8.0.0-release.zip
          ./dependency-check/bin/dependency-check.sh \
            --project "HFT System" \
            --scan . \
            --format HTML \
            --format JSON \
            --out dependency-check-report

      - name: Upload dependency report
        uses: actions/upload-artifact@v3
        with:
          name: dependency-check-report
          path: dependency-check-report/

  secret-scan:
    name: Secret Scanning
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for secret scanning

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Run TruffleHog
        run: |
          docker run --rm -v $(pwd):/scan \
            trufflesecurity/trufflehog:latest \
            filesystem /scan \
            --json > trufflehog-report.json

      - name: Check for secrets
        run: |
          if [ -s trufflehog-report.json ]; then
            echo "Secrets detected!"
            cat trufflehog-report.json
            exit 1
          fi

  static-analysis:
    name: Static Analysis Security
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Semgrep
        run: |
          pip install semgrep
          semgrep --config=auto --json --output=semgrep-report.json .

      - name: Run Flawfinder
        run: |
          pip install flawfinder
          flawfinder --html --context . > flawfinder-report.html

      - name: Upload reports
        uses: actions/upload-artifact@v3
        with:
          name: security-reports
          path: |
            semgrep-report.json
            flawfinder-report.html

  container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Docker image
        run: docker build -t trading-engine:test .

      - name: Run Trivy scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'trading-engine:test'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  code-scanning:
    name: CodeQL Security Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: cpp
          queries: security-extended

      - name: Build
        run: |
          cmake -B build
          cmake --build build

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2
```

Custom Security Checks
---------------------

```yaml
jobs:
  custom-security:
    name: Custom Security Checks
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for hardcoded secrets
        run: |
          # Look for common secret patterns
          if grep -r "password\s*=\s*['\"]" src/; then
            echo "Hardcoded password detected"
            exit 1
          fi
          if grep -r "api_key\s*=\s*['\"]" src/; then
            echo "Hardcoded API key detected"
            exit 1
          fi

      - name: Check for unsafe functions
        run: |
          # Look for dangerous C functions
          UNSAFE_FUNCS="strcpy strcat sprintf gets"
          for func in $UNSAFE_FUNCS; do
            if grep -r "\b$func\s*(" src/; then
              echo "Unsafe function $func detected"
              exit 1
            fi
          done

      - name: Verify encryption
        run: |
          # Ensure sensitive data is encrypted
          python3 scripts/verify_encryption.py src/

      - name: Check file permissions
        run: |
          # Ensure no world-writable files
          if find . -perm -002 -type f; then
            echo "World-writable files detected"
            exit 1
          fi
```

================================================================================
SECTION 7: RELEASE MANAGEMENT
================================================================================

Automated Release Workflow
--------------------------

.github/workflows/release.yml:
```yaml
name: Release

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          # Generate changelog from commits since last tag
          PREV_TAG=$(git describe --abbrev=0 --tags $(git rev-list --tags --skip=1 --max-count=1))
          CURRENT_TAG=${GITHUB_REF#refs/tags/}

          echo "# Changelog for $CURRENT_TAG" > changelog.md
          echo "" >> changelog.md

          # Group commits by type
          echo "## Features" >> changelog.md
          git log $PREV_TAG..$CURRENT_TAG --pretty=format:"- %s" --grep="^feat" >> changelog.md
          echo "" >> changelog.md

          echo "## Bug Fixes" >> changelog.md
          git log $PREV_TAG..$CURRENT_TAG --pretty=format:"- %s" --grep="^fix" >> changelog.md
          echo "" >> changelog.md

          echo "## Performance" >> changelog.md
          git log $PREV_TAG..$CURRENT_TAG --pretty=format:"- %s" --grep="^perf" >> changelog.md

      - name: Build release binaries
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=Release
          cmake --build build
          cd build
          tar -czf trading-engine-${GITHUB_REF#refs/tags/}-linux-x64.tar.gz bin/ lib/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          body_path: changelog.md
          files: |
            build/trading-engine-*.tar.gz
            LICENSE
            README.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update version file
        run: |
          echo "${GITHUB_REF#refs/tags/}" > VERSION
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add VERSION
          git commit -m "chore: Update version to ${GITHUB_REF#refs/tags/}"
          git push

  deploy-release:
    name: Deploy Release
    needs: create-release
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Download release artifacts
        uses: actions/download-artifact@v3

      - name: Deploy to production
        run: ./scripts/deploy_release.sh ${GITHUB_REF#refs/tags/}

      - name: Notify team
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK }}
          payload: |
            {
              "text": ":rocket: New release deployed: ${GITHUB_REF#refs/tags/}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Release ${GITHUB_REF#refs/tags/} deployed to production*"
                  }
                }
              ]
            }
```

Semantic Versioning Automation
------------------------------

```yaml
jobs:
  auto-version:
    name: Automatic Versioning
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version bump
        id: version
        run: |
          # Check commit messages for version bump type
          COMMITS=$(git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:"%s")

          if echo "$COMMITS" | grep -q "BREAKING CHANGE"; then
            echo "bump=major" >> $GITHUB_OUTPUT
          elif echo "$COMMITS" | grep -q "^feat"; then
            echo "bump=minor" >> $GITHUB_OUTPUT
          else
            echo "bump=patch" >> $GITHUB_OUTPUT
          fi

      - name: Bump version
        uses: anothrNick/github-tag-action@1.64.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEFAULT_BUMP: ${{ steps.version.outputs.bump }}
          WITH_V: true
```

================================================================================
SECTION 8: ENVIRONMENT-SPECIFIC WORKFLOWS
================================================================================

Environment Configuration
-------------------------

.github/workflows/environment.yml:
```yaml
name: Environment Management

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - provision
          - destroy
          - update
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - production

jobs:
  manage-environment:
    name: Manage ${{ github.event.inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Provision infrastructure
        if: github.event.inputs.action == 'provision'
        run: |
          cd terraform/${{ github.event.inputs.environment }}
          terraform init
          terraform apply -auto-approve \
            -var="instance_type=${{ vars.INSTANCE_TYPE }}" \
            -var="instance_count=${{ vars.INSTANCE_COUNT }}"

      - name: Destroy infrastructure
        if: github.event.inputs.action == 'destroy'
        run: |
          cd terraform/${{ github.event.inputs.environment }}
          terraform destroy -auto-approve

      - name: Update configuration
        if: github.event.inputs.action == 'update'
        run: |
          ./scripts/update_config.sh ${{ github.event.inputs.environment }}
```

Market Hours Awareness
---------------------

```yaml
jobs:
  deployment-check:
    name: Deployment Window Check
    runs-on: ubuntu-latest

    steps:
      - name: Check market hours
        id: market
        run: |
          # Get current time in NYSE timezone
          CURRENT_HOUR=$(TZ='America/New_York' date +%H)
          DAY_OF_WEEK=$(date +%u)

          # Market hours: 9:30 AM - 4:00 PM EST, Monday-Friday
          if [ $DAY_OF_WEEK -ge 6 ]; then
            echo "weekend=true" >> $GITHUB_OUTPUT
          elif [ $CURRENT_HOUR -ge 9 ] && [ $CURRENT_HOUR -lt 16 ]; then
            echo "market_open=true" >> $GITHUB_OUTPUT
          else
            echo "market_open=false" >> $GITHUB_OUTPUT
          fi

      - name: Block deployment during market hours
        if: steps.market.outputs.market_open == 'true'
        run: |
          echo "ERROR: Cannot deploy during market hours (9:30 AM - 4:00 PM EST)"
          echo "Please wait until market close or use emergency deployment workflow"
          exit 1

      - name: Allow deployment
        if: steps.market.outputs.market_open != 'true'
        run: echo "Deployment window OK - market closed"
```

================================================================================
SECTION 9: SECRETS MANAGEMENT
================================================================================

Using GitHub Secrets
-------------------

Accessing secrets in workflows:
```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Use secrets
        env:
          # Organization secrets
          EXCHANGE_API_KEY: ${{ secrets.EXCHANGE_API_KEY }}
          DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}

          # Environment secrets (production-specific)
          PROD_SIGNING_KEY: ${{ secrets.PROD_SIGNING_KEY }}

          # Variables (non-sensitive)
          DATABASE_HOST: ${{ vars.DATABASE_HOST }}
          LOG_LEVEL: ${{ vars.LOG_LEVEL }}

        run: |
          ./scripts/deploy.sh
```

AWS Secrets Manager Integration
-------------------------------

```yaml
jobs:
  fetch-secrets:
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Fetch secrets from AWS Secrets Manager
        run: |
          # Fetch trading credentials
          aws secretsmanager get-secret-value \
            --secret-id prod/trading/credentials \
            --query SecretString \
            --output text > credentials.json

          # Fetch database credentials
          aws secretsmanager get-secret-value \
            --secret-id prod/database/password \
            --query SecretString \
            --output text > db_password.txt

      - name: Use secrets
        run: |
          export DB_PASSWORD=$(cat db_password.txt)
          ./scripts/deploy.sh

      - name: Cleanup secrets
        if: always()
        run: |
          shred -vfz credentials.json db_password.txt
```

HashiCorp Vault Integration
---------------------------

```yaml
jobs:
  vault-secrets:
    runs-on: ubuntu-latest

    steps:
      - name: Import Secrets from Vault
        uses: hashicorp/vault-action@v2
        with:
          url: https://vault.example.com
          token: ${{ secrets.VAULT_TOKEN }}
          secrets: |
            secret/data/production/database password | DB_PASSWORD ;
            secret/data/production/exchange api_key | EXCHANGE_API_KEY ;
            secret/data/production/signing private_key | SIGNING_KEY

      - name: Use secrets
        env:
          DB_PASSWORD: ${{ env.DB_PASSWORD }}
          EXCHANGE_API_KEY: ${{ env.EXCHANGE_API_KEY }}
        run: |
          ./scripts/deploy.sh
```

Secret Rotation Workflow
------------------------

```yaml
name: Rotate Secrets

on:
  schedule:
    - cron: '0 0 1 * *'  # Monthly
  workflow_dispatch:

jobs:
  rotate-secrets:
    runs-on: ubuntu-latest

    steps:
      - name: Generate new credentials
        run: |
          # Generate new API key
          NEW_API_KEY=$(openssl rand -hex 32)
          echo "::add-mask::$NEW_API_KEY"

      - name: Update secret in AWS
        run: |
          aws secretsmanager update-secret \
            --secret-id prod/exchange/api-key \
            --secret-string "$NEW_API_KEY"

      - name: Update application config
        run: |
          ./scripts/update_credentials.sh

      - name: Verify new credentials
        run: |
          ./scripts/test_credentials.sh

      - name: Notify team
        run: |
          echo "Credentials rotated successfully" | \
          slack-cli --webhook ${{ secrets.SLACK_WEBHOOK }}
```

================================================================================
SECTION 10: MONITORING AND NOTIFICATIONS
================================================================================

Slack Notifications
------------------

```yaml
jobs:
  notify-slack:
    name: Slack Notifications
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Notify on success
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK }}
          payload: |
            {
              "text": ":white_check_mark: Deployment successful",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment Successful*\n\nCommit: ${{ github.sha }}\nAuthor: ${{ github.actor }}\nBranch: ${{ github.ref }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Changes"
                      },
                      "url": "${{ github.event.head_commit.url }}"
                    }
                  ]
                }
              ]
            }

      - name: Notify on failure
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK }}
          payload: |
            {
              "text": ":x: Deployment failed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment Failed*\n\n@channel Please investigate\n\nCommit: ${{ github.sha }}\nAuthor: ${{ github.actor }}\nWorkflow: ${{ github.workflow }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Logs"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
```

Email Notifications
------------------

```yaml
steps:
  - name: Send email on failure
    if: failure()
    uses: dawidd6/action-send-mail@v3
    with:
      server_address: smtp.gmail.com
      server_port: 465
      username: ${{ secrets.EMAIL_USERNAME }}
      password: ${{ secrets.EMAIL_PASSWORD }}
      subject: 'CI/CD Failure: ${{ github.workflow }}'
      to: team@example.com
      from: ci-cd@example.com
      body: |
        Workflow ${{ github.workflow }} failed.

        Repository: ${{ github.repository }}
        Branch: ${{ github.ref }}
        Commit: ${{ github.sha }}
        Author: ${{ github.actor }}

        View logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
```

PagerDuty Integration
--------------------

```yaml
steps:
  - name: Trigger PagerDuty incident
    if: failure()
    run: |
      curl -X POST https://events.pagerduty.com/v2/enqueue \
        -H 'Content-Type: application/json' \
        -d '{
          "routing_key": "${{ secrets.PAGERDUTY_ROUTING_KEY }}",
          "event_action": "trigger",
          "payload": {
            "summary": "Production deployment failed",
            "severity": "critical",
            "source": "GitHub Actions",
            "custom_details": {
              "workflow": "${{ github.workflow }}",
              "commit": "${{ github.sha }}",
              "author": "${{ github.actor }}"
            }
          }
        }'
```

Datadog Monitoring
-----------------

```yaml
steps:
  - name: Send metrics to Datadog
    run: |
      # Send deployment event
      curl -X POST "https://api.datadoghq.com/api/v1/events" \
        -H "Content-Type: application/json" \
        -H "DD-API-KEY: ${{ secrets.DATADOG_API_KEY }}" \
        -d '{
          "title": "Deployment to production",
          "text": "Deployed commit ${{ github.sha }}",
          "tags": ["env:production", "service:trading-engine"],
          "alert_type": "info"
        }'

      # Send deployment metric
      curl -X POST "https://api.datadoghq.com/api/v1/series" \
        -H "Content-Type: application/json" \
        -H "DD-API-KEY: ${{ secrets.DATADOG_API_KEY }}" \
        -d '{
          "series": [{
            "metric": "deployment.count",
            "points": [['"$(date +%s)"', 1]],
            "type": "count",
            "tags": ["env:production", "service:trading-engine"]
          }]
        }'
```

================================================================================
SECTION 11: ADVANCED PATTERNS
================================================================================

Reusable Workflows
-----------------

.github/workflows/reusable-build.yml:
```yaml
name: Reusable Build

on:
  workflow_call:
    inputs:
      build_type:
        required: true
        type: string
      run_tests:
        required: false
        type: boolean
        default: true
    outputs:
      artifact_name:
        description: "Name of the build artifact"
        value: ${{ jobs.build.outputs.artifact }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      artifact: ${{ steps.upload.outputs.artifact-id }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=${{ inputs.build_type }}
          cmake --build build

      - name: Test
        if: inputs.run_tests
        run: cd build && ctest

      - name: Upload artifact
        id: upload
        uses: actions/upload-artifact@v3
        with:
          name: build-${{ inputs.build_type }}
          path: build/
```

Using reusable workflow:
```yaml
name: CI

on: [push]

jobs:
  build-debug:
    uses: ./.github/workflows/reusable-build.yml
    with:
      build_type: Debug
      run_tests: true

  build-release:
    uses: ./.github/workflows/reusable-build.yml
    with:
      build_type: Release
      run_tests: false
```

Composite Actions
----------------

.github/actions/setup-cpp/action.yml:
```yaml
name: 'Setup C++ Environment'
description: 'Install and configure C++ build tools'

inputs:
  compiler:
    description: 'C++ compiler to use'
    required: true
    default: 'g++-11'

runs:
  using: "composite"
  steps:
    - name: Install compiler
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y ${{ inputs.compiler }}

    - name: Install dependencies
      shell: bash
      run: |
        sudo apt-get install -y \
          cmake \
          ninja-build \
          libboost-all-dev

    - name: Configure environment
      shell: bash
      run: |
        echo "CXX=${{ inputs.compiler }}" >> $GITHUB_ENV
        echo "CMAKE_GENERATOR=Ninja" >> $GITHUB_ENV
```

Using composite action:
```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup-cpp
        with:
          compiler: g++-11
      - run: cmake -B build && cmake --build build
```

Matrix Strategy
--------------

```yaml
jobs:
  test-matrix:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-20.04, ubuntu-22.04]
        compiler: [g++-10, g++-11, clang-14]
        build_type: [Debug, Release]
        exclude:
          - os: ubuntu-20.04
            compiler: clang-14
        include:
          - os: ubuntu-22.04
            compiler: g++-11
            build_type: Release
            artifact_upload: true

    steps:
      - uses: actions/checkout@v4

      - name: Build
        run: |
          cmake -B build \
            -DCMAKE_CXX_COMPILER=${{ matrix.compiler }} \
            -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
          cmake --build build

      - name: Upload artifacts
        if: matrix.artifact_upload
        uses: actions/upload-artifact@v3
        with:
          name: build-${{ matrix.os }}-${{ matrix.compiler }}-${{ matrix.build_type }}
          path: build/
```

Caching Strategies
-----------------

```yaml
steps:
  - name: Cache CMake build
    uses: actions/cache@v3
    with:
      path: |
        build
        ~/.cache/vcpkg
      key: ${{ runner.os }}-cmake-${{ hashFiles('CMakeLists.txt', 'vcpkg.json') }}
      restore-keys: |
        ${{ runner.os }}-cmake-

  - name: Cache dependencies
    uses: actions/cache@v3
    with:
      path: /usr/local
      key: ${{ runner.os }}-deps-${{ hashFiles('scripts/install_deps.sh') }}
```

Conditional Workflows
--------------------

```yaml
jobs:
  deploy:
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      !contains(github.event.head_commit.message, '[skip ci]')
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying..."

  performance-test:
    if: |
      contains(github.event.pull_request.labels.*.name, 'performance') ||
      contains(github.event.head_commit.message, '[perf]')
    runs-on: ubuntu-latest
    steps:
      - run: ./performance_tests.sh
```

================================================================================
SECTION 12: TROUBLESHOOTING
================================================================================

Common Issues and Solutions
---------------------------

Issue 1: Build timeout
```yaml
# Problem: Build takes too long
# Solution: Increase timeout and use caching

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Increased from default 360

    steps:
      - name: Cache build
        uses: actions/cache@v3
        with:
          path: build
          key: build-cache-${{ hashFiles('**/*.cpp') }}

      - name: Build with parallel jobs
        run: cmake --build build --parallel $(nproc)
```

Issue 2: Flaky tests
```yaml
# Problem: Tests sometimes fail
# Solution: Retry failed tests

steps:
  - name: Run tests with retry
    uses: nick-invision/retry@v2
    with:
      timeout_minutes: 10
      max_attempts: 3
      command: cd build && ctest --output-on-failure
```

Issue 3: Out of disk space
```yaml
# Problem: Runner runs out of disk space
# Solution: Clean up before build

steps:
  - name: Free disk space
    run: |
      sudo rm -rf /usr/share/dotnet
      sudo rm -rf /opt/ghc
      sudo rm -rf /usr/local/share/boost
      df -h

  - name: Build
    run: cmake --build build
```

Issue 4: Secret not available
```yaml
# Problem: Secret is empty or undefined
# Solution: Check and validate secrets

steps:
  - name: Validate secrets
    run: |
      if [ -z "${{ secrets.API_KEY }}" ]; then
        echo "ERROR: API_KEY secret not set"
        exit 1
      fi

  - name: Use secret
    env:
      API_KEY: ${{ secrets.API_KEY }}
    run: ./deploy.sh
```

Issue 5: Permission denied
```yaml
# Problem: Script is not executable
# Solution: Make scripts executable

steps:
  - name: Make scripts executable
    run: chmod +x scripts/*.sh

  - name: Run script
    run: ./scripts/deploy.sh
```

Debugging Workflows
------------------

Enable debug logging:
```yaml
# Add to workflow file or run with:
# gh workflow run ci.yml --ref main -f debug_enabled=true

on:
  workflow_dispatch:
    inputs:
      debug_enabled:
        type: boolean
        description: 'Enable debug logging'
        default: false

jobs:
  debug:
    runs-on: ubuntu-latest
    steps:
      - name: Enable debug
        if: ${{ inputs.debug_enabled }}
        run: |
          echo "ACTIONS_RUNNER_DEBUG=true" >> $GITHUB_ENV
          echo "ACTIONS_STEP_DEBUG=true" >> $GITHUB_ENV

      - name: Debug information
        run: |
          echo "Runner OS: ${{ runner.os }}"
          echo "GitHub ref: ${{ github.ref }}"
          echo "GitHub event: ${{ github.event_name }}"
          env | sort
```

Testing workflows locally:
```bash
# Install act
brew install act

# Run workflow locally
act -j build

# Run with secrets
act -j build --secret-file .secrets

# Run specific event
act pull_request
```

================================================================================
END OF DOCUMENT
================================================================================

This comprehensive GitHub Actions CI/CD guide provides production-ready
workflows for HFT systems with automated testing, deployment, and monitoring.

Last Updated: 2025-11-25
Version: 1.0
Maintained by: DevOps Team
