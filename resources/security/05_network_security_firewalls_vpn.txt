================================================================================
NETWORK SECURITY: FIREWALLS, VPN, AND NETWORK ISOLATION FOR HFT SYSTEMS
================================================================================

OVERVIEW
--------
This document provides comprehensive guidelines for implementing network
security in high-frequency trading systems, including firewall configuration,
VPN setup, network segmentation, and DDoS protection. Proper network security
is critical to protect trading infrastructure from external threats and ensure
low-latency, reliable connectivity to exchanges and market data providers.

================================================================================
SECURITY ARCHITECTURE
================================================================================

1. NETWORK SEGMENTATION ARCHITECTURE
-------------------------------------

Defense-in-Depth Network Layers:

Internet
    │
    ↓
[Perimeter Firewall (DMZ)]
    │
    ├─→ Public-Facing Services (Web UI, API Gateway)
    │
    ↓
[Internal Firewall]
    │
    ├─→ Trading Zone (VLAN 10)
    │   ├── Trading Engines
    │   ├── Order Management Systems
    │   └── Market Data Feed Handlers
    │
    ├─→ Exchange Connectivity Zone (VLAN 20)
    │   ├── Exchange Gateway Servers
    │   ├── Market Data Receivers
    │   └── FIX Protocol Handlers
    │
    ├─→ Risk Management Zone (VLAN 30)
    │   ├── Risk Engine
    │   ├── Compliance Monitoring
    │   └── Kill Switch System
    │
    ├─→ Data Zone (VLAN 40)
    │   ├── Tick Databases
    │   ├── Order History
    │   └── Analytics Databases
    │
    ├─→ Management Zone (VLAN 50)
    │   ├── Monitoring Systems
    │   ├── Log Aggregation
    │   └── Configuration Management
    │
    └─→ Development/Testing Zone (VLAN 60)
        ├── Development Environments
        ├── Testing Environments
        └── CI/CD Infrastructure

2. FIREWALL ARCHITECTURE
-------------------------

Multi-Layer Firewall Strategy:

Layer 1: Perimeter Firewall (Border Protection)
├── DDoS Protection
├── Geo-blocking (Block non-trading regions)
├── Rate Limiting
└── IDS/IPS Integration

Layer 2: Internal Firewall (Zone Segmentation)
├── VLAN Isolation
├── Micro-segmentation
├── Application-Level Filtering
└── Stateful Inspection

Layer 3: Host-Based Firewall
├── Individual Server Protection
├── Process-Level Filtering
├── Egress Filtering
└── Local Security Policies

3. VPN ARCHITECTURE
-------------------

Site-to-Site VPN (Exchange Connectivity):
Exchange Network ←→ [IPsec VPN Tunnel] ←→ Trading Infrastructure
    ├── Encryption: AES-256-GCM
    ├── Authentication: Certificate-Based
    ├── Key Exchange: IKEv2
    └── Perfect Forward Secrecy

Remote Access VPN (Admin/Trading):
Remote Users ←→ [SSL VPN / WireGuard] ←→ Management Network
    ├── Multi-Factor Authentication
    ├── Device Posture Checking
    ├── Split Tunneling Disabled
    └── Session Timeout: 4 hours

4. NETWORK MONITORING ARCHITECTURE
-----------------------------------

Traffic Analysis:
├── NetFlow / sFlow Collection
├── Deep Packet Inspection (DPI)
├── Anomaly Detection
└── Bandwidth Monitoring

Security Monitoring:
├── Intrusion Detection System (IDS)
├── Intrusion Prevention System (IPS)
├── Security Information and Event Management (SIEM)
└── Network Behavior Analysis (NBA)

================================================================================
IMPLEMENTATION CODE EXAMPLES
================================================================================

1. IPTABLES FIREWALL CONFIGURATION (LINUX)
-------------------------------------------

```bash
#!/bin/bash
# Secure iptables configuration for HFT Trading Server

# Flush existing rules
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X

# Set default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP

# Allow loopback
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# Allow established and related connections
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Drop invalid packets
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

# Protection against common attacks
# SYN flood protection
iptables -N syn_flood
iptables -A INPUT -p tcp --syn -j syn_flood
iptables -A syn_flood -m limit --limit 1/s --limit-burst 3 -j RETURN
iptables -A syn_flood -j DROP

# Port scan protection
iptables -N port_scan
iptables -A port_scan -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit \
    --limit 1/s --limit-burst 2 -j RETURN
iptables -A port_scan -j DROP

# Ping flood protection
iptables -A INPUT -p icmp --icmp-type echo-request -m limit \
    --limit 1/s --limit-burst 2 -j ACCEPT
iptables -A INPUT -p icmp --icmp-type echo-request -j DROP

# Allow SSH from management network only (with rate limiting)
MGMT_NETWORK="10.0.50.0/24"
iptables -A INPUT -p tcp -s $MGMT_NETWORK --dport 22 -m conntrack \
    --ctstate NEW -m recent --set --name ssh_conn
iptables -A INPUT -p tcp -s $MGMT_NETWORK --dport 22 -m conntrack \
    --ctstate NEW -m recent --update --seconds 60 --hitcount 4 \
    --name ssh_conn -j DROP
iptables -A INPUT -p tcp -s $MGMT_NETWORK --dport 22 -m conntrack \
    --ctstate NEW -j ACCEPT

# Allow exchange connectivity (specific IPs only)
EXCHANGE_IP_1="203.0.113.10"
EXCHANGE_IP_2="203.0.113.11"

# FIX protocol ports
iptables -A INPUT -p tcp -s $EXCHANGE_IP_1 --dport 8001:8010 -j ACCEPT
iptables -A OUTPUT -p tcp -d $EXCHANGE_IP_1 --dport 8001:8010 -j ACCEPT
iptables -A INPUT -p tcp -s $EXCHANGE_IP_2 --dport 8001:8010 -j ACCEPT
iptables -A OUTPUT -p tcp -d $EXCHANGE_IP_2 --dport 8001:8010 -j ACCEPT

# Market data multicast
MCAST_GROUP="239.1.1.0/24"
iptables -A INPUT -p udp -d $MCAST_GROUP --dport 10000:10100 -j ACCEPT

# Allow outbound DNS
iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT

# Allow outbound NTP
iptables -A OUTPUT -p udp --dport 123 -j ACCEPT

# Allow internal monitoring
MONITOR_SERVER="10.0.50.100"
iptables -A INPUT -p tcp -s $MONITOR_SERVER --dport 9100 -j ACCEPT  # Node exporter
iptables -A OUTPUT -p tcp -d $MONITOR_SERVER --dport 9090 -j ACCEPT # Prometheus

# Log dropped packets (rate limited)
iptables -A INPUT -m limit --limit 5/min -j LOG \
    --log-prefix "IPT-INPUT-DROP: " --log-level 4
iptables -A OUTPUT -m limit --limit 5/min -j LOG \
    --log-prefix "IPT-OUTPUT-DROP: " --log-level 4
iptables -A FORWARD -m limit --limit 5/min -j LOG \
    --log-prefix "IPT-FORWARD-DROP: " --log-level 4

# Save rules
iptables-save > /etc/iptables/rules.v4

echo "Firewall rules applied successfully"
```

2. NFTABLES CONFIGURATION (MODERN LINUX)
-----------------------------------------

```nft
#!/usr/sbin/nft -f
# nftables configuration for HFT Trading Server

# Flush existing rules
flush ruleset

# Define variables
define MGMT_NET = 10.0.50.0/24
define TRADING_NET = 10.0.10.0/24
define EXCHANGE_IP_1 = 203.0.113.10
define EXCHANGE_IP_2 = 203.0.113.11
define MCAST_GROUP = 239.1.1.0/24

table inet filter {
    # Connection tracking helpers
    ct helper ftp {
        type "ftp" protocol tcp
    }

    # Rate limiting sets
    set ssh_ratelimit {
        type ipv4_addr
        size 65536
        flags dynamic, timeout
        timeout 1m
    }

    # Blacklist set for automatic blocking
    set blacklist {
        type ipv4_addr
        flags timeout
        timeout 1h
    }

    chain input {
        type filter hook input priority filter; policy drop;

        # Allow loopback
        iif lo accept

        # Connection tracking
        ct state invalid drop
        ct state established,related accept

        # Drop from blacklist
        ip saddr @blacklist drop

        # Rate limit SSH
        tcp dport 22 ip saddr $MGMT_NET \
            ct state new \
            update @ssh_ratelimit { ip saddr limit rate 4/minute } \
            accept

        # Drop excessive SSH attempts and add to blacklist
        tcp dport 22 ip saddr $MGMT_NET \
            ct state new \
            add @blacklist { ip saddr timeout 1h } \
            drop

        # Exchange connectivity (FIX protocol)
        ip saddr { $EXCHANGE_IP_1, $EXCHANGE_IP_2 } \
            tcp dport 8001-8010 accept

        # Market data multicast
        ip daddr $MCAST_GROUP udp dport 10000-10100 accept

        # ICMP (rate limited)
        icmp type echo-request limit rate 1/second accept

        # Internal trading network
        ip saddr $TRADING_NET tcp dport { 7001-7010 } accept

        # Monitoring from management network
        ip saddr $MGMT_NET tcp dport { 9100, 9256 } accept

        # Log dropped packets (rate limited)
        limit rate 5/minute log prefix "NFT-INPUT-DROP: "
    }

    chain forward {
        type filter hook forward priority filter; policy drop;

        # No forwarding on trading servers
        limit rate 5/minute log prefix "NFT-FORWARD-DROP: "
    }

    chain output {
        type filter hook output priority filter; policy drop;

        # Allow loopback
        oif lo accept

        # Connection tracking
        ct state established,related accept

        # Exchange connectivity
        ip daddr { $EXCHANGE_IP_1, $EXCHANGE_IP_2 } \
            tcp dport 8001-8010 accept

        # DNS
        udp dport 53 accept
        tcp dport 53 accept

        # NTP
        udp dport 123 accept

        # HTTPS for updates (specific destinations only)
        # tcp dport 443 accept

        # Internal services
        ip daddr $MGMT_NET tcp dport { 9090, 3000, 8086 } accept

        # Log dropped packets (rate limited)
        limit rate 5/minute log prefix "NFT-OUTPUT-DROP: "
    }
}

# NAT table (if needed for outbound)
table ip nat {
    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;
        # SNAT configuration if required
        # ip saddr $TRADING_NET oifname "eth0" masquerade
    }
}
```

3. WIREGUARD VPN CONFIGURATION
-------------------------------

```ini
# /etc/wireguard/wg0.conf - WireGuard VPN Server Configuration

[Interface]
# Server private key (generated with: wg genkey)
PrivateKey = SERVER_PRIVATE_KEY_HERE

# Server IP address in VPN network
Address = 10.200.200.1/24

# Listening port
ListenPort = 51820

# Post-up and post-down scripts
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# DNS server for clients
DNS = 10.0.50.53

# MTU optimization for low latency
MTU = 1420

# Peer 1: Senior Trader
[Peer]
# Peer public key
PublicKey = TRADER1_PUBLIC_KEY_HERE

# Allowed IPs for this peer
AllowedIPs = 10.200.200.10/32

# Persistent keepalive for NAT traversal
PersistentKeepalive = 25

# Peer 2: Risk Manager
[Peer]
PublicKey = RISK_MGR_PUBLIC_KEY_HERE
AllowedIPs = 10.200.200.11/32
PersistentKeepalive = 25

# Peer 3: System Administrator
[Peer]
PublicKey = ADMIN1_PUBLIC_KEY_HERE
AllowedIPs = 10.200.200.20/32
PersistentKeepalive = 25
```

```ini
# /etc/wireguard/wg0.conf - WireGuard Client Configuration (Trader)

[Interface]
# Client private key
PrivateKey = CLIENT_PRIVATE_KEY_HERE

# Client VPN IP
Address = 10.200.200.10/24

# DNS
DNS = 10.0.50.53

# MTU
MTU = 1420

[Peer]
# Server public key
PublicKey = SERVER_PUBLIC_KEY_HERE

# Server endpoint
Endpoint = vpn.hft-system.com:51820

# Route only HFT network traffic through VPN (split tunnel)
AllowedIPs = 10.0.0.0/8

# Keepalive
PersistentKeepalive = 25
```

4. IPSEC VPN CONFIGURATION (StrongSwan)
----------------------------------------

```conf
# /etc/ipsec.conf - IPsec configuration for exchange connectivity

config setup
    charondebug="ike 2, knl 2, cfg 2, net 2, esp 2, dmn 2, mgr 2"
    uniqueids=never
    strictcrlpolicy=yes

conn exchange-connection
    # Authentication
    authby=rsasig
    leftcert=hft-gateway.pem
    leftid="C=US, O=HFT System, CN=hft-gateway.hft-system.com"
    rightid="C=US, O=Exchange, CN=gateway.exchange.com"

    # Key exchange
    keyexchange=ikev2
    ikelifetime=24h
    rekeymargin=3h
    keyingtries=3

    # Encryption
    ike=aes256gcm16-prfsha384-ecp384!
    esp=aes256gcm16-ecp384!

    # Perfect Forward Secrecy
    pfs=yes

    # Endpoints
    left=%defaultroute
    leftsubnet=10.0.10.0/24
    right=203.0.113.10
    rightsubnet=192.0.2.0/24

    # Options
    auto=start
    dpdaction=restart
    dpddelay=30s
    dpdtimeout=120s
    closeaction=restart

    # Compression (disable for low latency)
    compress=no

    # Mark packets for QoS
    mark=100
```

```conf
# /etc/ipsec.secrets - IPsec authentication secrets

# RSA private key
: RSA hft-gateway-key.pem "optional_passphrase"

# Pre-shared keys (if using PSK instead of certificates)
# 203.0.113.10 : PSK "very-strong-pre-shared-key-here"
```

5. NETWORK TRAFFIC ANALYZER (C++)
----------------------------------

```cpp
#include <pcap.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <iostream>
#include <atomic>
#include <thread>
#include <map>
#include <mutex>

class NetworkTrafficAnalyzer {
private:
    struct TrafficStats {
        std::atomic<uint64_t> packet_count{0};
        std::atomic<uint64_t> byte_count{0};
        std::atomic<uint64_t> tcp_count{0};
        std::atomic<uint64_t> udp_count{0};
        std::atomic<uint64_t> other_count{0};
    };

    struct FlowKey {
        uint32_t src_ip;
        uint32_t dst_ip;
        uint16_t src_port;
        uint16_t dst_port;
        uint8_t protocol;

        bool operator<(const FlowKey& other) const {
            if (src_ip != other.src_ip) return src_ip < other.src_ip;
            if (dst_ip != other.dst_ip) return dst_ip < other.dst_ip;
            if (src_port != other.src_port) return src_port < other.src_port;
            if (dst_port != other.dst_port) return dst_port < other.dst_port;
            return protocol < other.protocol;
        }
    };

    struct FlowStats {
        uint64_t packet_count{0};
        uint64_t byte_count{0};
        std::chrono::system_clock::time_point first_seen;
        std::chrono::system_clock::time_point last_seen;
    };

    pcap_t* handle_{nullptr};
    std::string interface_;
    TrafficStats global_stats_;
    std::map<FlowKey, FlowStats> flow_table_;
    std::mutex flow_table_mutex_;
    std::atomic<bool> running_{false};

public:
    explicit NetworkTrafficAnalyzer(const std::string& interface)
        : interface_(interface) {}

    ~NetworkTrafficAnalyzer() {
        stop();
    }

    bool start(const std::string& filter = "") {
        char errbuf[PCAP_ERRBUF_SIZE];

        // Open network interface
        handle_ = pcap_open_live(interface_.c_str(),
                                BUFSIZ,
                                1,  // Promiscuous mode
                                1000,  // Read timeout (ms)
                                errbuf);

        if (!handle_) {
            std::cerr << "Failed to open interface: " << errbuf << std::endl;
            return false;
        }

        // Apply BPF filter if provided
        if (!filter.empty()) {
            struct bpf_program fp;
            if (pcap_compile(handle_, &fp, filter.c_str(), 0,
                           PCAP_NETMASK_UNKNOWN) == -1) {
                std::cerr << "Failed to compile filter: "
                         << pcap_geterr(handle_) << std::endl;
                pcap_close(handle_);
                return false;
            }

            if (pcap_setfilter(handle_, &fp) == -1) {
                std::cerr << "Failed to set filter: "
                         << pcap_geterr(handle_) << std::endl;
                pcap_freecode(&fp);
                pcap_close(handle_);
                return false;
            }

            pcap_freecode(&fp);
        }

        running_ = true;

        // Start packet capture thread
        std::thread([this]() {
            this->captureLoop();
        }).detach();

        return true;
    }

    void stop() {
        running_ = false;

        if (handle_) {
            pcap_breakloop(handle_);
            pcap_close(handle_);
            handle_ = nullptr;
        }
    }

    void printStats() const {
        std::cout << "\n=== Network Traffic Statistics ===\n";
        std::cout << "Total Packets: " << global_stats_.packet_count << "\n";
        std::cout << "Total Bytes: " << global_stats_.byte_count << "\n";
        std::cout << "TCP Packets: " << global_stats_.tcp_count << "\n";
        std::cout << "UDP Packets: " << global_stats_.udp_count << "\n";
        std::cout << "Other Packets: " << global_stats_.other_count << "\n";

        std::lock_guard<std::mutex> lock(
            const_cast<std::mutex&>(flow_table_mutex_));

        std::cout << "\n=== Top 10 Flows by Packet Count ===\n";

        std::vector<std::pair<FlowKey, FlowStats>> flows(
            flow_table_.begin(), flow_table_.end());

        std::sort(flows.begin(), flows.end(),
                 [](const auto& a, const auto& b) {
                     return a.second.packet_count > b.second.packet_count;
                 });

        for (size_t i = 0; i < std::min(size_t(10), flows.size()); ++i) {
            const auto& [key, stats] = flows[i];

            struct in_addr src_addr, dst_addr;
            src_addr.s_addr = key.src_ip;
            dst_addr.s_addr = key.dst_ip;

            std::cout << inet_ntoa(src_addr) << ":" << key.src_port
                     << " -> " << inet_ntoa(dst_addr) << ":" << key.dst_port
                     << " (" << (key.protocol == IPPROTO_TCP ? "TCP" : "UDP")
                     << ") - Packets: " << stats.packet_count
                     << ", Bytes: " << stats.byte_count << "\n";
        }
    }

    // Detect potential DDoS or anomalous traffic
    bool detectAnomalies() const {
        std::lock_guard<std::mutex> lock(
            const_cast<std::mutex&>(flow_table_mutex_));

        // Check for single source generating excessive traffic
        std::map<uint32_t, uint64_t> src_packet_count;

        for (const auto& [key, stats] : flow_table_) {
            src_packet_count[key.src_ip] += stats.packet_count;
        }

        for (const auto& [src_ip, count] : src_packet_count) {
            // Alert if single source > 10% of total traffic
            if (count > global_stats_.packet_count * 0.1) {
                struct in_addr addr;
                addr.s_addr = src_ip;
                std::cerr << "[ALERT] Anomalous traffic from "
                         << inet_ntoa(addr)
                         << " (" << count << " packets)" << std::endl;
                return true;
            }
        }

        return false;
    }

private:
    void captureLoop() {
        while (running_) {
            struct pcap_pkthdr* header;
            const u_char* packet;

            int result = pcap_next_ex(handle_, &header, &packet);

            if (result == 1) {
                processPacket(header, packet);
            } else if (result == -1) {
                std::cerr << "Error reading packet: "
                         << pcap_geterr(handle_) << std::endl;
                break;
            }
        }
    }

    void processPacket(const struct pcap_pkthdr* header,
                      const u_char* packet) {
        global_stats_.packet_count++;
        global_stats_.byte_count += header->len;

        // Parse Ethernet header (14 bytes)
        if (header->caplen < 14) return;

        // Parse IP header
        const struct ip* ip_header =
            reinterpret_cast<const struct ip*>(packet + 14);

        if (header->caplen < 14 + sizeof(struct ip)) return;

        FlowKey key;
        key.src_ip = ip_header->ip_src.s_addr;
        key.dst_ip = ip_header->ip_dst.s_addr;
        key.protocol = ip_header->ip_p;

        size_t ip_header_len = ip_header->ip_hl * 4;

        // Parse transport layer header
        if (ip_header->ip_p == IPPROTO_TCP) {
            global_stats_.tcp_count++;

            const struct tcphdr* tcp_header =
                reinterpret_cast<const struct tcphdr*>(
                    packet + 14 + ip_header_len);

            if (header->caplen < 14 + ip_header_len + sizeof(struct tcphdr))
                return;

            key.src_port = ntohs(tcp_header->th_sport);
            key.dst_port = ntohs(tcp_header->th_dport);

        } else if (ip_header->ip_p == IPPROTO_UDP) {
            global_stats_.udp_count++;

            const struct udphdr* udp_header =
                reinterpret_cast<const struct udphdr*>(
                    packet + 14 + ip_header_len);

            if (header->caplen < 14 + ip_header_len + sizeof(struct udphdr))
                return;

            key.src_port = ntohs(udp_header->uh_sport);
            key.dst_port = ntohs(udp_header->uh_dport);

        } else {
            global_stats_.other_count++;
            key.src_port = 0;
            key.dst_port = 0;
        }

        // Update flow table
        std::lock_guard<std::mutex> lock(flow_table_mutex_);

        auto& flow = flow_table_[key];
        if (flow.packet_count == 0) {
            flow.first_seen = std::chrono::system_clock::now();
        }

        flow.packet_count++;
        flow.byte_count += header->len;
        flow.last_seen = std::chrono::system_clock::now();
    }
};
```

================================================================================
CONFIGURATION TEMPLATES
================================================================================

1. NETWORK SEGMENTATION CONFIGURATION (VLAN)
---------------------------------------------

```bash
# /etc/network/interfaces - VLAN Configuration

auto eth0
iface eth0 inet manual

# Trading VLAN (10)
auto eth0.10
iface eth0.10 inet static
    address 10.0.10.100
    netmask 255.255.255.0
    vlan-raw-device eth0

# Exchange Connectivity VLAN (20)
auto eth0.20
iface eth0.20 inet static
    address 10.0.20.100
    netmask 255.255.255.0
    vlan-raw-device eth0

# Risk Management VLAN (30)
auto eth0.30
iface eth0.30 inet static
    address 10.0.30.100
    netmask 255.255.255.0
    vlan-raw-device eth0

# Data VLAN (40)
auto eth0.40
iface eth0.40 inet static
    address 10.0.40.100
    netmask 255.255.255.0
    vlan-raw-device eth0

# Management VLAN (50)
auto eth0.50
iface eth0.50 inet static
    address 10.0.50.100
    netmask 255.255.255.0
    gateway 10.0.50.1
    vlan-raw-device eth0
```

2. QOS CONFIGURATION FOR LOW-LATENCY TRAFFIC
---------------------------------------------

```bash
#!/bin/bash
# Quality of Service (QoS) configuration for HFT traffic

IFACE="eth0.20"  # Exchange connectivity interface

# Clear existing qdisc
tc qdisc del dev $IFACE root 2>/dev/null

# Create HTB root qdisc
tc qdisc add dev $IFACE root handle 1: htb default 30

# Create root class (1 Gbps)
tc class add dev $IFACE parent 1: classid 1:1 htb rate 1000mbit

# High priority class for trading traffic (700 Mbps guaranteed)
tc class add dev $IFACE parent 1:1 classid 1:10 htb \
    rate 700mbit ceil 1000mbit prio 1

# Medium priority for market data (200 Mbps guaranteed)
tc class add dev $IFACE parent 1:1 classid 1:20 htb \
    rate 200mbit ceil 1000mbit prio 2

# Low priority for other traffic (100 Mbps)
tc class add dev $IFACE parent 1:1 classid 1:30 htb \
    rate 100mbit ceil 1000mbit prio 3

# Attach pfifo_fast qdisc to leaf classes for minimal latency
tc qdisc add dev $IFACE parent 1:10 handle 10: pfifo_fast
tc qdisc add dev $IFACE parent 1:20 handle 20: pfifo_fast
tc qdisc add dev $IFACE parent 1:30 handle 30: pfifo_fast

# Filter rules
# High priority: FIX protocol (port 8001-8010)
tc filter add dev $IFACE protocol ip parent 1: prio 1 u32 \
    match ip dport 8001 0xfff0 flowid 1:10

# Medium priority: Market data (multicast)
tc filter add dev $IFACE protocol ip parent 1: prio 2 u32 \
    match ip dst 239.1.1.0/24 flowid 1:20

# Mark packets for iptables integration
iptables -t mangle -A POSTROUTING -o $IFACE -p tcp --dport 8001:8010 \
    -j CLASSIFY --set-class 1:10

echo "QoS configuration applied to $IFACE"
```

3. DDOS PROTECTION CONFIGURATION (FAIL2BAN)
--------------------------------------------

```ini
# /etc/fail2ban/jail.local - Fail2ban configuration

[DEFAULT]
# Ban time: 1 hour
bantime = 3600

# Find time window: 10 minutes
findtime = 600

# Max retries before ban
maxretry = 5

# Destination email for alerts
destemail = security@hft-system.com
sender = fail2ban@hft-system.com

# Ban action (iptables + email notification)
banaction = iptables-multiport
action = %(action_mwl)s

[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 7200

[nginx-limit-req]
enabled = true
port = http,https
filter = nginx-limit-req
logpath = /var/log/nginx/error.log
maxretry = 10

[nginx-noscript]
enabled = true
port = http,https
filter = nginx-noscript
logpath = /var/log/nginx/access.log
maxretry = 6

[nginx-badbots]
enabled = true
port = http,https
filter = nginx-badbots
logpath = /var/log/nginx/access.log
maxretry = 2

[port-scan]
enabled = true
filter = port-scan
logpath = /var/log/syslog
maxretry = 1
bantime = 86400
```

================================================================================
THREAT MODELS
================================================================================

THREAT 1: DISTRIBUTED DENIAL OF SERVICE (DDoS) ATTACK
------------------------------------------------------
Threat Actor: Competitor or malicious actor
Attack Vector: Flood trading infrastructure with traffic
Impact: CRITICAL - Trading disruption, missed opportunities, financial loss

Mitigation:
1. DDoS protection service (Cloudflare, Akamai)
2. Rate limiting at multiple layers
3. Geo-blocking of non-trading regions
4. Traffic scrubbing and filtering
5. Overprovisioned bandwidth
6. BGP blackholing for severe attacks

Detection:
- Abnormal traffic volume
- Traffic from unusual sources
- Service degradation
- Network latency spikes
- Bandwidth saturation

Response:
1. Activate DDoS mitigation service
2. Enable aggressive rate limiting
3. Blackhole attack traffic
4. Notify ISP/upstream provider
5. Failover to backup connectivity

THREAT 2: MAN-IN-THE-MIDDLE (MITM) ON EXCHANGE CONNECTION
----------------------------------------------------------
Threat Actor: Advanced persistent threat (APT)
Attack Vector: Intercept or modify traffic to/from exchange
Impact: CRITICAL - Order manipulation, data theft, unauthorized trading

Mitigation:
1. Mandatory IPsec/VPN for all exchange connections
2. Certificate pinning
3. Mutual authentication
4. Network path verification
5. Encrypted and authenticated protocols

Detection:
- Certificate validation failures
- Unexpected network paths
- Latency anomalies
- Order acknowledgment mismatches
- Authentication errors

Response:
1. Immediately terminate suspicious connections
2. Halt trading on affected connections
3. Verify all recent orders with exchange
4. Investigate network path
5. Review certificates and authentication logs

THREAT 3: INTERNAL NETWORK LATERAL MOVEMENT
--------------------------------------------
Threat Actor: Attacker who compromised one system
Attack Vector: Move laterally to access other network segments
Impact: HIGH - Data breach, system compromise, trading disruption

Mitigation:
1. Network segmentation (VLANs)
2. Micro-segmentation
3. Host-based firewalls
4. Principle of least privilege
5. Network access control (NAC)
6. Zero trust architecture

Detection:
- Unusual inter-VLAN traffic
- Unexpected service access
- Privilege escalation attempts
- Lateral movement patterns
- Suspicious authentication

Response:
1. Isolate compromised system
2. Block suspicious traffic flows
3. Review access logs
4. Conduct forensic analysis
5. Re-image compromised systems

================================================================================
SECURITY CHECKLISTS
================================================================================

FIREWALL CONFIGURATION CHECKLIST
---------------------------------
[ ] Default deny policy enforced
[ ] Explicit allow rules for necessary traffic only
[ ] Rules reviewed and documented
[ ] Unused rules removed
[ ] Rule logging enabled
[ ] DDoS protection mechanisms in place
[ ] Rate limiting configured
[ ] Geo-blocking enabled (if applicable)
[ ] Regular rule audits scheduled
[ ] Firewall firmware/software up to date
[ ] Backup firewall configuration maintained
[ ] Change management process followed

VPN CONFIGURATION CHECKLIST
----------------------------
[ ] Strong encryption algorithms (AES-256-GCM)
[ ] Perfect Forward Secrecy enabled
[ ] Certificate-based authentication configured
[ ] Multi-factor authentication for remote access
[ ] VPN logs monitored
[ ] Split tunneling disabled (where appropriate)
[ ] Session timeouts configured
[ ] Dead peer detection enabled
[ ] VPN software/firmware up to date
[ ] Backup VPN concentrators configured
[ ] VPN performance monitored
[ ] Regular VPN connectivity tests

NETWORK SEGMENTATION CHECKLIST
-------------------------------
[ ] VLANs configured for each security zone
[ ] Inter-VLAN routing restricted
[ ] Firewall between security zones
[ ] No direct connectivity between untrusted zones
[ ] Jump hosts for administrative access
[ ] Network access control (NAC) implemented
[ ] VLAN tagging enforced
[ ] Broadcast domains isolated
[ ] Regular network scans performed
[ ] Network diagram maintained and current
[ ] Access control lists (ACLs) configured
[ ] Segmentation effectiveness tested

================================================================================
INCIDENT RESPONSE PROCEDURES
================================================================================

INCIDENT: NETWORK INTRUSION DETECTED
-------------------------------------

PHASE 1: DETECTION (0-5 minutes)
---------------------------------
1. Identify intrusion indicators:
   - IDS/IPS alerts
   - Unusual network traffic patterns
   - Unexpected connections
   - Firewall rule violations

2. Assess scope:
   - Source IP and location
   - Target systems
   - Traffic volume
   - Protocols involved

3. Classify severity:
   - CRITICAL: Active exploitation or data exfiltration
   - HIGH: Successful unauthorized access
   - MEDIUM: Scanning or reconnaissance

PHASE 2: CONTAINMENT (5-30 minutes)
------------------------------------
1. Block attacker IP addresses:
   - Add to firewall blacklist
   - Update IPS rules
   - Implement geo-blocking if needed

2. Isolate affected systems:
   - VLAN isolation
   - ACL updates
   - Disable network interfaces if necessary

3. Preserve evidence:
   - Capture packet dumps
   - Save firewall logs
   - Preserve IDS/IPS alerts

PHASE 3: ERADICATION (30 minutes - 4 hours)
--------------------------------------------
1. Remove attacker access:
   - Close unauthorized connections
   - Revoke compromised credentials
   - Patch vulnerabilities

2. Verify all systems:
   - Scan for indicators of compromise
   - Check for backdoors
   - Review system logs

3. Harden defenses:
   - Update firewall rules
   - Strengthen access controls
   - Deploy additional monitoring

PHASE 4: RECOVERY (4-24 hours)
-------------------------------
1. Restore normal operations:
   - Re-enable isolated systems
   - Verify connectivity
   - Test trading functionality

2. Enhanced monitoring:
   - Increase logging detail
   - Deploy additional sensors
   - Review alerts more frequently

3. Verify security:
   - Penetration testing
   - Vulnerability scan
   - Configuration audit

PHASE 5: POST-INCIDENT (24-72 hours)
-------------------------------------
1. Root cause analysis:
   - How did intrusion occur
   - What was compromised
   - Lessons learned

2. Update defenses:
   - Implement new controls
   - Update firewall rules
   - Enhance monitoring

3. Documentation:
   - Complete incident report
   - Update runbooks
   - Brief stakeholders

================================================================================
BEST PRACTICES SUMMARY
================================================================================

1. IMPLEMENT defense-in-depth with multiple firewall layers
2. USE network segmentation to isolate security zones
3. ENABLE encryption for all external connections (VPN/IPsec)
4. CONFIGURE DDoS protection and rate limiting
5. MONITOR network traffic continuously
6. IMPLEMENT strict egress filtering
7. USE certificate-based authentication for VPNs
8. ENABLE perfect forward secrecy
9. CONFIGURE QoS for critical trading traffic
10. REGULARLY audit and update firewall rules
11. MAINTAIN network diagrams and documentation
12. TEST security controls regularly
13. IMPLEMENT zero trust network principles
14. USE geo-blocking where appropriate
15. MAINTAIN backup network connectivity

================================================================================
END OF DOCUMENT
================================================================================
