================================================================================
SECRETS MANAGEMENT: VAULT, KMS, AND SECURE CREDENTIALS FOR HFT SYSTEMS
================================================================================

OVERVIEW
--------
This document provides comprehensive guidelines for managing secrets, credentials,
API keys, and cryptographic keys in high-frequency trading systems using HashiCorp
Vault, AWS KMS, and other secrets management solutions. Proper secrets management
is critical to prevent credential theft and unauthorized access.

================================================================================
SECURITY ARCHITECTURE
================================================================================

1. SECRETS MANAGEMENT HIERARCHY
--------------------------------

Tier 1: Root Secrets (Highest Security)
├── Master Encryption Keys
├── Root CA Private Keys
├── HSM Master Keys
└── Vault Unseal Keys

Tier 2: Application Secrets
├── Database Credentials
├── API Keys (Exchange, Broker)
├── Service Account Credentials
└── TLS/SSL Certificates

Tier 3: Configuration Secrets
├── Environment Variables
├── Configuration Parameters
└── Feature Flags

2. VAULT ARCHITECTURE
----------------------

HashiCorp Vault Cluster:
┌─────────────────────────────────────┐
│     Vault Cluster (HA)              │
│  ┌────────┐  ┌────────┐  ┌────────┐│
│  │ Node 1 │  │ Node 2 │  │ Node 3 ││
│  │Active  │  │Standby │  │Standby ││
│  └────────┘  └────────┘  └────────┘│
│          Storage Backend             │
│         (Consul/etcd)                │
└─────────────────────────────────────┘
           │
           ├── Secret Engines
           │   ├── KV (Key-Value) Store
           │   ├── Dynamic Database Credentials
           │   ├── PKI (Certificate Authority)
           │   ├── Transit (Encryption as a Service)
           │   └── SSH Certificate Authority
           │
           ├── Authentication Methods
           │   ├── AppRole (Service Authentication)
           │   ├── Kubernetes
           │   ├── LDAP
           │   └── TLS Certificates
           │
           └── Policies
               ├── Trading System Policy
               ├── Risk Management Policy
               └── Admin Policy

3. AWS KMS INTEGRATION
-----------------------

AWS KMS Architecture:
Customer Master Keys (CMK)
├── HFT-Master-Key (Symmetric)
│   └── Used for: Data Encryption Keys
├── HFT-DB-Key (Symmetric)
│   └── Used for: Database Encryption
└── HFT-Signing-Key (Asymmetric)
    └── Used for: Digital Signatures

Key Rotation:
- Automatic annual rotation
- Manual rotation for suspected compromise
- Version management for backward compatibility

4. SECRET ROTATION STRATEGY
----------------------------

Rotation Schedule:
- Database Passwords: Every 90 days
- API Keys: Every 60 days
- Service Account Credentials: Every 30 days
- TLS Certificates: Every 365 days (auto-renewed at 30 days)
- SSH Keys: Every 180 days

Rotation Process:
1. Generate new secret
2. Update secret in Vault
3. Deploy new secret to applications
4. Verify new secret works
5. Revoke old secret
6. Monitor for issues

================================================================================
IMPLEMENTATION CODE EXAMPLES
================================================================================

1. HASHICORP VAULT CLIENT (C++)
--------------------------------

```cpp
#include <curl/curl.h>
#include <json/json.h>
#include <string>
#include <optional>

class VaultClient {
private:
    std::string vault_addr_;
    std::string vault_token_;
    std::string mount_point_;

    static size_t writeCallback(void* contents, size_t size, size_t nmemb,
                               void* userp) {
        ((std::string*)userp)->append((char*)contents, size * nmemb);
        return size * nmemb;
    }

public:
    VaultClient(const std::string& addr, const std::string& token,
               const std::string& mount = "secret")
        : vault_addr_(addr), vault_token_(token), mount_point_(mount) {}

    // Read secret from Vault
    std::optional<Json::Value> readSecret(const std::string& path) {
        CURL* curl = curl_easy_init();
        if (!curl) return std::nullopt;

        std::string url = vault_addr_ + "/v1/" + mount_point_ + 
                         "/data/" + path;
        std::string response;

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers,
                  ("X-Vault-Token: " + vault_token_).c_str());

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);

        CURLcode res = curl_easy_perform(curl);
        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        if (res != CURLE_OK || http_code != 200) {
            return std::nullopt;
        }

        Json::CharReaderBuilder builder;
        Json::Value root;
        std::istringstream ss(response);
        std::string errs;

        if (!Json::parseFromStream(builder, ss, &root, &errs)) {
            return std::nullopt;
        }

        return root["data"]["data"];
    }

    // Write secret to Vault
    bool writeSecret(const std::string& path, const Json::Value& data) {
        CURL* curl = curl_easy_init();
        if (!curl) return false;

        Json::Value payload;
        payload["data"] = data;

        Json::StreamWriterBuilder builder;
        std::string json_data = Json::writeString(builder, payload);

        std::string url = vault_addr_ + "/v1/" + mount_point_ + 
                         "/data/" + path;
        std::string response;

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers,
                  ("X-Vault-Token: " + vault_token_).c_str());
        headers = curl_slist_append(headers, "Content-Type: application/json");

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);

        CURLcode res = curl_easy_perform(curl);
        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        return (res == CURLE_OK && (http_code == 200 || http_code == 204));
    }

    // Delete secret from Vault
    bool deleteSecret(const std::string& path) {
        CURL* curl = curl_easy_init();
        if (!curl) return false;

        std::string url = vault_addr_ + "/v1/" + mount_point_ + 
                         "/data/" + path;

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers,
                  ("X-Vault-Token: " + vault_token_).c_str());

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);

        CURLcode res = curl_easy_perform(curl);
        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        return (res == CURLE_OK && http_code == 204);
    }

    // Authenticate with AppRole
    static std::optional<std::string> authenticateAppRole(
        const std::string& vault_addr,
        const std::string& role_id,
        const std::string& secret_id) {

        CURL* curl = curl_easy_init();
        if (!curl) return std::nullopt;

        Json::Value payload;
        payload["role_id"] = role_id;
        payload["secret_id"] = secret_id;

        Json::StreamWriterBuilder builder;
        std::string json_data = Json::writeString(builder, payload);

        std::string url = vault_addr + "/v1/auth/approle/login";
        std::string response;

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers, "Content-Type: application/json");

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);

        CURLcode res = curl_easy_perform(curl);
        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        if (res != CURLE_OK || http_code != 200) {
            return std::nullopt;
        }

        Json::CharReaderBuilder reader_builder;
        Json::Value root;
        std::istringstream ss(response);
        std::string errs;

        if (!Json::parseFromStream(reader_builder, ss, &root, &errs)) {
            return std::nullopt;
        }

        return root["auth"]["client_token"].asString();
    }

    // Renew token
    bool renewToken(int increment_seconds = 3600) {
        CURL* curl = curl_easy_init();
        if (!curl) return false;

        Json::Value payload;
        payload["increment"] = increment_seconds;

        Json::StreamWriterBuilder builder;
        std::string json_data = Json::writeString(builder, payload);

        std::string url = vault_addr_ + "/v1/auth/token/renew-self";
        std::string response;

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers,
                  ("X-Vault-Token: " + vault_token_).c_str());
        headers = curl_slist_append(headers, "Content-Type: application/json");

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);

        CURLcode res = curl_easy_perform(curl);
        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        return (res == CURLE_OK && http_code == 200);
    }

    // Dynamic database credentials
    std::optional<std::pair<std::string, std::string>> getDatabaseCredentials(
        const std::string& role_name) {

        CURL* curl = curl_easy_init();
        if (!curl) return std::nullopt;

        std::string url = vault_addr_ + "/v1/database/creds/" + role_name;
        std::string response;

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers,
                  ("X-Vault-Token: " + vault_token_).c_str());

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);

        CURLcode res = curl_easy_perform(curl);
        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        if (res != CURLE_OK || http_code != 200) {
            return std::nullopt;
        }

        Json::CharReaderBuilder builder;
        Json::Value root;
        std::istringstream ss(response);
        std::string errs;

        if (!Json::parseFromStream(builder, ss, &root, &errs)) {
            return std::nullopt;
        }

        std::string username = root["data"]["username"].asString();
        std::string password = root["data"]["password"].asString();

        return std::make_pair(username, password);
    }

    // Transit encryption (Encryption as a Service)
    std::optional<std::string> encrypt(const std::string& plaintext,
                                      const std::string& key_name) {
        CURL* curl = curl_easy_init();
        if (!curl) return std::nullopt;

        // Base64 encode plaintext
        std::string encoded = base64Encode(plaintext);

        Json::Value payload;
        payload["plaintext"] = encoded;

        Json::StreamWriterBuilder builder;
        std::string json_data = Json::writeString(builder, payload);

        std::string url = vault_addr_ + "/v1/transit/encrypt/" + key_name;
        std::string response;

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers,
                  ("X-Vault-Token: " + vault_token_).c_str());
        headers = curl_slist_append(headers, "Content-Type: application/json");

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);

        CURLcode res = curl_easy_perform(curl);
        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        if (res != CURLE_OK || http_code != 200) {
            return std::nullopt;
        }

        Json::CharReaderBuilder reader_builder;
        Json::Value root;
        std::istringstream ss(response);
        std::string errs;

        if (!Json::parseFromStream(reader_builder, ss, &root, &errs)) {
            return std::nullopt;
        }

        return root["data"]["ciphertext"].asString();
    }

private:
    std::string base64Encode(const std::string& input) {
        BIO *bio, *b64;
        BUF_MEM *buffer_ptr;

        b64 = BIO_new(BIO_f_base64());
        bio = BIO_new(BIO_s_mem());
        bio = BIO_push(b64, bio);

        BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
        BIO_write(bio, input.c_str(), input.length());
        BIO_flush(bio);
        BIO_get_mem_ptr(bio, &buffer_ptr);

        std::string result(buffer_ptr->data, buffer_ptr->length);
        BIO_free_all(bio);

        return result;
    }
};
```

2. AWS KMS CLIENT (C++)
------------------------

```cpp
#include <aws/core/Aws.h>
#include <aws/kms/KMSClient.h>
#include <aws/kms/model/EncryptRequest.h>
#include <aws/kms/model/DecryptRequest.h>
#include <aws/kms/model/GenerateDataKeyRequest.h>
#include <aws/core/utils/Outcome.h>
#include <aws/core/utils/memory/stl/AWSString.h>

class AWSKMSClient {
private:
    std::unique_ptr<Aws::KMS::KMSClient> kms_client_;
    std::string master_key_id_;

public:
    AWSKMSClient(const std::string& region, const std::string& key_id)
        : master_key_id_(key_id) {

        Aws::Client::ClientConfiguration config;
        config.region = region.c_str();

        kms_client_ = std::make_unique<Aws::KMS::KMSClient>(config);
    }

    // Encrypt data with KMS
    std::optional<std::vector<unsigned char>> encrypt(
        const std::vector<unsigned char>& plaintext) {

        Aws::KMS::Model::EncryptRequest request;
        request.SetKeyId(master_key_id_.c_str());

        Aws::Utils::ByteBuffer plaintext_buffer(
            plaintext.data(), plaintext.size());
        request.SetPlaintext(plaintext_buffer);

        auto outcome = kms_client_->Encrypt(request);

        if (!outcome.IsSuccess()) {
            std::cerr << "KMS Encrypt failed: "
                     << outcome.GetError().GetMessage() << std::endl;
            return std::nullopt;
        }

        const auto& ciphertext_blob = outcome.GetResult().GetCiphertextBlob();

        std::vector<unsigned char> ciphertext(
            ciphertext_blob.GetUnderlyingData(),
            ciphertext_blob.GetUnderlyingData() + ciphertext_blob.GetLength());

        return ciphertext;
    }

    // Decrypt data with KMS
    std::optional<std::vector<unsigned char>> decrypt(
        const std::vector<unsigned char>& ciphertext) {

        Aws::KMS::Model::DecryptRequest request;

        Aws::Utils::ByteBuffer ciphertext_buffer(
            ciphertext.data(), ciphertext.size());
        request.SetCiphertextBlob(ciphertext_buffer);

        auto outcome = kms_client_->Decrypt(request);

        if (!outcome.IsSuccess()) {
            std::cerr << "KMS Decrypt failed: "
                     << outcome.GetError().GetMessage() << std::endl;
            return std::nullopt;
        }

        const auto& plaintext_blob = outcome.GetResult().GetPlaintext();

        std::vector<unsigned char> plaintext(
            plaintext_blob.GetUnderlyingData(),
            plaintext_blob.GetUnderlyingData() + plaintext_blob.GetLength());

        return plaintext;
    }

    // Generate data encryption key
    struct DataKey {
        std::vector<unsigned char> plaintext_key;
        std::vector<unsigned char> encrypted_key;
    };

    std::optional<DataKey> generateDataKey(size_t key_size = 32) {
        Aws::KMS::Model::GenerateDataKeyRequest request;
        request.SetKeyId(master_key_id_.c_str());
        request.SetKeySpec(
            Aws::KMS::Model::DataKeySpec::AES_256);

        auto outcome = kms_client_->GenerateDataKey(request);

        if (!outcome.IsSuccess()) {
            std::cerr << "KMS GenerateDataKey failed: "
                     << outcome.GetError().GetMessage() << std::endl;
            return std::nullopt;
        }

        DataKey data_key;

        const auto& plaintext_blob = outcome.GetResult().GetPlaintext();
        data_key.plaintext_key.assign(
            plaintext_blob.GetUnderlyingData(),
            plaintext_blob.GetUnderlyingData() + plaintext_blob.GetLength());

        const auto& ciphertext_blob = outcome.GetResult().GetCiphertextBlob();
        data_key.encrypted_key.assign(
            ciphertext_blob.GetUnderlyingData(),
            ciphertext_blob.GetUnderlyingData() + ciphertext_blob.GetLength());

        return data_key;
    }
};
```

================================================================================
CONFIGURATION TEMPLATES
================================================================================

1. VAULT SERVER CONFIGURATION
------------------------------

```hcl
# vault-config.hcl

storage "consul" {
  address = "127.0.0.1:8500"
  path    = "vault/"
}

listener "tcp" {
  address     = "0.0.0.0:8200"
  tls_cert_file = "/etc/vault/tls/vault.crt"
  tls_key_file  = "/etc/vault/tls/vault.key"
  tls_min_version = "tls13"
}

api_addr = "https://vault.hft-system.local:8200"
cluster_addr = "https://vault.hft-system.local:8201"
ui = true

telemetry {
  prometheus_retention_time = "30s"
  disable_hostname = false
}

log_level = "INFO"
```

2. VAULT POLICY CONFIGURATION
------------------------------

```hcl
# trading-system-policy.hcl

# Read API keys
path "secret/data/api-keys/*" {
  capabilities = ["read", "list"]
}

# Read database credentials
path "database/creds/trading-db" {
  capabilities = ["read"]
}

# Transit encryption
path "transit/encrypt/trading-data" {
  capabilities = ["update"]
}

path "transit/decrypt/trading-data" {
  capabilities = ["update"]
}

# Renew own token
path "auth/token/renew-self" {
  capabilities = ["update"]
}
```

3. SECRET ROTATION SCRIPT
--------------------------

```bash
#!/bin/bash
# secret-rotation.sh - Automated secret rotation script

VAULT_ADDR="https://vault.hft-system.local:8200"
VAULT_TOKEN=$(cat /var/run/secrets/vault-token)

# Function to rotate database password
rotate_database_password() {
    local db_name=$1
    local role_name=$2

    echo "Rotating password for database: $db_name"

    # Generate new credentials from Vault
    response=$(curl -s -H "X-Vault-Token: $VAULT_TOKEN" \
        "$VAULT_ADDR/v1/database/creds/$role_name")

    username=$(echo "$response" | jq -r '.data.username')
    password=$(echo "$response" | jq -r '.data.password')

    # Update application configuration
    kubectl create secret generic db-credentials \
        --from-literal=username="$username" \
        --from-literal=password="$password" \
        --dry-run=client -o yaml | kubectl apply -f -

    # Restart application pods
    kubectl rollout restart deployment/trading-engine

    echo "Password rotation completed for $db_name"
}

# Function to rotate API key
rotate_api_key() {
    local service_name=$1

    echo "Rotating API key for service: $service_name"

    # Generate new API key
    new_key=$(openssl rand -hex 32)
    
    # Store in Vault
    curl -s -H "X-Vault-Token: $VAULT_TOKEN" \
        -H "Content-Type: application/json" \
        -d "{\"data\": {\"api_key\": \"$new_key\"}}" \
        "$VAULT_ADDR/v1/secret/data/api-keys/$service_name"

    echo "API key rotation completed for $service_name"
}

# Main rotation logic
case "$1" in
    database)
        rotate_database_password "trading-db" "trading-role"
        ;;
    api-key)
        rotate_api_key "$2"
        ;;
    *)
        echo "Usage: $0 {database|api-key SERVICE_NAME}"
        exit 1
        ;;
esac
```

================================================================================
BEST PRACTICES SUMMARY
================================================================================

1. NEVER store secrets in version control
2. USE centralized secrets management (Vault, KMS)
3. IMPLEMENT automatic secret rotation
4. ENABLE audit logging for all secret access
5. USE dynamic credentials where possible
6. IMPLEMENT principle of least privilege
7. ENCRYPT secrets at rest and in transit
8. USE separate secrets for different environments
9. IMPLEMENT secret versioning
10. MONITOR secret access patterns
11. REVOKE secrets immediately when compromised
12. USE short-lived credentials
13. IMPLEMENT break-glass procedures
14. REGULARLY audit secret usage
15. TRAIN personnel on secrets management

================================================================================
END OF DOCUMENT
================================================================================
