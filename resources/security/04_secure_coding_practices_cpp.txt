================================================================================
SECURE CODING PRACTICES FOR C++ IN HFT SYSTEMS
================================================================================

OVERVIEW
--------
This document provides comprehensive secure coding guidelines specifically
tailored for C++ development in high-frequency trading systems. Following
these practices is critical to prevent vulnerabilities that could lead to
system compromise, data breaches, or trading disruptions.

================================================================================
SECURITY ARCHITECTURE
================================================================================

1. SECURE DEVELOPMENT LIFECYCLE
--------------------------------

Phase 1: Requirements & Design
├── Security Requirements Definition
├── Threat Modeling
├── Security Architecture Review
└── Data Classification

Phase 2: Implementation
├── Secure Coding Standards
├── Code Review Process
├── Static Analysis Integration
└── Unit Testing with Security Focus

Phase 3: Testing & Validation
├── Dynamic Analysis
├── Penetration Testing
├── Fuzzing
└── Security Testing Automation

Phase 4: Deployment
├── Secure Configuration
├── Hardening Procedures
├── Security Monitoring
└── Incident Response Planning

Phase 5: Maintenance
├── Security Patch Management
├── Vulnerability Scanning
├── Security Updates
└── Continuous Monitoring

2. DEFENSE IN DEPTH LAYERS
---------------------------

Layer 1: Input Validation
- Validate all external inputs
- Sanitize user-provided data
- Reject invalid data early

Layer 2: Memory Safety
- Use RAII and smart pointers
- Avoid manual memory management
- Implement bounds checking

Layer 3: Type Safety
- Use strong typing
- Avoid unsafe casts
- Leverage modern C++ type system

Layer 4: Cryptographic Security
- Use vetted cryptographic libraries
- Never implement custom crypto
- Properly manage cryptographic keys

Layer 5: Concurrency Safety
- Thread-safe data structures
- Proper synchronization
- Avoid race conditions

================================================================================
IMPLEMENTATION CODE EXAMPLES
================================================================================

1. MEMORY SAFETY - RAII AND SMART POINTERS
-------------------------------------------

```cpp
// BAD: Manual memory management with potential leaks
class UnsafeOrderManager {
private:
    Order* orders[MAX_ORDERS];
    int order_count;

public:
    void addOrder(const OrderData& data) {
        // Memory leak if exception thrown before assignment
        Order* order = new Order(data);
        orders[order_count++] = order;
    }

    ~UnsafeOrderManager() {
        // If destructor throws, remaining orders leak
        for (int i = 0; i < order_count; ++i) {
            delete orders[i];
        }
    }
};

// GOOD: RAII with smart pointers
class SecureOrderManager {
private:
    std::vector<std::unique_ptr<Order>> orders_;
    mutable std::shared_mutex mutex_;

public:
    void addOrder(const OrderData& data) {
        std::unique_lock lock(mutex_);

        // Exception-safe: unique_ptr automatically cleans up
        auto order = std::make_unique<Order>(data);

        // Validate before adding
        if (!validateOrder(*order)) {
            throw std::invalid_argument("Invalid order data");
        }

        orders_.push_back(std::move(order));
    }

    std::shared_ptr<const Order> getOrder(size_t index) const {
        std::shared_lock lock(mutex_);

        if (index >= orders_.size()) {
            throw std::out_of_range("Invalid order index");
        }

        // Return shared_ptr for safe concurrent access
        return std::shared_ptr<const Order>(orders_[index].get(),
                                           [](const Order*) {
                                               // Non-owning deleter
                                           });
    }

private:
    bool validateOrder(const Order& order) const {
        // Implement validation logic
        return order.quantity > 0 &&
               order.price > 0.0 &&
               !order.symbol.empty();
    }
};
```

2. INPUT VALIDATION AND SANITIZATION
-------------------------------------

```cpp
#include <regex>
#include <stdexcept>
#include <limits>

class SecureInputValidator {
public:
    // Validate trading symbol (alphanumeric, max 10 chars)
    static bool validateSymbol(const std::string& symbol) {
        if (symbol.empty() || symbol.length() > 10) {
            return false;
        }

        static const std::regex symbol_regex("^[A-Z0-9]+$");
        return std::regex_match(symbol, symbol_regex);
    }

    // Validate price (must be positive, within reasonable range)
    static bool validatePrice(double price) {
        if (!std::isfinite(price)) {
            return false;
        }

        if (price <= 0.0 || price > 1000000.0) {
            return false;
        }

        // Check for precision issues
        if (std::abs(price - std::round(price * 100.0) / 100.0) > 1e-10) {
            return false; // More than 2 decimal places
        }

        return true;
    }

    // Validate quantity (must be positive integer)
    static bool validateQuantity(int64_t quantity) {
        return quantity > 0 && quantity <= 1000000;
    }

    // Validate order side
    enum class OrderSide { BUY, SELL };
    static std::optional<OrderSide> parseOrderSide(const std::string& side) {
        if (side == "BUY") return OrderSide::BUY;
        if (side == "SELL") return OrderSide::SELL;
        return std::nullopt;
    }

    // Sanitize string input (remove control characters)
    static std::string sanitizeString(const std::string& input,
                                     size_t max_length = 256) {
        std::string sanitized;
        sanitized.reserve(std::min(input.length(), max_length));

        for (char c : input) {
            if (sanitized.length() >= max_length) {
                break;
            }

            // Allow printable ASCII characters only
            if (c >= 32 && c <= 126) {
                sanitized += c;
            }
        }

        return sanitized;
    }

    // Validate and parse decimal string to avoid injection
    static std::optional<double> safeParseDouble(const std::string& str) {
        if (str.empty() || str.length() > 32) {
            return std::nullopt;
        }

        // Strict regex for decimal numbers
        static const std::regex decimal_regex(
            "^[+-]?[0-9]+\\.?[0-9]*$");

        if (!std::regex_match(str, decimal_regex)) {
            return std::nullopt;
        }

        try {
            size_t pos;
            double value = std::stod(str, &pos);

            // Ensure entire string was consumed
            if (pos != str.length()) {
                return std::nullopt;
            }

            if (!std::isfinite(value)) {
                return std::nullopt;
            }

            return value;

        } catch (...) {
            return std::nullopt;
        }
    }
};

// Secure order creation with validation
class SecureOrder {
private:
    std::string symbol_;
    double price_;
    int64_t quantity_;
    SecureInputValidator::OrderSide side_;

public:
    SecureOrder(const std::string& symbol,
               double price,
               int64_t quantity,
               SecureInputValidator::OrderSide side) {

        // Validate all inputs
        if (!SecureInputValidator::validateSymbol(symbol)) {
            throw std::invalid_argument("Invalid trading symbol");
        }

        if (!SecureInputValidator::validatePrice(price)) {
            throw std::invalid_argument("Invalid price");
        }

        if (!SecureInputValidator::validateQuantity(quantity)) {
            throw std::invalid_argument("Invalid quantity");
        }

        symbol_ = symbol;
        price_ = price;
        quantity_ = quantity;
        side_ = side;
    }

    // Getters with const correctness
    const std::string& getSymbol() const { return symbol_; }
    double getPrice() const { return price_; }
    int64_t getQuantity() const { return quantity_; }
    SecureInputValidator::OrderSide getSide() const { return side_; }
};
```

3. BUFFER OVERFLOW PREVENTION
------------------------------

```cpp
#include <array>
#include <vector>
#include <cstring>

// BAD: Unsafe buffer operations
class UnsafeBuffer {
private:
    char buffer[256];

public:
    void copyData(const char* source) {
        strcpy(buffer, source);  // UNSAFE: No bounds checking
    }

    void appendData(const char* data, size_t length) {
        // UNSAFE: No overflow check
        memcpy(buffer + strlen(buffer), data, length);
    }
};

// GOOD: Safe buffer operations
class SecureBuffer {
private:
    std::vector<char> buffer_;
    size_t max_size_;

public:
    explicit SecureBuffer(size_t max_size = 4096)
        : max_size_(max_size) {
        buffer_.reserve(max_size_);
    }

    bool copyData(const char* source, size_t length) {
        if (!source || length == 0 || length > max_size_) {
            return false;
        }

        buffer_.clear();
        buffer_.assign(source, source + length);
        return true;
    }

    bool copyData(const std::string& source) {
        if (source.length() > max_size_) {
            return false;
        }

        buffer_.clear();
        buffer_.assign(source.begin(), source.end());
        return true;
    }

    bool appendData(const char* data, size_t length) {
        if (!data || length == 0) {
            return false;
        }

        if (buffer_.size() + length > max_size_) {
            return false; // Would exceed maximum size
        }

        buffer_.insert(buffer_.end(), data, data + length);
        return true;
    }

    const char* data() const {
        return buffer_.data();
    }

    size_t size() const {
        return buffer_.size();
    }

    void clear() {
        // Securely clear sensitive data
        std::fill(buffer_.begin(), buffer_.end(), 0);
        buffer_.clear();
    }

    ~SecureBuffer() {
        clear();
    }
};

// Safe fixed-size buffer using std::array
template<size_t N>
class FixedSecureBuffer {
private:
    std::array<char, N> buffer_;
    size_t used_;

public:
    FixedSecureBuffer() : used_(0) {
        buffer_.fill(0);
    }

    bool write(const void* data, size_t length) {
        if (!data || length == 0 || length > N) {
            return false;
        }

        std::memcpy(buffer_.data(), data, length);
        used_ = length;
        return true;
    }

    bool append(const void* data, size_t length) {
        if (!data || length == 0) {
            return false;
        }

        if (used_ + length > N) {
            return false;
        }

        std::memcpy(buffer_.data() + used_, data, length);
        used_ += length;
        return true;
    }

    const char* data() const { return buffer_.data(); }
    size_t size() const { return used_; }
    size_t capacity() const { return N; }

    void clear() {
        buffer_.fill(0);
        used_ = 0;
    }

    ~FixedSecureBuffer() {
        clear();
    }
};
```

4. INTEGER OVERFLOW PROTECTION
-------------------------------

```cpp
#include <limits>
#include <optional>
#include <type_traits>

class SafeArithmetic {
public:
    // Safe addition with overflow detection
    template<typename T>
    static std::optional<T> safeAdd(T a, T b) {
        static_assert(std::is_integral<T>::value, "Integer type required");

        if constexpr (std::is_unsigned<T>::value) {
            if (a > std::numeric_limits<T>::max() - b) {
                return std::nullopt; // Overflow
            }
        } else {
            if (b > 0 && a > std::numeric_limits<T>::max() - b) {
                return std::nullopt; // Overflow
            }
            if (b < 0 && a < std::numeric_limits<T>::min() - b) {
                return std::nullopt; // Underflow
            }
        }

        return a + b;
    }

    // Safe multiplication with overflow detection
    template<typename T>
    static std::optional<T> safeMultiply(T a, T b) {
        static_assert(std::is_integral<T>::value, "Integer type required");

        if (a == 0 || b == 0) {
            return 0;
        }

        if constexpr (std::is_unsigned<T>::value) {
            if (a > std::numeric_limits<T>::max() / b) {
                return std::nullopt; // Overflow
            }
        } else {
            // Check for overflow in both directions
            if (a > 0 && b > 0 &&
                a > std::numeric_limits<T>::max() / b) {
                return std::nullopt;
            }
            if (a > 0 && b < 0 &&
                b < std::numeric_limits<T>::min() / a) {
                return std::nullopt;
            }
            if (a < 0 && b > 0 &&
                a < std::numeric_limits<T>::min() / b) {
                return std::nullopt;
            }
            if (a < 0 && b < 0 &&
                a < std::numeric_limits<T>::max() / b) {
                return std::nullopt;
            }
        }

        return a * b;
    }

    // Safe subtraction with underflow detection
    template<typename T>
    static std::optional<T> safeSubtract(T a, T b) {
        static_assert(std::is_integral<T>::value, "Integer type required");

        if constexpr (std::is_unsigned<T>::value) {
            if (a < b) {
                return std::nullopt; // Underflow
            }
        } else {
            if (b > 0 && a < std::numeric_limits<T>::min() + b) {
                return std::nullopt; // Underflow
            }
            if (b < 0 && a > std::numeric_limits<T>::max() + b) {
                return std::nullopt; // Overflow
            }
        }

        return a - b;
    }

    // Safe type conversion with range checking
    template<typename To, typename From>
    static std::optional<To> safeCast(From value) {
        static_assert(std::is_arithmetic<To>::value &&
                     std::is_arithmetic<From>::value,
                     "Arithmetic types required");

        if (value < std::numeric_limits<To>::lowest() ||
            value > std::numeric_limits<To>::max()) {
            return std::nullopt;
        }

        return static_cast<To>(value);
    }
};

// Example usage in trading calculations
class SafeTradingCalculator {
public:
    // Calculate position value with overflow protection
    static std::optional<int64_t> calculatePositionValue(
        int64_t quantity, int64_t price_cents) {

        auto value = SafeArithmetic::safeMultiply(quantity, price_cents);
        if (!value) {
            std::cerr << "Position value calculation overflow" << std::endl;
            return std::nullopt;
        }

        return value;
    }

    // Calculate total P&L with overflow protection
    static std::optional<int64_t> calculatePnL(
        int64_t realized_pnl, int64_t unrealized_pnl) {

        auto total = SafeArithmetic::safeAdd(realized_pnl, unrealized_pnl);
        if (!total) {
            std::cerr << "P&L calculation overflow" << std::endl;
            return std::nullopt;
        }

        return total;
    }

    // Calculate average price with precision
    static std::optional<double> calculateAveragePrice(
        const std::vector<int64_t>& prices) {

        if (prices.empty()) {
            return std::nullopt;
        }

        int64_t sum = 0;
        for (int64_t price : prices) {
            auto new_sum = SafeArithmetic::safeAdd(sum, price);
            if (!new_sum) {
                std::cerr << "Sum calculation overflow" << std::endl;
                return std::nullopt;
            }
            sum = *new_sum;
        }

        return static_cast<double>(sum) / prices.size();
    }
};
```

5. THREAD SAFETY AND RACE CONDITION PREVENTION
-----------------------------------------------

```cpp
#include <mutex>
#include <shared_mutex>
#include <atomic>
#include <condition_variable>

// BAD: Race condition vulnerability
class UnsafeCounter {
private:
    int64_t value_ = 0;

public:
    void increment() {
        value_++;  // NOT THREAD-SAFE
    }

    int64_t getValue() const {
        return value_;  // NOT THREAD-SAFE
    }
};

// GOOD: Thread-safe counter
class SafeCounter {
private:
    std::atomic<int64_t> value_{0};

public:
    void increment() {
        value_.fetch_add(1, std::memory_order_relaxed);
    }

    int64_t getValue() const {
        return value_.load(std::memory_order_relaxed);
    }

    // Compare-and-swap for conditional updates
    bool compareAndSet(int64_t expected, int64_t new_value) {
        return value_.compare_exchange_strong(expected, new_value,
                                             std::memory_order_release,
                                             std::memory_order_relaxed);
    }
};

// Thread-safe order book with reader-writer lock
class ThreadSafeOrderBook {
private:
    struct PriceLevel {
        double price;
        int64_t quantity;
        std::vector<std::string> order_ids;
    };

    std::map<double, PriceLevel> bids_;
    std::map<double, PriceLevel> asks_;
    mutable std::shared_mutex mutex_;

public:
    // Add order (write operation)
    bool addOrder(const std::string& order_id,
                 bool is_buy,
                 double price,
                 int64_t quantity) {
        std::unique_lock lock(mutex_);

        auto& book = is_buy ? bids_ : asks_;
        auto& level = book[price];

        level.price = price;
        level.quantity += quantity;
        level.order_ids.push_back(order_id);

        return true;
    }

    // Get best bid/ask (read operation)
    std::optional<double> getBestBid() const {
        std::shared_lock lock(mutex_);

        if (bids_.empty()) {
            return std::nullopt;
        }

        return bids_.rbegin()->first;
    }

    std::optional<double> getBestAsk() const {
        std::shared_lock lock(mutex_);

        if (asks_.empty()) {
            return std::nullopt;
        }

        return asks_.begin()->first;
    }

    // Get market depth (read operation)
    std::vector<PriceLevel> getDepth(bool is_buy, size_t levels) const {
        std::shared_lock lock(mutex_);

        const auto& book = is_buy ? bids_ : asks_;
        std::vector<PriceLevel> result;
        result.reserve(std::min(levels, book.size()));

        size_t count = 0;
        if (is_buy) {
            // Iterate from highest to lowest bid
            for (auto it = book.rbegin();
                 it != book.rend() && count < levels;
                 ++it, ++count) {
                result.push_back(it->second);
            }
        } else {
            // Iterate from lowest to highest ask
            for (auto it = book.begin();
                 it != book.end() && count < levels;
                 ++it, ++count) {
                result.push_back(it->second);
            }
        }

        return result;
    }

    // Cancel order (write operation)
    bool cancelOrder(const std::string& order_id,
                    bool is_buy,
                    double price,
                    int64_t quantity) {
        std::unique_lock lock(mutex_);

        auto& book = is_buy ? bids_ : asks_;
        auto it = book.find(price);

        if (it == book.end()) {
            return false;
        }

        auto& level = it->second;
        auto order_it = std::find(level.order_ids.begin(),
                                  level.order_ids.end(),
                                  order_id);

        if (order_it == level.order_ids.end()) {
            return false;
        }

        level.order_ids.erase(order_it);
        level.quantity -= quantity;

        if (level.quantity <= 0) {
            book.erase(it);
        }

        return true;
    }
};

// Lock-free queue for high-performance message passing
#include <queue>

template<typename T>
class LockFreeQueue {
private:
    struct Node {
        std::shared_ptr<T> data;
        std::atomic<Node*> next{nullptr};
    };

    std::atomic<Node*> head_;
    std::atomic<Node*> tail_;

public:
    LockFreeQueue() {
        Node* dummy = new Node();
        head_.store(dummy);
        tail_.store(dummy);
    }

    ~LockFreeQueue() {
        while (auto data = pop()) {
            // Drain queue
        }
        delete head_.load();
    }

    void push(T value) {
        auto data = std::make_shared<T>(std::move(value));
        Node* new_node = new Node();

        Node* old_tail = tail_.load();

        while (true) {
            Node* tail_next = old_tail->next.load();

            if (old_tail == tail_.load()) {
                if (tail_next == nullptr) {
                    old_tail->data = data;

                    if (old_tail->next.compare_exchange_weak(tail_next,
                                                             new_node)) {
                        tail_.compare_exchange_weak(old_tail, new_node);
                        return;
                    }
                } else {
                    tail_.compare_exchange_weak(old_tail, tail_next);
                }
            }

            old_tail = tail_.load();
        }
    }

    std::shared_ptr<T> pop() {
        Node* old_head = head_.load();

        while (true) {
            Node* tail = tail_.load();
            Node* head_next = old_head->next.load();

            if (old_head == head_.load()) {
                if (old_head == tail) {
                    if (head_next == nullptr) {
                        return nullptr; // Queue is empty
                    }
                    tail_.compare_exchange_weak(tail, head_next);
                } else {
                    if (head_next == nullptr) {
                        continue;
                    }

                    std::shared_ptr<T> data = head_next->data;

                    if (head_.compare_exchange_weak(old_head, head_next)) {
                        delete old_head;
                        return data;
                    }
                }
            }

            old_head = head_.load();
        }
    }
};
```

6. SECURE RANDOM NUMBER GENERATION
-----------------------------------

```cpp
#include <random>
#include <openssl/rand.h>

// BAD: Predictable random numbers
class UnsafeRandom {
public:
    static int getRandomNumber() {
        return rand();  // NOT CRYPTOGRAPHICALLY SECURE
    }
};

// GOOD: Cryptographically secure random numbers
class SecureRandom {
public:
    // Generate cryptographically secure random bytes
    static bool generateRandomBytes(unsigned char* buffer, size_t length) {
        if (!buffer || length == 0) {
            return false;
        }

        return RAND_bytes(buffer, length) == 1;
    }

    // Generate random integer in range [min, max]
    static std::optional<int64_t> generateRandomInt(int64_t min,
                                                    int64_t max) {
        if (min >= max) {
            return std::nullopt;
        }

        int64_t range = max - min + 1;
        int64_t random_value;

        unsigned char buffer[sizeof(int64_t)];
        if (!generateRandomBytes(buffer, sizeof(buffer))) {
            return std::nullopt;
        }

        std::memcpy(&random_value, buffer, sizeof(random_value));

        // Map to range while avoiding modulo bias
        int64_t max_valid = std::numeric_limits<int64_t>::max() -
                           (std::numeric_limits<int64_t>::max() % range);

        if (random_value < 0) {
            random_value = -random_value;
        }

        if (random_value >= max_valid) {
            // Recursively retry to avoid bias
            return generateRandomInt(min, max);
        }

        return min + (random_value % range);
    }

    // Generate UUID
    static std::string generateUUID() {
        unsigned char uuid_bytes[16];
        if (!generateRandomBytes(uuid_bytes, sizeof(uuid_bytes))) {
            throw std::runtime_error("Failed to generate UUID");
        }

        // Set version (4) and variant bits
        uuid_bytes[6] = (uuid_bytes[6] & 0x0F) | 0x40;
        uuid_bytes[8] = (uuid_bytes[8] & 0x3F) | 0x80;

        std::ostringstream oss;
        oss << std::hex << std::setfill('0');

        for (int i = 0; i < 16; ++i) {
            if (i == 4 || i == 6 || i == 8 || i == 10) {
                oss << '-';
            }
            oss << std::setw(2) << static_cast<int>(uuid_bytes[i]);
        }

        return oss.str();
    }
};

// Secure nonce generator for cryptographic operations
class NonceGenerator {
private:
    std::atomic<uint64_t> counter_{0};
    std::array<unsigned char, 16> random_seed_;

public:
    NonceGenerator() {
        if (!SecureRandom::generateRandomBytes(random_seed_.data(),
                                               random_seed_.size())) {
            throw std::runtime_error("Failed to initialize nonce generator");
        }
    }

    // Generate unique nonce (never repeats)
    std::array<unsigned char, 12> generateNonce() {
        std::array<unsigned char, 12> nonce;

        // First 8 bytes: random seed portion
        std::memcpy(nonce.data(), random_seed_.data(), 8);

        // Last 4 bytes: counter
        uint32_t counter = counter_.fetch_add(1, std::memory_order_relaxed);
        std::memcpy(nonce.data() + 8, &counter, 4);

        return nonce;
    }
};
```

================================================================================
CONFIGURATION TEMPLATES
================================================================================

1. COMPILER SECURITY FLAGS (CMakeLists.txt)
--------------------------------------------

```cmake
# CMakeLists.txt - Secure Compilation Configuration

cmake_minimum_required(VERSION 3.15)
project(HFT_Trading_System CXX)

# C++ Standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Security Hardening Flags
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    # Stack protection
    add_compile_options(
        -fstack-protector-strong
        -fstack-clash-protection
    )

    # Position Independent Executable (PIE)
    add_compile_options(-fPIE)
    add_link_options(-pie)

    # ASLR and other hardening
    add_compile_options(
        -D_FORTIFY_SOURCE=2
        -Wformat
        -Wformat-security
        -Werror=format-security
    )

    # Control Flow Integrity
    if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
        add_compile_options(
            -fsanitize=cfi
            -fvisibility=hidden
        )
        add_link_options(-fsanitize=cfi)
    endif()

    # Warning flags
    add_compile_options(
        -Wall
        -Wextra
        -Wpedantic
        -Werror
        -Wconversion
        -Wsign-conversion
        -Wcast-align
        -Wcast-qual
        -Wshadow
        -Wpointer-arith
        -Wuninitialized
        -Winit-self
        -Wstrict-overflow=4
        -Wwrite-strings
        -Wno-unused-parameter
    )

    # Undefined Behavior Sanitizer (UBSan) for debug builds
    if(CMAKE_BUILD_TYPE MATCHES Debug)
        add_compile_options(-fsanitize=undefined)
        add_link_options(-fsanitize=undefined)
    endif()

    # Address Sanitizer (ASan) option
    option(ENABLE_ASAN "Enable Address Sanitizer" OFF)
    if(ENABLE_ASAN)
        add_compile_options(-fsanitize=address -fno-omit-frame-pointer)
        add_link_options(-fsanitize=address)
    endif()

    # Thread Sanitizer (TSan) option
    option(ENABLE_TSAN "Enable Thread Sanitizer" OFF)
    if(ENABLE_TSAN)
        add_compile_options(-fsanitize=thread)
        add_link_options(-fsanitize=thread)
    endif()

    # Memory Sanitizer (MSan) option (Clang only)
    option(ENABLE_MSAN "Enable Memory Sanitizer" OFF)
    if(ENABLE_MSAN AND CMAKE_CXX_COMPILER_ID MATCHES "Clang")
        add_compile_options(-fsanitize=memory -fno-omit-frame-pointer)
        add_link_options(-fsanitize=memory)
    endif()

    # Link-time optimization for release builds
    if(CMAKE_BUILD_TYPE MATCHES Release)
        add_compile_options(-flto)
        add_link_options(-flto)
    endif()

    # Relocation Read-Only (RELRO)
    add_link_options(
        -Wl,-z,relro
        -Wl,-z,now
        -Wl,-z,noexecstack
    )

elseif(MSVC)
    # MSVC Security Flags
    add_compile_options(
        /W4
        /WX
        /GS          # Buffer security check
        /guard:cf    # Control Flow Guard
        /DYNAMICBASE # ASLR
        /NXCOMPAT    # DEP
    )

    add_link_options(
        /DYNAMICBASE
        /NXCOMPAT
        /GUARD:CF
    )
endif()

# Static Analysis Integration
find_program(CLANG_TIDY_EXE NAMES "clang-tidy")
if(CLANG_TIDY_EXE)
    set(CMAKE_CXX_CLANG_TIDY
        ${CLANG_TIDY_EXE};
        -header-filter=.*;
        -checks=*;
    )
endif()

# CPPCheck Integration
find_program(CPPCHECK_EXE NAMES "cppcheck")
if(CPPCHECK_EXE)
    set(CMAKE_CXX_CPPCHECK
        ${CPPCHECK_EXE};
        --enable=all;
        --inconclusive;
        --force;
        --inline-suppr;
    )
endif()
```

2. STATIC ANALYSIS CONFIGURATION (.clang-tidy)
-----------------------------------------------

```yaml
# .clang-tidy - Clang-Tidy Configuration

Checks: >
  -*,
  bugprone-*,
  cert-*,
  clang-analyzer-*,
  cppcoreguidelines-*,
  google-*,
  hicpp-*,
  misc-*,
  modernize-*,
  performance-*,
  portability-*,
  readability-*,
  -google-readability-todo,
  -cppcoreguidelines-avoid-magic-numbers,
  -readability-magic-numbers

WarningsAsErrors: '*'

CheckOptions:
  - key:   cppcoreguidelines-special-member-functions.AllowSoleDefaultDtor
    value: '1'
  - key:   readability-identifier-naming.ClassCase
    value: CamelCase
  - key:   readability-identifier-naming.FunctionCase
    value: camelBack
  - key:   readability-identifier-naming.VariableCase
    value: lower_case
  - key:   readability-identifier-naming.ConstantCase
    value: UPPER_CASE
  - key:   readability-identifier-naming.PrivateMemberSuffix
    value: '_'
  - key:   cert-err33-c.CheckedFunctions
    value: '::aligned_alloc;::asctime_s;::at_quick_exit;::atexit;::bsearch;::bsearch_s;::btowc;::c16rtomb;::c32rtomb;::calloc;::clock'
```

================================================================================
THREAT MODELS
================================================================================

THREAT 1: BUFFER OVERFLOW EXPLOITATION
---------------------------------------
Threat Actor: External attacker or malicious input
Attack Vector: Crafted input causing buffer overflow
Impact: CRITICAL - Code execution, system compromise

Mitigation:
1. Use std::vector and std::string instead of C arrays
2. Enable stack canaries (-fstack-protector-strong)
3. Enable ASLR and DEP
4. Validate all input lengths
5. Use bounds-checked functions (std::copy, std::memcpy with checks)

Detection:
- Stack canary violations
- Segmentation faults
- Abnormal program termination
- Memory corruption patterns

Response:
1. Terminate affected process
2. Analyze core dump
3. Identify vulnerable code path
4. Deploy patch immediately
5. Review similar code patterns

THREAT 2: INTEGER OVERFLOW LEADING TO INCORRECT CALCULATIONS
-------------------------------------------------------------
Threat Actor: Malicious trader or software bug
Attack Vector: Crafted inputs causing integer overflow in trading calculations
Impact: CRITICAL - Incorrect position sizes, P&L miscalculation, financial loss

Mitigation:
1. Use SafeArithmetic class for all calculations
2. Validate input ranges before calculations
3. Use wider integer types where appropriate
4. Enable overflow detection (-fsanitize=undefined)
5. Implement upper bounds checks

Detection:
- Unrealistic position sizes
- Negative quantities where impossible
- P&L anomalies
- UBSan runtime errors

Response:
1. Halt trading immediately
2. Review all affected positions
3. Recalculate using corrected code
4. Reconcile with exchange
5. Update calculation logic

THREAT 3: RACE CONDITIONS IN CONCURRENT CODE
---------------------------------------------
Threat Actor: N/A (design flaw, not malicious)
Attack Vector: Concurrent access to shared data without proper synchronization
Impact: HIGH - Data corruption, incorrect trading decisions, system instability

Mitigation:
1. Use mutex/locks for shared data access
2. Prefer immutable data structures
3. Use atomic operations where appropriate
4. Enable Thread Sanitizer during development
5. Conduct thorough code reviews

Detection:
- TSan warnings during testing
- Inconsistent data states
- Deadlocks or livelocks
- Crashes in multi-threaded code

Response:
1. Identify affected data structures
2. Add appropriate synchronization
3. Review all concurrent access patterns
4. Re-test with TSan
5. Deploy fix and monitor

================================================================================
SECURITY CHECKLISTS
================================================================================

CODE REVIEW SECURITY CHECKLIST
-------------------------------
[ ] All inputs validated before use
[ ] Buffer operations use bounds checking
[ ] Integer arithmetic uses overflow protection
[ ] Memory management uses RAII and smart pointers
[ ] No raw new/delete operators
[ ] Thread safety verified for concurrent code
[ ] Const correctness enforced
[ ] No hard-coded secrets or credentials
[ ] Error handling implemented properly
[ ] Resource cleanup guaranteed (RAII)
[ ] Cryptographic operations use vetted libraries
[ ] Random number generation uses secure methods
[ ] Type safety enforced (no unsafe casts)
[ ] Compiler warnings addressed

DEPENDENCY SECURITY CHECKLIST
------------------------------
[ ] All third-party libraries from trusted sources
[ ] Dependencies scanned for known vulnerabilities
[ ] Dependency versions pinned (not "latest")
[ ] Transitive dependencies reviewed
[ ] License compliance verified
[ ] Regular dependency updates scheduled
[ ] Build reproducibility ensured
[ ] Supply chain attacks considered
[ ] Binary integrity verified (checksums)
[ ] Development vs. production dependencies separated

BUILD SECURITY CHECKLIST
-------------------------
[ ] Security compiler flags enabled
[ ] Static analysis integrated in CI/CD
[ ] Dynamic analysis tools configured
[ ] Sanitizers enabled in testing
[ ] Position-independent executable (PIE)
[ ] Stack protection enabled
[ ] ASLR enabled
[ ] DEP/NX enabled
[ ] RELRO enabled
[ ] Symbols stripped in production builds
[ ] Debug information removed from production
[ ] Build process automated and reproducible

================================================================================
INCIDENT RESPONSE PROCEDURES
================================================================================

INCIDENT: MEMORY CORRUPTION DETECTED
-------------------------------------

PHASE 1: DETECTION (0-5 minutes)
---------------------------------
1. Identify symptoms:
   - Segmentation fault
   - Stack corruption detected
   - Heap corruption detected
   - ASan/MSan alerts

2. Collect crash information:
   - Core dump
   - Stack trace
   - System logs
   - Recent inputs

PHASE 2: CONTAINMENT (5-15 minutes)
------------------------------------
1. Stop affected process
2. Preserve core dump and logs
3. Prevent automatic restart
4. Notify stakeholders

PHASE 3: ANALYSIS (15 minutes - 4 hours)
-----------------------------------------
1. Analyze core dump with debugger
2. Identify vulnerable code path
3. Determine root cause
4. Assess exploit potential
5. Check for data corruption

PHASE 4: REMEDIATION (4-24 hours)
----------------------------------
1. Develop and test fix
2. Verify with sanitizers
3. Conduct peer review
4. Deploy to testing environment
5. Verify fix resolves issue

PHASE 5: RECOVERY (24-48 hours)
--------------------------------
1. Deploy fix to production
2. Monitor for recurrence
3. Restore corrupted data if needed
4. Document incident and fix
5. Update test suite

================================================================================
BEST PRACTICES SUMMARY
================================================================================

1. ALWAYS use RAII for resource management
2. PREFER std::unique_ptr and std::shared_ptr over raw pointers
3. VALIDATE all external inputs
4. USE SafeArithmetic for integer calculations
5. ENABLE all compiler security flags
6. AVOID manual memory management (new/delete)
7. USE const correctness throughout codebase
8. IMPLEMENT proper error handling
9. LEVERAGE modern C++ features (C++17/20)
10. CONDUCT regular code reviews with security focus
11. INTEGRATE static analysis in CI/CD pipeline
12. TEST with sanitizers (ASan, UBSan, TSan, MSan)
13. FOLLOW principle of least privilege
14. USE strong typing to prevent errors
15. DOCUMENT security-critical code thoroughly

================================================================================
END OF DOCUMENT
================================================================================
