================================================================================
                    ORDER MANAGEMENT SYSTEM (OMS) ALGORITHMS
================================================================================

DOCUMENT VERSION: 1.0
TARGET: Ultra-Low Latency Order Management
PERFORMANCE TARGET: < 1 microsecond per operation

================================================================================
TABLE OF CONTENTS
================================================================================

1. OMS Architecture Overview
2. Order Lifecycle Management
3. Order State Machine
4. Order Routing Algorithms
5. Order Matching Engine
6. Order Book Management
7. Fill Management
8. Order Cancellation
9. Order Modification
10. Performance Optimization

================================================================================
1. OMS ARCHITECTURE OVERVIEW
================================================================================

CORE OMS RESPONSIBILITIES:
--------------------------
1. Order Creation & Validation
2. Order Routing (to execution venues)
3. Order State Tracking
4. Fill Management & Allocation
5. Position Updates
6. Risk Management Integration
7. Audit Trail & Compliance

OMS PERFORMANCE REQUIREMENTS:
-----------------------------
- Order acceptance: < 500 nanoseconds
- Order routing: < 1 microsecond
- State update: < 200 nanoseconds
- Fill processing: < 500 nanoseconds
- Position update: < 300 nanoseconds

SYSTEM ARCHITECTURE:
--------------------

[Strategy] → [Risk Check] → [OMS Core] → [Smart Order Router] → [Venues]
    ↓                           ↓              ↓                      ↓
[Signal]    [Pre-trade]    [Order Book]   [Execution]         [Exchange]
            [Limits]       [State Machine] [Algorithms]        [Matching]
                              ↓
                        [Position Mgmt]
                        [PnL Tracking]
                        [Audit Log]

================================================================================
2. ORDER LIFECYCLE MANAGEMENT
================================================================================

ORDER STATES:
-------------
PENDING_NEW     → Order created, awaiting submission
PENDING_SEND    → Passed risk checks, ready to send
SENT            → Sent to venue, awaiting acknowledgment
NEW             → Acknowledged by venue
PARTIALLY_FILLED → Some fills received
FILLED          → Completely filled
PENDING_CANCEL  → Cancel request sent
CANCELLED       → Cancel confirmed
REJECTED        → Order rejected (risk or venue)
EXPIRED         → Time-in-force expired

2.1 ORDER STRUCTURE
-------------------

```cpp
#include <cstdint>
#include <atomic>
#include <array>
#include <chrono>

// High-performance order structure (cache-aligned)
struct alignas(64) Order {
    // Identity
    uint64_t order_id;              // Unique order ID
    uint64_t client_order_id;       // Client reference
    uint32_t symbol_id;             // Instrument ID
    uint32_t strategy_id;           // Strategy ID

    // Order details
    uint64_t price;                 // Price (fixed-point)
    uint64_t quantity;              // Original quantity
    uint64_t filled_quantity;       // Filled quantity
    uint64_t remaining_quantity;    // Remaining quantity

    // Timing
    uint64_t create_time_ns;        // Creation timestamp
    uint64_t send_time_ns;          // Send timestamp
    uint64_t ack_time_ns;           // Acknowledgment timestamp
    uint64_t done_time_ns;          // Completion timestamp

    // Attributes
    enum class Side : uint8_t { BUY = 0, SELL = 1 };
    enum class Type : uint8_t { MARKET = 0, LIMIT = 1, STOP = 2 };
    enum class TIF : uint8_t { DAY = 0, IOC = 1, FOK = 2, GTC = 3 };
    enum class State : uint8_t {
        PENDING_NEW = 0,
        PENDING_SEND = 1,
        SENT = 2,
        NEW = 3,
        PARTIALLY_FILLED = 4,
        FILLED = 5,
        PENDING_CANCEL = 6,
        CANCELLED = 7,
        REJECTED = 8,
        EXPIRED = 9
    };

    Side side;
    Type type;
    TIF time_in_force;
    std::atomic<State> state;

    uint8_t venue_id;               // Execution venue
    uint8_t flags;                  // Custom flags
    uint16_t padding;

    // Methods
    bool is_active() const {
        State s = state.load(std::memory_order_relaxed);
        return s >= State::PENDING_SEND && s <= State::PARTIALLY_FILLED;
    }

    bool is_done() const {
        State s = state.load(std::memory_order_relaxed);
        return s >= State::FILLED;
    }

    bool can_cancel() const {
        State s = state.load(std::memory_order_relaxed);
        return s == State::NEW || s == State::PARTIALLY_FILLED;
    }

    // Update filled quantity (atomic)
    void add_fill(uint64_t fill_qty) {
        filled_quantity += fill_qty;
        remaining_quantity = quantity - filled_quantity;

        if (remaining_quantity == 0) {
            state.store(State::FILLED, std::memory_order_release);
        } else {
            state.store(State::PARTIALLY_FILLED, std::memory_order_release);
        }
    }
};

static_assert(sizeof(Order) == 128, "Order should be 128 bytes (2 cache lines)");
```

2.2 ORDER POOL MANAGEMENT
-------------------------

```cpp
#include <vector>
#include <mutex>

// Lock-free order pool for fast allocation
template<size_t PoolSize = 100000>
class OrderPool {
private:
    alignas(64) std::array<Order, PoolSize> orders_;
    alignas(64) std::atomic<uint64_t> next_id_{1};
    alignas(64) std::atomic<uint32_t> alloc_index_{0};

    // Free list for returned orders
    struct FreeNode {
        uint32_t next;
    };
    alignas(64) std::atomic<uint32_t> free_head_{UINT32_MAX};
    std::array<FreeNode, PoolSize> free_list_;

public:
    OrderPool() {
        // Initialize all orders
        for (size_t i = 0; i < PoolSize; i++) {
            orders_[i] = Order{};
        }
    }

    // Allocate order (< 50ns)
    Order* allocate() {
        // Try free list first
        uint32_t head = free_head_.load(std::memory_order_acquire);
        while (head != UINT32_MAX) {
            uint32_t next = free_list_[head].next;
            if (free_head_.compare_exchange_weak(head, next,
                                                std::memory_order_release,
                                                std::memory_order_acquire)) {
                Order* order = &orders_[head];
                order->order_id = next_id_.fetch_add(1, std::memory_order_relaxed);
                return order;
            }
        }

        // Allocate from pool
        uint32_t idx = alloc_index_.fetch_add(1, std::memory_order_relaxed);
        if (idx >= PoolSize) {
            return nullptr; // Pool exhausted
        }

        Order* order = &orders_[idx];
        order->order_id = next_id_.fetch_add(1, std::memory_order_relaxed);
        return order;
    }

    // Return order to pool (< 30ns)
    void deallocate(Order* order) {
        if (!order) return;

        // Calculate index
        uint32_t idx = order - orders_.data();
        if (idx >= PoolSize) return;

        // Add to free list
        uint32_t head = free_head_.load(std::memory_order_acquire);
        do {
            free_list_[idx].next = head;
        } while (!free_head_.compare_exchange_weak(head, idx,
                                                   std::memory_order_release,
                                                   std::memory_order_acquire));
    }

    // Get order by ID (< 20ns)
    Order* get_by_id(uint64_t order_id) {
        for (size_t i = 0; i < PoolSize; i++) {
            if (orders_[i].order_id == order_id) {
                return &orders_[i];
            }
        }
        return nullptr;
    }
};
```

================================================================================
3. ORDER STATE MACHINE
================================================================================

3.1 STATE TRANSITION LOGIC
---------------------------

```cpp
class OrderStateMachine {
public:
    // Validate state transition
    static bool can_transition(Order::State from, Order::State to) {
        using State = Order::State;

        switch (from) {
            case State::PENDING_NEW:
                return to == State::PENDING_SEND || to == State::REJECTED;

            case State::PENDING_SEND:
                return to == State::SENT || to == State::REJECTED;

            case State::SENT:
                return to == State::NEW || to == State::REJECTED;

            case State::NEW:
                return to == State::PARTIALLY_FILLED ||
                       to == State::FILLED ||
                       to == State::PENDING_CANCEL ||
                       to == State::CANCELLED ||
                       to == State::EXPIRED;

            case State::PARTIALLY_FILLED:
                return to == State::FILLED ||
                       to == State::PENDING_CANCEL ||
                       to == State::CANCELLED ||
                       to == State::EXPIRED;

            case State::PENDING_CANCEL:
                return to == State::CANCELLED ||
                       to == State::FILLED; // Race condition: filled before cancel

            case State::FILLED:
            case State::CANCELLED:
            case State::REJECTED:
            case State::EXPIRED:
                return false; // Terminal states

            default:
                return false;
        }
    }

    // Attempt state transition (atomic)
    static bool transition(Order* order, Order::State expected, Order::State desired) {
        if (!can_transition(expected, desired)) {
            return false;
        }

        return order->state.compare_exchange_strong(
            expected, desired,
            std::memory_order_release,
            std::memory_order_acquire
        );
    }

    // Force state transition (for corrections)
    static void force_transition(Order* order, Order::State new_state) {
        order->state.store(new_state, std::memory_order_release);
    }
};
```

3.2 EVENT-DRIVEN STATE UPDATES
-------------------------------

```cpp
#include <functional>
#include <unordered_map>

class OrderEventHandler {
public:
    using EventCallback = std::function<void(Order*)>;

    enum class EventType {
        ORDER_NEW,
        ORDER_ACK,
        ORDER_FILL,
        ORDER_PARTIAL_FILL,
        ORDER_CANCEL_ACK,
        ORDER_REJECT,
        ORDER_EXPIRE
    };

private:
    std::unordered_map<EventType, std::vector<EventCallback>> callbacks_;

public:
    // Register callback for event
    void on_event(EventType event, EventCallback callback) {
        callbacks_[event].push_back(callback);
    }

    // Trigger event
    void trigger(EventType event, Order* order) {
        auto it = callbacks_.find(event);
        if (it != callbacks_.end()) {
            for (const auto& callback : it->second) {
                callback(order);
            }
        }
    }

    // Handle order acknowledgment
    void handle_order_ack(Order* order, uint64_t ack_time_ns) {
        if (OrderStateMachine::transition(order, Order::State::SENT,
                                         Order::State::NEW)) {
            order->ack_time_ns = ack_time_ns;
            trigger(EventType::ORDER_ACK, order);
        }
    }

    // Handle fill
    void handle_fill(Order* order, uint64_t fill_qty, uint64_t fill_price,
                    uint64_t fill_time_ns) {
        Order::State old_state = order->state.load(std::memory_order_acquire);

        if (old_state != Order::State::NEW &&
            old_state != Order::State::PARTIALLY_FILLED) {
            return; // Invalid state for fill
        }

        // Update fill quantities
        order->add_fill(fill_qty);

        // Trigger appropriate event
        if (order->state.load(std::memory_order_relaxed) == Order::State::FILLED) {
            order->done_time_ns = fill_time_ns;
            trigger(EventType::ORDER_FILL, order);
        } else {
            trigger(EventType::ORDER_PARTIAL_FILL, order);
        }
    }

    // Handle cancel acknowledgment
    void handle_cancel_ack(Order* order, uint64_t cancel_time_ns) {
        if (OrderStateMachine::transition(order, Order::State::PENDING_CANCEL,
                                         Order::State::CANCELLED)) {
            order->done_time_ns = cancel_time_ns;
            trigger(EventType::ORDER_CANCEL_ACK, order);
        }
    }

    // Handle reject
    void handle_reject(Order* order, const char* reason, uint64_t reject_time_ns) {
        Order::State current = order->state.load(std::memory_order_acquire);
        OrderStateMachine::force_transition(order, Order::State::REJECTED);
        order->done_time_ns = reject_time_ns;
        trigger(EventType::ORDER_REJECT, order);
    }
};
```

================================================================================
4. ORDER ROUTING ALGORITHMS
================================================================================

4.1 SIMPLE ROUTER (SINGLE VENUE)
---------------------------------

```cpp
class SimpleOrderRouter {
private:
    uint8_t venue_id_;
    OrderPool<100000>& order_pool_;
    VenueConnection& venue_;

public:
    SimpleOrderRouter(uint8_t venue_id, OrderPool<100000>& pool,
                     VenueConnection& venue)
        : venue_id_(venue_id), order_pool_(pool), venue_(venue) {}

    // Route order to venue (< 500ns)
    bool route(Order* order) {
        if (!order || !order->is_active()) {
            return false;
        }

        // Set venue
        order->venue_id = venue_id_;

        // Transition to SENT state
        Order::State expected = Order::State::PENDING_SEND;
        if (!OrderStateMachine::transition(order, expected, Order::State::SENT)) {
            return false;
        }

        // Record send time
        order->send_time_ns = TSCTimestamp::read_tsc_fast();

        // Send to venue
        return venue_.send_order(order);
    }

    // Cancel order
    bool cancel(Order* order) {
        if (!order || !order->can_cancel()) {
            return false;
        }

        // Transition to PENDING_CANCEL
        Order::State expected = order->state.load(std::memory_order_acquire);
        if (!OrderStateMachine::transition(order, expected,
                                          Order::State::PENDING_CANCEL)) {
            return false;
        }

        // Send cancel request
        return venue_.send_cancel(order->order_id);
    }
};
```

4.2 SMART ORDER ROUTER (MULTIPLE VENUES)
-----------------------------------------

```cpp
class SmartOrderRouter {
private:
    struct VenueInfo {
        uint8_t venue_id;
        VenueConnection* connection;
        uint64_t latency_ns;        // Average latency
        uint32_t fill_rate;         // Fill rate percentage
        bool active;
    };

    std::vector<VenueInfo> venues_;
    OrderPool<100000>& order_pool_;

public:
    SmartOrderRouter(OrderPool<100000>& pool) : order_pool_(pool) {}

    void add_venue(uint8_t venue_id, VenueConnection* conn,
                  uint64_t latency_ns, uint32_t fill_rate) {
        venues_.push_back({venue_id, conn, latency_ns, fill_rate, true});
    }

    // Select best venue based on criteria (< 200ns)
    VenueInfo* select_venue(Order* order) {
        VenueInfo* best = nullptr;
        uint64_t best_score = UINT64_MAX;

        for (auto& venue : venues_) {
            if (!venue.active) continue;

            // Score = latency * (100 / fill_rate)
            uint64_t score = venue.latency_ns * 100 / venue.fill_rate;

            if (score < best_score) {
                best_score = score;
                best = &venue;
            }
        }

        return best;
    }

    // Route order to best venue
    bool route(Order* order) {
        VenueInfo* venue = select_venue(order);
        if (!venue) {
            return false;
        }

        order->venue_id = venue->venue_id;

        Order::State expected = Order::State::PENDING_SEND;
        if (!OrderStateMachine::transition(order, expected, Order::State::SENT)) {
            return false;
        }

        order->send_time_ns = TSCTimestamp::read_tsc_fast();
        return venue->connection->send_order(order);
    }

    // Update venue statistics
    void update_venue_stats(uint8_t venue_id, uint64_t latency_ns,
                           bool filled) {
        for (auto& venue : venues_) {
            if (venue.venue_id == venue_id) {
                // EWMA for latency
                venue.latency_ns = (venue.latency_ns * 95 + latency_ns * 5) / 100;

                // Update fill rate
                if (filled) {
                    venue.fill_rate = std::min(100u,
                        (venue.fill_rate * 99 + 100) / 100);
                } else {
                    venue.fill_rate = (venue.fill_rate * 99) / 100;
                }
                break;
            }
        }
    }
};
```

================================================================================
5. ORDER MATCHING ENGINE
================================================================================

5.1 SIMPLE MATCHING ENGINE (FOR INTERNALIZATION)
-------------------------------------------------

```cpp
#include <map>
#include <list>

class OrderMatchingEngine {
private:
    // Order book: price level → list of orders
    std::map<uint64_t, std::list<Order*>, std::greater<uint64_t>> buy_orders_;
    std::map<uint64_t, std::list<Order*>> sell_orders_;

    OrderPool<100000>& order_pool_;
    OrderEventHandler& event_handler_;

public:
    OrderMatchingEngine(OrderPool<100000>& pool, OrderEventHandler& handler)
        : order_pool_(pool), event_handler_(handler) {}

    // Add order to book
    void add_order(Order* order) {
        if (order->side == Order::Side::BUY) {
            buy_orders_[order->price].push_back(order);
            // Try to match with sell orders
            match_buy_order(order);
        } else {
            sell_orders_[order->price].push_back(order);
            // Try to match with buy orders
            match_sell_order(order);
        }
    }

    // Remove order from book
    void remove_order(Order* order) {
        auto& book = (order->side == Order::Side::BUY) ? buy_orders_ : sell_orders_;
        auto it = book.find(order->price);
        if (it != book.end()) {
            it->second.remove(order);
            if (it->second.empty()) {
                book.erase(it);
            }
        }
    }

private:
    // Match buy order against sell orders
    void match_buy_order(Order* buy_order) {
        if (sell_orders_.empty()) return;

        auto sell_it = sell_orders_.begin();
        while (sell_it != sell_orders_.end() &&
               sell_it->first <= buy_order->price &&
               buy_order->remaining_quantity > 0) {

            auto& sell_list = sell_it->second;
            auto order_it = sell_list.begin();

            while (order_it != sell_list.end() &&
                   buy_order->remaining_quantity > 0) {
                Order* sell_order = *order_it;

                // Calculate match quantity
                uint64_t match_qty = std::min(buy_order->remaining_quantity,
                                             sell_order->remaining_quantity);

                // Execute match
                uint64_t match_price = sell_order->price; // Sell price (FIFO)
                uint64_t match_time = TSCTimestamp::read_tsc_fast();

                // Update both orders
                event_handler_.handle_fill(buy_order, match_qty, match_price,
                                          match_time);
                event_handler_.handle_fill(sell_order, match_qty, match_price,
                                          match_time);

                // Remove filled sell order
                if (sell_order->remaining_quantity == 0) {
                    order_it = sell_list.erase(order_it);
                } else {
                    ++order_it;
                }
            }

            // Remove empty price level
            if (sell_list.empty()) {
                sell_it = sell_orders_.erase(sell_it);
            } else {
                ++sell_it;
            }
        }
    }

    // Match sell order against buy orders
    void match_sell_order(Order* sell_order) {
        if (buy_orders_.empty()) return;

        auto buy_it = buy_orders_.begin();
        while (buy_it != buy_orders_.end() &&
               buy_it->first >= sell_order->price &&
               sell_order->remaining_quantity > 0) {

            auto& buy_list = buy_it->second;
            auto order_it = buy_list.begin();

            while (order_it != buy_list.end() &&
                   sell_order->remaining_quantity > 0) {
                Order* buy_order = *order_it;

                uint64_t match_qty = std::min(sell_order->remaining_quantity,
                                             buy_order->remaining_quantity);

                uint64_t match_price = buy_order->price; // Buy price (FIFO)
                uint64_t match_time = TSCTimestamp::read_tsc_fast();

                event_handler_.handle_fill(sell_order, match_qty, match_price,
                                          match_time);
                event_handler_.handle_fill(buy_order, match_qty, match_price,
                                          match_time);

                if (buy_order->remaining_quantity == 0) {
                    order_it = buy_list.erase(order_it);
                } else {
                    ++order_it;
                }
            }

            if (buy_list.empty()) {
                buy_it = buy_orders_.erase(buy_it);
            } else {
                ++buy_it;
            }
        }
    }
};
```

================================================================================
6. FILL MANAGEMENT
================================================================================

6.1 FILL STRUCTURE
------------------

```cpp
struct alignas(64) Fill {
    uint64_t fill_id;
    uint64_t order_id;
    uint64_t execution_id;      // Venue execution ID

    uint32_t symbol_id;
    uint32_t strategy_id;

    uint64_t price;             // Fill price
    uint64_t quantity;          // Fill quantity
    uint64_t timestamp_ns;      // Fill timestamp

    Order::Side side;
    uint8_t venue_id;
    uint8_t liquidity_flag;     // Maker/Taker
    uint8_t padding[5];

    // Calculate notional value
    uint64_t notional() const {
        return price * quantity;
    }
};

static_assert(sizeof(Fill) == 64, "Fill should be 64 bytes (1 cache line)");
```

6.2 FILL PROCESSOR
------------------

```cpp
class FillProcessor {
private:
    OrderPool<100000>& order_pool_;
    PositionManager& position_mgr_;
    PnLCalculator& pnl_calc_;

    // Fill history
    std::array<Fill, 1000000> fills_;
    std::atomic<uint64_t> fill_count_{0};

public:
    FillProcessor(OrderPool<100000>& pool,
                 PositionManager& pos_mgr,
                 PnLCalculator& pnl)
        : order_pool_(pool), position_mgr_(pos_mgr), pnl_calc_(pnl) {}

    // Process fill (< 500ns)
    void process_fill(uint64_t order_id, uint64_t fill_qty,
                     uint64_t fill_price, uint64_t timestamp_ns) {
        // Get order
        Order* order = order_pool_.get_by_id(order_id);
        if (!order) {
            return; // Order not found
        }

        // Create fill record
        uint64_t fill_idx = fill_count_.fetch_add(1, std::memory_order_relaxed);
        if (fill_idx >= fills_.size()) {
            return; // Fill buffer full
        }

        Fill* fill = &fills_[fill_idx];
        fill->fill_id = fill_idx;
        fill->order_id = order_id;
        fill->symbol_id = order->symbol_id;
        fill->strategy_id = order->strategy_id;
        fill->price = fill_price;
        fill->quantity = fill_qty;
        fill->timestamp_ns = timestamp_ns;
        fill->side = order->side;
        fill->venue_id = order->venue_id;

        // Update order
        order->add_fill(fill_qty);

        // Update position (< 200ns)
        int64_t qty_signed = (order->side == Order::Side::BUY) ?
            static_cast<int64_t>(fill_qty) :
            -static_cast<int64_t>(fill_qty);
        position_mgr_.update_position(order->symbol_id, qty_signed, fill_price);

        // Update PnL (< 100ns)
        pnl_calc_.update_pnl(order->strategy_id, order->symbol_id,
                            qty_signed, fill_price);
    }
};
```

================================================================================
7. ORDER CANCELLATION
================================================================================

```cpp
class OrderCancellationManager {
private:
    OrderPool<100000>& order_pool_;
    SmartOrderRouter& router_;
    OrderEventHandler& event_handler_;

    // Cancel statistics
    struct CancelStats {
        std::atomic<uint64_t> cancel_requests{0};
        std::atomic<uint64_t> cancel_success{0};
        std::atomic<uint64_t> cancel_reject{0};
        std::atomic<uint64_t> too_late{0};  // Already filled
    };
    CancelStats stats_;

public:
    OrderCancellationManager(OrderPool<100000>& pool,
                            SmartOrderRouter& router,
                            OrderEventHandler& handler)
        : order_pool_(pool), router_(router), event_handler_(handler) {}

    // Cancel order (< 800ns)
    bool cancel_order(uint64_t order_id) {
        stats_.cancel_requests.fetch_add(1, std::memory_order_relaxed);

        // Get order
        Order* order = order_pool_.get_by_id(order_id);
        if (!order) {
            return false;
        }

        // Check if cancellable
        if (!order->can_cancel()) {
            if (order->state.load(std::memory_order_relaxed) ==
                Order::State::FILLED) {
                stats_.too_late.fetch_add(1, std::memory_order_relaxed);
            }
            return false;
        }

        // Route cancel request
        if (router_.cancel(order)) {
            stats_.cancel_success.fetch_add(1, std::memory_order_relaxed);
            return true;
        } else {
            stats_.cancel_reject.fetch_add(1, std::memory_order_relaxed);
            return false;
        }
    }

    // Cancel all orders for symbol
    size_t cancel_all_for_symbol(uint32_t symbol_id) {
        size_t cancelled = 0;

        // Iterate through all orders (could be optimized with index)
        for (size_t i = 0; i < order_pool_.size(); i++) {
            Order* order = order_pool_.get_at(i);
            if (order && order->symbol_id == symbol_id && order->can_cancel()) {
                if (cancel_order(order->order_id)) {
                    cancelled++;
                }
            }
        }

        return cancelled;
    }

    // Emergency cancel all
    size_t cancel_all() {
        size_t cancelled = 0;

        for (size_t i = 0; i < order_pool_.size(); i++) {
            Order* order = order_pool_.get_at(i);
            if (order && order->can_cancel()) {
                if (cancel_order(order->order_id)) {
                    cancelled++;
                }
            }
        }

        return cancelled;
    }

    // Get statistics
    void print_stats() {
        printf("Cancel Statistics:\n");
        printf("  Requests: %lu\n",
               stats_.cancel_requests.load(std::memory_order_relaxed));
        printf("  Success:  %lu\n",
               stats_.cancel_success.load(std::memory_order_relaxed));
        printf("  Reject:   %lu\n",
               stats_.cancel_reject.load(std::memory_order_relaxed));
        printf("  Too Late: %lu\n",
               stats_.too_late.load(std::memory_order_relaxed));
    }
};
```

================================================================================
8. ORDER MODIFICATION
================================================================================

```cpp
class OrderModificationManager {
private:
    OrderPool<100000>& order_pool_;
    SmartOrderRouter& router_;

public:
    OrderModificationManager(OrderPool<100000>& pool, SmartOrderRouter& router)
        : order_pool_(pool), router_(router) {}

    // Modify order price (cancel-replace)
    bool modify_price(uint64_t order_id, uint64_t new_price) {
        Order* order = order_pool_.get_by_id(order_id);
        if (!order || !order->can_cancel()) {
            return false;
        }

        // Save order details
        uint32_t symbol_id = order->symbol_id;
        Order::Side side = order->side;
        uint64_t quantity = order->remaining_quantity;
        Order::TIF tif = order->time_in_force;

        // Cancel existing order
        if (!router_.cancel(order)) {
            return false;
        }

        // Create new order with modified price
        Order* new_order = order_pool_.allocate();
        if (!new_order) {
            return false; // Pool exhausted
        }

        new_order->client_order_id = order->client_order_id;
        new_order->symbol_id = symbol_id;
        new_order->side = side;
        new_order->price = new_price;
        new_order->quantity = quantity;
        new_order->remaining_quantity = quantity;
        new_order->filled_quantity = 0;
        new_order->type = Order::Type::LIMIT;
        new_order->time_in_force = tif;
        new_order->state.store(Order::State::PENDING_SEND,
                              std::memory_order_release);

        // Route new order
        return router_.route(new_order);
    }

    // Modify order quantity
    bool modify_quantity(uint64_t order_id, uint64_t new_quantity) {
        Order* order = order_pool_.get_by_id(order_id);
        if (!order || !order->can_cancel()) {
            return false;
        }

        // Some venues support quantity reduction without cancel
        if (new_quantity < order->remaining_quantity) {
            // Send quantity reduction request
            // Implementation depends on venue protocol
            return true;
        }

        // For quantity increase, must cancel-replace
        return false; // Not supported (would lose queue priority)
    }
};
```

================================================================================
9. PERFORMANCE OPTIMIZATION
================================================================================

9.1 CACHE OPTIMIZATION
----------------------

```cpp
// Order cache for hot orders (L1/L2 cache resident)
class OrderCache {
private:
    static constexpr size_t CACHE_SIZE = 64; // Fits in L1 cache

    struct CacheEntry {
        uint64_t order_id;
        Order* order;
    };

    alignas(64) std::array<CacheEntry, CACHE_SIZE> cache_;
    std::atomic<uint32_t> next_slot_{0};

public:
    // Add to cache (< 10ns)
    void add(uint64_t order_id, Order* order) {
        uint32_t slot = next_slot_.fetch_add(1, std::memory_order_relaxed) %
                       CACHE_SIZE;
        cache_[slot] = {order_id, order};
    }

    // Lookup in cache (< 15ns)
    Order* lookup(uint64_t order_id) {
        for (const auto& entry : cache_) {
            if (entry.order_id == order_id) {
                return entry.order;
            }
        }
        return nullptr;
    }
};
```

9.2 BATCH PROCESSING
--------------------

```cpp
// Process multiple orders in batch (better cache utilization)
class BatchOrderProcessor {
private:
    static constexpr size_t BATCH_SIZE = 32;

    struct OrderBatch {
        std::array<Order*, BATCH_SIZE> orders;
        size_t count = 0;
    };

    OrderBatch pending_batch_;
    SmartOrderRouter& router_;

public:
    BatchOrderProcessor(SmartOrderRouter& router) : router_(router) {}

    // Add order to batch
    void add_order(Order* order) {
        pending_batch_.orders[pending_batch_.count++] = order;

        if (pending_batch_.count >= BATCH_SIZE) {
            flush();
        }
    }

    // Flush batch (process all)
    void flush() {
        for (size_t i = 0; i < pending_batch_.count; i++) {
            router_.route(pending_batch_.orders[i]);
        }
        pending_batch_.count = 0;
    }
};
```

PERFORMANCE METRICS:
--------------------
- Order creation: 200-500 nanoseconds
- Order routing: 500-1000 nanoseconds
- State update: 50-200 nanoseconds
- Fill processing: 300-800 nanoseconds
- Cancel request: 500-1000 nanoseconds
- Modify request: 1000-2000 nanoseconds

THROUGHPUT:
-----------
- Order creation: 2-5 million orders/second
- Order routing: 1-2 million orders/second
- Fill processing: 1-3 million fills/second

================================================================================
END OF DOCUMENT
================================================================================
