================================================================================
                    CONNECTION TYPES FOR HFT SYSTEMS
================================================================================

DOCUMENT VERSION: 1.0
CLASSIFICATION: Technical Implementation Guide
PROTOCOLS: TLS, WebSocket, FIX, UDP Multicast, Kernel Bypass

================================================================================
TABLE OF CONTENTS
================================================================================

1. Connection Types Overview
2. TLS/SSL Connections
3. WebSocket Connections
4. FIX Protocol
5. UDP Multicast
6. Kernel Bypass (DPDK/OpenOnload)
7. RDMA and InfiniBand
8. Performance Comparison
9. Implementation Examples
10. Best Practices

================================================================================
1. CONNECTION TYPES OVERVIEW
================================================================================

TRADING SYSTEM CONNECTION REQUIREMENTS:
---------------------------------------

CONNECTION TYPE     Latency     Throughput   Reliability   Use Case
---------------------------------------------------------------------------
TLS/SSL             100us+      100 MB/s     High          REST APIs, Web
WebSocket           50-500us    500 MB/s     Medium        Real-time feeds
FIX (TCP)           10-100us    1 GB/s       High          Order routing
UDP Multicast       1-50us      10 GB/s      Best-effort   Market data
Kernel Bypass       0.1-10us    100 GB/s     Medium        Ultra-low latency
RDMA                0.05-5us    200 GB/s     High          Inter-server
---------------------------------------------------------------------------

LATENCY BREAKDOWN BY CONNECTION TYPE:
--------------------------------------

Stack               Connection   Data TX/RX   Total
--------------------------------------------------------
Traditional TCP     100-500us    10-50us      110-550us
TLS/TCP             500-2000us   20-100us     520-2100us
WebSocket/TCP       100-500us    15-75us      115-575us
FIX/TCP (opt)       10-100us     5-20us       15-120us
UDP                 5-50us       1-10us       6-60us
Kernel Bypass       1-10us       0.1-1us      1.1-11us
RDMA                0.5-5us      0.05-0.5us   0.55-5.5us
--------------------------------------------------------

================================================================================
2. TLS/SSL CONNECTIONS
================================================================================

2.1 TLS OVERVIEW
----------------

TLS (Transport Layer Security) provides:
- Encryption: Confidential data transmission
- Authentication: Verify server/client identity
- Integrity: Detect tampering

PERFORMANCE COST:
- Handshake: 2-10 milliseconds (includes multiple RTTs)
- Encryption overhead: 10-30% CPU
- Additional latency: 50-200 microseconds per message
- Memory overhead: ~50KB per connection

TLS VERSIONS:
- TLS 1.0/1.1: Deprecated (insecure)
- TLS 1.2: Widely used
- TLS 1.3: Latest, faster handshake (1-RTT vs 2-RTT)

2.2 TLS 1.3 IMPLEMENTATION (OpenSSL)
------------------------------------

```cpp
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <cstring>

class TLSClient {
private:
    SSL_CTX* ctx_ = nullptr;
    SSL* ssl_ = nullptr;
    int socket_fd_ = -1;

public:
    TLSClient() {
        // Initialize OpenSSL
        SSL_load_error_strings();
        OpenSSL_add_ssl_algorithms();
    }

    ~TLSClient() {
        cleanup();
        EVP_cleanup();
    }

    // Initialize TLS 1.3 context
    bool init_context() {
        // Create TLS 1.3 client method
        const SSL_METHOD* method = TLS_client_method();
        ctx_ = SSL_CTX_new(method);

        if (!ctx_) {
            ERR_print_errors_fp(stderr);
            return false;
        }

        // Force TLS 1.3 only
        SSL_CTX_set_min_proto_version(ctx_, TLS1_3_VERSION);
        SSL_CTX_set_max_proto_version(ctx_, TLS1_3_VERSION);

        // Set cipher suites (fastest first)
        SSL_CTX_set_ciphersuites(ctx_,
            "TLS_AES_128_GCM_SHA256:"      // Fastest (AES-NI)
            "TLS_CHACHA20_POLY1305_SHA256:" // Good without AES-NI
            "TLS_AES_256_GCM_SHA384"       // Most secure
        );

        // Enable session resumption (0-RTT)
        SSL_CTX_set_session_cache_mode(ctx_,
            SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL_STORE);

        return true;
    }

    // Connect to server
    bool connect(const char* host, uint16_t port) {
        // Create TCP socket
        socket_fd_ = socket(AF_INET, SOCK_STREAM, 0);
        if (socket_fd_ < 0) {
            return false;
        }

        // Set TCP_NODELAY (disable Nagle's algorithm)
        int flag = 1;
        setsockopt(socket_fd_, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag));

        // Connect
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        inet_pton(AF_INET, host, &addr.sin_addr);

        if (::connect(socket_fd_, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
            close(socket_fd_);
            socket_fd_ = -1;
            return false;
        }

        // Create SSL object
        ssl_ = SSL_new(ctx_);
        SSL_set_fd(ssl_, socket_fd_);
        SSL_set_tlsext_host_name(ssl_, host); // SNI

        // Perform TLS handshake (1-5ms for TLS 1.3)
        auto start = std::chrono::steady_clock::now();
        if (SSL_connect(ssl_) != 1) {
            ERR_print_errors_fp(stderr);
            cleanup();
            return false;
        }
        auto end = std::chrono::steady_clock::now();
        auto handshake_us = std::chrono::duration_cast<
            std::chrono::microseconds>(end - start).count();

        printf("TLS handshake completed in %ld us\n", handshake_us);
        return true;
    }

    // Send data (encrypted)
    ssize_t send(const void* data, size_t len) {
        if (!ssl_) return -1;

        ssize_t written = SSL_write(ssl_, data, len);
        if (written <= 0) {
            int err = SSL_get_error(ssl_, written);
            fprintf(stderr, "SSL_write error: %d\n", err);
            return -1;
        }
        return written;
    }

    // Receive data (encrypted)
    ssize_t receive(void* buffer, size_t len) {
        if (!ssl_) return -1;

        ssize_t received = SSL_read(ssl_, buffer, len);
        if (received <= 0) {
            int err = SSL_get_error(ssl_, received);
            if (err != SSL_ERROR_ZERO_RETURN) {
                fprintf(stderr, "SSL_read error: %d\n", err);
            }
            return -1;
        }
        return received;
    }

    // Get negotiated cipher
    const char* get_cipher() const {
        return ssl_ ? SSL_get_cipher(ssl_) : nullptr;
    }

private:
    void cleanup() {
        if (ssl_) {
            SSL_shutdown(ssl_);
            SSL_free(ssl_);
            ssl_ = nullptr;
        }
        if (socket_fd_ >= 0) {
            close(socket_fd_);
            socket_fd_ = -1;
        }
        if (ctx_) {
            SSL_CTX_free(ctx_);
            ctx_ = nullptr;
        }
    }
};
```

2.3 TLS OPTIMIZATION TECHNIQUES
--------------------------------

```cpp
// Session resumption for faster reconnection
class TLSSessionCache {
private:
    std::unordered_map<std::string, SSL_SESSION*> sessions_;
    std::mutex mutex_;

public:
    // Save session for host
    void save_session(const std::string& host, SSL* ssl) {
        SSL_SESSION* session = SSL_get1_session(ssl);
        if (session) {
            std::lock_guard<std::mutex> lock(mutex_);
            auto it = sessions_.find(host);
            if (it != sessions_.end()) {
                SSL_SESSION_free(it->second);
            }
            sessions_[host] = session;
        }
    }

    // Resume session for host (0-RTT in TLS 1.3)
    SSL_SESSION* get_session(const std::string& host) {
        std::lock_guard<std::mutex> lock(mutex_);
        auto it = sessions_.find(host);
        return (it != sessions_.end()) ? it->second : nullptr;
    }

    ~TLSSessionCache() {
        for (auto& pair : sessions_) {
            SSL_SESSION_free(pair.second);
        }
    }
};

// Hardware acceleration for TLS (AES-NI, AVX)
void enable_hardware_acceleration(SSL_CTX* ctx) {
    // OpenSSL automatically uses hardware acceleration when available
    // Verify AES-NI support
    unsigned int eax, ebx, ecx, edx;
    __get_cpuid(1, &eax, &ebx, &ecx, &edx);

    if (ecx & (1 << 25)) {
        printf("AES-NI supported and enabled\n");
        // AES-GCM encryption: 0.5-2 cycles/byte with AES-NI
    } else {
        printf("AES-NI not available (software crypto slower)\n");
        // Software AES: 10-20 cycles/byte
    }
}
```

PERFORMANCE METRICS (TLS 1.3 with AES-NI):
-------------------------------------------
- Handshake (full): 1-2 ms
- Handshake (resumed): 200-500 us
- Encryption overhead: 5-15 us per KB
- Throughput: 500 MB/s - 2 GB/s per core

================================================================================
3. WEBSOCKET CONNECTIONS
================================================================================

3.1 WEBSOCKET PROTOCOL
-----------------------

WebSocket provides full-duplex communication over TCP:
- HTTP upgrade handshake
- Framing protocol for messages
- Lower overhead than HTTP polling
- Suitable for real-time data

FRAME FORMAT:
- Minimal: 2 bytes header + payload
- With masking: 6 bytes header + payload
- With large payload: 8-10 bytes header + payload

3.2 WEBSOCKET IMPLEMENTATION
-----------------------------

```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <openssl/sha.h>
#include <cstring>
#include <string>
#include <vector>

class WebSocketClient {
private:
    int socket_fd_ = -1;
    bool connected_ = false;

    static constexpr char WS_MAGIC[] = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

public:
    // Connect and perform WebSocket handshake
    bool connect(const char* host, uint16_t port, const char* path) {
        // Create TCP connection (same as TLS example)
        socket_fd_ = socket(AF_INET, SOCK_STREAM, 0);
        if (socket_fd_ < 0) return false;

        // Set TCP_NODELAY
        int flag = 1;
        setsockopt(socket_fd_, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag));

        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        inet_pton(AF_INET, host, &addr.sin_addr);

        if (::connect(socket_fd_, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
            close(socket_fd_);
            socket_fd_ = -1;
            return false;
        }

        // Send WebSocket upgrade request
        std::string key = generate_websocket_key();
        std::string request =
            "GET " + std::string(path) + " HTTP/1.1\r\n"
            "Host: " + std::string(host) + "\r\n"
            "Upgrade: websocket\r\n"
            "Connection: Upgrade\r\n"
            "Sec-WebSocket-Key: " + key + "\r\n"
            "Sec-WebSocket-Version: 13\r\n"
            "\r\n";

        if (::send(socket_fd_, request.c_str(), request.size(), 0) < 0) {
            close(socket_fd_);
            return false;
        }

        // Receive and validate handshake response
        char response[1024];
        ssize_t received = ::recv(socket_fd_, response, sizeof(response) - 1, 0);
        if (received <= 0) {
            close(socket_fd_);
            return false;
        }
        response[received] = '\0';

        // Check for "101 Switching Protocols"
        if (strstr(response, "101") == nullptr) {
            close(socket_fd_);
            return false;
        }

        connected_ = true;
        return true;
    }

    // Send WebSocket frame
    bool send(const void* data, size_t len, uint8_t opcode = 0x02) {
        if (!connected_) return false;

        // Build WebSocket frame
        std::vector<uint8_t> frame;

        // FIN + opcode
        frame.push_back(0x80 | opcode);

        // Mask + payload length
        if (len < 126) {
            frame.push_back(0x80 | len); // Mask bit + length
        } else if (len < 65536) {
            frame.push_back(0x80 | 126);
            frame.push_back((len >> 8) & 0xFF);
            frame.push_back(len & 0xFF);
        } else {
            frame.push_back(0x80 | 127);
            for (int i = 7; i >= 0; i--) {
                frame.push_back((len >> (i * 8)) & 0xFF);
            }
        }

        // Masking key (required for client-to-server)
        uint8_t mask[4];
        for (int i = 0; i < 4; i++) {
            mask[i] = rand() & 0xFF;
            frame.push_back(mask[i]);
        }

        // Masked payload
        const uint8_t* payload = static_cast<const uint8_t*>(data);
        for (size_t i = 0; i < len; i++) {
            frame.push_back(payload[i] ^ mask[i % 4]);
        }

        // Send frame
        return ::send(socket_fd_, frame.data(), frame.size(), 0) ==
               static_cast<ssize_t>(frame.size());
    }

    // Receive WebSocket frame
    ssize_t receive(void* buffer, size_t buffer_size, uint8_t& opcode) {
        if (!connected_) return -1;

        // Read frame header (minimum 2 bytes)
        uint8_t header[14];
        if (::recv(socket_fd_, header, 2, 0) != 2) {
            return -1;
        }

        uint8_t fin = (header[0] >> 7) & 0x01;
        opcode = header[0] & 0x0F;
        uint8_t masked = (header[1] >> 7) & 0x01;
        uint64_t payload_len = header[1] & 0x7F;

        // Extended payload length
        if (payload_len == 126) {
            if (::recv(socket_fd_, header + 2, 2, 0) != 2) return -1;
            payload_len = (header[2] << 8) | header[3];
        } else if (payload_len == 127) {
            if (::recv(socket_fd_, header + 2, 8, 0) != 8) return -1;
            payload_len = 0;
            for (int i = 0; i < 8; i++) {
                payload_len = (payload_len << 8) | header[2 + i];
            }
        }

        // Masking key (server-to-client should NOT be masked)
        uint8_t mask[4] = {0};
        if (masked) {
            if (::recv(socket_fd_, mask, 4, 0) != 4) return -1;
        }

        // Receive payload
        if (payload_len > buffer_size) {
            return -1; // Buffer too small
        }

        ssize_t received = ::recv(socket_fd_, buffer, payload_len, MSG_WAITALL);
        if (received != static_cast<ssize_t>(payload_len)) {
            return -1;
        }

        // Unmask payload if needed
        if (masked) {
            uint8_t* data = static_cast<uint8_t*>(buffer);
            for (size_t i = 0; i < payload_len; i++) {
                data[i] ^= mask[i % 4];
            }
        }

        return received;
    }

    ~WebSocketClient() {
        if (socket_fd_ >= 0) {
            close(socket_fd_);
        }
    }

private:
    std::string generate_websocket_key() {
        // Generate random 16-byte key
        uint8_t random_bytes[16];
        for (int i = 0; i < 16; i++) {
            random_bytes[i] = rand() & 0xFF;
        }

        // Base64 encode
        static const char base64_chars[] =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

        std::string encoded;
        for (int i = 0; i < 16; i += 3) {
            uint32_t val = (random_bytes[i] << 16);
            if (i + 1 < 16) val |= (random_bytes[i + 1] << 8);
            if (i + 2 < 16) val |= random_bytes[i + 2];

            encoded += base64_chars[(val >> 18) & 0x3F];
            encoded += base64_chars[(val >> 12) & 0x3F];
            encoded += (i + 1 < 16) ? base64_chars[(val >> 6) & 0x3F] : '=';
            encoded += (i + 2 < 16) ? base64_chars[val & 0x3F] : '=';
        }

        return encoded;
    }
};
```

WEBSOCKET PERFORMANCE:
----------------------
- Handshake: 100-500 microseconds
- Frame overhead: 2-14 bytes
- Latency per message: 10-100 microseconds
- Throughput: 100-500 MB/s

================================================================================
4. FIX PROTOCOL
================================================================================

4.1 FIX PROTOCOL OVERVIEW
--------------------------

FIX (Financial Information eXchange) is the standard protocol for trading:
- Text-based key=value pairs
- Session-level protocol (logon, heartbeat, logout)
- Application-level messages (orders, executions, market data)
- Versions: 4.2, 4.4, 5.0

TYPICAL FIX MESSAGE:
8=FIX.4.4|9=123|35=D|49=SENDER|56=TARGET|34=1|52=20250126-12:00:00|
11=ORDER123|55=AAPL|54=1|38=100|40=2|44=150.50|10=123|

Fields:
- 8: BeginString
- 9: BodyLength
- 35: MsgType (D=NewOrderSingle)
- 49: SenderCompID
- 56: TargetCompID
- 11: ClOrdID
- 55: Symbol
- 54: Side (1=Buy, 2=Sell)
- 38: OrderQty
- 40: OrdType (2=Limit)
- 44: Price
- 10: Checksum

4.2 OPTIMIZED FIX ENGINE
------------------------

```cpp
#include <cstdint>
#include <cstring>
#include <string>
#include <unordered_map>

// Fast FIX parser (zero-copy, minimal allocations)
class FastFIXParser {
private:
    struct FIXField {
        uint16_t tag;
        const char* value;
        uint16_t length;
    };

    static constexpr size_t MAX_FIELDS = 100;
    std::array<FIXField, MAX_FIELDS> fields_;
    size_t field_count_ = 0;

public:
    // Parse FIX message (zero-copy, ~500ns)
    bool parse(const char* message, size_t length) {
        field_count_ = 0;
        const char* ptr = message;
        const char* end = message + length;

        while (ptr < end && field_count_ < MAX_FIELDS) {
            // Parse tag
            uint16_t tag = 0;
            while (ptr < end && *ptr >= '0' && *ptr <= '9') {
                tag = tag * 10 + (*ptr - '0');
                ptr++;
            }

            if (ptr >= end || *ptr != '=') {
                return false; // Invalid format
            }
            ptr++; // Skip '='

            // Parse value
            const char* value_start = ptr;
            while (ptr < end && *ptr != '\x01') {
                ptr++;
            }

            fields_[field_count_++] = {
                tag,
                value_start,
                static_cast<uint16_t>(ptr - value_start)
            };

            if (ptr < end) {
                ptr++; // Skip SOH (\x01)
            }
        }

        return true;
    }

    // Get field value by tag (~20ns)
    const char* get_field(uint16_t tag, uint16_t& length) const {
        for (size_t i = 0; i < field_count_; i++) {
            if (fields_[i].tag == tag) {
                length = fields_[i].length;
                return fields_[i].value;
            }
        }
        return nullptr;
    }

    // Get integer field (~50ns)
    bool get_int_field(uint16_t tag, int64_t& value) const {
        uint16_t length;
        const char* str = get_field(tag, length);
        if (!str) return false;

        value = 0;
        bool negative = false;

        if (*str == '-') {
            negative = true;
            str++;
            length--;
        }

        for (uint16_t i = 0; i < length; i++) {
            if (str[i] < '0' || str[i] > '9') return false;
            value = value * 10 + (str[i] - '0');
        }

        if (negative) value = -value;
        return true;
    }
};

// FIX message builder (pre-allocated buffers)
class FastFIXBuilder {
private:
    char buffer_[1024];
    size_t offset_ = 0;

    static constexpr char SOH = '\x01';

public:
    FastFIXBuilder() { reset(); }

    void reset() {
        offset_ = 0;
        // Start with FIX header
        add_string_field(8, "FIX.4.4");
    }

    // Add string field (~100ns)
    void add_string_field(uint16_t tag, const char* value) {
        offset_ += std::sprintf(buffer_ + offset_, "%u=", tag);
        size_t len = strlen(value);
        memcpy(buffer_ + offset_, value, len);
        offset_ += len;
        buffer_[offset_++] = SOH;
    }

    // Add integer field (~80ns)
    void add_int_field(uint16_t tag, int64_t value) {
        offset_ += std::sprintf(buffer_ + offset_, "%u=%ld%c",
                               tag, value, SOH);
    }

    // Add float field (price) (~120ns)
    void add_price_field(uint16_t tag, double value, int decimals = 2) {
        offset_ += std::sprintf(buffer_ + offset_, "%u=%.*f%c",
                               tag, decimals, value, SOH);
    }

    // Finalize message (add length and checksum) (~200ns)
    std::pair<const char*, size_t> finalize() {
        // Reserve space for body length field (after tag 8)
        size_t body_start = 10; // "8=FIX.4.4\x01"
        size_t body_length = offset_ - body_start;

        // Insert body length field
        char temp[32];
        int len_field_size = std::sprintf(temp, "9=%zu%c", body_length, SOH);

        // Move body to make room for length field
        memmove(buffer_ + body_start + len_field_size,
                buffer_ + body_start,
                body_length);
        memcpy(buffer_ + body_start, temp, len_field_size);
        offset_ += len_field_size;

        // Calculate checksum
        uint8_t checksum = 0;
        for (size_t i = 0; i < offset_; i++) {
            checksum += buffer_[i];
        }
        checksum %= 256;

        // Add checksum field
        offset_ += std::sprintf(buffer_ + offset_, "10=%03u%c",
                               checksum, SOH);

        return {buffer_, offset_};
    }

    // Build NewOrderSingle message (~800ns total)
    std::pair<const char*, size_t> build_new_order_single(
        const char* sender_comp_id,
        const char* target_comp_id,
        uint32_t msg_seq_num,
        const char* cl_ord_id,
        const char* symbol,
        char side, // '1'=Buy, '2'=Sell
        int64_t quantity,
        char ord_type, // '2'=Limit
        double price
    ) {
        reset();

        add_string_field(35, "D"); // MsgType=NewOrderSingle
        add_string_field(49, sender_comp_id); // SenderCompID
        add_string_field(56, target_comp_id); // TargetCompID
        add_int_field(34, msg_seq_num); // MsgSeqNum

        // Sending time
        char sending_time[32];
        time_t now = time(nullptr);
        struct tm* tm_info = gmtime(&now);
        strftime(sending_time, sizeof(sending_time),
                "%Y%m%d-%H:%M:%S", tm_info);
        add_string_field(52, sending_time); // SendingTime

        add_string_field(11, cl_ord_id); // ClOrdID
        add_string_field(55, symbol); // Symbol
        buffer_[offset_++] = '5'; buffer_[offset_++] = '4';
        buffer_[offset_++] = '='; buffer_[offset_++] = side;
        buffer_[offset_++] = SOH; // Side
        add_int_field(38, quantity); // OrderQty
        buffer_[offset_++] = '4'; buffer_[offset_++] = '0';
        buffer_[offset_++] = '='; buffer_[offset_++] = ord_type;
        buffer_[offset_++] = SOH; // OrdType

        if (ord_type == '2') { // Limit order
            add_price_field(44, price); // Price
        }

        return finalize();
    }
};

// FIX session management
class FIXSession {
private:
    std::string sender_comp_id_;
    std::string target_comp_id_;
    uint32_t outgoing_seq_num_ = 1;
    uint32_t incoming_seq_num_ = 1;
    bool logged_in_ = false;

    int socket_fd_ = -1;
    FastFIXParser parser_;
    FastFIXBuilder builder_;

public:
    FIXSession(const std::string& sender, const std::string& target)
        : sender_comp_id_(sender), target_comp_id_(target) {}

    // Send FIX logon
    bool logon() {
        builder_.reset();
        builder_.add_string_field(35, "A"); // MsgType=Logon
        builder_.add_string_field(49, sender_comp_id_.c_str());
        builder_.add_string_field(56, target_comp_id_.c_str());
        builder_.add_int_field(34, outgoing_seq_num_++);
        builder_.add_int_field(98, 0); // EncryptMethod=None
        builder_.add_int_field(108, 30); // HeartBtInt=30 seconds

        auto [msg, len] = builder_.finalize();
        ssize_t sent = ::send(socket_fd_, msg, len, 0);

        return sent == static_cast<ssize_t>(len);
    }

    // Send order
    bool send_order(const char* cl_ord_id, const char* symbol,
                   char side, int64_t quantity, double price) {
        auto [msg, len] = builder_.build_new_order_single(
            sender_comp_id_.c_str(),
            target_comp_id_.c_str(),
            outgoing_seq_num_++,
            cl_ord_id,
            symbol,
            side,
            quantity,
            '2', // Limit order
            price
        );

        ssize_t sent = ::send(socket_fd_, msg, len, 0);
        return sent == static_cast<ssize_t>(len);
    }

    // Process incoming message
    void process_message(const char* msg, size_t len) {
        if (!parser_.parse(msg, len)) {
            return; // Invalid message
        }

        // Get message type
        uint16_t msg_type_len;
        const char* msg_type = parser_.get_field(35, msg_type_len);

        if (!msg_type) return;

        // Handle different message types
        if (msg_type_len == 1 && *msg_type == 'A') {
            // Logon response
            logged_in_ = true;
        } else if (msg_type_len == 1 && *msg_type == '8') {
            // Execution report
            handle_execution_report();
        } else if (msg_type_len == 1 && *msg_type == '0') {
            // Heartbeat
            // No action needed
        }
    }

private:
    void handle_execution_report() {
        // Extract execution details
        uint16_t len;
        const char* cl_ord_id = parser_.get_field(11, len);
        const char* exec_type = parser_.get_field(150, len);
        const char* ord_status = parser_.get_field(39, len);

        int64_t last_qty = 0;
        parser_.get_int_field(32, last_qty);

        // Process execution...
    }
};
```

FIX PROTOCOL PERFORMANCE:
-------------------------
- Parse: 300-800 nanoseconds
- Build: 500-1500 nanoseconds
- Total latency: 1-5 microseconds (optimized)

================================================================================
5. UDP MULTICAST
================================================================================

5.1 UDP MULTICAST OVERVIEW
---------------------------

UDP Multicast for market data:
- One-to-many delivery
- Best-effort (no reliability)
- Extremely low latency (1-50 microseconds)
- Used for market data feeds (NASDAQ, NYSE, CME)

MULTICAST GROUPS:
- Class D IP addresses: 224.0.0.0 to 239.255.255.255
- Example: 233.54.12.1 (market data feed)

5.2 UDP MULTICAST RECEIVER
---------------------------

```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <cstring>

class UDPMulticastReceiver {
private:
    int socket_fd_ = -1;
    struct sockaddr_in local_addr_;

public:
    // Join multicast group
    bool join(const char* multicast_ip, uint16_t port,
             const char* interface_ip = "0.0.0.0") {
        // Create UDP socket
        socket_fd_ = socket(AF_INET, SOCK_DGRAM, 0);
        if (socket_fd_ < 0) {
            return false;
        }

        // Allow multiple processes to bind to same port
        int reuse = 1;
        setsockopt(socket_fd_, SOL_SOCKET, SO_REUSEADDR,
                  &reuse, sizeof(reuse));

        // Bind to port
        memset(&local_addr_, 0, sizeof(local_addr_));
        local_addr_.sin_family = AF_INET;
        local_addr_.sin_addr.s_addr = INADDR_ANY;
        local_addr_.sin_port = htons(port);

        if (bind(socket_fd_, (struct sockaddr*)&local_addr_,
                sizeof(local_addr_)) < 0) {
            close(socket_fd_);
            return false;
        }

        // Join multicast group
        struct ip_mreq mreq;
        inet_pton(AF_INET, multicast_ip, &mreq.imr_multiaddr);
        inet_pton(AF_INET, interface_ip, &mreq.imr_interface);

        if (setsockopt(socket_fd_, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                      &mreq, sizeof(mreq)) < 0) {
            close(socket_fd_);
            return false;
        }

        // Set receive buffer size (reduce packet loss)
        int buffer_size = 16 * 1024 * 1024; // 16 MB
        setsockopt(socket_fd_, SOL_SOCKET, SO_RCVBUF,
                  &buffer_size, sizeof(buffer_size));

        return true;
    }

    // Receive packet (blocking)
    ssize_t receive(void* buffer, size_t buffer_size) {
        return recvfrom(socket_fd_, buffer, buffer_size, 0, nullptr, nullptr);
    }

    // Receive packet with timestamp
    ssize_t receive_with_timestamp(void* buffer, size_t buffer_size,
                                   uint64_t& timestamp_ns) {
        struct msghdr msg;
        struct iovec iov;
        char control[256];

        iov.iov_base = buffer;
        iov.iov_len = buffer_size;

        memset(&msg, 0, sizeof(msg));
        msg.msg_iov = &iov;
        msg.msg_iovlen = 1;
        msg.msg_control = control;
        msg.msg_controllen = sizeof(control);

        ssize_t received = recvmsg(socket_fd_, &msg, 0);

        if (received > 0) {
            // Extract hardware timestamp (if available)
            for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
                 cmsg != nullptr;
                 cmsg = CMSG_NXTHDR(&msg, cmsg)) {
                if (cmsg->cm_level == SOL_SOCKET &&
                    cmsg->cm_type == SO_TIMESTAMPNS) {
                    struct timespec* ts = (struct timespec*)CMSG_DATA(cmsg);
                    timestamp_ns = ts->tv_sec * 1000000000ULL + ts->tv_nsec;
                }
            }
        }

        return received;
    }

    ~UDPMulticastReceiver() {
        if (socket_fd_ >= 0) {
            close(socket_fd_);
        }
    }
};

// Fast UDP multicast market data processor
class MarketDataProcessor {
private:
    UDPMulticastReceiver receiver_;
    OrderBookL2 order_book_;

    struct __attribute__((packed)) MDPacketHeader {
        uint32_t sequence_num;
        uint16_t message_count;
        uint16_t padding;
    };

    struct __attribute__((packed)) MDMessage {
        uint8_t msg_type;  // 'A'=Add, 'U'=Update, 'D'=Delete
        uint8_t side;      // 'B'=Bid, 'A'=Ask
        uint16_t symbol_id;
        uint64_t price;
        uint64_t quantity;
        uint64_t order_id;
    };

public:
    // Start processing market data
    void run(const char* multicast_ip, uint16_t port) {
        if (!receiver_.join(multicast_ip, port)) {
            fprintf(stderr, "Failed to join multicast group\n");
            return;
        }

        uint8_t buffer[9000]; // Jumbo frame
        uint32_t expected_seq = 0;

        while (true) {
            uint64_t rx_timestamp;
            ssize_t received = receiver_.receive_with_timestamp(
                buffer, sizeof(buffer), rx_timestamp);

            if (received < 0) {
                continue;
            }

            uint64_t process_start = TSCTimestamp::read_tsc_fast();

            // Parse packet header
            if (received < static_cast<ssize_t>(sizeof(MDPacketHeader))) {
                continue;
            }

            const MDPacketHeader* header =
                reinterpret_cast<const MDPacketHeader*>(buffer);

            // Check sequence number (detect gaps)
            if (header->sequence_num != expected_seq) {
                printf("Gap detected: expected %u, got %u\n",
                      expected_seq, header->sequence_num);
                // Request retransmission or snapshot
            }
            expected_seq = header->sequence_num + 1;

            // Process messages
            const uint8_t* msg_ptr = buffer + sizeof(MDPacketHeader);
            for (uint16_t i = 0; i < header->message_count; i++) {
                const MDMessage* msg =
                    reinterpret_cast<const MDMessage*>(msg_ptr);

                process_message(msg);

                msg_ptr += sizeof(MDMessage);
            }

            uint64_t process_end = TSCTimestamp::read_tsc_fast();
            uint64_t latency_ns = (process_end - process_start) * 0.33; // 3GHz CPU

            if (latency_ns > 10000) { // Alert if > 10us
                printf("High processing latency: %lu ns\n", latency_ns);
            }
        }
    }

private:
    void process_message(const MDMessage* msg) {
        switch (msg->msg_type) {
            case 'A': // Add order
            case 'U': // Update order
                if (msg->side == 'B') {
                    order_book_.update_bid(msg->price, msg->quantity);
                } else {
                    order_book_.update_ask(msg->price, msg->quantity);
                }
                break;

            case 'D': // Delete order
                if (msg->side == 'B') {
                    order_book_.update_bid(msg->price, 0);
                } else {
                    order_book_.update_ask(msg->price, 0);
                }
                break;
        }
    }
};
```

UDP MULTICAST PERFORMANCE:
---------------------------
- Receive latency: 1-10 microseconds
- Processing latency: 5-50 microseconds
- Total latency: 10-100 microseconds
- Throughput: 1-10 million messages/second

================================================================================
6. KERNEL BYPASS (DPDK/OpenOnload)
================================================================================

6.1 DPDK (Data Plane Development Kit)
--------------------------------------

DPDK bypasses the kernel network stack:
- Poll Mode Driver (PMD) - no interrupts
- Zero-copy packet processing
- User-space drivers
- Huge pages for memory
- CPU core isolation

DPDK ARCHITECTURE:
[NIC] → [DMA to user space] → [Poll Mode Driver] → [Application]

Latency: 100-500 nanoseconds

6.2 DPDK BASIC SETUP
--------------------

```cpp
#include <rte_eal.h>
#include <rte_ethdev.h>
#include <rte_mbuf.h>

// DPDK initialization
int initialize_dpdk(int argc, char** argv) {
    // Initialize EAL (Environment Abstraction Layer)
    int ret = rte_eal_init(argc, argv);
    if (ret < 0) {
        rte_exit(EXIT_FAILURE, "Cannot init EAL\n");
    }

    // Check available ports
    uint16_t nb_ports = rte_eth_dev_count_avail();
    if (nb_ports == 0) {
        rte_exit(EXIT_FAILURE, "No Ethernet ports found\n");
    }

    printf("DPDK initialized with %u ports\n", nb_ports);
    return 0;
}

// Configure DPDK port for ultra-low latency
bool configure_port_low_latency(uint16_t port_id) {
    struct rte_eth_conf port_conf = {};

    // Disable features that add latency
    port_conf.rxmode.mq_mode = RTE_ETH_MQ_RX_NONE; // Single queue
    port_conf.txmode.mq_mode = RTE_ETH_MQ_TX_NONE;
    port_conf.rxmode.offloads = 0; // Disable all offloads
    port_conf.txmode.offloads = 0;

    // Configure device
    int ret = rte_eth_dev_configure(port_id, 1, 1, &port_conf);
    if (ret < 0) {
        return false;
    }

    // Setup RX queue
    ret = rte_eth_rx_queue_setup(port_id, 0, 128,
                                 rte_eth_dev_socket_id(port_id),
                                 nullptr, mbuf_pool);
    if (ret < 0) {
        return false;
    }

    // Setup TX queue
    ret = rte_eth_tx_queue_setup(port_id, 0, 128,
                                 rte_eth_dev_socket_id(port_id),
                                 nullptr);
    if (ret < 0) {
        return false;
    }

    // Start device
    ret = rte_eth_dev_start(port_id);
    if (ret < 0) {
        return false;
    }

    // Enable promiscuous mode
    rte_eth_promiscuous_enable(port_id);

    return true;
}
```

DPDK COMMAND LINE:
------------------
./trading_app -l 0-3 -n 4 --huge-dir=/mnt/huge -- --port=0

-l 0-3: Use CPU cores 0-3
-n 4: 4 memory channels
--huge-dir: Huge pages directory

DPDK PERFORMANCE:
-----------------
- RX latency: 100-300 nanoseconds
- TX latency: 100-300 nanoseconds
- Throughput: 100+ Gbps
- Packet rate: 100+ million pps

================================================================================
7. PERFORMANCE COMPARISON
================================================================================

LATENCY COMPARISON (1500-byte packet):
---------------------------------------

Method              Setup       RX          TX          Total
--------------------------------------------------------------------
Traditional TCP     100-500us   10-50us     10-50us     120-600us
TLS/TCP             500-2ms     20-100us    20-100us    540-2200us
WebSocket/TCP       100-500us   15-75us     15-75us     130-650us
FIX/TCP (opt)       10-100us    5-20us      5-20us      20-140us
UDP                 5-50us      1-10us      1-10us      7-70us
UDP Multicast       5-50us      1-10us      N/A         6-60us
Kernel Bypass       1-10us      0.1-1us     0.1-1us     1.2-12us
RDMA                0.5-5us     0.05-0.5us  0.05-0.5us  0.6-6us
--------------------------------------------------------------------

THROUGHPUT COMPARISON:
----------------------

Method              Single Core  Multi Core   Max BW
--------------------------------------------------------
Traditional TCP     100 MB/s     1 GB/s       10 Gbps
TLS/TCP (AES-NI)    500 MB/s     5 GB/s       40 Gbps
WebSocket           200 MB/s     2 GB/s       20 Gbps
UDP                 1 GB/s       10 GB/s      100 Gbps
Kernel Bypass       10 GB/s      100 GB/s     100+ Gbps
RDMA                20 GB/s      200 GB/s     200 Gbps
--------------------------------------------------------

================================================================================
8. BEST PRACTICES
================================================================================

CONNECTION TYPE SELECTION:
--------------------------

REST API / Web UI:
→ Use TLS/TCP or WebSocket over TLS

Regulatory Reporting / Audit:
→ Use TLS/TCP (encryption + reliability required)

Order Routing (< 100us latency acceptable):
→ Use FIX over TCP (standard protocol, reliable)

Order Routing (< 10us latency required):
→ Use kernel bypass with custom binary protocol

Market Data (thousands of updates/sec):
→ Use UDP multicast

Market Data (millions of updates/sec):
→ Use kernel bypass with UDP multicast

Inter-server Communication (same datacenter):
→ Use RDMA or shared memory

Inter-server Communication (cross-datacenter):
→ Use optimized TCP or kernel bypass

OPTIMIZATION CHECKLIST:
-----------------------
[X] Disable Nagle's algorithm (TCP_NODELAY)
[X] Set large socket buffers (SO_RCVBUF, SO_SNDBUF)
[X] Use CPU core pinning
[X] Use huge pages for memory
[X] Enable hardware offloads (checksum, TSO)
[X] Use zero-copy techniques
[X] Minimize system calls
[X] Pre-allocate buffers
[X] Use binary protocols (not text)
[X] Measure and monitor latency continuously

================================================================================
END OF DOCUMENT
================================================================================
