================================================================================
HFT RISK CONFIGURATION - RISK LIMITS AND CONTROLS
================================================================================
Version: 1.0.0
Last Updated: 2025-11-25
Description: Comprehensive risk management and control configuration
================================================================================

TABLE OF CONTENTS
-----------------
1. Risk Framework Overview
2. Position Limits
3. Order Limits
4. P&L Limits
5. Exposure Limits
6. Market Risk Controls
7. Operational Risk Controls
8. Pre-Trade Risk Checks
9. Post-Trade Risk Monitoring
10. Circuit Breakers
11. C++ Risk Manager Implementation

================================================================================
1. RISK FRAMEWORK OVERVIEW
================================================================================

RISK MANAGEMENT FRAMEWORK:
--------------------------
```yaml
risk_framework:
  mode: "realtime"  # realtime, end_of_day, hybrid

  enforcement:
    level: "strict"  # strict, warning, advisory
    auto_liquidate: true
    notify_on_breach: true

  hierarchy:
    levels:
      - name: "system"
        priority: 1
        override_allowed: false

      - name: "strategy"
        priority: 2
        override_allowed: true
        override_approval: "risk_manager"

      - name: "instrument"
        priority: 3
        override_allowed: true

  monitoring:
    check_frequency_ms: 100
    alert_latency_ms: 10
    escalation_enabled: true

  calculation:
    # Real-time P&L calculation
    pnl_calculation: "mark_to_market"  # mark_to_market, realized_only
    mark_source: "mid"  # mid, last, bid, ask

    # Exposure calculation
    exposure_method: "gross"  # gross, net, var
    include_pending_orders: true
```

GLOBAL RISK LIMITS:
-------------------
```yaml
global_limits:
  # Maximum daily loss
  max_daily_loss_usd: 500000
  max_daily_loss_pct: 2.0

  # Maximum total exposure
  max_gross_exposure_usd: 10000000
  max_net_exposure_usd: 5000000

  # Position limits
  max_total_positions: 100
  max_position_concentration_pct: 10.0

  # Order limits
  max_orders_per_second: 1000
  max_order_value_usd: 1000000
  max_message_rate: 2000

  # Leverage
  max_leverage: 4.0
  margin_requirement_pct: 25.0
```

================================================================================
2. POSITION LIMITS
================================================================================

POSITION LIMIT CONFIGURATION:
------------------------------
```yaml
position_limits:
  # Per-instrument limits
  instruments:
    AAPL:
      max_position_size: 10000
      max_position_value_usd: 2000000
      max_long_position: 10000
      max_short_position: -10000

    MSFT:
      max_position_size: 8000
      max_position_value_usd: 1500000
      max_long_position: 8000
      max_short_position: -8000

    SPY:
      max_position_size: 20000
      max_position_value_usd: 5000000
      max_long_position: 20000
      max_short_position: -20000

  # Per-strategy limits
  strategies:
    market_making_v1:
      max_gross_position: 50000
      max_net_position: 10000
      max_position_concentration_pct: 20.0

    stat_arb_pairs:
      max_gross_position: 30000
      max_net_position: 5000

  # Sector limits
  sectors:
    technology:
      max_exposure_usd: 5000000
      max_concentration_pct: 50.0

    financials:
      max_exposure_usd: 3000000
      max_concentration_pct: 30.0

  # Position age
  position_age:
    max_holding_period_s: 86400  # 24 hours
    warn_holding_period_s: 43200  # 12 hours
    auto_liquidate_on_timeout: false
```

POSITION MONITORING:
--------------------
```yaml
position_monitoring:
  real_time_checks:
    enabled: true
    check_interval_ms: 100

  alerts:
    - condition: "position_size > 0.9 * max_position"
      level: "warning"
      action: "notify"

    - condition: "position_size >= max_position"
      level: "critical"
      action: "reject_new_orders"

    - condition: "position_value > max_position_value"
      level: "critical"
      action: "auto_liquidate"

  concentration_check:
    enabled: true
    max_instrument_pct: 15.0
    max_sector_pct: 40.0
    max_strategy_pct: 30.0
```

C++ POSITION LIMIT CHECKER:
----------------------------
```cpp
class PositionLimitChecker {
private:
    struct InstrumentLimits {
        int32_t max_position_size;
        int32_t max_long_position;
        int32_t max_short_position;
        double max_position_value_usd;
    };

    std::unordered_map<std::string, InstrumentLimits> instrument_limits_;
    std::unordered_map<std::string, int32_t> current_positions_;
    mutable std::shared_mutex mutex_;

public:
    enum class CheckResult {
        APPROVED,
        REJECTED_POSITION_LIMIT,
        REJECTED_VALUE_LIMIT,
        REJECTED_CONCENTRATION
    };

    CheckResult CheckOrder(const std::string& symbol,
                          Side side,
                          uint32_t quantity,
                          double price) {

        std::shared_lock lock(mutex_);

        auto it = instrument_limits_.find(symbol);
        if (it == instrument_limits_.end()) {
            LOG_WARN("No limits configured for {}", symbol);
            return CheckResult::REJECTED_POSITION_LIMIT;
        }

        const auto& limits = it->second;

        // Get current position
        int32_t current_pos = GetPosition(symbol);

        // Calculate new position after order
        int32_t new_position = current_pos;
        if (side == Side::BUY) {
            new_position += quantity;
        } else {
            new_position -= quantity;
        }

        // Check position size limit
        if (std::abs(new_position) > limits.max_position_size) {
            LOG_WARN("Position limit exceeded for {}: {} > {}",
                    symbol, std::abs(new_position),
                    limits.max_position_size);
            return CheckResult::REJECTED_POSITION_LIMIT;
        }

        // Check long/short limits
        if (new_position > limits.max_long_position) {
            LOG_WARN("Long position limit exceeded for {}", symbol);
            return CheckResult::REJECTED_POSITION_LIMIT;
        }

        if (new_position < -limits.max_short_position) {
            LOG_WARN("Short position limit exceeded for {}", symbol);
            return CheckResult::REJECTED_POSITION_LIMIT;
        }

        // Check position value limit
        double position_value =
            std::abs(new_position) * price;

        if (position_value > limits.max_position_value_usd) {
            LOG_WARN("Position value limit exceeded for {}: ${} > ${}",
                    symbol, position_value,
                    limits.max_position_value_usd);
            return CheckResult::REJECTED_VALUE_LIMIT;
        }

        // Check concentration
        if (!CheckConcentration(symbol, position_value)) {
            return CheckResult::REJECTED_CONCENTRATION;
        }

        return CheckResult::APPROVED;
    }

    void UpdatePosition(const std::string& symbol,
                       const Fill& fill) {
        std::unique_lock lock(mutex_);

        int32_t qty = fill.quantity;
        if (fill.side == Side::SELL) {
            qty = -qty;
        }

        current_positions_[symbol] += qty;

        LOG_DEBUG("Position updated: {} = {}",
                 symbol, current_positions_[symbol]);

        // Check if we're approaching limits
        CheckPositionAlerts(symbol);
    }

private:
    int32_t GetPosition(const std::string& symbol) const {
        auto it = current_positions_.find(symbol);
        return (it != current_positions_.end()) ? it->second : 0;
    }

    bool CheckConcentration(const std::string& symbol,
                           double position_value) {
        // Calculate total portfolio value
        double total_value = CalculateTotalPortfolioValue();

        // Check concentration percentage
        double concentration_pct =
            (position_value / total_value) * 100.0;

        const double MAX_CONCENTRATION_PCT = 15.0;

        if (concentration_pct > MAX_CONCENTRATION_PCT) {
            LOG_WARN("Concentration limit exceeded: {}%",
                    concentration_pct);
            return false;
        }

        return true;
    }

    void CheckPositionAlerts(const std::string& symbol) {
        auto it = instrument_limits_.find(symbol);
        if (it == instrument_limits_.end()) return;

        int32_t current_pos = GetPosition(symbol);
        const auto& limits = it->second;

        // Warning at 90% of limit
        double usage_pct = (static_cast<double>(std::abs(current_pos)) /
                           limits.max_position_size) * 100.0;

        if (usage_pct > 90.0) {
            LOG_WARN("Position limit warning for {}: {}% used",
                    symbol, usage_pct);
            // Send alert
        }
    }

    double CalculateTotalPortfolioValue() const {
        // Implementation to calculate total portfolio value
        return 10000000.0;  // Example
    }
};
```

================================================================================
3. ORDER LIMITS
================================================================================

ORDER LIMIT CONFIGURATION:
--------------------------
```yaml
order_limits:
  # Order size limits
  size_limits:
    min_order_size: 1
    max_order_size: 10000
    max_order_value_usd: 1000000

    # Clip large orders
    auto_clip_enabled: true
    clip_size: 1000

  # Order rate limits
  rate_limits:
    max_orders_per_second: 100
    max_cancels_per_second: 200
    max_modifies_per_second: 50

    # Burst allowance
    burst_window_ms: 100
    max_burst_orders: 20

  # Order-to-trade ratio
  order_trade_ratio:
    max_ratio: 20.0
    window_minutes: 60
    breach_action: "throttle"  # throttle, block, warn

  # Fat finger checks
  fat_finger:
    enabled: true

    price_checks:
      # Price deviation from reference
      max_deviation_pct: 5.0
      reference_price: "mid"  # mid, last, nbbo

      # Price collar
      collar_enabled: true
      collar_pct: 10.0

    size_checks:
      # Unusual size detection
      max_size_multiplier: 10.0
      reference_period_s: 300

    value_checks:
      # Maximum single order value
      max_single_order_value: 500000
      require_confirmation_above: 100000
```

ORDER VALIDATION:
-----------------
```yaml
order_validation:
  pre_submission:
    checks:
      - "valid_symbol"
      - "valid_price"
      - "valid_quantity"
      - "market_hours"
      - "position_limits"
      - "order_limits"
      - "fat_finger"
      - "duplicate_detection"

    duplicate_detection:
      enabled: true
      window_ms: 1000
      tolerance_price_pct: 0.01
      tolerance_size_pct: 0.01

  market_hours:
    enforce: true
    allow_extended_hours: true

    regular_hours:
      start: "09:30:00"
      end: "16:00:00"

    extended_hours:
      pre_market_start: "04:00:00"
      after_hours_end: "20:00:00"
```

C++ ORDER VALIDATOR:
--------------------
```cpp
class OrderValidator {
private:
    struct OrderLimits {
        uint32_t max_order_size;
        double max_order_value_usd;
        double max_price_deviation_pct;
    };

    OrderLimits limits_;
    RateLimiter rate_limiter_;
    FatFingerChecker fat_finger_checker_;

public:
    struct ValidationResult {
        bool approved;
        std::string rejection_reason;
        std::vector<std::string> warnings;
    };

    ValidationResult ValidateOrder(const Order& order) {
        ValidationResult result{true, "", {}};

        // Check order size
        if (order.quantity < 1 ||
            order.quantity > limits_.max_order_size) {
            result.approved = false;
            result.rejection_reason = "Invalid order size";
            return result;
        }

        // Check order value
        double order_value = order.quantity * order.price;
        if (order_value > limits_.max_order_value_usd) {
            result.approved = false;
            result.rejection_reason = "Order value exceeds limit";
            return result;
        }

        // Check rate limits
        if (!rate_limiter_.CheckLimit()) {
            result.approved = false;
            result.rejection_reason = "Rate limit exceeded";
            return result;
        }

        // Fat finger check
        if (!fat_finger_checker_.Check(order)) {
            result.approved = false;
            result.rejection_reason = "Fat finger detected";
            return result;
        }

        // Check price deviation
        double ref_price = GetReferencePrice(order.symbol);
        double deviation_pct =
            std::abs(order.price - ref_price) / ref_price * 100.0;

        if (deviation_pct > limits_.max_price_deviation_pct) {
            result.warnings.push_back(
                fmt::format("Price deviation: {:.2f}%",
                           deviation_pct));

            if (deviation_pct > limits_.max_price_deviation_pct * 2) {
                result.approved = false;
                result.rejection_reason =
                    "Price deviation too large";
                return result;
            }
        }

        // Check market hours
        if (!IsMarketOpen()) {
            result.approved = false;
            result.rejection_reason = "Market closed";
            return result;
        }

        return result;
    }

private:
    double GetReferencePrice(const std::string& symbol) {
        // Get reference price from order book
        return 100.0;  // Example
    }

    bool IsMarketOpen() {
        auto now = std::chrono::system_clock::now();
        // Check if within market hours
        return true;  // Example
    }
};

class RateLimiter {
private:
    uint32_t max_requests_;
    uint32_t window_ms_;

    struct RequestWindow {
        std::deque<uint64_t> timestamps;
        mutable std::mutex mutex;
    };

    RequestWindow window_;

public:
    RateLimiter(uint32_t max_requests, uint32_t window_ms)
        : max_requests_(max_requests), window_ms_(window_ms) {}

    bool CheckLimit() {
        std::lock_guard lock(window_.mutex);

        auto now = GetCurrentTimeMicros();
        auto cutoff = now - (window_ms_ * 1000);

        // Remove old timestamps
        while (!window_.timestamps.empty() &&
               window_.timestamps.front() < cutoff) {
            window_.timestamps.pop_front();
        }

        // Check if we're under the limit
        if (window_.timestamps.size() >= max_requests_) {
            return false;
        }

        // Add current timestamp
        window_.timestamps.push_back(now);
        return true;
    }
};
```

================================================================================
4. P&L LIMITS
================================================================================

P&L LIMIT CONFIGURATION:
------------------------
```yaml
pnl_limits:
  # Daily P&L limits
  daily:
    max_loss_usd: 500000
    max_loss_pct: 2.0
    take_profit_usd: 1000000
    take_profit_pct: 4.0

    actions:
      on_max_loss: "stop_trading"  # stop_trading, liquidate, notify
      on_take_profit: "notify"

  # Intraday drawdown limits
  intraday:
    max_drawdown_usd: 250000
    max_drawdown_pct: 1.0

    trailing_stop:
      enabled: true
      trailing_pct: 0.5

  # Per-strategy P&L limits
  per_strategy:
    market_making_v1:
      max_daily_loss: 100000
      stop_loss_threshold: 50000

    stat_arb_pairs:
      max_daily_loss: 75000
      stop_loss_threshold: 40000

  # Per-instrument P&L limits
  per_instrument:
    default:
      max_loss_usd: 50000
      stop_loss_bps: 100

    high_volatility:
      max_loss_usd: 25000
      stop_loss_bps: 50
```

REAL-TIME P&L CALCULATION:
--------------------------
```yaml
pnl_calculation:
  method: "mark_to_market"  # mark_to_market, realized_only

  mark_to_market:
    pricing_source: "mid"  # mid, last, bid, ask, vwap
    update_frequency_ms: 100

  realized_pnl:
    calculation_method: "fifo"  # fifo, lifo, average

  unrealized_pnl:
    include_pending_orders: false
    mark_to_market_frequency_ms: 100

  # P&L components
  components:
    trading_pnl: true
    commission: true
    fees: true
    financing: true
    slippage_estimate: true

  # P&L reporting
  reporting:
    real_time_updates: true
    snapshot_interval_s: 60
    end_of_day_reconciliation: true
```

C++ P&L MANAGER:
----------------
```cpp
class PnLManager {
private:
    struct Position {
        int32_t quantity;
        double avg_price;
        double realized_pnl;
        double unrealized_pnl;
    };

    std::unordered_map<std::string, Position> positions_;
    mutable std::shared_mutex mutex_;

    double daily_realized_pnl_{0.0};
    double daily_unrealized_pnl_{0.0};
    double high_water_mark_{0.0};
    double max_drawdown_{0.0};

    struct PnLLimits {
        double max_daily_loss;
        double max_drawdown;
        double take_profit;
    } limits_;

public:
    void OnFill(const Fill& fill) {
        std::unique_lock lock(mutex_);

        auto& pos = positions_[fill.symbol];

        if ((fill.side == Side::BUY && pos.quantity < 0) ||
            (fill.side == Side::SELL && pos.quantity > 0)) {
            // Reducing position - calculate realized P&L
            UpdateRealizedPnL(pos, fill);
        } else {
            // Increasing position - update average price
            UpdateAveragePrice(pos, fill);
        }

        // Update position quantity
        if (fill.side == Side::BUY) {
            pos.quantity += fill.quantity;
        } else {
            pos.quantity -= fill.quantity;
        }

        // Recalculate unrealized P&L
        UpdateUnrealizedPnL();

        // Check P&L limits
        CheckPnLLimits();
    }

    void UpdateMarketData(const std::string& symbol,
                         double current_price) {
        std::shared_lock lock(mutex_);

        auto it = positions_.find(symbol);
        if (it == positions_.end()) return;

        auto& pos = it->second;

        // Calculate unrealized P&L
        if (pos.quantity != 0) {
            pos.unrealized_pnl =
                pos.quantity * (current_price - pos.avg_price);
        }

        // Update total unrealized P&L
        UpdateUnrealizedPnL();

        // Check P&L limits
        CheckPnLLimits();
    }

    double GetDailyPnL() const {
        std::shared_lock lock(mutex_);
        return daily_realized_pnl_ + daily_unrealized_pnl_;
    }

    double GetMaxDrawdown() const {
        std::shared_lock lock(mutex_);
        return max_drawdown_;
    }

private:
    void UpdateRealizedPnL(Position& pos, const Fill& fill) {
        double pnl = 0.0;

        if (fill.side == Side::BUY) {
            // Buying to cover short
            pnl = (-pos.quantity) * (pos.avg_price - fill.price);
        } else {
            // Selling long position
            pnl = fill.quantity * (fill.price - pos.avg_price);
        }

        pos.realized_pnl += pnl;
        daily_realized_pnl_ += pnl;

        LOG_INFO("Realized P&L: {} {} = ${:.2f}",
                fill.symbol,
                fill.side == Side::BUY ? "BUY" : "SELL",
                pnl);
    }

    void UpdateAveragePrice(Position& pos, const Fill& fill) {
        double total_value =
            std::abs(pos.quantity) * pos.avg_price +
            fill.quantity * fill.price;

        double total_qty =
            std::abs(pos.quantity) + fill.quantity;

        pos.avg_price = total_value / total_qty;
    }

    void UpdateUnrealizedPnL() {
        daily_unrealized_pnl_ = 0.0;

        for (const auto& [symbol, pos] : positions_) {
            daily_unrealized_pnl_ += pos.unrealized_pnl;
        }
    }

    void CheckPnLLimits() {
        double total_pnl = GetDailyPnL();

        // Update high water mark
        if (total_pnl > high_water_mark_) {
            high_water_mark_ = total_pnl;
        }

        // Calculate current drawdown
        double current_drawdown = high_water_mark_ - total_pnl;

        if (current_drawdown > max_drawdown_) {
            max_drawdown_ = current_drawdown;
        }

        // Check daily loss limit
        if (total_pnl < -limits_.max_daily_loss) {
            LOG_CRITICAL("Daily loss limit breached: ${:.2f}",
                        total_pnl);
            TriggerStopTrading();
        }

        // Check drawdown limit
        if (current_drawdown > limits_.max_drawdown) {
            LOG_CRITICAL("Drawdown limit breached: ${:.2f}",
                        current_drawdown);
            TriggerStopTrading();
        }

        // Check take profit
        if (total_pnl > limits_.take_profit) {
            LOG_INFO("Take profit target reached: ${:.2f}",
                    total_pnl);
            // Notify but don't stop trading
        }
    }

    void TriggerStopTrading() {
        // Implementation to stop all trading activity
        LOG_CRITICAL("STOP TRADING TRIGGERED");
        // Notify risk manager, cancel all orders, etc.
    }
};
```

================================================================================
5. CIRCUIT BREAKERS
================================================================================

CIRCUIT BREAKER CONFIGURATION:
------------------------------
```yaml
circuit_breakers:
  # Global circuit breaker
  global:
    enabled: true

    triggers:
      - name: "daily_loss"
        threshold_usd: 500000
        action: "halt_all_trading"
        cooldown_s: 300

      - name: "order_reject_rate"
        threshold_pct: 50.0
        window_s: 60
        action: "pause_new_orders"

      - name: "connection_loss"
        threshold_count: 3
        window_s: 60
        action: "halt_all_trading"

  # Per-strategy circuit breakers
  per_strategy:
    enabled: true

    triggers:
      - name: "strategy_loss"
        threshold_usd: 100000
        action: "disable_strategy"

      - name: "fill_rate_anomaly"
        deviation_std: 3.0
        action: "pause_strategy"

  # Recovery actions
  recovery:
    auto_resume: false
    manual_approval_required: true
    max_auto_resume_attempts: 0
```

================================================================================
END OF RISK CONFIGURATION
================================================================================
