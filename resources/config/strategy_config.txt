================================================================================
HFT STRATEGY CONFIGURATION - TRADING STRATEGY PARAMETERS
================================================================================
Version: 1.0.0
Last Updated: 2025-11-25
Description: Strategy parameters and algorithm configuration
================================================================================

TABLE OF CONTENTS
-----------------
1. Strategy Framework Configuration
2. Market Making Strategies
3. Arbitrage Strategies
4. Statistical Arbitrage
5. Momentum Strategies
6. Mean Reversion Strategies
7. Strategy Parameter Management
8. Backtesting Configuration
9. Live Trading Parameters
10. C++ Strategy Implementation
11. Parameter Optimization

================================================================================
1. STRATEGY FRAMEWORK CONFIGURATION
================================================================================

STRATEGY REGISTRY:
------------------
```yaml
strategies:
  enabled:
    - "market_making_v1"
    - "stat_arb_pairs"
    - "momentum_breakout"
    - "mean_reversion"

  global_settings:
    max_concurrent_strategies: 10
    strategy_isolation: true
    shared_state_enabled: false

  execution:
    mode: "live"  # backtest, paper, live
    latency_target_us: 50
    max_slippage_bps: 5

  resource_allocation:
    max_memory_per_strategy_mb: 512
    max_cpu_cores_per_strategy: 2
```

STRATEGY LIFECYCLE:
-------------------
```yaml
lifecycle:
  initialization:
    warmup_period_s: 60
    historical_data_required_days: 30
    validate_params_on_start: true

  runtime:
    health_check_interval_s: 10
    performance_monitoring: true
    auto_disable_on_loss_threshold: true

  shutdown:
    graceful_shutdown: true
    cancel_pending_orders: true
    close_positions: false  # Manual intervention
    max_shutdown_time_s: 30
```

================================================================================
2. MARKET MAKING STRATEGIES
================================================================================

BASIC MARKET MAKING:
--------------------
```yaml
market_making_v1:
  enabled: true
  strategy_type: "market_making"

  instruments:
    - symbol: "AAPL"
      exchange: "NASDAQ"
      min_spread_bps: 1
      max_spread_bps: 10

    - symbol: "MSFT"
      exchange: "NASDAQ"
      min_spread_bps: 1
      max_spread_bps: 10

  quoting:
    # Spread configuration
    base_spread_bps: 2
    spread_adjustment_factor: 1.5
    spread_skew_enabled: true

    # Quote sizes
    min_quote_size: 100
    max_quote_size: 1000
    size_increment: 100

    # Inventory management
    target_inventory: 0
    max_inventory: 5000
    inventory_skew_factor: 0.1  # Adjust spread based on inventory

    # Pricing
    reference_price: "mid"  # mid, micro, last, vwap
    tick_size: 0.01
    price_offset_enabled: false

  risk_limits:
    max_position_size: 10000
    max_order_value_usd: 100000
    max_daily_loss_usd: 50000
    max_drawdown_pct: 5.0

  timing:
    quote_refresh_interval_ms: 100
    min_quote_lifetime_ms: 50
    cancel_on_disconnect: true

  adverse_selection:
    enabled: true
    lookback_window_s: 5
    threshold_bps: 10
    pause_duration_s: 30

  microstructure:
    queue_position_tracking: true
    order_book_imbalance_factor: 0.5
    trade_flow_toxicity_enabled: true
```

ADVANCED MARKET MAKING:
-----------------------
```yaml
market_making_advanced:
  enabled: true

  # Multi-level quoting
  levels:
    - level: 1
      offset_bps: 0
      size: 500
      refresh_rate_ms: 50

    - level: 2
      offset_bps: 5
      size: 300
      refresh_rate_ms: 100

    - level: 3
      offset_bps: 10
      size: 200
      refresh_rate_ms: 200

  # Dynamic spread adjustment
  spread_model:
    type: "adaptive"  # fixed, adaptive, reinforcement_learning

    volatility_adjustment:
      enabled: true
      lookback_window_s: 60
      multiplier: 2.0

    volume_adjustment:
      enabled: true
      high_volume_threshold: 10000
      low_volume_threshold: 1000
      spread_reduction_pct: 20

  # Inventory risk
  inventory_management:
    model: "ou_process"  # ornstein_uhlenbeck

    parameters:
      mean_reversion_speed: 0.5
      volatility: 0.1
      risk_aversion: 2.0

    hedging:
      enabled: true
      hedge_ratio: 0.8
      hedge_instrument: "SPY"
      rebalance_threshold: 100

  # Order placement optimization
  placement:
    passive_orders_pct: 80  # Percentage of passive orders
    aggressive_orders_pct: 20  # Cross spread if needed
    take_liquidity_on_imbalance: true
    imbalance_threshold: 0.7

    smart_routing:
      enabled: true
      evaluate_queue_position: true
      min_probability_fill: 0.5
```

C++ MARKET MAKING IMPLEMENTATION:
----------------------------------
```cpp
class MarketMakingStrategy : public Strategy {
private:
    struct QuoteLevel {
        double offset_bps;
        uint32_t size;
        uint32_t refresh_rate_ms;
    };

    struct StrategyParams {
        double base_spread_bps;
        double spread_adjustment_factor;
        int32_t target_inventory;
        int32_t max_inventory;
        double inventory_skew_factor;
        std::vector<QuoteLevel> levels;
    };

    StrategyParams params_;
    std::atomic<int32_t> current_inventory_{0};
    OrderBook& order_book_;
    RiskManager& risk_manager_;

public:
    MarketMakingStrategy(const StrategyParams& params,
                        OrderBook& ob,
                        RiskManager& rm)
        : params_(params), order_book_(ob), risk_manager_(rm) {}

    void OnMarketData(const MarketDataUpdate& update) override {
        // Get current mid price
        double mid_price = order_book_.GetMidPrice();

        // Calculate optimal quotes
        auto [bid_price, ask_price, bid_size, ask_size] =
            CalculateQuotes(mid_price);

        // Check risk limits
        if (!risk_manager_.CheckQuote(bid_size, ask_size)) {
            CancelAllQuotes();
            return;
        }

        // Update quotes
        UpdateQuotes(bid_price, ask_price, bid_size, ask_size);
    }

    std::tuple<double, double, uint32_t, uint32_t>
    CalculateQuotes(double mid_price) {

        // Calculate base spread
        double spread = params_.base_spread_bps * mid_price / 10000.0;

        // Adjust for volatility
        double volatility = order_book_.GetVolatility();
        spread *= (1.0 + volatility * params_.spread_adjustment_factor);

        // Adjust for inventory
        int32_t inventory = current_inventory_.load();
        double inventory_ratio =
            static_cast<double>(inventory) / params_.max_inventory;
        double skew = inventory_ratio * params_.inventory_skew_factor;

        // Calculate prices
        double bid_price = mid_price - (spread / 2.0) * (1.0 + skew);
        double ask_price = mid_price + (spread / 2.0) * (1.0 - skew);

        // Calculate sizes based on inventory
        uint32_t bid_size = CalculateBidSize(inventory);
        uint32_t ask_size = CalculateAskSize(inventory);

        return {bid_price, ask_price, bid_size, ask_size};
    }

    uint32_t CalculateBidSize(int32_t inventory) {
        if (inventory > params_.target_inventory) {
            // Reduce bid size if long inventory
            return params_.levels[0].size / 2;
        }
        return params_.levels[0].size;
    }

    uint32_t CalculateAskSize(int32_t inventory) {
        if (inventory < params_.target_inventory) {
            // Reduce ask size if short inventory
            return params_.levels[0].size / 2;
        }
        return params_.levels[0].size;
    }

    void OnFill(const Fill& fill) override {
        // Update inventory
        int32_t qty = fill.quantity;
        if (fill.side == Side::SELL) {
            qty = -qty;
        }

        current_inventory_.fetch_add(qty);

        LOG_INFO("Fill: {} {} @ {}, Inventory: {}",
                 fill.side == Side::BUY ? "BUY" : "SELL",
                 fill.quantity, fill.price,
                 current_inventory_.load());

        // Requote immediately after fill
        RequoteImmediate();
    }

private:
    void UpdateQuotes(double bid, double ask,
                     uint32_t bid_size, uint32_t ask_size) {
        // Cancel existing quotes
        CancelAllQuotes();

        // Send new quotes
        SendLimitOrder(Side::BUY, bid, bid_size);
        SendLimitOrder(Side::SELL, ask, ask_size);
    }

    void RequoteImmediate() {
        double mid = order_book_.GetMidPrice();
        auto [bid, ask, bid_size, ask_size] = CalculateQuotes(mid);
        UpdateQuotes(bid, ask, bid_size, ask_size);
    }
};
```

================================================================================
3. ARBITRAGE STRATEGIES
================================================================================

CROSS-EXCHANGE ARBITRAGE:
-------------------------
```yaml
cross_exchange_arbitrage:
  enabled: true
  strategy_type: "arbitrage"

  pairs:
    - symbol: "BTC/USD"
      exchange_a: "COINBASE"
      exchange_b: "BINANCE"

      thresholds:
        min_spread_bps: 10
        min_profit_usd: 5
        max_execution_time_ms: 500

      sizing:
        min_size: 0.01
        max_size: 1.0
        size_increment: 0.01

      fees:
        exchange_a_taker_bps: 50
        exchange_b_taker_bps: 40
        withdrawal_fee_usd: 25

  execution:
    mode: "simultaneous"  # simultaneous, sequential, hedge_first
    timeout_ms: 1000
    retry_on_partial: true
    max_retries: 3

  risk_management:
    max_position_per_exchange: 10.0
    max_transfer_risk: 5.0
    require_both_fills: true
```

TRIANGULAR ARBITRAGE:
---------------------
```yaml
triangular_arbitrage:
  enabled: true
  exchange: "BINANCE"

  triangles:
    - path: ["BTC/USD", "ETH/BTC", "ETH/USD"]
      min_profit_bps: 15
      max_execution_time_ms: 200

    - path: ["BTC/USD", "XRP/BTC", "XRP/USD"]
      min_profit_bps: 20
      max_execution_time_ms: 300

  execution:
    leg_timeout_ms: 100
    rollback_on_failure: true

  monitoring:
    calculate_opportunities_per_second: 1000
    log_profitable_only: true
```

STATISTICAL ARBITRAGE:
----------------------
```yaml
stat_arb_pairs:
  enabled: true
  strategy_type: "statistical_arbitrage"

  pairs:
    - pair_id: "MSFT_AAPL"
      symbol_a: "MSFT"
      symbol_b: "AAPL"
      hedge_ratio: 1.2

      model:
        type: "cointegration"  # cointegration, correlation
        lookback_window_bars: 100
        z_score_entry: 2.0
        z_score_exit: 0.5
        z_score_stop: 3.0

      parameters:
        half_life_days: 5
        recalibration_frequency_hours: 24

      execution:
        leg_size: 100
        max_position_size: 1000
        entry_mode: "market"  # market, limit, adaptive
        exit_mode: "limit"

  risk_limits:
    max_pairs: 10
    max_correlation_decay: 0.3
    min_cointegration_pvalue: 0.05
    max_spread_zscore: 5.0
```

C++ PAIRS TRADING:
------------------
```cpp
class PairsTradingStrategy : public Strategy {
private:
    struct PairParams {
        std::string symbol_a;
        std::string symbol_b;
        double hedge_ratio;
        double z_entry;
        double z_exit;
        double z_stop;
        size_t lookback_window;
    };

    PairParams params_;
    std::deque<double> spread_history_;
    double spread_mean_{0.0};
    double spread_std_{0.0};

    enum class Position { NONE, LONG_SPREAD, SHORT_SPREAD };
    Position current_position_{Position::NONE};

public:
    void OnMarketData(const MarketDataUpdate& update) override {
        double price_a = GetPrice(params_.symbol_a);
        double price_b = GetPrice(params_.symbol_b);

        // Calculate spread
        double spread = price_a - params_.hedge_ratio * price_b;

        // Update statistics
        UpdateStatistics(spread);

        // Calculate z-score
        double z_score = (spread - spread_mean_) / spread_std_;

        // Generate signals
        GenerateSignals(z_score, price_a, price_b);
    }

    void UpdateStatistics(double spread) {
        spread_history_.push_back(spread);

        if (spread_history_.size() > params_.lookback_window) {
            spread_history_.pop_front();
        }

        // Calculate mean
        spread_mean_ = std::accumulate(
            spread_history_.begin(),
            spread_history_.end(), 0.0) / spread_history_.size();

        // Calculate standard deviation
        double variance = 0.0;
        for (double s : spread_history_) {
            variance += (s - spread_mean_) * (s - spread_mean_);
        }
        spread_std_ = std::sqrt(variance / spread_history_.size());
    }

    void GenerateSignals(double z_score,
                        double price_a, double price_b) {

        if (current_position_ == Position::NONE) {
            // Entry signals
            if (z_score > params_.z_entry) {
                // Spread too high, short the spread
                EnterShortSpread(price_a, price_b);
            } else if (z_score < -params_.z_entry) {
                // Spread too low, long the spread
                EnterLongSpread(price_a, price_b);
            }
        } else {
            // Exit signals
            if (std::abs(z_score) < params_.z_exit) {
                ExitPosition();
            }
            // Stop loss
            else if (std::abs(z_score) > params_.z_stop) {
                LOG_WARN("Stop loss triggered, z_score: {}", z_score);
                ExitPosition();
            }
        }
    }

    void EnterLongSpread(double price_a, double price_b) {
        // Long spread = Buy A, Sell B
        uint32_t qty_a = 100;
        uint32_t qty_b = static_cast<uint32_t>(
            qty_a * params_.hedge_ratio);

        SendMarketOrder(params_.symbol_a, Side::BUY, qty_a);
        SendMarketOrder(params_.symbol_b, Side::SELL, qty_b);

        current_position_ = Position::LONG_SPREAD;
        LOG_INFO("Entered LONG spread position");
    }

    void EnterShortSpread(double price_a, double price_b) {
        // Short spread = Sell A, Buy B
        uint32_t qty_a = 100;
        uint32_t qty_b = static_cast<uint32_t>(
            qty_a * params_.hedge_ratio);

        SendMarketOrder(params_.symbol_a, Side::SELL, qty_a);
        SendMarketOrder(params_.symbol_b, Side::BUY, qty_b);

        current_position_ = Position::SHORT_SPREAD;
        LOG_INFO("Entered SHORT spread position");
    }

    void ExitPosition() {
        // Flatten all positions
        FlattenPosition(params_.symbol_a);
        FlattenPosition(params_.symbol_b);

        current_position_ = Position::NONE;
        LOG_INFO("Exited spread position");
    }
};
```

================================================================================
4. MOMENTUM STRATEGIES
================================================================================

MOMENTUM BREAKOUT:
------------------
```yaml
momentum_breakout:
  enabled: true
  strategy_type: "momentum"

  instruments:
    - symbol: "SPY"
      exchange: "NYSE"

  indicators:
    lookback_period_bars: 20
    breakout_threshold_std: 2.0

    volume_filter:
      enabled: true
      min_relative_volume: 1.5

    atr_filter:
      enabled: true
      min_atr_pct: 0.5

  entry:
    breakout_type: "high_low"  # high_low, range, volatility
    confirmation_bars: 2
    stop_loss_atr_multiple: 2.0
    take_profit_atr_multiple: 4.0

  position_sizing:
    method: "risk_based"  # fixed, risk_based, kelly
    risk_per_trade_pct: 1.0
    max_position_value: 100000

  filters:
    time_of_day:
      enabled: true
      start_time: "09:45:00"
      end_time: "15:30:00"

    market_regime:
      enabled: true
      min_vix: 15
      max_vix: 40
```

MICROSTRUCTURE MOMENTUM:
------------------------
```yaml
microstructure_momentum:
  enabled: true

  signal_generation:
    # Order flow imbalance
    ofi:
      enabled: true
      lookback_ticks: 100
      threshold: 0.6

    # Volume-weighted order book imbalance
    voi:
      enabled: true
      depth_levels: 5
      threshold: 0.7

    # Trade flow toxicity
    tft:
      enabled: true
      window_s: 5
      threshold: 0.5

  execution:
    entry_type: "aggressive"  # aggressive, passive, adaptive
    hold_time_ms: 500
    max_hold_time_ms: 5000

  risk:
    max_position: 1000
    stop_loss_bps: 10
```

================================================================================
5. MEAN REVERSION STRATEGIES
================================================================================

MEAN REVERSION:
---------------
```yaml
mean_reversion:
  enabled: true
  strategy_type: "mean_reversion"

  instruments:
    - symbol: "GLD"
      exchange: "NYSE"

  model:
    type: "bollinger_bands"  # bollinger_bands, rsi, z_score

    bollinger_bands:
      period: 20
      std_dev: 2.0
      entry_threshold: 2.0
      exit_threshold: 0.5

    rsi:
      period: 14
      oversold: 30
      overbought: 70

  entry_rules:
    require_confirmation: true
    min_bars_away_from_mean: 2

  exit_rules:
    profit_target_pct: 1.0
    stop_loss_pct: 0.5
    time_stop_bars: 50

  position_management:
    pyramiding_enabled: false
    averaging_down_enabled: false
    max_positions: 1
```

================================================================================
6. STRATEGY PARAMETER MANAGEMENT
================================================================================

PARAMETER OPTIMIZATION:
-----------------------
```yaml
optimization:
  enabled: true
  method: "grid_search"  # grid_search, random_search, bayesian

  parameters:
    - name: "base_spread_bps"
      type: "float"
      min: 1.0
      max: 10.0
      step: 0.5

    - name: "inventory_skew_factor"
      type: "float"
      min: 0.05
      max: 0.5
      step: 0.05

    - name: "quote_size"
      type: "int"
      min: 100
      max: 1000
      step: 100

  objective:
    metric: "sharpe_ratio"  # sharpe_ratio, pnl, win_rate
    maximize: true

  validation:
    method: "walk_forward"
    train_period_days: 30
    test_period_days: 7
```

C++ PARAMETER MANAGER:
----------------------
```cpp
class ParameterManager {
private:
    struct Parameter {
        std::string name;
        std::variant<int, double, std::string, bool> value;
        std::variant<int, double> min_value;
        std::variant<int, double> max_value;
    };

    std::unordered_map<std::string, Parameter> parameters_;
    std::shared_mutex mutex_;
    ConfigWatcher watcher_;

public:
    template<typename T>
    T Get(const std::string& name) const {
        std::shared_lock lock(mutex_);

        auto it = parameters_.find(name);
        if (it == parameters_.end()) {
            throw std::runtime_error("Parameter not found: " + name);
        }

        return std::get<T>(it->second.value);
    }

    template<typename T>
    void Set(const std::string& name, T value) {
        std::unique_lock lock(mutex_);

        auto it = parameters_.find(name);
        if (it == parameters_.end()) {
            throw std::runtime_error("Parameter not found: " + name);
        }

        // Validate range
        if constexpr (std::is_arithmetic_v<T>) {
            T min_val = std::get<T>(it->second.min_value);
            T max_val = std::get<T>(it->second.max_value);

            if (value < min_val || value > max_val) {
                throw std::out_of_range("Value out of range");
            }
        }

        it->second.value = value;

        LOG_INFO("Parameter updated: {} = {}", name, value);
    }

    void LoadFromFile(const std::string& file_path) {
        auto config = YAML::LoadFile(file_path);
        // Parse and load parameters
    }

    void StartWatching(const std::string& file_path) {
        watcher_.Watch(file_path, [this](const std::string& path) {
            LoadFromFile(path);
        });
    }
};
```

================================================================================
7. BACKTESTING CONFIGURATION
================================================================================

BACKTEST SETTINGS:
------------------
```yaml
backtesting:
  enabled: true

  data:
    source: "historical_db"
    start_date: "2024-01-01"
    end_date: "2024-12-31"
    symbols: ["AAPL", "MSFT", "GOOGL"]
    resolution: "tick"  # tick, 1s, 1m

  simulation:
    initial_capital: 1000000
    commission_per_share: 0.001
    slippage_model: "volume_based"  # fixed, volume_based, market_impact

    market_impact:
      model: "sqrt"  # linear, sqrt, log
      coefficient: 0.1
      max_impact_bps: 50

  execution:
    fill_model: "realistic"  # optimistic, realistic, pessimistic
    latency_model: "variable"
    latency_mean_us: 100
    latency_std_us: 50

  metrics:
    calculate:
      - "total_return"
      - "sharpe_ratio"
      - "max_drawdown"
      - "win_rate"
      - "profit_factor"
      - "avg_trade_duration"

  output:
    save_trades: true
    save_equity_curve: true
    generate_report: true
    report_format: "html"
```

================================================================================
END OF STRATEGY CONFIGURATION
================================================================================
