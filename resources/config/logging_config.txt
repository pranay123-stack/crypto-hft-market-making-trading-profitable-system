================================================================================
HFT LOGGING CONFIGURATION - LOGGING AND AUDIT SYSTEM
================================================================================
Version: 1.0.0
Last Updated: 2025-11-25
Description: Comprehensive logging configuration for HFT system
================================================================================

TABLE OF CONTENTS
-----------------
1. Logging Framework Overview
2. Log Levels and Categories
3. Log Destinations
4. Performance Logging
5. Audit Logging
6. Message Logging
7. Trade Logging
8. Log Rotation and Retention
9. C++ Logger Implementation
10. Structured Logging

================================================================================
1. LOGGING FRAMEWORK OVERVIEW
================================================================================

LOGGING FRAMEWORK:
------------------
```yaml
logging:
  framework: "spdlog"  # spdlog, log4cpp, glog, custom

  global_settings:
    async_mode: true
    queue_size: 262144
    flush_interval_ms: 1000
    flush_on_critical: true

  performance:
    low_latency_mode: true
    thread_affinity: [14]  # Dedicated logging thread
    cpu_priority: 50  # Lower priority than trading

  buffer_settings:
    buffer_size_kb: 1024
    use_memory_mapped_files: true
    preallocate_files: true

  formats:
    default: "[%Y-%m-%d %H:%M:%S.%f] [%l] [%n] %v"
    with_thread: "[%Y-%m-%d %H:%M:%S.%f] [%t] [%l] [%n] %v"
    json: '{"timestamp":"%Y-%m-%d %H:%M:%S.%f","level":"%l","logger":"%n","message":"%v"}'
```

LOGGER HIERARCHY:
-----------------
```yaml
loggers:
  root:
    level: "info"
    handlers: ["console", "file"]

  trading:
    level: "debug"
    handlers: ["trading_file", "network"]
    parent: "root"

  market_data:
    level: "info"
    handlers: ["market_data_file"]
    parent: "root"

  order_execution:
    level: "debug"
    handlers: ["order_file", "audit_file"]
    parent: "root"

  risk:
    level: "info"
    handlers: ["risk_file", "alert"]
    parent: "root"

  performance:
    level: "trace"
    handlers: ["performance_file"]
    parent: "root"
```

================================================================================
2. LOG LEVELS AND CATEGORIES
================================================================================

LOG LEVELS:
-----------
```yaml
log_levels:
  # Standard levels
  trace: 0      # Very detailed, performance impact
  debug: 1      # Debugging information
  info: 2       # General information
  warning: 3    # Warning conditions
  error: 4      # Error conditions
  critical: 5   # Critical conditions
  off: 6        # Disable logging

  # Production settings
  production:
    default: "info"
    trading: "info"
    market_data: "warning"
    order_execution: "debug"  # Keep for audit
    risk: "info"
    performance: "off"  # Disabled in production

  # Development settings
  development:
    default: "debug"
    trading: "trace"
    market_data: "debug"
    order_execution: "trace"
    risk: "debug"
    performance: "trace"
```

LOG CATEGORIES:
---------------
```yaml
categories:
  system:
    - "startup"
    - "shutdown"
    - "config_reload"
    - "health_check"

  trading:
    - "order_submission"
    - "order_ack"
    - "order_fill"
    - "order_cancel"
    - "order_reject"

  market_data:
    - "quote_update"
    - "trade_update"
    - "orderbook_snapshot"
    - "orderbook_update"

  risk:
    - "limit_check"
    - "limit_breach"
    - "position_update"
    - "pnl_update"

  performance:
    - "latency_measurement"
    - "throughput_measurement"
    - "resource_usage"
```

================================================================================
3. LOG DESTINATIONS (HANDLERS)
================================================================================

FILE HANDLERS:
--------------
```yaml
handlers:
  # Console handler
  console:
    type: "console"
    level: "info"
    format: "[%H:%M:%S.%e] [%^%l%$] %v"
    color: true

  # Main log file
  file:
    type: "rotating_file"
    path: "/var/log/hft/main.log"
    level: "info"
    format: "[%Y-%m-%d %H:%M:%S.%f] [%l] [%n] %v"
    max_size_mb: 100
    max_files: 10

  # Trading log
  trading_file:
    type: "rotating_file"
    path: "/var/log/hft/trading.log"
    level: "debug"
    format: "[%Y-%m-%d %H:%M:%S.%f] [%l] %v"
    max_size_mb: 500
    max_files: 30
    compress_rotated: true

  # Market data log
  market_data_file:
    type: "rotating_file"
    path: "/var/log/hft/market_data.log"
    level: "info"
    format: "%v"  # Compact format for high volume
    max_size_mb: 1000
    max_files: 7

  # Order execution log (audit trail)
  order_file:
    type: "daily_file"
    path: "/var/log/hft/orders/order_%Y%m%d.log"
    level: "debug"
    format: "[%Y-%m-%d %H:%M:%S.%f] %v"
    retention_days: 90

  # Audit log (immutable)
  audit_file:
    type: "daily_file"
    path: "/var/log/hft/audit/audit_%Y%m%d.log"
    level: "info"
    format: '{"timestamp":"%Y-%m-%d %H:%M:%S.%f","event":"%v"}'
    retention_days: 2555  # 7 years
    immutable: true
    checksum: true

  # Performance log
  performance_file:
    type: "rotating_file"
    path: "/var/log/hft/performance.log"
    level: "trace"
    format: "%v"  # CSV format
    max_size_mb: 100
    max_files: 5

  # Risk log
  risk_file:
    type: "daily_file"
    path: "/var/log/hft/risk/risk_%Y%m%d.log"
    level: "info"
    format: "[%Y-%m-%d %H:%M:%S.%f] [%l] %v"
    retention_days: 365

  # Network handler (syslog)
  network:
    type: "syslog"
    host: "syslog.company.com"
    port: 514
    level: "warning"
    facility: "local0"

  # Alert handler
  alert:
    type: "custom"
    level: "critical"
    destination: "alert_system"
```

ROTATING FILE SETTINGS:
------------------------
```yaml
rotation:
  size_based:
    enabled: true
    max_size_mb: 100
    max_files: 10

  time_based:
    enabled: true
    interval: "daily"  # hourly, daily, weekly
    time: "00:00:00"  # Rotation time

  compression:
    enabled: true
    format: "gzip"  # gzip, bzip2, lz4
    compression_level: 6

  cleanup:
    delete_old_files: true
    retention_days: 30
    archive_path: "/var/log/hft/archive"
```

================================================================================
4. PERFORMANCE LOGGING
================================================================================

LATENCY LOGGING:
----------------
```yaml
performance_logging:
  latency_tracking:
    enabled: true
    sample_rate: 0.1  # 10% sampling in production

    measurements:
      - name: "order_submission_latency"
        start_event: "order_created"
        end_event: "order_ack_received"
        log_percentiles: [50, 90, 95, 99, 99.9]

      - name: "market_data_latency"
        start_event: "market_data_received"
        end_event: "market_data_processed"
        log_percentiles: [50, 90, 95, 99]

      - name: "end_to_end_latency"
        start_event: "signal_generated"
        end_event: "order_filled"
        log_percentiles: [50, 90, 95, 99, 99.9, 99.99]

  throughput_logging:
    enabled: true
    interval_s: 60

    metrics:
      - "orders_per_second"
      - "fills_per_second"
      - "market_data_updates_per_second"
      - "messages_per_second"

  resource_logging:
    enabled: true
    interval_s: 60

    metrics:
      - "cpu_usage_pct"
      - "memory_usage_mb"
      - "network_bandwidth_mbps"
      - "disk_io_ops"
      - "cache_hit_rate_pct"
```

PERFORMANCE LOG FORMAT:
-----------------------
```yaml
performance_format:
  csv:
    enabled: true
    path: "/var/log/hft/performance/latency_%Y%m%d.csv"

    columns:
      - timestamp_us
      - event_type
      - latency_us
      - symbol
      - order_id

  binary:
    enabled: true
    path: "/var/log/hft/performance/binary_%Y%m%d.bin"
    format: "custom"  # Custom binary format for minimal overhead
```

C++ PERFORMANCE LOGGER:
-----------------------
```cpp
class PerformanceLogger {
private:
    struct LatencyMeasurement {
        uint64_t timestamp_us;
        uint64_t latency_us;
        std::string event_type;
        std::string symbol;
        uint64_t order_id;
    };

    // Lock-free ring buffer for measurements
    struct alignas(64) RingBuffer {
        static constexpr size_t SIZE = 1048576;  // 1M entries
        std::array<LatencyMeasurement, SIZE> buffer;
        std::atomic<size_t> write_idx{0};
        std::atomic<size_t> read_idx{0};
    };

    RingBuffer ring_buffer_;
    std::thread writer_thread_;
    std::atomic<bool> running_{true};

    std::ofstream csv_file_;
    std::ofstream binary_file_;

public:
    PerformanceLogger(const std::string& csv_path,
                     const std::string& binary_path) {

        csv_file_.open(csv_path, std::ios::out);
        binary_file_.open(binary_path, std::ios::binary);

        // Write CSV header
        csv_file_ << "timestamp_us,event_type,latency_us,"
                     "symbol,order_id\n";

        // Start writer thread
        writer_thread_ = std::thread([this]() {
            WriterThread();
        });
    }

    ~PerformanceLogger() {
        running_ = false;
        if (writer_thread_.joinable()) {
            writer_thread_.join();
        }
        csv_file_.close();
        binary_file_.close();
    }

    void LogLatency(const std::string& event_type,
                   uint64_t latency_us,
                   const std::string& symbol = "",
                   uint64_t order_id = 0) {

        // Get write index
        size_t write_idx =
            ring_buffer_.write_idx.fetch_add(1,
                std::memory_order_relaxed);

        size_t idx = write_idx % RingBuffer::SIZE;

        // Write measurement
        auto& measurement = ring_buffer_.buffer[idx];
        measurement.timestamp_us = GetCurrentTimeMicros();
        measurement.latency_us = latency_us;
        measurement.event_type = event_type;
        measurement.symbol = symbol;
        measurement.order_id = order_id;
    }

private:
    void WriterThread() {
        while (running_) {
            size_t read_idx =
                ring_buffer_.read_idx.load(std::memory_order_relaxed);
            size_t write_idx =
                ring_buffer_.write_idx.load(std::memory_order_acquire);

            while (read_idx < write_idx) {
                size_t idx = read_idx % RingBuffer::SIZE;
                const auto& m = ring_buffer_.buffer[idx];

                // Write to CSV
                csv_file_ << m.timestamp_us << ","
                         << m.event_type << ","
                         << m.latency_us << ","
                         << m.symbol << ","
                         << m.order_id << "\n";

                // Write to binary
                binary_file_.write(
                    reinterpret_cast<const char*>(&m),
                    sizeof(m));

                read_idx++;
            }

            ring_buffer_.read_idx.store(read_idx,
                std::memory_order_release);

            // Flush periodically
            if (read_idx % 10000 == 0) {
                csv_file_.flush();
                binary_file_.flush();
            }

            // Small sleep to avoid busy waiting
            std::this_thread::sleep_for(
                std::chrono::milliseconds(1));
        }
    }
};
```

================================================================================
5. AUDIT LOGGING
================================================================================

AUDIT LOG CONFIGURATION:
------------------------
```yaml
audit_logging:
  enabled: true
  mandatory: true  # Cannot be disabled

  events:
    # Order events
    - "order_submitted"
    - "order_acknowledged"
    - "order_filled"
    - "order_partially_filled"
    - "order_canceled"
    - "order_rejected"
    - "order_expired"

    # Risk events
    - "limit_breach"
    - "circuit_breaker_triggered"
    - "position_limit_exceeded"

    # System events
    - "user_login"
    - "user_logout"
    - "config_changed"
    - "system_started"
    - "system_stopped"

  format:
    type: "json"
    include_fields:
      - "timestamp"
      - "event_type"
      - "user_id"
      - "session_id"
      - "details"
      - "checksum"

  storage:
    path: "/var/log/hft/audit"
    encryption: true
    encryption_key_file: "/etc/hft/keys/audit.key"
    write_once: true  # Immutable logs

  compliance:
    retention_years: 7
    tamper_detection: true
    digital_signature: true
```

AUDIT LOG STRUCTURE:
--------------------
```json
{
  "timestamp": "2025-11-25T10:15:30.123456Z",
  "event_type": "order_submitted",
  "event_id": "550e8400-e29b-41d4-a716-446655440000",
  "user_id": "trader001",
  "session_id": "session_12345",
  "source_ip": "10.0.1.100",
  "details": {
    "order_id": "ORD-001",
    "client_order_id": "CLO-123",
    "symbol": "AAPL",
    "side": "BUY",
    "quantity": 100,
    "price": 150.25,
    "order_type": "LIMIT",
    "time_in_force": "DAY"
  },
  "checksum": "sha256:a1b2c3d4...",
  "signature": "RSA:e5f6g7h8..."
}
```

C++ AUDIT LOGGER:
-----------------
```cpp
class AuditLogger {
private:
    std::unique_ptr<EncryptedFile> log_file_;
    std::mutex mutex_;

    struct AuditEntry {
        std::string timestamp;
        std::string event_type;
        std::string event_id;
        std::string user_id;
        nlohmann::json details;
    };

public:
    AuditLogger(const std::string& log_path,
               const std::string& key_file) {

        // Open encrypted log file
        log_file_ = std::make_unique<EncryptedFile>(
            log_path, key_file);
    }

    void LogOrderSubmission(const Order& order,
                           const std::string& user_id) {

        AuditEntry entry;
        entry.timestamp = GetISO8601Timestamp();
        entry.event_type = "order_submitted";
        entry.event_id = GenerateUUID();
        entry.user_id = user_id;

        entry.details = {
            {"order_id", order.order_id},
            {"client_order_id", order.client_order_id},
            {"symbol", order.symbol},
            {"side", order.side == Side::BUY ? "BUY" : "SELL"},
            {"quantity", order.quantity},
            {"price", order.price},
            {"order_type", OrderTypeToString(order.type)},
            {"time_in_force", TIFToString(order.tif)}
        };

        WriteAuditEntry(entry);
    }

    void LogLimitBreach(const std::string& limit_type,
                       const std::string& details,
                       const std::string& user_id) {

        AuditEntry entry;
        entry.timestamp = GetISO8601Timestamp();
        entry.event_type = "limit_breach";
        entry.event_id = GenerateUUID();
        entry.user_id = user_id;

        entry.details = {
            {"limit_type", limit_type},
            {"details", details}
        };

        WriteAuditEntry(entry);
    }

private:
    void WriteAuditEntry(const AuditEntry& entry) {
        std::lock_guard lock(mutex_);

        nlohmann::json j = {
            {"timestamp", entry.timestamp},
            {"event_type", entry.event_type},
            {"event_id", entry.event_id},
            {"user_id", entry.user_id},
            {"details", entry.details}
        };

        // Calculate checksum
        std::string json_str = j.dump();
        std::string checksum = CalculateSHA256(json_str);
        j["checksum"] = checksum;

        // Write to encrypted file
        log_file_->WriteLine(j.dump());
        log_file_->Flush();  // Ensure immediate write
    }

    std::string CalculateSHA256(const std::string& data) {
        // Implementation of SHA256 hash
        return "sha256:...";
    }

    std::string GenerateUUID() {
        // Implementation of UUID generation
        return "uuid-...";
    }
};
```

================================================================================
6. MESSAGE LOGGING
================================================================================

MESSAGE LOG CONFIGURATION:
--------------------------
```yaml
message_logging:
  enabled: true

  protocols:
    fix:
      log_inbound: true
      log_outbound: true
      log_heartbeats: false
      mask_sensitive_fields: true

      sensitive_fields:
        - "Password"
        - "SecretKey"

    binary:
      log_inbound: true
      log_outbound: true
      format: "hex_dump"

  storage:
    path: "/var/log/hft/messages"
    format: "pcap"  # pcap, text, binary
    compression: true
```

FIX MESSAGE LOGGING:
--------------------
```cpp
class FIXMessageLogger {
private:
    std::ofstream log_file_;
    std::mutex mutex_;

public:
    void LogInboundMessage(const std::string& fix_msg) {
        std::lock_guard lock(mutex_);

        auto timestamp = GetCurrentTimeMicros();

        log_file_ << timestamp << "|IN|"
                 << MaskSensitiveFields(fix_msg) << "\n";
    }

    void LogOutboundMessage(const std::string& fix_msg) {
        std::lock_guard lock(mutex_);

        auto timestamp = GetCurrentTimeMicros();

        log_file_ << timestamp << "|OUT|" << fix_msg << "\n";
    }

private:
    std::string MaskSensitiveFields(const std::string& msg) {
        std::string masked = msg;

        // Mask password fields (tag 554)
        std::regex pwd_regex("554=([^|]+)");
        masked = std::regex_replace(masked, pwd_regex,
                                   "554=***MASKED***");

        return masked;
    }
};
```

================================================================================
7. LOG ROTATION AND RETENTION
================================================================================

ROTATION POLICY:
----------------
```yaml
log_rotation:
  policies:
    # Size-based rotation
    size_based:
      trading_log:
        max_size_mb: 500
        max_files: 30

      market_data_log:
        max_size_mb: 1000
        max_files: 7

    # Time-based rotation
    time_based:
      audit_log:
        interval: "daily"
        time: "00:00:00"
        retention_days: 2555

      order_log:
        interval: "daily"
        time: "00:00:00"
        retention_days: 90

  compression:
    enabled: true
    algorithm: "gzip"
    compression_level: 6
    delete_after_compress: true

  archival:
    enabled: true
    archive_path: "/mnt/archive/hft/logs"
    archive_after_days: 30
    delete_after_archive: true
```

RETENTION POLICY:
-----------------
```yaml
log_retention:
  # Regulatory requirements
  regulatory:
    order_logs: 2555  # 7 years
    audit_logs: 2555  # 7 years
    trade_logs: 2555  # 7 years

  # Operational logs
  operational:
    system_logs: 90
    performance_logs: 30
    debug_logs: 7

  # Archive storage
  archive:
    location: "s3://hft-logs-archive"
    encryption: true
    lifecycle_policy: "glacier_after_1_year"
```

================================================================================
8. STRUCTURED LOGGING
================================================================================

STRUCTURED LOG FORMAT:
----------------------
```yaml
structured_logging:
  enabled: true
  format: "json"

  fields:
    standard:
      - "timestamp"
      - "level"
      - "logger"
      - "message"
      - "thread_id"
      - "process_id"

    custom:
      - "symbol"
      - "order_id"
      - "strategy_id"
      - "latency_us"

  examples:
    order_submission:
      format: |
        {
          "timestamp": "2025-11-25T10:15:30.123456Z",
          "level": "INFO",
          "logger": "order_execution",
          "message": "Order submitted",
          "order_id": "ORD-001",
          "symbol": "AAPL",
          "side": "BUY",
          "quantity": 100,
          "price": 150.25,
          "latency_us": 45
        }
```

C++ STRUCTURED LOGGER:
----------------------
```cpp
#include <spdlog/spdlog.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <spdlog/async.h>

class StructuredLogger {
private:
    std::shared_ptr<spdlog::logger> logger_;

public:
    StructuredLogger(const std::string& name) {
        // Create async logger with rotating file sink
        auto sink = std::make_shared<
            spdlog::sinks::rotating_file_sink_mt>(
                fmt::format("/var/log/hft/{}.log", name),
                100 * 1024 * 1024,  // 100MB
                10);  // 10 files

        logger_ = std::make_shared<spdlog::async_logger>(
            name, sink,
            spdlog::thread_pool(),
            spdlog::async_overflow_policy::block);

        logger_->set_pattern("%v");  // Only message
        logger_->set_level(spdlog::level::debug);
    }

    template<typename... Args>
    void LogOrder(const Order& order, Args&&... args) {
        nlohmann::json j = {
            {"timestamp", GetISO8601Timestamp()},
            {"level", "INFO"},
            {"logger", "order_execution"},
            {"message", "Order submitted"},
            {"order_id", order.order_id},
            {"symbol", order.symbol},
            {"side", order.side == Side::BUY ? "BUY" : "SELL"},
            {"quantity", order.quantity},
            {"price", order.price}
        };

        logger_->info(j.dump());
    }

    void Flush() {
        logger_->flush();
    }
};
```

================================================================================
END OF LOGGING CONFIGURATION
================================================================================
