================================================================================
HFT SYSTEM CONFIGURATION - MAIN SYSTEM SETTINGS
================================================================================
Version: 1.0.0
Last Updated: 2025-11-25
Description: Core system configuration for high-frequency trading platform
================================================================================

TABLE OF CONTENTS
-----------------
1. Configuration Format Standards
2. System Architecture Settings
3. Thread Pool Configuration
4. Memory Management
5. CPU Affinity and NUMA
6. Queue Configurations
7. Timing and Latency
8. System Resources
9. Hot Reload Implementation
10. Validation Schemas
11. C++ Parser Implementation
12. Environment Overrides

================================================================================
1. CONFIGURATION FORMAT STANDARDS
================================================================================

YAML FORMAT EXAMPLE:
--------------------
```yaml
system:
  name: "HFT_Trading_System"
  version: "1.0.0"
  environment: "production"

  core:
    max_threads: 16
    worker_threads: 12
    io_threads: 4
    cpu_affinity_enabled: true
    numa_aware: true

  memory:
    heap_size_mb: 8192
    stack_size_mb: 8
    shared_memory_mb: 4096
    huge_pages_enabled: true
    huge_page_size: "2MB"
    preallocate_buffers: true

  threading:
    scheduler: "SCHED_FIFO"
    priority: 99
    realtime_enabled: true
    core_isolation: [2, 3, 4, 5, 6, 7]

  queues:
    order_queue_size: 65536
    market_data_queue_size: 262144
    response_queue_size: 32768
    lockfree_enabled: true
    spsc_optimized: true

  timing:
    tick_interval_us: 100
    heartbeat_interval_ms: 1000
    timeout_ms: 5000
    max_processing_time_us: 50

  limits:
    max_orders_per_second: 10000
    max_connections: 100
    max_symbols: 5000
    max_strategies: 50
```

JSON FORMAT EXAMPLE:
--------------------
```json
{
  "system": {
    "name": "HFT_Trading_System",
    "version": "1.0.0",
    "environment": "production",
    "core": {
      "max_threads": 16,
      "worker_threads": 12,
      "io_threads": 4,
      "cpu_affinity_enabled": true,
      "numa_aware": true
    },
    "memory": {
      "heap_size_mb": 8192,
      "stack_size_mb": 8,
      "shared_memory_mb": 4096,
      "huge_pages_enabled": true,
      "huge_page_size": "2MB",
      "preallocate_buffers": true
    },
    "threading": {
      "scheduler": "SCHED_FIFO",
      "priority": 99,
      "realtime_enabled": true,
      "core_isolation": [2, 3, 4, 5, 6, 7]
    },
    "performance": {
      "zero_copy_enabled": true,
      "kernel_bypass_enabled": true,
      "busy_polling": true,
      "interrupt_coalescing": false,
      "prefetch_enabled": true
    }
  }
}
```

TOML FORMAT EXAMPLE:
--------------------
```toml
[system]
name = "HFT_Trading_System"
version = "1.0.0"
environment = "production"

[system.core]
max_threads = 16
worker_threads = 12
io_threads = 4
cpu_affinity_enabled = true
numa_aware = true

[system.memory]
heap_size_mb = 8192
stack_size_mb = 8
shared_memory_mb = 4096
huge_pages_enabled = true
huge_page_size = "2MB"
preallocate_buffers = true

[system.threading]
scheduler = "SCHED_FIFO"
priority = 99
realtime_enabled = true
core_isolation = [2, 3, 4, 5, 6, 7]

[system.performance]
zero_copy_enabled = true
kernel_bypass_enabled = true
busy_polling = true
interrupt_coalescing = false
prefetch_enabled = true
```

================================================================================
2. SYSTEM ARCHITECTURE SETTINGS
================================================================================

PROCESS ARCHITECTURE:
---------------------
```yaml
architecture:
  mode: "single_process"  # single_process, multi_process, hybrid

  processes:
    main:
      name: "hft_main"
      priority: 99
      cpu_cores: [2, 3, 4]
      memory_limit_mb: 4096

    market_data:
      name: "hft_md"
      priority: 98
      cpu_cores: [5, 6]
      memory_limit_mb: 2048

    order_execution:
      name: "hft_oe"
      priority: 99
      cpu_cores: [7, 8]
      memory_limit_mb: 2048

    risk_management:
      name: "hft_risk"
      priority: 97
      cpu_cores: [9]
      memory_limit_mb: 1024

  ipc:
    method: "shared_memory"  # shared_memory, mmap, unix_socket
    shared_memory_size_mb: 512
    semaphore_type: "futex"
    zero_copy: true
```

PARAMETER DESCRIPTIONS:
-----------------------
- mode: Process architecture model
  * single_process: All components in one process (lowest latency)
  * multi_process: Separate processes for isolation (better stability)
  * hybrid: Critical path in one process, others separate

- priority: Real-time priority (1-99, higher = more important)
- cpu_cores: CPU cores assigned to process (NUMA-aware)
- memory_limit_mb: Maximum memory allocation per process
- ipc.method: Inter-process communication mechanism
- ipc.zero_copy: Enable zero-copy shared memory transfers

================================================================================
3. THREAD POOL CONFIGURATION
================================================================================

THREAD POOL SETTINGS:
---------------------
```yaml
thread_pools:
  market_data:
    size: 4
    queue_size: 262144
    queue_type: "lockfree_spsc"
    thread_affinity: [2, 3, 4, 5]
    priority: 98
    stack_size_kb: 8192

  order_execution:
    size: 2
    queue_size: 65536
    queue_type: "lockfree_mpsc"
    thread_affinity: [6, 7]
    priority: 99
    stack_size_kb: 8192

  strategy:
    size: 4
    queue_size: 32768
    queue_type: "lockfree_mpmc"
    thread_affinity: [8, 9, 10, 11]
    priority: 95
    stack_size_kb: 8192

  io:
    size: 2
    queue_size: 16384
    queue_type: "lockfree_mpsc"
    thread_affinity: [12, 13]
    priority: 90
    stack_size_kb: 4096

  logging:
    size: 1
    queue_size: 65536
    queue_type: "lockfree_mpsc"
    thread_affinity: [14]
    priority: 50
    stack_size_kb: 4096
    async_mode: true
```

QUEUE TYPE DESCRIPTIONS:
-------------------------
- lockfree_spsc: Single Producer Single Consumer (fastest)
- lockfree_mpsc: Multiple Producer Single Consumer
- lockfree_mpmc: Multiple Producer Multiple Consumer
- lockfree_spmc: Single Producer Multiple Consumer

ADVANCED THREAD SETTINGS:
--------------------------
```yaml
thread_advanced:
  context_switch_minimization: true
  thread_local_storage_size_kb: 256
  enable_thread_sanitizer: false  # Debug only

  scheduling:
    policy: "SCHED_FIFO"  # SCHED_FIFO, SCHED_RR, SCHED_DEADLINE
    use_cgroups: true
    cgroup_path: "/sys/fs/cgroup/hft"

  synchronization:
    mutex_type: "adaptive"  # adaptive, spin, futex
    spin_count: 1000
    use_atomic_ops: true
    memory_order: "seq_cst"  # relaxed, acquire, release, seq_cst
```

================================================================================
4. MEMORY MANAGEMENT
================================================================================

MEMORY ALLOCATION:
------------------
```yaml
memory:
  allocator: "jemalloc"  # jemalloc, tcmalloc, mimalloc, system

  heap:
    initial_size_mb: 4096
    max_size_mb: 8192
    growth_increment_mb: 512

  pools:
    order_pool:
      object_size: 256
      initial_count: 10000
      max_count: 100000
      preallocate: true

    market_data_pool:
      object_size: 512
      initial_count: 50000
      max_count: 500000
      preallocate: true

    message_pool:
      object_size: 1024
      initial_count: 20000
      max_count: 200000
      preallocate: true

  huge_pages:
    enabled: true
    size: "2MB"  # 2MB or 1GB
    transparent_huge_pages: false
    reserve_count: 2048

  numa:
    enabled: true
    policy: "bind"  # bind, preferred, interleave
    node: 0
    local_allocation_threshold: 1048576  # 1MB

  buffer_management:
    ring_buffer_size: 16777216  # 16MB
    packet_buffer_size: 65536
    zero_copy_buffers: true

  garbage_collection:
    enabled: false  # Not applicable for C++
    manual_cleanup_interval_ms: 1000
```

MEMORY PARAMETER EXPLANATIONS:
-------------------------------
- allocator: Memory allocator for performance
  * jemalloc: Facebook's allocator (good general purpose)
  * tcmalloc: Google's thread-caching malloc (low fragmentation)
  * mimalloc: Microsoft's allocator (excellent performance)

- huge_pages.size: Large page sizes reduce TLB misses
  * 2MB: Standard huge pages (recommended)
  * 1GB: Gigantic pages (for very large allocations)

- numa.policy: NUMA memory allocation strategy
  * bind: Strictly bind to node (best performance)
  * preferred: Prefer node but allow fallback
  * interleave: Distribute across nodes

================================================================================
5. CPU AFFINITY AND NUMA CONFIGURATION
================================================================================

CPU BINDING:
------------
```yaml
cpu_affinity:
  enabled: true
  strategy: "dedicated"  # dedicated, shared, dynamic

  core_assignments:
    # Critical path - dedicated cores
    market_data_receiver: [2, 3]
    order_sender: [4, 5]
    strategy_engine: [6, 7, 8, 9]
    risk_checker: [10]

    # Non-critical - shared cores
    logging: [14]
    monitoring: [15]
    admin: [15]

  isolation:
    isolated_cores: [2, 3, 4, 5, 6, 7, 8, 9, 10]
    isolate_from_kernel: true
    nohz_full: true  # Tickless kernel for isolated cores
    rcu_nocbs: true  # Move RCU callbacks off isolated cores

  interrupts:
    irq_affinity: [0, 1]  # Route all IRQs to cores 0,1
    disable_irqbalance: true

  frequency:
    governor: "performance"  # performance, powersave, userspace
    min_freq_ghz: 3.5
    max_freq_ghz: 4.5
    turbo_boost: true
```

NUMA TOPOLOGY:
--------------
```yaml
numa:
  nodes:
    - id: 0
      cpus: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
      memory_gb: 64
      pci_devices: ["0000:01:00.0", "0000:02:00.0"]

    - id: 1
      cpus: [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]
      memory_gb: 64
      pci_devices: ["0000:81:00.0", "0000:82:00.0"]

  allocation:
    preferred_node: 0
    fallback_allowed: false

  network_devices:
    eth0:
      numa_node: 0
      irq_affinity: [0, 1]

    eth1:
      numa_node: 0
      irq_affinity: [0, 1]
```

================================================================================
6. QUEUE CONFIGURATIONS
================================================================================

LOCKFREE QUEUE SETTINGS:
-------------------------
```yaml
queues:
  order_queue:
    type: "spsc_lockfree"
    capacity: 65536
    element_size: 256
    cache_line_padding: true
    false_sharing_prevention: true
    memory_order: "acquire_release"

  market_data_queue:
    type: "mpsc_lockfree"
    capacity: 262144
    element_size: 512
    batch_processing: true
    batch_size: 64

  response_queue:
    type: "mpmc_lockfree"
    capacity: 32768
    element_size: 512
    backpressure_strategy: "block"  # block, drop, error

  event_queue:
    type: "mpmc_lockfree"
    capacity: 16384
    element_size: 256
    priority_levels: 4
```

RING BUFFER CONFIGURATION:
---------------------------
```yaml
ring_buffers:
  main_buffer:
    size: 16777216  # 16MB, must be power of 2
    slot_size: 1024
    multi_producer: false
    wait_strategy: "busy_spin"  # busy_spin, yield, block

  market_data_buffer:
    size: 33554432  # 32MB
    slot_size: 512
    multi_producer: true
    wait_strategy: "busy_spin"
```

================================================================================
7. TIMING AND LATENCY CONFIGURATION
================================================================================

TIMING SETTINGS:
----------------
```yaml
timing:
  clock_source: "tsc"  # tsc, hpet, clock_gettime

  tsc:
    enabled: true
    invariant: true  # Constant rate TSC
    calibration_interval_s: 60

  latency:
    target_one_way_us: 50
    max_acceptable_us: 100
    measurement_enabled: true
    percentiles: [50, 75, 90, 95, 99, 99.9, 99.99]

  timeouts:
    order_response_ms: 1000
    market_data_stale_ms: 500
    heartbeat_interval_ms: 1000
    connection_timeout_ms: 5000

  synchronization:
    ntp_enabled: true
    ntp_servers:
      - "time.google.com"
      - "time.cloudflare.com"
    ptp_enabled: true  # Precision Time Protocol
    ptp_domain: 0
    max_clock_drift_us: 100
```

PERFORMANCE MONITORING:
-----------------------
```yaml
performance:
  metrics:
    enabled: true
    collection_interval_ms: 100

  latency_tracking:
    order_submission: true
    order_ack: true
    market_data_processing: true
    strategy_execution: true

  instrumentation:
    low_overhead_mode: true
    sampling_rate: 0.01  # 1% sampling
    detailed_profiling: false  # Production should be false
```

================================================================================
8. SYSTEM RESOURCES
================================================================================

RESOURCE LIMITS:
----------------
```yaml
resource_limits:
  file_descriptors:
    soft_limit: 65536
    hard_limit: 1048576

  processes:
    max_processes: 4096
    max_threads: 8192

  memory:
    locked_memory_mb: 8192  # For realtime
    virtual_memory_mb: 16384
    stack_size_kb: 8192

  network:
    socket_buffers:
      send_buffer_kb: 4096
      receive_buffer_kb: 4096
      max_buffer_kb: 8192

    connections:
      max_connections: 1024
      backlog: 4096
      keepalive_time_s: 60
      keepalive_interval_s: 10
      keepalive_probes: 5
```

KERNEL PARAMETERS:
------------------
```yaml
kernel_tuning:
  sysctl:
    # Network
    net.core.rmem_max: 134217728
    net.core.wmem_max: 134217728
    net.core.rmem_default: 67108864
    net.core.wmem_default: 67108864
    net.ipv4.tcp_rmem: "4096 87380 67108864"
    net.ipv4.tcp_wmem: "4096 65536 67108864"
    net.core.netdev_max_backlog: 250000
    net.core.somaxconn: 4096

    # Memory
    vm.swappiness: 0
    vm.dirty_ratio: 80
    vm.dirty_background_ratio: 5
    vm.overcommit_memory: 1

    # Realtime
    kernel.sched_rt_runtime_us: -1
    kernel.sched_rt_period_us: 1000000
```

================================================================================
9. HOT RELOAD IMPLEMENTATION
================================================================================

HOT RELOAD CONFIGURATION:
--------------------------
```yaml
hot_reload:
  enabled: true
  watch_interval_ms: 1000

  watched_files:
    - "/etc/hft/system_config.yaml"
    - "/etc/hft/strategy_config.yaml"
    - "/etc/hft/risk_config.yaml"

  reload_strategy: "graceful"  # graceful, immediate, scheduled

  graceful_reload:
    wait_for_idle: true
    max_wait_time_ms: 5000
    cancel_pending_orders: false

  validation:
    validate_before_apply: true
    rollback_on_error: true
    backup_config: true

  notifications:
    log_reload: true
    emit_event: true
    alert_on_failure: true
```

C++ HOT RELOAD IMPLEMENTATION:
-------------------------------
```cpp
class ConfigManager {
private:
    std::shared_ptr<SystemConfig> active_config_;
    std::shared_ptr<SystemConfig> pending_config_;
    std::mutex config_mutex_;
    std::atomic<uint64_t> config_version_{0};

    FileWatcher file_watcher_;
    ConfigValidator validator_;

public:
    void StartWatching() {
        file_watcher_.Watch("/etc/hft/system_config.yaml",
            [this](const std::string& path) {
                OnConfigFileChanged(path);
            });
    }

    void OnConfigFileChanged(const std::string& path) {
        try {
            // Parse new configuration
            auto new_config = ConfigParser::Parse(path);

            // Validate new configuration
            if (!validator_.Validate(new_config)) {
                LOG_ERROR("Config validation failed");
                return;
            }

            // Check for breaking changes
            if (HasBreakingChanges(active_config_, new_config)) {
                LOG_WARN("Breaking changes detected, requires restart");
                return;
            }

            // Perform hot reload
            HotReload(new_config);

        } catch (const std::exception& e) {
            LOG_ERROR("Config reload failed: {}", e.what());
        }
    }

    void HotReload(std::shared_ptr<SystemConfig> new_config) {
        // Wait for system to be idle
        WaitForIdleState();

        // Backup current config
        auto backup = active_config_;

        // Apply new config atomically
        {
            std::lock_guard<std::mutex> lock(config_mutex_);
            active_config_ = new_config;
            config_version_.fetch_add(1);
        }

        // Notify all subsystems
        NotifyConfigChange();

        LOG_INFO("Config reloaded successfully, version: {}",
                 config_version_.load());
    }

    template<typename T>
    T GetValue(const std::string& key) const {
        std::lock_guard<std::mutex> lock(config_mutex_);
        return active_config_->Get<T>(key);
    }

    uint64_t GetVersion() const {
        return config_version_.load(std::memory_order_acquire);
    }
};
```

================================================================================
10. VALIDATION SCHEMAS
================================================================================

JSON SCHEMA FOR VALIDATION:
----------------------------
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "HFT System Configuration",
  "type": "object",
  "required": ["system"],
  "properties": {
    "system": {
      "type": "object",
      "required": ["name", "version", "environment"],
      "properties": {
        "name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 100
        },
        "version": {
          "type": "string",
          "pattern": "^\\d+\\.\\d+\\.\\d+$"
        },
        "environment": {
          "type": "string",
          "enum": ["development", "staging", "production"]
        },
        "core": {
          "type": "object",
          "properties": {
            "max_threads": {
              "type": "integer",
              "minimum": 1,
              "maximum": 256
            },
            "worker_threads": {
              "type": "integer",
              "minimum": 1,
              "maximum": 128
            },
            "cpu_affinity_enabled": {
              "type": "boolean"
            }
          }
        }
      }
    }
  }
}
```

C++ VALIDATION IMPLEMENTATION:
-------------------------------
```cpp
class ConfigValidator {
public:
    struct ValidationResult {
        bool valid;
        std::vector<std::string> errors;
        std::vector<std::string> warnings;
    };

    ValidationResult Validate(const SystemConfig& config) {
        ValidationResult result{true, {}, {}};

        // Validate thread counts
        if (config.core.max_threads < 1 ||
            config.core.max_threads > 256) {
            result.valid = false;
            result.errors.push_back(
                "max_threads must be between 1 and 256");
        }

        // Validate CPU affinity
        if (config.cpu_affinity.enabled) {
            auto cores = GetAvailableCores();
            for (auto core : config.cpu_affinity.isolated_cores) {
                if (core >= cores) {
                    result.valid = false;
                    result.errors.push_back(
                        fmt::format("Invalid core {}", core));
                }
            }
        }

        // Validate memory settings
        if (config.memory.heap_size_mb < 1024) {
            result.warnings.push_back(
                "Heap size below 1GB may cause issues");
        }

        // Validate queue sizes (must be power of 2)
        if (!IsPowerOfTwo(config.queues.order_queue_size)) {
            result.valid = false;
            result.errors.push_back(
                "Queue sizes must be power of 2");
        }

        return result;
    }

private:
    bool IsPowerOfTwo(uint64_t n) {
        return n && !(n & (n - 1));
    }

    uint32_t GetAvailableCores() {
        return std::thread::hardware_concurrency();
    }
};
```

================================================================================
11. C++ CONFIGURATION PARSER IMPLEMENTATION
================================================================================

YAML PARSER (using yaml-cpp):
------------------------------
```cpp
#include <yaml-cpp/yaml.h>
#include <fstream>
#include <memory>

class YAMLConfigParser {
public:
    static std::shared_ptr<SystemConfig> Parse(
        const std::string& file_path) {

        auto config = std::make_shared<SystemConfig>();

        try {
            YAML::Node root = YAML::LoadFile(file_path);

            if (root["system"]) {
                ParseSystem(root["system"], *config);
            }

            if (root["memory"]) {
                ParseMemory(root["memory"], *config);
            }

            if (root["thread_pools"]) {
                ParseThreadPools(root["thread_pools"], *config);
            }

            return config;

        } catch (const YAML::Exception& e) {
            throw std::runtime_error(
                fmt::format("YAML parse error: {}", e.what()));
        }
    }

private:
    static void ParseSystem(const YAML::Node& node,
                           SystemConfig& config) {
        config.name = node["name"].as<std::string>();
        config.version = node["version"].as<std::string>();
        config.environment = node["environment"].as<std::string>();

        if (node["core"]) {
            config.core.max_threads =
                node["core"]["max_threads"].as<uint32_t>();
            config.core.worker_threads =
                node["core"]["worker_threads"].as<uint32_t>();
            config.core.cpu_affinity_enabled =
                node["core"]["cpu_affinity_enabled"].as<bool>();
        }
    }

    static void ParseMemory(const YAML::Node& node,
                           SystemConfig& config) {
        config.memory.heap_size_mb =
            node["heap_size_mb"].as<uint64_t>();
        config.memory.huge_pages_enabled =
            node["huge_pages_enabled"].as<bool>();
    }
};
```

JSON PARSER (using nlohmann/json):
-----------------------------------
```cpp
#include <nlohmann/json.hpp>
using json = nlohmann::json;

class JSONConfigParser {
public:
    static std::shared_ptr<SystemConfig> Parse(
        const std::string& file_path) {

        std::ifstream file(file_path);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open config file");
        }

        json j;
        file >> j;

        auto config = std::make_shared<SystemConfig>();

        if (j.contains("system")) {
            config->name = j["system"]["name"];
            config->version = j["system"]["version"];

            if (j["system"].contains("core")) {
                config->core.max_threads =
                    j["system"]["core"]["max_threads"];
                config->core.worker_threads =
                    j["system"]["core"]["worker_threads"];
            }
        }

        return config;
    }
};
```

================================================================================
12. ENVIRONMENT-SPECIFIC CONFIGURATIONS
================================================================================

DEVELOPMENT CONFIGURATION:
--------------------------
```yaml
system:
  environment: "development"

  debug:
    enabled: true
    verbose_logging: true
    assertions_enabled: true
    sanitizers: ["address", "thread", "undefined"]

  performance:
    realtime_priority: false
    cpu_affinity: false
    huge_pages: false

  limits:
    max_orders_per_second: 100
    connection_timeout_ms: 30000
```

PRODUCTION CONFIGURATION:
-------------------------
```yaml
system:
  environment: "production"

  debug:
    enabled: false
    verbose_logging: false
    assertions_enabled: false
    sanitizers: []

  performance:
    realtime_priority: true
    cpu_affinity: true
    huge_pages: true
    kernel_bypass: true

  limits:
    max_orders_per_second: 10000
    connection_timeout_ms: 5000

  monitoring:
    metrics_enabled: true
    profiling_enabled: false
    tracing_enabled: true
```

================================================================================
END OF SYSTEM CONFIGURATION
================================================================================
